=pod

=head1 Perl 6 Meta-Model

This document will attempt to codify the perl 6 meta-model. It is very
much still a work in progress and it's contents may change by the minute
at times.

=head1 The Perl 6 Object environment

The perl6 object environment will be a multi-layered environment which 
might look something like this:

 +-{Instance}-+ +--{Class}--+ +{MetaClass}+ +{MetaMetaClass}+
 |            | |           | |           | |               |
 |   ------   | |   -----   | |  -------  | |  -----------  |
 |  ( $foo )------>( Foo )----->( Class )---->( MetaClass ) |
 |   ------   | |   -----   | |  -------  | |  -----------  |
 |            | |           | |           | |               |
 +------------+ +-----------+ +-----------+ +---------------+

The following describes some of the details of this leveled environment.

=over 4

=item B<each "level" is independant of the levels above and below it>

Relationships such as "is a", "does a", etc only make sense within a
particular level of the object system.  So, for example, it does not
make sense to describe all of these objects as descending from some
I<Ã¼ber>-Object class.  Rules and principles that apply on one level do
not necessarily transfer to the levels below.

To a type system freak, you could say that each level is seperated by
exactly one lamdba; that is, the distance between a type and a value.
By starting with a solid type definition at some level arbitrarily
designated as the "top", it is possible (in principle, at least) to
induct the lamdba calculus safely down to the lower levels.  This is
important when writing I<type-safe> compilers that are capable of
mutating their object systems at any time.

=item B<each "level" looks like Objects from Perl>

Despite this inherant heterogeneity of each level, they all look like
Objects from Perl.  They are described and accessed in exactly the
same way, and can even share type definitions and refer to each other,
to some extent.

Note that references "between" levels may inhibit the capability of the
code to be compiled so far as to run without an interpreter.

To summarise the above two principles in code;

  MyClass.isa(Object);   # false
  MyClass.isa(Class);    # true
  MyClass.does(Object);  # true

  MyClass.meta.isa(Object);    # false
  MyClass.meta.isa(Class);     # false
  MyClass.meta.isa(MetaClass); # true
  MyClass.meta.does(Object);   # true

  MyClass.meta.meta.isa(Object);        # false
  MyClass.meta.meta.isa(Class);         # false
  MyClass.meta.meta.isa(MetaClass);     # false
  MyClass.meta.meta.isa(MetaMetaClass); # true
  MyClass.meta.meta.does(Object);       # true

Even the above is in an ideal situation; it might be that with some
weird MetaModels, you simply don't get those guarantees.  However,
such situations are probably a bit 'obstruese' so won't be mentioned
further.

=back

=head2 Occupants of the Perl6 object environment
 
=over 4

=item B<Every C<Object> is an instance of some C<Class>>

These are the occupants of our environment B<O>.  Every noted
C<Object> has a uniquely associated entity called a C<Class>.

99% of code will be using C<Objects> for absolutely everything.

=item B<Every C<Class> is an instance of a C<MetaClass>>

These objects are what would normally be described as your program's
I<Model>; ie, objects that are I<Classes> (or I<Roles>, etc) will be
called "Dog", "Tree", etc.

When you write:

  class Dog {
  }

You are actually doing something like this;

  Class.new(name => Dog).apply;   # FIXME perl6ify

This is because the term C<Class> actually refers to a C<MetaClass>,
not a C<Class>.  There is nothing special about the term C<Class> that
makes it so, other than it was defined so.  If we had chosen the term
C<Qualifarniciferate> to refer to instances of C<MetaClasses>, then
the above would simply create an object of class (sorry,
Qualifarniciferate) C<Class>.

C<Class> objects are presented to Perl in much the same manner as
instances of some C<Class> called C<MetaClass> might be.  This might
fool you into thinking that they are also instances of some C<Class>,
however in truth they are only ever instances of C<MetaClass> objects.

=item B<Every C<MetaClass> is an instance of some C<MetaMetaClass>>

These objects are what would normally be described as your B<language>
I<Model>, or program I<Meta-Model>.  These will be called "Class",
"Role", etc.

It is these objects that implement methods like C<.isa>, C<.does>,
etc.  They will almost certainly provide proxy methods in the C<Class>
objects that they produce, that when compiled will produce the desired
behaviour.

=item B<Every I<MetaMetaClass> is an instance of the underlying system>

In theory, we could extend this relationship to any level.  However,
it simply does not make much sense to deal with these objects
directly; they might be Haskell definitions in the case of C<pugs>, or
perhaps in a Pure Perl Interpreter they will actually be real
C<Object>s; but you will not see the definition of C<MetaMetaClass> in
this module; in a sense, Perl 6 classes are being used as an
underlying I<Meta-Meta-Model>.

=back

=head1 AUTHORS

Sam Vilain E<lt>samv@cpan.orgE<gt>

Stevan Little E<lt>stevan@iinteractive.comE<gt>

=cut
