=encoding utf8

=head1 TITLE

Synopsis 3: Summary of Perl 6 Operators

=head1 AUTHOR

Luke Palmer <luke@luqui.org>

=head1 VERSION

  Maintainer: Larry Wall <larry@wall.org>
  Date: 8 Mar 2004
  Last Modified: 19 Jul 2006
  Number: 3
  Version: 51

=head1 Changes to existing operators

Several operators have been given new names to increase clarity and better
Huffman-code the language, while others have changed precedence.  (If an
operator is not mentioned in this Synopsis, assume that it remains the
same as in Perl 5.  And if that doesn't make sense, assume this document
is faulty. :)

=over

=item * C<< -> >> becomes C<.>, like the rest of the world uses.

=item * The string concatenation C<.> becomes C<~>.  Think of it as
"stitching" the two ends of its arguments together.  String append
is likewise C<~=>.

=item * All postfix operators that do not start with a dot also have
an alternate form that does.  (The converse does not hold--just because
you can write C<x().foo> doesn't mean you can write C<x()foo>.)  In the
absence of a postfix interpretation, the dot form will call the corresponding
prefix operator instead.  So C<x().!> will call C<!x()> unless someone
defines a postfix C<!> operator.  In particular, you can say things like
C<$array.@> and C<$filename.-e.-r>, but you can't say C<$fh.=> because
there's a C<.=> operator already.

=item * Unary C<~> now imposes a string (C<Str>) context on its
argument, and C<+> imposes a numeric (C<Num>) context (as opposed
to being a no-op in Perl 5).  Along the same lines, C<?> imposes
a boolean (C<Bool>) context, and the C<[,]> list operator imposes
a function-arguments (C<Capture>) context on its arguments.
Unary sigils impose the container context implied by their sigil.
As with Perl 5, however, C<$$foo[bar]> parses as C<$($foo)[bar]>,
so you need C<$($foo[bar])> to mean the other way.

=item * Bitwise operators get a data type prefix: C<+>, C<~>, or C<?>.
For example, Perl 5's C<|> becomes either C<+|> or C<~|> or C<?|>,
depending on whether the operands are to be treated as numbers,
strings, or boolean values.  Perl 5's left shift C< << > becomes
C< +< >, and correspondingly with right shift. Perl 5's unary C<~>
(one's complement) becomes either C<+^> or C<~^> or C<?^>, since a
bitwise NOT is like an exclusive-or against solid ones.  Note that
C<?^> is functionally identical to C<!>, but conceptually coerces to
boolean first and then flips the bit.  Please use C<!> instead.

C<?|> is a logical OR but differs from C<||> in that C<?|> always
evaluates both sides and returns a standard boolean value.  That is,
it's equivalent to C<< ?$a + ?$b != 0 >>.  Another difference is that
it has the precedence of an additive operator.

C<?&> is a logical AND but differs from C<&&> in that C<?&> always
evaluates both sides and returns a standard boolean value.  That is,
it's equivalent to C<< ?$a * ?$b != 0 >>.  Another difference is that
it has the precedence of a multiplicative operator.

Bitwise string operators (those starting with C<~>) may only be
applied to C<Buf> types or similar compact integer arrays, and treat
the entire chunk of memory as a single huge integer.  They differ from
the C<+> operators in that the C<+> operators would try to convert
the string to a number first on the assumption that the string was an
ASCII representation of a number.

=item * C<x> splits into two operators: C<x> (which concatenates repetitions 
of a string to produce a single string), and C<xx> (which creates a list of 
repetitions of a list or scalar).  C<"foo" xx *> represents an arbitrary
number of copies, useful for initializing lists.  The left side of
an C<xx> is evaluated only once.  (To call a block repeatedly, use a C<map>
instead.)

=item * Trinary C<? :> becomes C<?? !!>.  It is a syntax error to use an
operator in the middle that binds looser in precedence, such as C<=>.

=item * C<qw{ ... }> gets a synonym: C< < ... > >, and an interpolating
variant, C<«...»>.
For those still living without the blessings of Unicode, that can also be
written: C<<< << ... >> >>>.

=item * The scalar comma C<,> now constructs a C<List> object from its
operands.  You have to use a C<[-1]> subscript to get the last one.

=item * The unary backslash operator captures its arguments, and returns an
object representing those arguments.  You can I<dereference> this object
in several ways to retrieve different parts of the arguments; see the
definition of C<Capture> in S02 for details.  (No whitespace is allowed
after the backslash because that would instead start an "unspace", that is,
an escaped sequence of whitespace or comments.  See S02 for details.
However, oddly enough, because of that unspace rule, saying C<\\ $foo>
turns out to be equivalent to C<\$foo>.)

=item * The old scalar C<..> flipflop operator is now done with
C<ff> operator.  (C<..> now always produces a C<Range> object
even in scalar context.)  The C<ff> operator may take a caret on
either end to exclude either the beginning or ending.  There is
also a corresponding C<fff> operator with Perl 5's C<...> semantics.
You may say

    /foo/ ff *

to indicate a flipflop that never flops once flipped.

=item * All comparison operators are unified at the same precedence level.
See Chained Comparisons below.

=item * The list assignment operator now parses on the right like
any other list operator, so you don't need parens on the right side of:

    @foo = 1,2,3;

You do still need them on the left for

    ($a,$b,$c) = 1,2,3;

since assignment operators are tighter than comma to their left.

=item * The scalar assignment operator still parses as it did before, so

    loop ($a = 1, $b = 2; ; $a++, $b++) {...}

still works fine.  The syntactic distinction between scalar and list
assignment is similar to the way Perl 5 defines it, but has to be a
little different because we can no longer decide on the basis of
the sigil.  The following forms are parsed as "simple lvalues",
and imply scalar assignment:

    $a		# simple scalar variable
    $(ANY)      # scalar dereference (including $$a)
    $::(ANY)    # symbolic scalar dereference
    ANY[SIMPLE]	# single simple subscript
    ANY{SIMPLE}	# single simple subscript
    ANY<x>	# single literal subscript

Where SIMPLE is (recursively) defined as one of the forms above,
plus the following forms:

    123		# single literal
    'x'		# single literal
    "$x"	# single literal
    qq/$x/	# single literal
    +TERM	# any single term coerced to numeric
    -TERM	# any single term coerced to numeric
    ~TERM	# any single term coerced to string
    ?TERM	# any single term coerced to boolean
    !TERM	# any single term coerced to boolean
    (SIMPLE)	# any simple expression in circumfix parens

Note that circumfix parens are considered simple only when used as
part of a subscript.  Putting parens around the entire lvalue still
implies list context as in Perl 5.

We also include:

    OP SIMPLE	
    SIMPLE OP
    SIMPLE OP SIMPLE

where C<OP> is includes any standard scalar operators in the five
precedence levels autoincrement, exponentiation, symbolic unary,
multiplicative, and additive; but these are limited to standard
operators that are known to return numbers, strings, or booleans.

Operators that imply list operations are excluded: prefix C<@>,
prefix C<%> and infix C<xx>, for instance.  Hyper operators are
also excluded, but post-assignment forms such as C<SIMPLE += SIMPLE>
are allowed.

All other forms imply parsing as a list assignment, which may or may not
result in a list assignment at run time.  (See below.) However, this is
exclusively a syntactic distinction, and no semantic or type information
is used, since it influences subsequent parsing.  In particular, even
if a function is known to return a scalar value from its declaration,
you must use C<+> or C<~> if you wish to force scalar parsing from
within a subscript:

    @a[foo()] = bar();		# foo() and bar() called in list context
    @a[+foo()] = bar();		# foo() and bar() called in scalar context

But note that the first form still works fine if C<foo()> and C<bar()>
are scalar functions that are not context sensitive.  The difference
in parsing is only an issue if C<bar()> is followed by a comma or
some such.

For non-simple lvalues, at run time, both sides are evaluated in list
context, but if the left side results in a single non-list scalar,
the right side is treated as a single scalar value, as if the right
side had been evaluated in list context (which is indeed the case)
but coerced into scalar context.

If the left side returns a list, however, then regardless of whether
the list contains a single or multiple values, the right side values
are assigned one by one as in any other list assignment, discarding any
extra values if the right side is too long, or assigning undef if the
right side is too short.  To force list assignment when a subscript
would return a non-list, either put parens around the entire lvalue,
or use a comma within the subscript.  (A semicolon in the subscript
also works to indicate multidimensional slices.)

Assuming

    sub bar { return <a b c> }

then we have:

    sub foo { return 1,2,3 }
    @a[foo()] = bar();		# (@a[1,2,3]) = <a b c>

    sub foo { return 1 }
    @a[foo()] = bar();		# @a[1] = [<a b c>]

    sub foo { return(1) }
    @a[foo()] = bar();		# @a[1] = [<a b c>]

    sub foo { return (1) }
    @a[foo()] = bar();		# (@a[1]) = <a b c>

    sub foo { return 1 }
    @a[foo(),] = bar();		# (@a[1]) = <a b c>

    sub foo { return 1 }
    (@a[foo()]) = bar();	# (@a[1]) = <a b c>

Those are all parsed as list assignments, but we get different run-time
behaviors based on the run-time type of the left side.

In general, this will all just do what the user expects most of the time.
The rest of the time scalar or list behavior can be forced with minimal
syntax.

=item * List operators are all parsed consistently.  As in Perl 5,
to the left a list operator look like term, while to the right it looks like
an operator that is looser than comma.  Unlike in Perl 5, the difference
between the list operator form and the function form is consistently
indicated via whitespace between the list operator and the first
argument.  If there is whitespace, it is always a list operator,
and the next token will be taken as the first term of the list (or
if there are no terms, as the expression terminator).  Any infix operator
occurring where a term is expected will be misinterpreted as a term:

    say + 2;	# means say(+2);

If there is no whitespace, subsequent parsing depends on the
syntactic category of the next item.  Parentheses (with or without
a dot) turn the list operator into a function call instead, and
all the function's arguments must be passed inside the parentheses
(with the sole exception of an adverbial block, which may follow the
parentheses).

Other than various forms of parentheses, all other postfixes are
disallowed immediately after a list operator, even if there are no
arguments.  To add a postfix to an argumentless list operator you
must write it as a function call with empty parentheses:

    foo.[]	# ILLEGAL
    foo++	# ILLEGAL
    foo().[]	# legal
    foo()++	# legal (if foo() is rw)

After the parentheses any postfix operators are allowed, and apply
to the result of the function call.  (Also note that the postfix
restriction applies only to list operators; it doesn't apply to
methods.  It is legal to say

    $foo.bar<a b c>

to mean

    $foo.bar().{'a','b','c'}

because methods never assume there are arguments unless followed by
parentheses or a colon.)

If the next item after the list operator is either an infix operator
or a term, a syntax error.  [Conjecture: this may be relaxed in
non-strict mode.]

Examples:

    say foo + 1;			say(foo(+1));
    say foo $x;				say(foo($x));
    say foo$x;				ILLEGAL, need space or parens
    say foo+1;				ILLEGAL, need space or parens
    say foo++;				ILLEGAL, need parens

    say foo($bar+1),$baz		say(foo($bar+1), $baz);
    say foo.($bar+1),$baz		say(foo($bar+1), $baz);
    say foo ($bar+1),$baz		say(foo($bar+1, $baz));
    say foo .($bar+1),$baz		say(foo($_.($bar+1), $baz));

    say foo[$bar+1],$baz		ILLEGAL, need foo()[]
    say foo.[$bar+1],$baz		ILLEGAL, need foo().[]
    say foo [$bar+1],$baz		say(foo([$bar+1], $baz));
    say foo .[$bar+1],$baz		say(foo($_.[$bar+1], $baz));

    say foo{$bar+1},$baz		ILLEGAL, need foo(){}
    say foo.{$bar+1},$baz		ILLEGAL, need foo().{}
    say foo {$bar+1},$baz		say(foo({$bar+1}, $baz));
    say foo .{$bar+1},$baz		say(foo($_.{$bar+1}, $baz));

    say foo<$bar+1>,$baz		ILLEGAL, need foo()<>
    say foo.<$bar+1>,$baz		ILLEGAL, need foo().<>
    say foo <$bar+1>,$baz		say(foo(<$bar+1>, $baz));
    say foo .<$bar+1>,$baz		say(foo($_.<$bar+1>, $baz));

Note that Perl 6 is making a consistent three-way distinction between
term vs postfix vs infix, and will interpret an overloaded character
like C<< < >> accordingly:

    any <a b c>			any('a','b','c')	# term
    any()<a b c>		(any).{'a','b','c'}	# postfix
    any() < $x			(any) < $x		# infix
    any<a b c>			ILLEGAL			# stealth postfix

This will seem unfamiliar and "undwimmy" to Perl 5 programmers, who
are used to a grammar that sloppily hardwires a few postfix operators
at the price of extensibility.  Perl 6 chooses instead to mandate a
whitespace dependency in order to gain a completely extensible class
of postfix operators.

=item * A list operator's arguments are also terminated by a closure
that is not followed by a comma or colon.  (And a semicolon is implied
if the closure is the final thing on a line.  Use an "unspace" to
suppress that.)  This final closure may be followed by a postfix,
in which case the postfix is applied to the result of the entire
list operator.

=item * A function predeclared as 0-ary is never considered list
operator, though it allows an optional set of empty parentheses.
Unlike functions and list operators with arguments (see above),
a 0-ary function does not require parentheses even if followed
immediately by a postfix.

=item * A non-multi sub predeclared with an arity of exactly 1 parses
as a named unary in precedence.  All other subs with arguments
parse as list operators.  (In other words, a named unary operator
may be declared to take extra arguments only if they are named-only
arguments.)

=back

=head1 New operators

=over

=item * Binary C<//> is just like C<||>, except that it tests its left
side for definedness instead of truth. There is a low-precedence form,
too: C<err>.

=item * Binary C<===> tests immutable type and value correspondence:
for two value types (that is, immutable types), tests whether
they are the same value (eg. C<1 === 1>); for two mutable types
(object types), checks whether they have the same identity value.
(For most such types the identity is simply the reference itself.)
It is not true that C<[1,2] === [1,2]> because those are different
C<Array> objects, but it is true that C<@a === @a> because those are
the same C<Array> object).

Any object type may pretend to be a value type by defining a C<.valid>
method which returns a value type that can be recursively compared
using C<===>, or in cases where that is impractical, by overloading
C<===> such that the comparison treats values consistently with their
"eternal" identity.  (Strings are defined as values this way despite
also being objects.)

(Because Perl 6 uses a false C<.valid> to signify a non-instantiated prototype,
all instances should arrange to return a C<.valid> that boolifies to true.)

Two values are never equivalent unless they are of exactly the same type.  By
contrast, C<eq> always coerces to string, while C<==> always coerces to
numeric.  In fact, C<$a eq $b> really means "C<~$a === ~$b>" and C<$a == $b>
means "C<+$a === +$b>.

Note also that, while string hashes use C<eq> semantics by default,
object hashes use C<===> semantics.

=item * Binary C<eqv> tests equality much like C<===> does, but does
so with "snapshot" semantics rather than "eternal" semantics.  For
top-level components of your value that are of immutable types, C<eqv>
is identical in behavior to C<===>.  For components of your value
that are mutable, however, rather than comparing object identity using
C<===>, the C<eqv> operator tests whether the canonical representation
of both subvalues would be identical if we took a snapshot of them
right now and compared those (now-immutable) snapshots using C<===>.

If that's not enough flexibility, there is also an C<eqv()> function
that can be passed additional information specifying how you want
canonical values to be generated before comparison.  This gives
C<eqv()> the same kind of expressive power as a sort signature.
(And indeed, the C<cmp> operator from Perl 5 also has a functional
analog, C<cmp()>, that takes additional instructions on how to
do 3-way comparisons of the kind that a sorting algorithm wants.)
In particular, a signature passed to C<eqv()> will be bound to the
two operands in question, and then the comparison will proceed
on the formal parameters according to the information contained
in the signature, so you can force numeric, string, natural, or
other comparisons with proper declarations of the parameter's type
and traits.  If the signature doesn't match the operands, C<eqv()>
reverts to standard C<eqv> comparison.  (Likewise for C<cmp()>.)

=item * Binary C<cmp> is no longer the comparison operator that
forces stringification.  Use the C<leg> operator for the old Perl 5
C<cmp> semantics.  The C<cmp> is just like the C<eqv> above except that
instead of returning C<Bool::False> or C<Bool::True> values it always
returns C<Order::Increase>, C<Order::Same>, or C<Order::Decrease>
(which numerify to -1, 0, or +1).

=item * the C<leg> operator (less than, equal, or greater) is defined
in terms of C<cmp>, so C<$a leg $b> is now defined as C<~$a cmp ~$b>.
The sort operator still defaults to C<cmp> rather than C<leg>.  The
C<< <=> >> operator's semantics are unchanged except that it returns
an C<Order> value as described above.  In other words, C<< $a <=> $b >>
is now equivalent to C<+$a cmp +$b>.

=item * Binary C<< => >> is no longer just a "fancy comma".  It now
constructs a C<Pair> object that can, among other things, be used to
pass named arguments to functions.  It provides scalar context to both sides.
Its precedence is now equivalent to assignment, and it is right associative.

=item * C<^^> is the high-precedence version of C<xor>.

=item * C<=~> becomes the "smart match" operator C<~~>, with a whole new set
of semantics.  Anywhere you used C<=~> before you now use C<~~>, but C<~~>
is much more general now.  See "Smart matching" below for details.  (To catch
"brainos", the Perl 6 parser defines an C<< infix:<=~> >> macro which always
fails at compile time with a message directing the user either to use C<~~>
or C<~=> (string append) instead, or to put a space between if they
really wanted to assign a stringified value.)  A negated smart match is
spelled C<!~~>.

=item * "Unary" C<.> calls its single argument (which must a postfix operator)
on C<$_>.  (It's not really a unary operator, so we put it in quotes.)

=item * The C<..> range operator has variants with C<^> on either
end to indicate exclusion of that endpoint from the range.  It always
produces a C<Range> object.  Range objects are lazy iterators, and can
be interrogated for their current C<.min> and C<.max> values (which
change as they are iterated).  Ranges are not autoreversing: C<2..1>
is always a null range, as is C<1^..^2>.  To reverse a range use:

    2..1:by(-1)
    reverse 1..2

(The C<reverse> is preferred because it works for alphabetic ranges
as well.)

Because C<Range> objects are lazy, they do not automatically generate
a list.  So smart matching against a C<Range> object smartmatches the
endpoints in the domain of the object being matched, so fractional
numbers are C<not> truncated before comparison to integer ranges:

    1.5 ~~ 1^..^2  # true, equivalent to 1 < 1.5 < 2
    2.1 ~~ 1..2    # false, equivalent to 1 <= 2.1 <= 2

If a C<*> (see the "Whatever" type in S02) occurs on
the right side of a range, it is taken to mean "positive infinity"
in whatever space the range is operating.  A C<*> on the left means
"negative infinity" for types that support negative values.  If the
C<*> occurs on one side but not the other, the type is inferred from
the other argument.  A star on both sides will match any value that
supports the C<Ordered> role.

    0..*	# 0 .. +Inf
    'a'..*	# 'a' .. 'zzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
    *..0	# -Inf .. 0
    *..*	# "-Inf .. +Inf", really Ordered
    1.2.3..*	# Any version higher than 1.2.3.

Note: infinite lists are constructed lazily.  And even though C<*..*>
can't be constructed at all, it's still useful as a selector object.

=item * The unary C<^> operator generates a range from C<0> up to
one less than its argument.  So C<^4> is short for C<0..^4> or C<0..3>.

    for ^4 { say $_ } # 0, 1, 2, 3

If applied to a list, it generates a multidimensional set of subscripts.

    for ^(3,3) { ... } # (0,0)(0,1)(0,2)(1,0)(1,1)(1,2)(2,0)(2,1)(2,2)

If applied to a type name, it indicates the metaclass instance instead,
so C<^Moose> is short for C<Moose.meta>.  It still kinda means "what
is this thing's domain" in an abstract sort of way.

=item * The C<...> operator is the "yada, yada, yada" list operator,
which is used as the body in function prototypes.  It complains
bitterly (by calling C<fail>) if it is ever executed.  Variant C<???>
calls C<warn>, and C<!!!> calls C<die>.  The argument is optional,
but if provided, is passed onto the C<fail>, C<warn>, or C<die>.
Otherwise the system will make up a message for you based on the
context, indicating that you tried to execute something that is
stubbed out.  (This message differs from what C<fail>, C<warn>, and
C<die> would say by default, since the latter operators typically point
out bad data or programming rather than just an incomplete design.)

=item * In addition to the ordinary C<.> method invocation, there are
variants C<.*>, C<.?>, and C<.+> to control how multiple related methods
of the same name are handled.  The C<.=> operator does inplace modification
of the object on the left.  The C<.^> operator calls a class metamethod;
C<foo.^bar> is short for C<foo.meta.bar>.

=item * Unary C<=> reads lines from a filehandle or filename, or
iterates an iterator, or in general causes a scalar to explode its guts
when it would otherwise not.  How it does that is context sensitive.
For instance, C<=$iterator> is scalar/list sensitive and will
produce one value in scalar context but many values in list context.
(Use C<@$iterator> to force a fetch of all the values even in scalar
context, and C<$$iterator> to force a fetch of a single value even
in list context.)  On the other hand, C<=$capture> interpolates all
parts of the capture that makes sense in the current list context,
depending on what controls that list context.

=back

=head1 Smart matching

Here is the current table of smart matches.
The list is intended to reflect forms that can be recognized at
compile time.  If none of these forms is recognized at compile time, it
falls through to do MMD to C<< infix:<~~>() >>, which presumably
reflects similar semantics, but can finesse things that aren't exact
type matches.  Note that all types are scalarized here.  Both C<~~>
and C<given>/C<when> provide scalar contexts to their arguments.
(You can always hyperize C<~~> explicitly, though.)  So both C<$_>
and C<$x> here are potentially references to container objects.
And since lists promote to arrays in scalar context, there need be no
separate entries for lists.

    $_      $x        Type of Match Implied    Matching Code
    ======  =====     =====================    =============
    Any     Code:($)   scalar sub truth         match if $x($_)
    Hash    Hash      hash keys identical      match if $_.keys.sort »eq« $x.keys.sort
    Hash    any(Hash) hash key intersection    match if $_{any(Hash.keys)}
    Hash    Array     hash value slice truth   match if $_{any(@$x)}
    Hash    any(list) hash key slice existence match if exists $_{any(list)}
    Hash    all(list) hash key slice existence match if exists $_{all(list)}
    Hash    Regex     hash key grep            match if any($_.keys) ~~ /$x/
    Hash    Any       hash entry existence     match if exists $_{$x}
    Hash    .{Any}    hash element truth*      match if $_{Any}
    Hash    .<string> hash element truth*      match if $_<string>
    Array   Array     arrays are comparable    match if $_ »~~« $x
    Array   any(list) list intersection        match if any(@$_) ~~ any(list)
    Array   Regex     array grep               match if any(@$_) ~~ /$x/
    Array   Num       array contains number    match if any($_) == $x
    Array   Str       array contains string    match if any($_) eq $x
    Array   .[number] array element truth*     match if $_[number]
    Num     NumRange  in numeric range         match if $min <= $_ <= $max
    Str     StrRange  in string range          match if $min le $_ le $max
    Capture Signature parameter binding        match if $cap can bind to $sig
    Any     Code:()    simple closure truth*    match if $x() (ignoring $_)
    Any     Class     class membership         match if $_.does($x)
    Any     Role      role playing             match if $_.does($x)
    Any     Num       numeric equality         match if $_ == $x
    Any     Str       string equality          match if $_ eq $x
    Any     .method   method truth*            match if $_.method
    Any     Regex     pattern match            match if $_ ~~ /$x/
    Any     subst     substitution match*      match if $_ ~~ subst
    Any     boolean   simple expression truth* match if true given $_
    Any     undef     undefined                match unless defined $_
    Any     Whatever  default                  match anything
    Any     Any       run-time dispatch        match if infix:<~~>($_, $x)

Matches marked with * are non-reversible, typically because C<~~> takes
its left side as the topic for the right side, and sets the topic to a
private instance of C<$_> for its right side, so C<$_> means something
different on either side.  Such non-reversible constructs can be made
reversible by putting the leading term into a closure to defer the
binding of C<$_>.  For example:

    $x ~~ .does(Storeable)	# okay
    .does(Storeable) ~~ $x	# not okay--gets wrong $_ on left
    { .does(Storeable) } ~~ $x	# okay--closure binds its $_ to $x

Exactly the same consideration applies to C<given> and C<when>:

    given $x { when .does(Storeable) {...} }      # okay
    given .does(Storeable) { when $x {...} }      # not okay
    given { .does(Storeable) } { when $x {...} }  # okay

Boolean expressions are those known to return a boolean value, such
as comparisons, or the unary C<?> operator.  They may reference C<$_>
explicitly or implicitly.  If they don't reference C<$_> at all, that's
okay too--in that case you're just using the switch structure as a more
readable alternative to a string of elsifs.  Note, however, that this means
you can't write:

    given $boolean {
	when True {...}
	when False {...}
    }

because it will always choose the C<True> case.  Instead use something like:

    given $boolean {
	when .true {...}
	when .not {...}
    }

Better, just use an C<if> statement.

The primary use of the C<~~> operator is to return a boolean value in
a boolean context.  However, for certain operands such as regular
expressions, use of the operator within scalar or list context transfers
the context to that operand, so that, for instance, a regular expression
can return a list of matched substrings, as in Perl 5.  The complete
list of such operands is TBD.

It has not yet been determined if run-time dispatch of C<~~> will
attempt to emulate the compile-time precedence table before reverting
to MMD, or just go directly to MMD.  There are good arguments for
both sides, and we can decide when we see more examples of how
it'll work out.

=head1 Meta operators

Perl 6's operators have been greatly regularized, for instance, by
consistently prefixing numeric, stringwise, and boolean operators
with C<+>, C<~> and C<?> respectively to indicate whether the bitwise
operation is done on a number, a string, or a single bit.
But that's just a naming convention, and if you wanted to add a new
bitwise C<¬> operator, you'd have the add the C<+¬>, C<~¬>, and C<?¬>
operators yourself.  Similarly, the carets that exclude the endpoints
on ranges are there by convention only.

In contrast to that, Perl 6 has four standard metaoperators for
turning a given existing operator into a related operator that is
more powerful (or at least differently powerful).  These differ from a
mere naming convention in that Perl automatically generates these new
metaoperators from user-defined operators as well as from builtins.
In fact, you're not generally supposed to define the individual
metaoperations--their semantics are supposed to be self-evident by
the transformation of the base operator.

Note: spaces are never allowed between any metaoperator and the
operator it's modifying, because all operators including modified
ones have to be recognized by the Longest-Token Rule, which disallows
spaces within a token.

=head2 Assignment operators

These are already familiar to C and Perl programmers.  (Though the
C<.=> operator now means to call a mutating method on the object on
the left, and C<~=> is string concatenation.)  Most non-relational
infix operators may be turned into their corresponding assignment
operator by suffixing with C<=>.  The limitation is actually based
on whether the left side can function both as an rvalue and an lvalue
by the usual correspondence:

    A op= B;
    A = A op B;

Existing forms ending in C<=> may not be modified with this metaoperator.

Regardless of the precedence of the base operator, the precedence
of any assignment operators is forced to be the same as that of
ordinary assignment.

=head2 Negated relational operators.

Any infix relational operator may be transformed into its negative
by prefixing with C<!>.  A couple of these have traditional shortcuts:

    Full form	Shortcut
    ---------	--------
    !==		!=
    !eq		ne

but most of them do not:

    !~~
    !<
    !>=
    !ge
    !===
    !eqv
    !=:=

To avoid visual confusion with the C<!!> operator, you may not modify
any operator already beginning with C<!>.

The precedence of any negated operator is the same as the base operator.

=head2 Hyper operators

The Unicode characters C<»> (C<\x[BB]>) and C<«> (C<\x[AB]>) and
their ASCII digraphs C<<< >> >>> and C<<< << >>> are used to denote
"list operations", which operate on each element of two lists (or
arrays) and return a list (or array) of the results.  Spaces are not
allowed on the "pointy" end of each "hyper", but are allowed on the
blunt end (except for postfix operators, which must still follow postfix
spacing rules, but do allow for an additional dot before the "hyper").

The precedence of any hyperoperator is the same as its base operator.
This means that you must parenthesize your lists for most operators.
For example:

     (1,1,2,3,5) »+« (1,2,3,5,8);  # (2,3,5,8,13)

If either argument is insufficiently dimensioned, Perl "upgrades" it:

     (3,8,2,9,3,8) >>-<< 1;          # (2,7,1,8,2,7)

In fact, this is the I<only> form that will work for an unordered type
such as a C<Bag>:

     Bag(3,8,2,9,3,8) >>-<< 1;       # Bag(2,7,1,8,2,7) ~~ Bag(1,2,2,7,7,8)

When using a unary operator, only put the "hyper" on the side of the
single operand:

     @negatives = -« @positives;

     @positions»++;            # Increment all positions

     @positions.»++;           # Same thing, dot form
     @positions».++;           # Same thing, dot form
     @positions.».++;          # Same thing, dot form
     @positions\  .»\  .++;    # Same thing, long dot form

     @objects.».run();
     ("f","oo","bar").>>.chars;   # (1,2,3)

Note that method calls are really postfix operators, not infix, so you
shouldn't put a C<«> after the dot.

Hyper operators are defined recursively on arrays, so:

    -« [[1, 2], 3]               #    [-«[1, 2], -«3]
                                 # == [[-1, -2], -3]
    [[1, 2], 3] »+« [4, [5, 6]]  #    [[1,2] »+« 4, 3 »+« [5, 6]]
                                 # == [[5, 6], [8, 9]]

More generally, hyper operators work recursively for any object
matching the C<Each> role even if the object itself doesn't support
the operator in question:

    Bag(3,8,[2,Seq(9,3)],8) >>-<< 1;         # Bag(2,7,[1,Seq(8,2)],7)
    Seq(3,8,[2,Seq(9,3)],8) >>-<< (1,1,2,1); # Seq(2,7,[0,Seq(7,1)],7)

In particular, tree node types with C<Each> semantics enable visitation:

    $tree.».foo;	# short for $tree.foo, $tree.each: { .».foo }

If not all nodes support the operation, you need a form of it that
specifies the call is optional:

    $tree.».?foo;	# short for $tree.?foo, $tree.each: { .».?foo }
    $tree.».*foo;	# short for $tree.*foo, $tree.each: { .».*foo }

You are not allowed to define your own hyper operators, because they
are supposed to have consistent semantics derivable entirely from
the modified scalar operator.  If you're looking for a mathematical
vector product, this isn't where you'll find it.  A hyperoperator
is one of the ways that you can promise to the optimizer that your
code is parallelizable.  (The tree visitation above is allowed to
have side effects, but it is erroneous for the meaning of those side
effects to depend on the order of visitation.  [Conjecture: we could
allow dependencies that assume top-down visitation and only leaves
sibling calls unordered.])

Even in the absence of hardware that can do parallel processing,
hyperoperators may be faster than the corresponding scalar operators
if they can factor out looping overhead to lower-level code, or
can apply loop-unrolling optimizations, or can factor out some or
all of the MMD dispatch overhead, based on the known types of the
operands (and also based on the fact that hyper operators promise
no interaction among the "iterations", whereas the corresponding
scalar operator in a loop cannot make the same promise unless all
the operations within the loop are known to be side-effect free.)

In particular, infix hyperops on two C<int> or C<num> arrays need
only do a single MMD dispatch to find the correct function to call for
all pairs, and can further bypass any type-checking or type-coercion
entry points to such functions when there are known to be low-level
entry points of the appropriate type.  (And similarly for unary C<int>
or C<num> ops.)

Application-wide analysis of finalizable object types may also enable
such optimizations to be applied to C<Int>, C<Num>, and such.  In the
absence of that, run-time analysis of partial MMD dispatch may save
some MMD searching overhead.  Or particular object arrays might even
keep track of their own run-time type purity and cache partial MMD
dispatch tables when they know they're likely to be used in hyperops.

=head2 Reduction operators

The final metaoperator in Perl 6 is the reduction operator.  Any
infix operator (except for non-associating operators and assignment
operators) can be surrounded by square brackets in term position to
create a list operator that reduces using that operation:

    [+] 1, 2, 3;      # 1 + 2 + 3 = 6
    my @a = (5,6);
    [*] @a;           # 5 * 6 = 30

As with the all metaoperators, space is not allowed inside.  The whole
thing parses as a single token.

A reduction operator has the same precedence as a list operator.  In fact,
a reduction operator really is a list operator, and is invoked as one.
Hence, you can implement a reduction operator in one of two ways.  Either
you can write an explicit list operator:

    proto prefix:<[+]> (*@args) {
        my $accum = 0;
        while (@args) {
            $accum += @args.shift();
        }
        return $accum;
    }

or you can let the system autogenerate one for you based on the
corresponding infix operator, probably by currying:

    # (examples, actual system may define prefix:[**] instead)
    &prefix:<[*]> ::= &reduce.assuming(&infix:<*>, 1);
    &prefix:<[**]> ::= &reducerev.assuming(&infix:<**>);

As a special form of name, the non-prefix notation, as in

    proto [foo] (*@args) {
        ...
    }

or

    &[foo] ::= ...

defines both the C<[foo]> reduce operator and the C<foo> infix operator.
Where appropriate, use of the infix form may be optimized like this:

    # Original          # Optimized
    $a foo $b           # [foo] $a, $b
    $a foo $b foo $c    # [foo] $a, $b, $c

If the reduction operator is defined separately from the infix operator,
it must associate the same way as the operator used:

    [-] 4, 3, 2;      # 4-3-2 = (4-3)-2 = -1
    [**] 4, 3, 2;     # 4**3**2 = 4**(3**2) = 262144

For list-associating operators (like C<< < >>), all arguments are taken
together, just as if you had written it out explicitly:

    [<] 1, 3, 5;      # 1 < 3 < 5

If fewer than two arguments are given, a dispatch is still attempted
with whatever arguments are given, and it is up to the receiver of that
dispatch to deal with fewer than two arguments.  Note that the proto
list operator definition is the most general, so you are allowed to define
different ways to handle the one argument case depending on type:

    multi prefix:<[foo]> (Int $x) { 42 }
    multi prefix:<[foo]> (Str $x) { fail "Can't foo a single Str" }

However, the zero argument case must of necessity be handled by the
proto version, since there is no type information to dispatch on.
Operators that wish to specify an identity value should do so by
specifying the proto listop.  Among the builtin operators, C<[+]()>
returns 0 and C<[*]()> returns 1, for instance.

By default, if there is one argument, the built-in reduce operators
return that one argument.  However, this default doesn't make sense
for operators like C<< < >> that don't return the same type as they
take, so these kinds of operators overload the single-argument case
to return something more meaningful.  All the comparison operators
return a boolean for either 1 or 0 arguments.  Negated operators
return C<Bool::False>, and all the rest return C<Bool::True>.

You can also make a reduce operator of the comma operator.  This has
the effect of dereferencing its arguments into another argument list
as if they'd been placed there directly.

    @args = \@foo,1,2,3;
    push [,] @args;	# same as push @foo,1,2,3

See S06 for more.

You may also reduce using the semicolon second-dimension separator:

    [[;] 1,2,3]   # equivalent to [1;2;3]

Builtin reduce operators return the following identity operations:

    [**]()      # 1     (arguably nonsensical)
    [*]()       # 1
    [/]()       # fail  (reduce is nonsensical)
    [%]()       # fail  (reduce is nonsensical)
    [x]()       # fail  (reduce is nonsensical)
    [xx]()      # fail  (reduce is nonsensical)
    [+&]()      # +^0   (-1 on 2's complement machine)
    [+<]()      # fail  (reduce is nonsensical)
    [+>]()      # fail  (reduce is nonsensical)
    [~&]()      # fail  (sensical but 1's length indeterminate)
    [~<]()      # fail  (reduce is nonsensical)
    [~>]()      # fail  (reduce is nonsensical)
    [+]()       # 0
    [-]()       # 0
    [~]()       # ''
    [+|]()      # 0
    [+^]()      # 0
    [~|]()      # ''    (length indeterminate but 0's default)
    [~^]()      # ''    (length indeterminate but 0's default)
    [&]()       # all()
    [|]()       # any()
    [^]()       # one()
    [!==]()     # Bool::False   (also for 1 arg)
    [==]()      # Bool::True    (also for 1 arg)
    [<]()       # Bool::True    (also for 1 arg)
    [<=]()      # Bool::True    (also for 1 arg)
    [>]()       # Bool::True    (also for 1 arg)
    [>=]()      # Bool::True    (also for 1 arg)
    [~~]()      # Bool::True    (also for 1 arg)
    [!~~]()     # Bool::False   (also for 1 arg)
    [eq]()      # Bool::True    (also for 1 arg)
    [!eq]()     # Bool::False   (also for 1 arg)
    [lt]()      # Bool::True    (also for 1 arg)
    [le]()      # Bool::True    (also for 1 arg)
    [gt]()      # Bool::True    (also for 1 arg)
    [ge]()      # Bool::True    (also for 1 arg)
    [=:=]()     # Bool::True    (also for 1 arg)
    [!=:=]()    # Bool::False    (also for 1 arg)
    [===]()     # Bool::True    (also for 1 arg)
    [!===]()    # Bool::False    (also for 1 arg)
    [eqv]()     # Bool::True    (also for 1 arg)
    [!eqv]()    # Bool::False    (also for 1 arg)
    [&&]()      # Bool::True
    [||]()      # Bool::False
    [^^]()      # Bool::False
    [//]()      # undef
    [=]()       # undef    (same for all assignment operators)
    [,]()       # ()
    [¥]()       # []

User-defined operators may define their own identity values, but
there is no explicit identity property.  The value is implicit in the
behavior of the 0-arg reduce, so mathematical code wishing to find
the identity value for an operation can call C<prefix:{"[$opname]"}()>
to discover it.

To call some other non-infix function as a reduce operator, you may
define an alias in infix form.  The infix form will parse the right
argument as a scalar even if the aliased function would have parsed it
as a list:

    &infix:<dehash> ::= postcircumfix:<{ }>;
    $x = [dehash] $a,'foo','bar';  # $a<foo><bar>, not $a<foo bar>

Alternately, just define your own C<< prefix:<[dehash]> >> routine.

Note that, because a reduce is a list operator, the argument list is
evaluated in list context.  Therefore the following would be incorrect:

    $x = [dehash] %a,'foo','bar';

You'd instead have to say one of:

    $x = [dehash] \%a,'foo','bar';
    $x = [dehash] %a<foo>,'bar';

On the plus side, this works without a star:

    @args = (\%a,'foo','bar');
    $x = [dehash] @args;

A reduce operator returns only a scalar result regardless of context.
(Even C<[,]> returns a single C<Capture> object which is then spliced
into the outer argument list.)  To return all intermediate results,
backslash the operator:

    say [\+] 1..*  #  (1, 3, 6, 10, 15, ...)

The visual picture of a triangle is not accidental.  To produce a triangular
list of lists, you can use a "triangular comma":

    [\,] 1..5
    [1],
    [1,2],
    [1,2,3],
    [1,2,3,4],
    [1,2,3,4,5]

If there is ambiguity between a triangular reduce and an infix operator
beginning with backslash, the infix operator is chosen, and an extra backslash
indicates the corresponding triangular reduce.  As a consequence, defining an
infix operator beginning with backslash, C<< infix:<\x> >> say, will make it
impossible to write certain triangular reduction operators, since C<[\x]> would
mean the normal reduction of C<< infix:<\x> >> operator, not the triangular
reduction of C<< infix:<x> >>.  This is deemed to be an insignificant problem.

=head1 Junctive operators

C<|>, C<&>, and C<^> are no longer bitwise operators (see
L</Changes to existing operators>) but now serve a much higher cause:
they are now the junction constructors.

A junction is a single value that is equivalent to multiple values. They
thread through operations, returning another junction representing the
result:

     (1|2|3) + 4;                            # 5|6|7
     (1|2) + (3&4);                          # (4|5) & (5|6)

Note how when two junctions are applied through an operator, the result
is a junction representing the operator applied to each combination of
values.

Junctions come with the functional variants C<any>, C<all>, C<one>, and C<none>.

This opens doors for constructions like:

     unless $roll == any(1..6) { print "Invalid roll" }

     if $roll == 1|2|3 { print "Low roll" }

Junctions work through subscripting:

    print if @foo[any(1,2,3)]

Junctions are specifically unordered.  So if you say

    for all(@foo) {...}

it indicates to the compiler that there is no coupling between loop
iterations and they can be run in any order or even in parallel.

Use of negative operators with syntactically recognizable junctions may
produce a warning on code that works differently in English than in Perl.
Instead of writing

    if $a != 1 | 2 | 3 {...}

you need to write

    if not $a == 1 | 2 | 3 {...}

However, this is only a syntactic warning, and

    if $a != $b {...}

will not complain if $b happens to contain a junction at runtime.

=head1 Chained comparisons

Perl 6 supports the natural extension to the comparison operators,
allowing multiple operands.

    if 1 < $a < 100 { say "Good, you picked a number *between* 1 and 100." }

    if 3 < $roll <= 6              { print "High roll" }

    if 1 <= $roll1 == $roll2 <= 6  { print "Doubles!" }

Note: any operator beginning with C<< < >> must have whitespace
in front of it, or it will be interpreted as a hash subscript instead.

=head1 Binding

A new form of assignment is present in Perl 6, called "binding," used in
place of typeglob assignment.  It is performed with the C<:=> operator.
Instead of replacing the value in a container like normal assignment, it
replaces the container itself.  For instance:

    my $x = 'Just Another';
    my $y := $x;
    $y = 'Perl Hacker';

After this, both C<$x> and C<$y> contain the string "Perl Hacker," since
they are really just two different names for the same variable.

There is another variant, spelled C<::=>, that does the same thing at
compile time.

There is also an identity test, C<=:=>, which tests whether two names
are bound to the same underlying variable.  C<$x =:= $y> would return
true in the above example.

The binding fails if the type of the variable being bound is sufficiently
inconsistent with the type of the current declaration.

=head1 Declarators

The list of variable declarators has expanded from C<my> and C<our>
to include:

    my $foo		# ordinary lexically scoped variable
    our $foo		# lexically scoped alias to package variable
    has $foo		# object attribute
    state $foo		# persistent lexical (cloned with closures)
    constant $foo	# lexically scoped compile-time constant

Variable declarators such as C<my> now take a I<signature> as their
argument.  (The syntax of function signatures is described more fully in S06.)
The parentheses around the signature may be omitted for a
simple declaration that declares a single variable, along with its
associated type and traits.  Parentheses must always be used when
declaring multiple parameters:

    my $a;		# okay
    my ($b, $c);	# okay
    my $b, $c;		# wrong: "Use of undeclared variable: $c"

[XXX the following probably belongs in S06.]
The syntax for constructing a C<Signature> object when the parser isn't already
expecting one is:

    :(Dog $a, *@c)

This might be used like this:

    my $sig = :(Dog $a, *@c);

Signatures are expected after declarators such as C<my>, C<sub>, C<method>,
C<rule>, etc.  In such declarators the colon may be omitted.  But it's
also legal to use it:

    my :($b, $c);		# okay
    sub foo :($a,$b) {...}	# okay

The C<< -> >> "pointy sub" token also introduces a signature, but
in this case you must omit both the colon and the parens.  For instance,
if you're defining the "loop variable" of a loop block:

    for @dogpound -> Dog $fido { ... }

If a signature is assigned to (whether declared or colon form), the
signature is converted to a list of lvalue variables and the ordinary
rules of assignment apply, except that the evaluation of the right
side and the assignment happens at time determined by the declarator.
(With C<my> this is always when an ordinary assignment would happen.)
If the signature is too complicated to convert to an assignment,
a compile-time error occurs.  Assignment to a signature makes the
same scalar/list distinction as ordinary assignment, so

    my $a = foo();	# foo in scalar context
    my ($a) = foo();	# foo in list context

If a signature is bound to an argument list, then the binding of the
arguments proceeds as if the signature were the formal parameters for
a function, except that, unlike in a function call, the parameters
are bound C<rw> by default rather than C<readonly>.  See Binding above.

Note that C<temp> and C<let> are I<not> variable declarators, because
their effects only take place at runtime.  Therefore, they take an ordinary
lvalue object as their argument.  See S04 for more details.

There are a number of other declarators that are not variable
declarators.  These include both type declarators:

    package Foo
    module Foo
    class Foo
    role Foo
    subset Foo

and code declarators:

    sub foo
    method foo
    submethod foo
    multi foo
    proto foo
    macro foo
    quote qX
    regex foo
    rule foo
    token foo

These all have their uses and are explained in subsequent Synopses.

=head1 Argument List Interpolating

Perl 5 forced interpolation of a functions argument list by use of
the C<&> prefix.  That option is no longer available in Perl 6, so
instead the C<[,]> reduction operator serves as an
interpolator, by casting its operands to C<Capture> objects
and inserting them into the current argument list.

It can be used to interpolate an C<Array> or C<Hash> into the current
call, as positional and named arguments respectively.

Note that those arguments still must comply with the subroutine's
signature, but the presence of C<[,]> defers that test until run time for
that argument (and for any subsequent arguments):

    my @args = \@foo, @bar;
    push [,] @args;

is equivalent to:

    push @foo, @bar;

as is this:

    my $args = \(@foo, @bar);    # construct a Capture object
    push [,] @$args;

In list context, a C<Scalar> holding an C<Array> object does not flatten.  Hence

    $bar = @bar;
    push @foo, $bar;

merely pushes a single C<Array> object onto C<@foo>.  You can
explicitly flatten it in either of these ways:

    push @foo, @$bar;
    push @foo, $bar[];

Those two forms work because the slurpy array in C<push>'s signature
flattens the C<Array> object into a list argument.

Note that those two forms also allow you to specify list context on
assignment:

    @$bar = 1,2,3;
    $bar[] = 1,2,3;

Some lvalues can be rather lengthy, so that second form can help keep
the "arrayness" of the lvalue close to the assignment operator:

    $foo.bar.baz.bletch.whatever.attr[] = 1,2,3;

Otherwise you'd have to write:

    @($foo.bar.baz.bletch.whatever.attr) = 1,2,3;

and remember the C<@> at the front until you get to the C<=>.

The empty C<[]> and C<.[]> postfix operators are interpreted as
zero-dimensional slices returning the entire array, not null slices
returning no elements.  Likewise for C<{}> and C<.{}> on hashes,
not to mention the C<< <> >>, C<< .<> >>, C<«»>, and C<.«»>
constant and interpolating slice subscripting forms.

The C<[,]> operator interpolates lazily for C<Array> and C<Range> objects.
To get an immediate interpolation like Perl 5 does, add the C<eager> list
operator:

    func([,] 1..Inf);         # works fine
    func([,] eager 1..Inf);   # never terminates

To interpolate a function's return value, you must say:

    push [,] func()

Within the argument list of a C<[,]>, function return values are
automatically exploded into their various parts, as if you'd said:

    my \$capture := func();
    push [,] $$capture: @$capture, %$capture;

or some such.  The C<[,]> then handles the various zones appropriately
depending on the context.  An invocant only makes sense as the first
argument to the outer function call.  An invocant inserted anywhere
else just becomes a positional argument at the front of its list,
as if its colon changed back to a comma.

If you already have a capture variable, you can interpolate all of
its bits at once using the C<< prefix:<=> >> operator, which serves
to iterate or dereference a scalar that would otherwise stay packed
into its scalar value.  The above is equivalent to:

    my \$capture := func();
    push [,] =$capture;

=head1 Feed operators

The new operators C<< ==> >> and C<< <== >> are akin to UNIX pipes, but
work with functions that accept and return lists.  Since these lists are
composed of discrete objects and not liquids, we call these I<feed> operators
rather than pipes.  For example,

     @result = map { floor($^x / 2) },
                 grep { /^ \d+ $/ },
                   @data;

can also now be written with rightward feeds as:

     @data ==> grep { /^ \d+ $/ }
           ==> map { floor($^x / 2) }
           ==> @result;

or with leftward feeds as:

     @result <== map { floor($^x / 2) }
             <== grep { /^ \d+ $/ }
             <== @data;

Either form more clearly indicates the flow of data.  See S06 for 
more of the (less-than-obvious) details on these two operators.

=head1 Invocant marker

An appended C<:> marks the invocant when using the indirect-object
syntax for Perl 6 method calls.  The following two statements are
equivalent:

    $hacker.feed('Pizza and cola');
    feed $hacker: 'Pizza and cola';

A colon may also be used on an ordinary method call to indicate that
it should be parsed as a list operator:

    $hacker.feed: 'Pizza and cola';

This colon is a separate token.  A colon prefixing an adverb is not
a separate token.  Therefore, under the longest-token rule,

    $hacker.feed:xxx('Pizza and cola');

is tokenized as an adverb applying to the method:

    $hacker.feed :xxx('Pizza and cola');

not as an xxx sub in the argument list of .feed:

    $hacker.feed: xxx('Pizza and cola');  # wrong

If you want both meanings of colon, you have to put it twice:

    $hacker.feed: :xxx('Pizza and cola'), 1,2,3;

(For similar reasons it's required to put whitespace after the colon of a label.)

=head1 Traversing arrays in parallel

In order to support parallel iteration over multiple arrays, Perl 6 has
a C<zip> function that builds C<Seq> objects from the elements of two or more
arrays.

    for zip(@names; @codes) -> [$name, $zip] {
        print "Name: $name;   Zip code: $zip\n";
    }

C<zip> has an infix synonym, the Unicode operator C<¥>, and its the ASCII
equivalent C<Y>.

To read arrays in parallel like C<zip> but just sequence the values
rather than generating tuples, use C<each> instead of C<zip>.

    for each(@names; @codes) -> $name, $zip {
        print "Name: $name;   Zip code: $zip\n";
    }

The C<each> function reads to the end of the longest list, not counting
lists that are known to be infinite such as C<0..Inf>.  Missing values
are replaced with C<undef>.  In contrast, use C<roundrobin> if you just
wish to skip missing entries:

    for roundrobin(@queue1; @queue2; @queue3) -> $next {
        ...
    }

To read arrays serially rather than in parallel, use C<cat(@x;@y)>.
This wins a "useless use of cat award" in this case since you could
always just write C<(@x,@y)> to mean the same thing.  But sometimes
it's nice to be explicit about that:

    @foo := [[1,2,3],[4,5,6]]; say cat([;] @foo); # 1,2,3,4,5,6

=head1 Minimal whitespace DWIMmery

Whitespace is no longer allowed before the opening bracket of an array
or hash subscript, or the opening parenthesis of an argument list.  That is:

    @deadbeef[$x]         # okay
    @a       [$b]         # WRONG
    %monsters{'cookie'}   # okay
    %people  {'john'}     # WRONG
    saymewant('cookie')   # okay
    mewant   ('cookie')   # WRONG

One of the several useful side-effects of this restriction is that
parentheses are no longer required around the condition of control
constructs:

    if $value eq $target {
        print "Bullseye!";
    }
    while $i < 10 { $i++ }

It is, however, still possible to align subscripts and other postfix
operators by explicitly using the I<long dot> syntax (see S02):

     %monsters.{'cookie'} = Monster.new;
     %beatles\.{'ringo'}  = Beatle.new;
     %people\ .{'john'}   = Person.new;
     %cats\   .{'fluffy'} = Cat.new;

Whitespace is in general required between any keyword and any opening
bracket that is I<not> introducing a subscript or function arguments.
Any keyword followed directly by parentheses will be taken as a
function call instead.

    if $a == 1 { say "yes" }		# preferred syntax
    if ($a == 1) { say "yes" }		# P5-ish if construct
    if($a,$b,$c)			# if function call

It is possible for C<if()> to also invoke a macro call, but if so, it's a
C<< prefix:<if> >> macro rather than a C<< statement_control:<if> >> macro.

=head1 Precedence

Perl 6 has 22 precedence levels (which is fewer than Perl 5):

    terms               42 3.14 "eek" qq["foo"] [1,2,3] {...} \(@a,$b,%c)
			    $x @y %z /abc/ MyType @@multidim $^a
			    (1+2) a(1) :by(2) :!verbose :(Dog $self:)
			    .meth with implicit invocant
			    listops leftward
    method postfix      .meth .+ .? .* .() .[] .{} .<> .«» .:: .= .^
    autoincrement       ++ --
    exponentiation      **
    symbolic unary      ! + - ~ ? $ @ % & +^ ~^ ?^ \ ^ =
    multiplicative      * / % x xx +& +< +> ~& ~< ~> ?&
    additive            + - ~ +| +^ ~| ~^ ?| ?^
    junctive and (all)  &
    junctive or (any)   | ^
    named unary         rand sleep abs etc. -e -r -w -x etc.
    nonchaining binary  but does <=> leg cmp
			    .. ^.. ..^ ^..^
			    ff ^ff ff^ ^ff^
			    fff ^fff fff^ ^fff^
    chaining binary     != == < <= > >=
			    eq ne lt le gt ge
			    ~~ =:= === eqv
			    !== !~~ !eq !=:= !=== !eqv etc.
    tight and           &&
    tight or            || ^^ //
    ternary             ?? !!
    assignment          := ::= =>
			    (also = with simple lvalues)
			    += -= **= xx= .= etc.
    loose unary         true not
    list ops            , print push say join split substr open etc.
			    any all one none
			    die fail warn
			    !!! ...  ???
			    [+] [*] [<] [,] [\+] [\*] etc.
			    (also = as list assignment)
    list infix          ¥ <== ==>
    loose and           and
    loose or            or xor err
    expr terminator     ; {} as control block, statement modifiers
			    unmatched ), ], }, etc.

Comma is the only listop that is allowed to occur where an operator is
expected.  All other listops function as a term within the list to the left.

