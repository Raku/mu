# !!! DO NOT EDIT !!!
# This file was generated by util/gen-rule-pmc.pl at Sat Jul  7 23:31:27 2007

package Pugs::Grammar::Rule;
use utf8;
no strict 'refs';
use Pugs::Runtime::Match;
use Pugs::Runtime::Regex;

our %rule_terms;
our %variables;
*pod_begin = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       (
           ( $pad{I1951} = $pos or 1 )
           && (
           (
              (   ( $pad{I1952} = $pos or 1 ) && 
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I1952} ) && 0 ) )
           &&
             ## <constant>
             ( ( substr( $s, $pos, 1 ) eq '=' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&
             ## <constant>
             ( ( substr( $s, $pos, 1 ) eq 'e' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&
             ## <constant>
             ( ( substr( $s, $pos, 1 ) eq 'n' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&
              (   ( $pad{I1953} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq 'd' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1953} ) && 0 ) )
           &&
             do { while (
              (   ( $pad{I1954} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1954} ) && 0 ) )) {}; $bool = 1 }
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1951} ) or 1 )
           &&            (
              (   ( $pad{I1955} = $pos or 1 ) && 
               ( substr( $s, $pos++, 1 ) ne '' ) ||    ( ( $pos = $pad{I1955} ) && 0 ) )
           &&
             do { while (
              (   ( $pad{I1956} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1956} ) && 0 ) )) {}; $bool = 1 }
           &&
              (   ( $pad{I1957} = $pos or 1 ) && 

               ## <metasyntax>
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match = 
                           $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I1957} ) && 0 ) )
           )
         )
       )
## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for pod_begin
 # Data::Bind->sub_signature
#  (\&pod_begin, );
;
*pod_other = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       (
           ( $pad{I1958} = $pos or 1 )
           && (
           (
              (   ( $pad{I1959} = $pos or 1 ) && 
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I1959} ) && 0 ) )
           &&
             ## <constant>
             ( ( substr( $s, $pos, 1 ) eq '=' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&
             ## <constant>
             ( ( substr( $s, $pos, 1 ) eq 'c' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&
             ## <constant>
             ( ( substr( $s, $pos, 1 ) eq 'u' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&
              (   ( $pad{I1960} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq 't' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1960} ) && 0 ) )
           &&
             do { while (
              (   ( $pad{I1961} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1961} ) && 0 ) )) {}; $bool = 1 }
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1958} ) or 1 )
           &&            (
              (   ( $pad{I1962} = $pos or 1 ) && 
               ( substr( $s, $pos++, 1 ) ne '' ) ||    ( ( $pos = $pad{I1962} ) && 0 ) )
           &&
             do { while (
              (   ( $pad{I1963} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1963} ) && 0 ) )) {}; $bool = 1 }
           &&
              (   ( $pad{I1964} = $pos or 1 ) && 

               ## <metasyntax>
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match = 
                           $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I1964} ) && 0 ) )
           )
         )
       )
## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for pod_other
 # Data::Bind->sub_signature
#  (\&pod_other, );
;
*ws = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
        (   ( $pad{I1965} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I1966} = $pos or 1 )
               && (
               (
                  (   ( $pad{I1967} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '#' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1967} ) && 0 ) )
               &&
                 do { while (
                  (   ( $pad{I1968} = $pos or 1 ) && 
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
 ||    ( ( $pos = $pad{I1968} ) && 0 ) )) {}; $bool = 1 }
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1966} ) or 1 )
               &&                (
                  (   ( $pad{I1969} = $pos or 1 ) && 
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
 ||    ( ( $pos = $pad{I1969} ) && 0 ) )
               &&
                 (
                  (   ( $pad{I1970} = $pos or 1 ) && 
                     (
                        (   ( $pad{I1971} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1971} ) && 0 ) )
                     &&
                       (
                        (   ( $pad{I1972} = $pos or 1 ) && 
                           ## <alt>
                           (
                               ( $pad{I1973} = $pos or 1 )
                               && (
                               (
                                  (   ( $pad{I1974} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1974} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1975} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1975} ) && 0 ) )
                               &&
                                  (   ( $pad{I1976} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1976} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'E' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'N' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1977} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'D' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1977} ) && 0 ) )
                               &&
                                 do { while (
                                  (   ( $pad{I1978} = $pos or 1 ) && 
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
 ||    ( ( $pos = $pad{I1978} ) && 0 ) )) {}; $bool = 1 }
                               &&
                                 do { while (
                                  (   ( $pad{I1979} = $pos or 1 ) && 
                                     ( substr( $s, $pos++, 1 ) ne '' ) ||    ( ( $pos = $pad{I1979} ) && 0 ) )) {}; $bool = 1 }
                               )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1973} ) or 1 )
                               &&                                (
                                  (   ( $pad{I1980} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1980} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1981} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1981} ) && 0 ) )
                               &&
                                  (   ( $pad{I1982} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1982} ) && 0 ) )
                               )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1973} ) or 1 )
                               &&                                (
                                  (   ( $pad{I1983} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'k' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1983} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'w' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1984} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1984} ) && 0 ) )
                               &&
                                  (   ( $pad{I1985} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1985} ) && 0 ) )
                               )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1973} ) or 1 )
                               &&                                (
                                  (   ( $pad{I1986} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'p' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1986} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1987} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1987} ) && 0 ) )
                               &&
                                  (   ( $pad{I1988} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1988} ) && 0 ) )
                               )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1973} ) or 1 )
                               &&                                (
                                  (   ( $pad{I1989} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'f' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1989} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1990} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'r' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1990} ) && 0 ) )
                               &&
                                  (   ( $pad{I1991} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1991} ) && 0 ) )
                               )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1973} ) or 1 )
                               &&                                (
                                  (   ( $pad{I1992} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'h' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1992} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'a' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'd' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1993} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq '1' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1993} ) && 0 ) )
                               &&
                                  (   ( $pad{I1994} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1994} ) && 0 ) )
                               )
                             )
                           )
## </alt>
 ||    ( ( $pos = $pad{I1972} ) && 0 ) )
                       || ( $bool = 1 )
                       ) 
                     ) ||    ( ( $pos = $pad{I1970} ) && 0 ) )
                 || ( $bool = 1 )
                 ) 
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1966} ) or 1 )
               &&                 (   ( $pad{I1995} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1995} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I1965} ) && 0 ) )
       && do { while (
        (   ( $pad{I1965} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I1966} = $pos or 1 )
               && (
               (
                  (   ( $pad{I1967} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '#' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1967} ) && 0 ) )
               &&
                 do { while (
                  (   ( $pad{I1968} = $pos or 1 ) && 
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
 ||    ( ( $pos = $pad{I1968} ) && 0 ) )) {}; $bool = 1 }
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1966} ) or 1 )
               &&                (
                  (   ( $pad{I1969} = $pos or 1 ) && 
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
 ||    ( ( $pos = $pad{I1969} ) && 0 ) )
               &&
                 (
                  (   ( $pad{I1970} = $pos or 1 ) && 
                     (
                        (   ( $pad{I1971} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1971} ) && 0 ) )
                     &&
                       (
                        (   ( $pad{I1972} = $pos or 1 ) && 
                           ## <alt>
                           (
                               ( $pad{I1973} = $pos or 1 )
                               && (
                               (
                                  (   ( $pad{I1974} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1974} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1975} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1975} ) && 0 ) )
                               &&
                                  (   ( $pad{I1976} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1976} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'E' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'N' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1977} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'D' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1977} ) && 0 ) )
                               &&
                                 do { while (
                                  (   ( $pad{I1978} = $pos or 1 ) && 
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
 ||    ( ( $pos = $pad{I1978} ) && 0 ) )) {}; $bool = 1 }
                               &&
                                 do { while (
                                  (   ( $pad{I1979} = $pos or 1 ) && 
                                     ( substr( $s, $pos++, 1 ) ne '' ) ||    ( ( $pos = $pad{I1979} ) && 0 ) )) {}; $bool = 1 }
                               )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1973} ) or 1 )
                               &&                                (
                                  (   ( $pad{I1980} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1980} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1981} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1981} ) && 0 ) )
                               &&
                                  (   ( $pad{I1982} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1982} ) && 0 ) )
                               )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1973} ) or 1 )
                               &&                                (
                                  (   ( $pad{I1983} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'k' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1983} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'w' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1984} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1984} ) && 0 ) )
                               &&
                                  (   ( $pad{I1985} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1985} ) && 0 ) )
                               )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1973} ) or 1 )
                               &&                                (
                                  (   ( $pad{I1986} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'p' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1986} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1987} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1987} ) && 0 ) )
                               &&
                                  (   ( $pad{I1988} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1988} ) && 0 ) )
                               )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1973} ) or 1 )
                               &&                                (
                                  (   ( $pad{I1989} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'f' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1989} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1990} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'r' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1990} ) && 0 ) )
                               &&
                                  (   ( $pad{I1991} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1991} ) && 0 ) )
                               )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1973} ) or 1 )
                               &&                                (
                                  (   ( $pad{I1992} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq 'h' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1992} ) && 0 ) )
                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'a' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq 'd' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
                                  (   ( $pad{I1993} = $pos or 1 ) && 
                                   ## <constant>
                                   ( ( substr( $s, $pos, 1 ) eq '1' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1993} ) && 0 ) )
                               &&
                                  (   ( $pad{I1994} = $pos or 1 ) && 

                                   ## <metasyntax>
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1994} ) && 0 ) )
                               )
                             )
                           )
## </alt>
 ||    ( ( $pos = $pad{I1972} ) && 0 ) )
                       || ( $bool = 1 )
                       ) 
                     ) ||    ( ( $pos = $pad{I1970} ) && 0 ) )
                 || ( $bool = 1 )
                 ) 
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1966} ) or 1 )
               &&                 (   ( $pad{I1995} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1995} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I1965} ) && 0 ) )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for ws
 # Data::Bind->sub_signature
#  (\&ws, );
;
*ident = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
        (   ( $pad{I1996} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I1997} = $pos or 1 )
               && (
                (   ( $pad{I1998} = $pos or 1 ) && 

                 ## <metasyntax>
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = 
                             $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1998} ) && 0 ) )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1997} ) or 1 )
               &&                 (   ( $pad{I1999} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '_' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1999} ) && 0 ) )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1997} ) or 1 )
               &&                 (   ( $pad{I2000} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 2 ) eq '::' )
                     ? ( $pos += 2 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2000} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I1996} ) && 0 ) )
       && do { while (
        (   ( $pad{I1996} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I1997} = $pos or 1 )
               && (
                (   ( $pad{I1998} = $pos or 1 ) && 

                 ## <metasyntax>
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = 
                             $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1998} ) && 0 ) )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1997} ) or 1 )
               &&                 (   ( $pad{I1999} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '_' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1999} ) && 0 ) )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1997} ) or 1 )
               &&                 (   ( $pad{I2000} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 2 ) eq '::' )
                     ? ( $pos += 2 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2000} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I1996} ) && 0 ) )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for ident
 # Data::Bind->sub_signature
#  (\&ident, );
;
*alnum = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2001} = $pos or 1 ) && 
         ## <perl5>
         ( ( substr( $s, $pos ) =~ m/^((?:(?=[0-9a-zA-Z]))\X)/ )
             ? ( $pos += length( $1 ) or 1 )
             : 0
         )
         ## </perl5>
 ||    ( ( $pos = $pad{I2001} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for alnum
 # Data::Bind->sub_signature
#  (\&alnum, );
;
*alpha = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2002} = $pos or 1 ) && 
         ## <perl5>
         ( ( substr( $s, $pos ) =~ m/^((?:(?=[a-zA-Z]))\X)/ )
             ? ( $pos += length( $1 ) or 1 )
             : 0
         )
         ## </perl5>
 ||    ( ( $pos = $pad{I2002} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for alpha
 # Data::Bind->sub_signature
#  (\&alpha, );
;
*special_char = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       (
           ( $pad{I2003} = $pos or 1 )
           && (
           (
              (   ( $pad{I2004} = $pos or 1 ) && 
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       (
                           ( $pad{I2005} = $pos or 1 )
                           && (
                            (   ( $pad{I2006} = $pos or 1 ) && 
                             ## <constant>
                             ( ( substr( $s, $pos, 1 ) eq 'c' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2006} ) && 0 ) )
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2005} ) or 1 )
                           &&                             (   ( $pad{I2007} = $pos or 1 ) && 
                             ## <constant>
                             ( ( substr( $s, $pos, 1 ) eq 'C' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2007} ) && 0 ) )
                         )
                       )
## </alt>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I2004} ) && 0 ) )
           &&
              (   ( $pad{I2008} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2008} ) && 0 ) )
           &&
              (   ( $pad{I2009} = $pos or 1 ) && 
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                        (   ( $pad{I2010} = $pos or 1 ) && 
                           ## <alt>
                           (
                               ( $pad{I2011} = $pos or 1 )
                               && (
                               do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                           $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'alnum'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2011} ) or 1 )
                               &&                                ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2011} ) or 1 )
                               &&                                 (   ( $pad{I2012} = $pos or 1 ) && 
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq ';' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2012} ) && 0 ) )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2011} ) or 1 )
                               &&                                 (   ( $pad{I2013} = $pos or 1 ) && 
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq '(' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2013} ) && 0 ) )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2011} ) or 1 )
                               &&                                 (   ( $pad{I2014} = $pos or 1 ) && 
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq ')' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2014} ) && 0 ) )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2011} ) or 1 )
                               &&                                 (   ( $pad{I2015} = $pos or 1 ) && 
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq '-' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2015} ) && 0 ) )
                             )
                           )
## </alt>
 ||    ( ( $pos = $pad{I2010} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I2010} = $pos or 1 ) && 
                           ## <alt>
                           (
                               ( $pad{I2011} = $pos or 1 )
                               && (
                               do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                           $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'alnum'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2011} ) or 1 )
                               &&                                ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2011} ) or 1 )
                               &&                                 (   ( $pad{I2012} = $pos or 1 ) && 
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq ';' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2012} ) && 0 ) )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2011} ) or 1 )
                               &&                                 (   ( $pad{I2013} = $pos or 1 ) && 
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq '(' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2013} ) && 0 ) )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2011} ) or 1 )
                               &&                                 (   ( $pad{I2014} = $pos or 1 ) && 
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq ')' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2014} ) && 0 ) )
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2011} ) or 1 )
                               &&                                 (   ( $pad{I2015} = $pos or 1 ) && 
                                 ## <constant>
                                 ( ( substr( $s, $pos, 1 ) eq '-' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2015} ) && 0 ) )
                             )
                           )
## </alt>
 ||    ( ( $pos = $pad{I2010} ) && 0 ) )) {}; $bool = 1 }
                       ) ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I2009} ) && 0 ) )
           &&
              (   ( $pad{I2016} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2016} ) && 0 ) )
           &&
              (   ( $pad{I2017} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2017} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2003} ) or 1 )
           &&            (
              (   ( $pad{I2018} = $pos or 1 ) && 
               ## <alt>
               (
                   ( $pad{I2019} = $pos or 1 )
                   && (
                    (   ( $pad{I2020} = $pos or 1 ) && 
                     ## <constant>
                     ( ( substr( $s, $pos, 1 ) eq 'x' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I2020} ) && 0 ) )
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2019} ) or 1 )
                   &&                     (   ( $pad{I2021} = $pos or 1 ) && 
                     ## <constant>
                     ( ( substr( $s, $pos, 1 ) eq 'X' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I2021} ) && 0 ) )
                 )
               )
## </alt>
 ||    ( ( $pos = $pad{I2018} ) && 0 ) )
           &&
             (
              (   ( $pad{I2022} = $pos or 1 ) && 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                             $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2022} ) && 0 ) )
             && do { while (
              (   ( $pad{I2022} = $pos or 1 ) && 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                             $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2022} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I2023} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2023} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2003} ) or 1 )
           &&            (
              (   ( $pad{I2024} = $pos or 1 ) && 
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       (
                           ( $pad{I2025} = $pos or 1 )
                           && (
                            (   ( $pad{I2026} = $pos or 1 ) && 
                             ## <constant>
                             ( ( substr( $s, $pos, 1 ) eq 'x' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2026} ) && 0 ) )
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2025} ) or 1 )
                           &&                             (   ( $pad{I2027} = $pos or 1 ) && 
                             ## <constant>
                             ( ( substr( $s, $pos, 1 ) eq 'X' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2027} ) && 0 ) )
                         )
                       )
## </alt>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I2024} ) && 0 ) )
           &&
              (   ( $pad{I2028} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2028} ) && 0 ) )
           &&
              (   ( $pad{I2029} = $pos or 1 ) && 
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                        (   ( $pad{I2030} = $pos or 1 ) && 
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                       $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2030} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I2030} = $pos or 1 ) && 
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                       $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2030} ) && 0 ) )) {}; $bool = 1 }
                       ) ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I2029} ) && 0 ) )
           &&
              (   ( $pad{I2031} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2031} ) && 0 ) )
           &&
              (   ( $pad{I2032} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2032} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2003} ) or 1 )
           &&            (
              (   ( $pad{I2033} = $pos or 1 ) && 
               ## <alt>
               (
                   ( $pad{I2034} = $pos or 1 )
                   && (
                    (   ( $pad{I2035} = $pos or 1 ) && 
                     ## <constant>
                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I2035} ) && 0 ) )
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2034} ) or 1 )
                   &&                     (   ( $pad{I2036} = $pos or 1 ) && 
                     ## <constant>
                     ( ( substr( $s, $pos, 1 ) eq 'O' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I2036} ) && 0 ) )
                 )
               )
## </alt>
 ||    ( ( $pos = $pad{I2033} ) && 0 ) )
           &&
             (
              (   ( $pad{I2037} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2037} ) && 0 ) )
             && do { while (
              (   ( $pad{I2037} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2037} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I2038} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2038} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2003} ) or 1 )
           &&            (
              (   ( $pad{I2039} = $pos or 1 ) && 
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       (
                           ( $pad{I2040} = $pos or 1 )
                           && (
                            (   ( $pad{I2041} = $pos or 1 ) && 
                             ## <constant>
                             ( ( substr( $s, $pos, 1 ) eq 'o' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2041} ) && 0 ) )
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2040} ) or 1 )
                           &&                             (   ( $pad{I2042} = $pos or 1 ) && 
                             ## <constant>
                             ( ( substr( $s, $pos, 1 ) eq 'O' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2042} ) && 0 ) )
                         )
                       )
## </alt>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I2039} ) && 0 ) )
           &&
              (   ( $pad{I2043} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2043} ) && 0 ) )
           &&
              (   ( $pad{I2044} = $pos or 1 ) && 
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                        (   ( $pad{I2045} = $pos or 1 ) && 
                           ## <perl5>
                           ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                               ? ( $pos += length( $1 ) or 1 )
                               : 0
                           )
                           ## </perl5>
 ||    ( ( $pos = $pad{I2045} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I2045} = $pos or 1 ) && 
                           ## <perl5>
                           ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                               ? ( $pos += length( $1 ) or 1 )
                               : 0
                           )
                           ## </perl5>
 ||    ( ( $pos = $pad{I2045} ) && 0 ) )) {}; $bool = 1 }
                       ) ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I2044} ) && 0 ) )
           &&
              (   ( $pad{I2046} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2046} ) && 0 ) )
           &&
              (   ( $pad{I2047} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2047} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2003} ) or 1 )
           &&            (
              (   ( $pad{I2048} = $pos or 1 ) && 
               ( substr( $s, $pos++, 1 ) ne '' ) ||    ( ( $pos = $pad{I2048} ) && 0 ) )
           &&
              (   ( $pad{I2049} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2049} ) && 0 ) )
           )
         )
       )
## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for special_char
 # Data::Bind->sub_signature
#  (\&special_char, );
;
*literal = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       do { while (
        (   ( $pad{I2050} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I2051} = $pos or 1 )
               && (
               (
                  (   ( $pad{I2052} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2052} ) && 0 ) )
               &&
                  (   ( $pad{I2053} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2053} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2051} ) or 1 )
               &&                 (   ( $pad{I2054} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\']))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2054} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I2050} ) && 0 ) )) {}; $bool = 1 };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for literal
 # Data::Bind->sub_signature
#  (\&literal, );
;
*double_quoted = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       do { while (
        (   ( $pad{I2055} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I2056} = $pos or 1 )
               && (
               (
                  (   ( $pad{I2057} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2057} ) && 0 ) )
               &&
                  (   ( $pad{I2058} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2058} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2056} ) or 1 )
               &&                 (   ( $pad{I2059} = $pos or 1 ) && 
                 do{
                my $match = 
          do {
            our $I2060;
            our $I2060_sizes;
            unless ( $I2060 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I2060_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I2060 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I2060_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I2060->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I2060, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          };
                if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2059} ) && 0 ) )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2056} ) or 1 )
               &&                 (   ( $pad{I2061} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\"]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2061} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I2055} ) && 0 ) )) {}; $bool = 1 };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for double_quoted
 # Data::Bind->sub_signature
#  (\&double_quoted, );
;
*metasyntax = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
        (   ( $pad{I2062} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I2063} = $pos or 1 )
               && (
               (
                  (   ( $pad{I2064} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2064} ) && 0 ) )
               &&
                  (   ( $pad{I2065} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2065} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2063} ) or 1 )
               &&                (
                  (   ( $pad{I2066} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2066} ) && 0 ) )
               &&
                  (   ( $pad{I2067} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2067} ) && 0 ) )
               &&
                  (   ( $pad{I2068} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2068} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2063} ) or 1 )
               &&                (
                  (   ( $pad{I2069} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2069} ) && 0 ) )
               &&
                  (   ( $pad{I2070} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2070} ) && 0 ) )
               &&
                  (   ( $pad{I2071} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2071} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2063} ) or 1 )
               &&                (
                  (   ( $pad{I2072} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2072} ) && 0 ) )
               &&
                  (   ( $pad{I2073} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2073} ) && 0 ) )
               &&
                  (   ( $pad{I2074} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2074} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2063} ) or 1 )
               &&                (
                  (   ( $pad{I2075} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2075} ) && 0 ) )
               &&
                  (   ( $pad{I2076} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2076} ) && 0 ) )
               &&
                  (   ( $pad{I2077} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2077} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2063} ) or 1 )
               &&                 (   ( $pad{I2078} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2078} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I2062} ) && 0 ) )
       && do { while (
        (   ( $pad{I2062} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I2063} = $pos or 1 )
               && (
               (
                  (   ( $pad{I2064} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2064} ) && 0 ) )
               &&
                  (   ( $pad{I2065} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2065} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2063} ) or 1 )
               &&                (
                  (   ( $pad{I2066} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2066} ) && 0 ) )
               &&
                  (   ( $pad{I2067} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2067} ) && 0 ) )
               &&
                  (   ( $pad{I2068} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2068} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2063} ) or 1 )
               &&                (
                  (   ( $pad{I2069} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2069} ) && 0 ) )
               &&
                  (   ( $pad{I2070} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2070} ) && 0 ) )
               &&
                  (   ( $pad{I2071} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2071} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2063} ) or 1 )
               &&                (
                  (   ( $pad{I2072} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2072} ) && 0 ) )
               &&
                  (   ( $pad{I2073} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2073} ) && 0 ) )
               &&
                  (   ( $pad{I2074} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2074} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2063} ) or 1 )
               &&                (
                  (   ( $pad{I2075} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2075} ) && 0 ) )
               &&
                  (   ( $pad{I2076} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2076} ) && 0 ) )
               &&
                  (   ( $pad{I2077} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2077} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2063} ) or 1 )
               &&                 (   ( $pad{I2078} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2078} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I2062} ) && 0 ) )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for metasyntax
 # Data::Bind->sub_signature
#  (\&metasyntax, );
;
*char_range = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
        (   ( $pad{I2079} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I2080} = $pos or 1 )
               && (
               (
                  (   ( $pad{I2081} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2081} ) && 0 ) )
               &&
                  (   ( $pad{I2082} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2082} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2080} ) or 1 )
               &&                 (   ( $pad{I2083} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2083} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I2079} ) && 0 ) )
       && do { while (
        (   ( $pad{I2079} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I2080} = $pos or 1 )
               && (
               (
                  (   ( $pad{I2081} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2081} ) && 0 ) )
               &&
                  (   ( $pad{I2082} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2082} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2080} ) or 1 )
               &&                 (   ( $pad{I2083} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2083} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I2079} ) && 0 ) )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for char_range
 # Data::Bind->sub_signature
#  (\&char_range, );
;
*char_class = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       (
           ( $pad{I2084} = $pos or 1 )
           && (
           (
            (   ( $pad{I2085} = $pos or 1 ) && 

               ## <metasyntax>
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match = 
                           $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I2085} ) && 0 ) )
           && do { while (
            (   ( $pad{I2085} = $pos or 1 ) && 

               ## <metasyntax>
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match = 
                           $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I2085} ) && 0 ) )) {}; $bool = 1 }
           ) 
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2084} ) or 1 )
           &&            (
              (   ( $pad{I2086} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2086} ) && 0 ) )
           &&
              (   ( $pad{I2087} = $pos or 1 ) && 

               ## <metasyntax>
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match = 
                           $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I2087} ) && 0 ) )
           &&
              (   ( $pad{I2088} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2088} ) && 0 ) )
           )
         )
       )
## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for char_class
 # Data::Bind->sub_signature
#  (\&char_class, );
;
*string_code = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
        (   ( $pad{I2089} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I2090} = $pos or 1 )
               && (
               (
                  (   ( $pad{I2091} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2091} ) && 0 ) )
               &&
                  (   ( $pad{I2092} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2092} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2093} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2093} ) && 0 ) )
               &&
                  (   ( $pad{I2094} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2094} ) && 0 ) )
               &&
                  (   ( $pad{I2095} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2095} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2096} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2096} ) && 0 ) )
               &&
                  (   ( $pad{I2097} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2097} ) && 0 ) )
               &&
                  (   ( $pad{I2098} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2098} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2099} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2099} ) && 0 ) )
               &&
                  (   ( $pad{I2100} = $pos or 1 ) && 
                   ## <alt>
                   (
                       ( $pad{I2101} = $pos or 1 )
                       && (
                        (   ( $pad{I2102} = $pos or 1 ) && 

                         ## <metasyntax>
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2102} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2101} ) or 1 )
                       &&                         (   ( $pad{I2103} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I2103} ) && 0 ) )
                     )
                   )
## </alt>
 ||    ( ( $pos = $pad{I2100} ) && 0 ) )
               &&
                  (   ( $pad{I2104} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2104} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2105} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '(' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2105} ) && 0 ) )
               &&
                  (   ( $pad{I2106} = $pos or 1 ) && 
                   ## <alt>
                   (
                       ( $pad{I2107} = $pos or 1 )
                       && (
                        (   ( $pad{I2108} = $pos or 1 ) && 

                         ## <metasyntax>
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2108} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2107} ) or 1 )
                       &&                         (   ( $pad{I2109} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I2109} ) && 0 ) )
                     )
                   )
## </alt>
 ||    ( ( $pos = $pad{I2106} ) && 0 ) )
               &&
                  (   ( $pad{I2110} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq ')' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2110} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2111} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2111} ) && 0 ) )
               &&
                  (   ( $pad{I2112} = $pos or 1 ) && 
                   ## <alt>
                   (
                       ( $pad{I2113} = $pos or 1 )
                       && (
                        (   ( $pad{I2114} = $pos or 1 ) && 

                         ## <metasyntax>
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2114} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2113} ) or 1 )
                       &&                         (   ( $pad{I2115} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I2115} ) && 0 ) )
                     )
                   )
## </alt>
 ||    ( ( $pos = $pad{I2112} ) && 0 ) )
               &&
                  (   ( $pad{I2116} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2116} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2117} = $pos or 1 ) && 
                   ## <alt>
                   (
                       ( $pad{I2118} = $pos or 1 )
                       && (
                        (   ( $pad{I2119} = $pos or 1 ) && 

                         ## <metasyntax>
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = 
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2119} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2118} ) or 1 )
                       &&                         (   ( $pad{I2120} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq '>' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2120} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2118} ) or 1 )
                       &&                         (   ( $pad{I2121} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2121} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2118} ) or 1 )
                       &&                         (   ( $pad{I2122} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq '-' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2122} ) && 0 ) )
                     )
                   )
## </alt>
 ||    ( ( $pos = $pad{I2117} ) && 0 ) )
               &&
                  (   ( $pad{I2123} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2123} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                 (   ( $pad{I2124} = $pos or 1 ) && 

                 ## <metasyntax>
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = 
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2124} ) && 0 ) )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                 (   ( $pad{I2125} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2125} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I2089} ) && 0 ) )
       && do { while (
        (   ( $pad{I2089} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I2090} = $pos or 1 )
               && (
               (
                  (   ( $pad{I2091} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2091} ) && 0 ) )
               &&
                  (   ( $pad{I2092} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2092} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2093} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2093} ) && 0 ) )
               &&
                  (   ( $pad{I2094} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2094} ) && 0 ) )
               &&
                  (   ( $pad{I2095} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2095} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2096} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2096} ) && 0 ) )
               &&
                  (   ( $pad{I2097} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2097} ) && 0 ) )
               &&
                  (   ( $pad{I2098} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2098} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2099} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2099} ) && 0 ) )
               &&
                  (   ( $pad{I2100} = $pos or 1 ) && 
                   ## <alt>
                   (
                       ( $pad{I2101} = $pos or 1 )
                       && (
                        (   ( $pad{I2102} = $pos or 1 ) && 

                         ## <metasyntax>
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2102} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2101} ) or 1 )
                       &&                         (   ( $pad{I2103} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I2103} ) && 0 ) )
                     )
                   )
## </alt>
 ||    ( ( $pos = $pad{I2100} ) && 0 ) )
               &&
                  (   ( $pad{I2104} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2104} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2105} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '(' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2105} ) && 0 ) )
               &&
                  (   ( $pad{I2106} = $pos or 1 ) && 
                   ## <alt>
                   (
                       ( $pad{I2107} = $pos or 1 )
                       && (
                        (   ( $pad{I2108} = $pos or 1 ) && 

                         ## <metasyntax>
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2108} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2107} ) or 1 )
                       &&                         (   ( $pad{I2109} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I2109} ) && 0 ) )
                     )
                   )
## </alt>
 ||    ( ( $pos = $pad{I2106} ) && 0 ) )
               &&
                  (   ( $pad{I2110} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq ')' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2110} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2111} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2111} ) && 0 ) )
               &&
                  (   ( $pad{I2112} = $pos or 1 ) && 
                   ## <alt>
                   (
                       ( $pad{I2113} = $pos or 1 )
                       && (
                        (   ( $pad{I2114} = $pos or 1 ) && 

                         ## <metasyntax>
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2114} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2113} ) or 1 )
                       &&                         (   ( $pad{I2115} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I2115} ) && 0 ) )
                     )
                   )
## </alt>
 ||    ( ( $pos = $pad{I2112} ) && 0 ) )
               &&
                  (   ( $pad{I2116} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2116} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                (
                  (   ( $pad{I2117} = $pos or 1 ) && 
                   ## <alt>
                   (
                       ( $pad{I2118} = $pos or 1 )
                       && (
                        (   ( $pad{I2119} = $pos or 1 ) && 

                         ## <metasyntax>
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = 
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2119} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2118} ) or 1 )
                       &&                         (   ( $pad{I2120} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq '>' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2120} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2118} ) or 1 )
                       &&                         (   ( $pad{I2121} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2121} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2118} ) or 1 )
                       &&                         (   ( $pad{I2122} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq '-' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2122} ) && 0 ) )
                     )
                   )
## </alt>
 ||    ( ( $pos = $pad{I2117} ) && 0 ) )
               &&
                  (   ( $pad{I2123} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2123} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                 (   ( $pad{I2124} = $pos or 1 ) && 

                 ## <metasyntax>
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = 
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2124} ) && 0 ) )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2090} ) or 1 )
               &&                 (   ( $pad{I2125} = $pos or 1 ) && 
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2125} ) && 0 ) )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I2089} ) && 0 ) )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for string_code
 # Data::Bind->sub_signature
#  (\&string_code, );
;
*parsed_code = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2126} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2126} ) && 0 ) )
       &&
          (   ( $pad{I2127} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return('{' . $::_V6_MATCH_ . '}');
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2127} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for parsed_code
 # Data::Bind->sub_signature
#  (\&parsed_code, );
;
*named_capture_body = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       (
           ( $pad{I2128} = $pos or 1 )
           && (
           (
              (   ( $pad{I2129} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq '(' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2129} ) && 0 ) )
           &&
              (   ( $pad{I2130} = $pos or 1 ) && 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2130} ) && 0 ) )
           &&
              (   ( $pad{I2131} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq ')' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2131} ) && 0 ) )
           &&
              (   ( $pad{I2132} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'capturing_group' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2132} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2128} ) or 1 )
           &&            (
              (   ( $pad{I2133} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2133} ) && 0 ) )
           &&
              (   ( $pad{I2134} = $pos or 1 ) && 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2134} ) && 0 ) )
           &&
              (   ( $pad{I2135} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2135} ) && 0 ) )
           &&
              (   ( $pad{I2136} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'rule'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2136} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2128} ) or 1 )
           &&            (
              (   ( $pad{I2137} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq '<' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2137} ) && 0 ) )
           &&
              (   ( $pad{I2138} = $pos or 1 ) && 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                           $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parse_metasyntax'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2138} ) && 0 ) )
           &&
              (   ( $pad{I2139} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'parse_metasyntax'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2139} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2128} ) or 1 )
           &&            (
              (   ( $pad{I2140} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq chr(39) )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2140} ) && 0 ) )
           &&
              (   ( $pad{I2141} = $pos or 1 ) && 

               ## <metasyntax>
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match = 
                           $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I2141} ) && 0 ) )
           &&
              (   ( $pad{I2142} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq chr(39) )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2142} ) && 0 ) )
           &&
              (   ( $pad{I2143} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' =>  "" . ${$::_V6_MATCH_}}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2143} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2128} ) or 1 )
           &&             (   ( $pad{I2144} = $pos or 1 ) && 
             do { 
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               sub { my $_V6_SELF = shift;  { die("invalid alias syntax");
 } }->( $m );
               1;
             } ||    ( ( $pos = $pad{I2144} ) && 0 ) )
         )
       )
## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for named_capture_body
 # Data::Bind->sub_signature
#  (\&named_capture_body, );
;
*parse_metasyntax = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2145} = $pos or 1 ) && 
           do{
                my $from = $pos;
                my $bool =                    ## <alt>
                   (
                       ( $pad{I2146} = $pos or 1 )
                       && (
                        (   ( $pad{I2147} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq '!' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2147} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2146} ) or 1 )
                       &&                         (   ( $pad{I2148} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq '?' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2148} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2146} ) or 1 )
                       &&                         (   ( $pad{I2149} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I2149} ) && 0 ) )
                     )
                   )
## </alt>
;
                my $match = Pugs::Runtime::Match->new(
                    { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                ); $named{'modifier'} = $match;
                $bool
            } ||    ( ( $pos = $pad{I2145} ) && 0 ) )
       &&
          (   ( $pad{I2150} = $pos or 1 ) && 
           ## <alt>
           (
               ( $pad{I2151} = $pos or 1 )
               && (
               (
                  (   ( $pad{I2152} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2152} ) && 0 ) )
               &&
                  (   ( $pad{I2153} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2153} ) && 0 ) )
               &&
                  (   ( $pad{I2154} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 2 ) eq '}>' )
                       ? ( $pos += 2 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2154} ) && 0 ) )
               &&
                  (   ( $pad{I2155} = $pos or 1 ) && 
                   do { 
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'closure' => {'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   } ||    ( ( $pos = $pad{I2155} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2151} ) or 1 )
               &&                (
                  (   ( $pad{I2156} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2156} ) && 0 ) )
               &&
                 (
                  (   ( $pad{I2157} = $pos or 1 ) && 
                     do{
                         my $hash = do {
                           my $bool = 1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
                             (
                                (   ( $pad{I2158} = $pos or 1 ) && 
                                 ## <perl5>
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 )
                                 ## </perl5>
 ||    ( ( $pos = $pad{I2158} ) && 0 ) )
                             &&
                                (   ( $pad{I2159} = $pos or 1 ) && 
                                 do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                             $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2159} ) && 0 ) )
                             );
                           { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                         };
                         my $bool = ${$hash->{'bool'}};
                         if ( $bool ) {
                             push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                         }
                         $bool;
                     } ||    ( ( $pos = $pad{I2157} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I2157} = $pos or 1 ) && 
                     do{
                         my $hash = do {
                           my $bool = 1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
                             (
                                (   ( $pad{I2158} = $pos or 1 ) && 
                                 ## <perl5>
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 )
                                 ## </perl5>
 ||    ( ( $pos = $pad{I2158} ) && 0 ) )
                             &&
                                (   ( $pad{I2159} = $pos or 1 ) && 
                                 do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                             $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2159} ) && 0 ) )
                             );
                           { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                         };
                         my $bool = ${$hash->{'bool'}};
                         if ( $bool ) {
                             push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                         }
                         $bool;
                     } ||    ( ( $pos = $pad{I2157} ) && 0 ) )) {}; $bool = 1 }
                 ) 
               &&
                  (   ( $pad{I2160} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2160} ) && 0 ) )
               &&
                  (   ( $pad{I2161} = $pos or 1 ) && 
                   do { 
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if(${ $::_V6_MATCH_->{'modifier'}} eq '!') { return({'negate' => {'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]}});
 } 
;
return({'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   } ||    ( ( $pos = $pad{I2161} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2151} ) or 1 )
               &&                (
                  (   ( $pad{I2162} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2162} ) && 0 ) )
               &&
                  (   ( $pad{I2163} = $pos or 1 ) && 
                   ## <alt>
                   (
                       ( $pad{I2164} = $pos or 1 )
                       && (
                       (
                          (   ( $pad{I2165} = $pos or 1 ) && 

                           ## <metasyntax>
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match = 
                                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
 ||    ( ( $pos = $pad{I2165} ) && 0 ) )
                       &&
                          (   ( $pad{I2166} = $pos or 1 ) && 
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2166} ) && 0 ) )
                       &&
                          (   ( $pad{I2167} = $pos or 1 ) && 
                           ## <constant>
                           ( ( substr( $s, $pos, 1 ) eq '>' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2167} ) && 0 ) )
                       &&
                          (   ( $pad{I2168} = $pos or 1 ) && 
                           do { 
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if((${ $::_V6_MATCH_->{'ident'}} eq 'before' || ${ $::_V6_MATCH_->{'ident'}} eq 'after')) { return({${ $::_V6_MATCH_->{'ident'}} => {'rule' => ${ $::_V6_MATCH_->{'rule'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } 
;
return({'metasyntax' => {'metasyntax' => ${ $::_V6_MATCH_->{'ident'}}, 'rule' => ${ $::_V6_MATCH_->{'rule'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           } ||    ( ( $pos = $pad{I2168} ) && 0 ) )
                       )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2164} ) or 1 )
                       &&                        (
                          (   ( $pad{I2169} = $pos or 1 ) && 
                           ## <constant>
                           ( ( substr( $s, $pos, 1 ) eq ':' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2169} ) && 0 ) )
                       &&
                         (
                          (   ( $pad{I2170} = $pos or 1 ) && 

                             ## <metasyntax>
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match = 
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
 ||    ( ( $pos = $pad{I2170} ) && 0 ) )
                         || ( $bool = 1 )
                         ) 
                       &&
                          (   ( $pad{I2171} = $pos or 1 ) && 
                           do{
                my $from = $pos;
                my $bool =                                    do { while (
                                    (   ( $pad{I2172} = $pos or 1 ) && 
                                       ## <alt>
                                       (
                                           ( $pad{I2173} = $pos or 1 )
                                           && (
                                           (
                                              (   ( $pad{I2174} = $pos or 1 ) && 
                                               ## <constant>
                                               ( ( substr( $s, $pos, 1 ) eq '\\' )
                                                   ? ( $pos += 1 or 1 )
                                                   : 0
                                               )
                                               ## </constant>
 ||    ( ( $pos = $pad{I2174} ) && 0 ) )
                                           &&
                                              (   ( $pad{I2175} = $pos or 1 ) && 
                                               do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                                           $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2175} ) && 0 ) )
                                           )
                                           )
                                         || (
                                           ( ( $bool = 1 ) && ( $pos = $pad{I2173} ) or 1 )
                                           &&                                             (   ( $pad{I2176} = $pos or 1 ) && 
                                             do{
                my $match = 
          do {
            our $I2177;
            our $I2177_sizes;
            unless ( $I2177 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I2177_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I2177 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I2177_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I2177->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I2177, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          };
                if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2176} ) && 0 ) )
                                           )
                                         || (
                                           ( ( $bool = 1 ) && ( $pos = $pad{I2173} ) or 1 )
                                           &&                                             (   ( $pad{I2178} = $pos or 1 ) && 
                                             ## <perl5>
                                             ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                                                 ? ( $pos += length( $1 ) or 1 )
                                                 : 0
                                             )
                                             ## </perl5>
 ||    ( ( $pos = $pad{I2178} ) && 0 ) )
                                         )
                                       )
## </alt>
 ||    ( ( $pos = $pad{I2172} ) && 0 ) )) {}; $bool = 1 };
                my $match = Pugs::Runtime::Match->new(
                    { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                ); $named{'str'} = $match;
                $bool
            } ||    ( ( $pos = $pad{I2171} ) && 0 ) )
                       &&
                          (   ( $pad{I2179} = $pos or 1 ) && 
                           ## <constant>
                           ( ( substr( $s, $pos, 1 ) eq '>' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2179} ) && 0 ) )
                       &&
                          (   ( $pad{I2180} = $pos or 1 ) && 
                           do { 
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if((${ $::_V6_MATCH_->{'ident'}} eq 'before' || ${ $::_V6_MATCH_->{'ident'}} eq 'after')) { return({${ $::_V6_MATCH_->{'ident'}} => {'rule' => {'metasyntax' => {'metasyntax' => '\'' . ${ $::_V6_MATCH_->{'str'}} . '\''}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } 
;
return({'metasyntax' => {'metasyntax' => ${ $::_V6_MATCH_->{'ident'}}, 'string' => ${ $::_V6_MATCH_->{'str'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           } ||    ( ( $pos = $pad{I2180} ) && 0 ) )
                       )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2164} ) or 1 )
                       &&                        (
                          (   ( $pad{I2181} = $pos or 1 ) && 
                           ## <constant>
                           ( ( substr( $s, $pos, 1 ) eq '(' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2181} ) && 0 ) )
                       &&
                          (   ( $pad{I2182} = $pos or 1 ) && 
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                       $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2182} ) && 0 ) )
                       &&
                          (   ( $pad{I2183} = $pos or 1 ) && 
                           ## <constant>
                           ( ( substr( $s, $pos, 1 ) eq ')' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2183} ) && 0 ) )
                       &&
                          (   ( $pad{I2184} = $pos or 1 ) && 
                           ## <constant>
                           ( ( substr( $s, $pos, 1 ) eq '>' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2184} ) && 0 ) )
                       &&
                          (   ( $pad{I2185} = $pos or 1 ) && 
                           do { 
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'call' => {'method' => ${ $::_V6_MATCH_->{'ident'}}, 'params' => ${ $::_V6_MATCH_->{'parsed_code'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           } ||    ( ( $pos = $pad{I2185} ) && 0 ) )
                       )
                     )
                   )
## </alt>
 ||    ( ( $pos = $pad{I2163} ) && 0 ) )
               )
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2151} ) or 1 )
               &&                (
                  (   ( $pad{I2186} = $pos or 1 ) && 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'metasyntax'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2186} ) && 0 ) )
               &&
                  (   ( $pad{I2187} = $pos or 1 ) && 
                   ## <constant>
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2187} ) && 0 ) )
               &&
                  (   ( $pad{I2188} = $pos or 1 ) && 
                   do { 
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' =>  "" . ${ $::_V6_MATCH_->{'metasyntax'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   } ||    ( ( $pos = $pad{I2188} ) && 0 ) )
               )
             )
           )
## </alt>
 ||    ( ( $pos = $pad{I2150} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for parse_metasyntax
 # Data::Bind->sub_signature
#  (\&parse_metasyntax, );
;
%variables = ('$<' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2189} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2189} ) && 0 ) )
       &&
          (   ( $pad{I2190} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2190} ) && 0 ) )
       &&
          (   ( $pad{I2191} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '$' .  $::_V6_MATCH_->{'ident'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2191} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'$' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       (
           ( $pad{I2192} = $pos or 1 )
           && (
           (
             (
              (   ( $pad{I2193} = $pos or 1 ) && 

                 ## <metasyntax>
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2193} ) && 0 ) )
             && do { while (
              (   ( $pad{I2193} = $pos or 1 ) && 

                 ## <metasyntax>
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2193} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I2194} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '$' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2194} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2192} ) or 1 )
           &&            (
             (
              (   ( $pad{I2195} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '^' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2195} ) && 0 ) )
             || ( $bool = 1 )
             ) 
           &&
             (
              (   ( $pad{I2196} = $pos or 1 ) && 
                 ## <alt>
                 (
                     ( $pad{I2197} = $pos or 1 )
                     && (
                      (   ( $pad{I2198} = $pos or 1 ) && 

                       ## <metasyntax>
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2198} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2197} ) or 1 )
                     &&                       (   ( $pad{I2199} = $pos or 1 ) && 
                       ## <constant>
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2199} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2197} ) or 1 )
                     &&                      (
                        (   ( $pad{I2200} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2200} ) && 0 ) )
                     &&
                        (   ( $pad{I2201} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2201} ) && 0 ) )
                     )
                   )
                 )
## </alt>
 ||    ( ( $pos = $pad{I2196} ) && 0 ) )
             && do { while (
              (   ( $pad{I2196} = $pos or 1 ) && 
                 ## <alt>
                 (
                     ( $pad{I2197} = $pos or 1 )
                     && (
                      (   ( $pad{I2198} = $pos or 1 ) && 

                       ## <metasyntax>
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2198} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2197} ) or 1 )
                     &&                       (   ( $pad{I2199} = $pos or 1 ) && 
                       ## <constant>
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2199} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2197} ) or 1 )
                     &&                      (
                        (   ( $pad{I2200} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2200} ) && 0 ) )
                     &&
                        (   ( $pad{I2201} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2201} ) && 0 ) )
                     )
                   )
                 )
## </alt>
 ||    ( ( $pos = $pad{I2196} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I2202} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'variable' => '$' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2202} ) && 0 ) )
           )
         )
       )
## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'@' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       (
           ( $pad{I2203} = $pos or 1 )
           && (
           (
             (
              (   ( $pad{I2204} = $pos or 1 ) && 

                 ## <metasyntax>
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2204} ) && 0 ) )
             && do { while (
              (   ( $pad{I2204} = $pos or 1 ) && 

                 ## <metasyntax>
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2204} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I2205} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '@' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2205} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2203} ) or 1 )
           &&            (
             (
              (   ( $pad{I2206} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '^' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2206} ) && 0 ) )
             || ( $bool = 1 )
             ) 
           &&
             (
              (   ( $pad{I2207} = $pos or 1 ) && 
                 ## <alt>
                 (
                     ( $pad{I2208} = $pos or 1 )
                     && (
                      (   ( $pad{I2209} = $pos or 1 ) && 

                       ## <metasyntax>
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2209} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2208} ) or 1 )
                     &&                       (   ( $pad{I2210} = $pos or 1 ) && 
                       ## <constant>
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2210} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2208} ) or 1 )
                     &&                      (
                        (   ( $pad{I2211} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2211} ) && 0 ) )
                     &&
                        (   ( $pad{I2212} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2212} ) && 0 ) )
                     )
                   )
                 )
## </alt>
 ||    ( ( $pos = $pad{I2207} ) && 0 ) )
             && do { while (
              (   ( $pad{I2207} = $pos or 1 ) && 
                 ## <alt>
                 (
                     ( $pad{I2208} = $pos or 1 )
                     && (
                      (   ( $pad{I2209} = $pos or 1 ) && 

                       ## <metasyntax>
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2209} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2208} ) or 1 )
                     &&                       (   ( $pad{I2210} = $pos or 1 ) && 
                       ## <constant>
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2210} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2208} ) or 1 )
                     &&                      (
                        (   ( $pad{I2211} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2211} ) && 0 ) )
                     &&
                        (   ( $pad{I2212} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2212} ) && 0 ) )
                     )
                   )
                 )
## </alt>
 ||    ( ( $pos = $pad{I2207} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I2213} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'variable' => '@' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2213} ) && 0 ) )
           )
         )
       )
## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'%' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       (
           ( $pad{I2214} = $pos or 1 )
           && (
           (
             (
              (   ( $pad{I2215} = $pos or 1 ) && 

                 ## <metasyntax>
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2215} ) && 0 ) )
             && do { while (
              (   ( $pad{I2215} = $pos or 1 ) && 

                 ## <metasyntax>
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2215} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I2216} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '%' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2216} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2214} ) or 1 )
           &&            (
             (
              (   ( $pad{I2217} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '^' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2217} ) && 0 ) )
             || ( $bool = 1 )
             ) 
           &&
             (
              (   ( $pad{I2218} = $pos or 1 ) && 
                 ## <alt>
                 (
                     ( $pad{I2219} = $pos or 1 )
                     && (
                      (   ( $pad{I2220} = $pos or 1 ) && 

                       ## <metasyntax>
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2220} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2219} ) or 1 )
                     &&                       (   ( $pad{I2221} = $pos or 1 ) && 
                       ## <constant>
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2221} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2219} ) or 1 )
                     &&                      (
                        (   ( $pad{I2222} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2222} ) && 0 ) )
                     &&
                        (   ( $pad{I2223} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2223} ) && 0 ) )
                     )
                   )
                 )
## </alt>
 ||    ( ( $pos = $pad{I2218} ) && 0 ) )
             && do { while (
              (   ( $pad{I2218} = $pos or 1 ) && 
                 ## <alt>
                 (
                     ( $pad{I2219} = $pos or 1 )
                     && (
                      (   ( $pad{I2220} = $pos or 1 ) && 

                       ## <metasyntax>
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2220} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2219} ) or 1 )
                     &&                       (   ( $pad{I2221} = $pos or 1 ) && 
                       ## <constant>
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2221} ) && 0 ) )
                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2219} ) or 1 )
                     &&                      (
                        (   ( $pad{I2222} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2222} ) && 0 ) )
                     &&
                        (   ( $pad{I2223} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2223} ) && 0 ) )
                     )
                   )
                 )
## </alt>
 ||    ( ( $pos = $pad{I2218} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I2224} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'variable' => '%' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2224} ) && 0 ) )
           )
         )
       )
## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
);
%rule_terms = ('{*}' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2225} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' => 'null'}});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2225} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'\'' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2226} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2226} ) && 0 ) )
       &&
          (   ( $pad{I2227} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq chr(39) )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2227} ) && 0 ) )
       &&
          (   ( $pad{I2228} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' => '\'' . ${$::_V6_MATCH_}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2228} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'(' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2229} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2229} ) && 0 ) )
       &&
          (   ( $pad{I2230} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq ')' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2230} ) && 0 ) )
       &&
          (   ( $pad{I2231} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'capturing_group' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2231} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<(' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2232} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2232} ) && 0 ) )
       &&
          (   ( $pad{I2233} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 2 ) eq ')>' )
               ? ( $pos += 2 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2233} ) && 0 ) )
       &&
          (   ( $pad{I2234} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'capture_as_result' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2234} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<+' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2235} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2235} ) && 0 ) )
       &&
         do { while (
          (   ( $pad{I2236} = $pos or 1 ) && 
             do{
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     (
                        (   ( $pad{I2237} = $pos or 1 ) && 
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
 ||    ( ( $pos = $pad{I2237} ) && 0 ) )
                     &&
                        (   ( $pad{I2238} = $pos or 1 ) && 
                         do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2238} ) && 0 ) )
                     );
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             } ||    ( ( $pos = $pad{I2236} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I2239} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2239} ) && 0 ) )
       &&
          (   ( $pad{I2240} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2240} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<-' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2241} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2241} ) && 0 ) )
       &&
         do { while (
          (   ( $pad{I2242} = $pos or 1 ) && 
             do{
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     (
                        (   ( $pad{I2243} = $pos or 1 ) && 
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
 ||    ( ( $pos = $pad{I2243} ) && 0 ) )
                     &&
                        (   ( $pad{I2244} = $pos or 1 ) && 
                         do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2244} ) && 0 ) )
                     );
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             } ||    ( ( $pos = $pad{I2242} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I2245} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2245} ) && 0 ) )
       &&
          (   ( $pad{I2246} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'char_class' => ['-' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2246} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<[' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2247} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_range'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2247} ) && 0 ) )
       &&
          (   ( $pad{I2248} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq ']' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2248} ) && 0 ) )
       &&
         do { while (
          (   ( $pad{I2249} = $pos or 1 ) && 
             do{
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     (
                        (   ( $pad{I2250} = $pos or 1 ) && 
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
 ||    ( ( $pos = $pad{I2250} ) && 0 ) )
                     &&
                        (   ( $pad{I2251} = $pos or 1 ) && 
                         do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2251} ) && 0 ) )
                     );
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             } ||    ( ( $pos = $pad{I2249} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I2252} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2252} ) && 0 ) )
       &&
          (   ( $pad{I2253} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'char_class' => ['+[' .  $::_V6_MATCH_->{'char_range'} . ']',
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2253} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2254} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parse_metasyntax'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2254} ) && 0 ) )
       &&
          (   ( $pad{I2255} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'parse_metasyntax'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2255} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'{' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2256} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2256} ) && 0 ) )
       &&
          (   ( $pad{I2257} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq '}' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2257} ) && 0 ) )
       &&
          (   ( $pad{I2258} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'closure' => {'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}, 'modifier' => 'plain'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2258} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'\\' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2259} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'special_char'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2259} ) && 0 ) )
       &&
          (   ( $pad{I2260} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'special_char'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2260} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'.' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2261} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'dot' => 1});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2261} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'[' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2262} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2262} ) && 0 ) )
       &&
          (   ( $pad{I2263} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq ']' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2263} ) && 0 ) )
       &&
          (   ( $pad{I2264} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'rule'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2264} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':::' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2265} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':::'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2265} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':?' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2266} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':?'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2266} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':+' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2267} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':+'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2267} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'::' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2268} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '::'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2268} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2269} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2269} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'$$' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2270} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '$$'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2270} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'$' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2271} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '$'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2271} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'^^' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2272} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '^^'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2272} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'^' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2273} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '^'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2273} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'>>' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2274} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '>>'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2274} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2275} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '>>'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2275} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<<' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2276} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '<<'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2276} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
        (   ( $pad{I2277} = $pos or 1 ) && 
         do { 
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '<<'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         } ||    ( ( $pos = $pad{I2277} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':i' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2278} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2278} ) && 0 ) )
       &&
          (   ( $pad{I2279} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2279} ) && 0 ) )
       &&
          (   ( $pad{I2280} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => {'modifier' => 'ignorecase', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2280} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':ignorecase' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2281} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2281} ) && 0 ) )
       &&
          (   ( $pad{I2282} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2282} ) && 0 ) )
       &&
          (   ( $pad{I2283} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => {'modifier' => 'ignorecase', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2283} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':s' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2284} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2284} ) && 0 ) )
       &&
          (   ( $pad{I2285} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2285} ) && 0 ) )
       &&
          (   ( $pad{I2286} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'sigspace', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2286} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':sigspace' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2287} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2287} ) && 0 ) )
       &&
          (   ( $pad{I2288} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2288} ) && 0 ) )
       &&
          (   ( $pad{I2289} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'sigspace', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2289} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':P5' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2290} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2290} ) && 0 ) )
       &&
          (   ( $pad{I2291} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2291} ) && 0 ) )
       &&
          (   ( $pad{I2292} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'Perl5', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2292} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':Perl5' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2293} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2293} ) && 0 ) )
       &&
          (   ( $pad{I2294} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2294} ) && 0 ) )
       &&
          (   ( $pad{I2295} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'Perl5', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2295} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':bytes' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2296} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2296} ) && 0 ) )
       &&
          (   ( $pad{I2297} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2297} ) && 0 ) )
       &&
          (   ( $pad{I2298} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'bytes', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2298} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':codes' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2299} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2299} ) && 0 ) )
       &&
          (   ( $pad{I2300} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2300} ) && 0 ) )
       &&
          (   ( $pad{I2301} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'codes', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2301} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':graphs' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2302} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2302} ) && 0 ) )
       &&
          (   ( $pad{I2303} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2303} ) && 0 ) )
       &&
          (   ( $pad{I2304} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'graphs', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2304} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':langs' => ## <global>
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2305} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2305} ) && 0 ) )
       &&
          (   ( $pad{I2306} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2306} ) && 0 ) )
       &&
          (   ( $pad{I2307} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'langs', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2307} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
);
*term = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       (
           ( $pad{I2308} = $pos or 1 )
           && (
           (
              (   ( $pad{I2309} = $pos or 1 ) && 
               do{
                my $match = 
          do {
            our $I2310;
            our $I2310_sizes;
            unless ( $I2310 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I2310_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I2310 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I2310_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I2310->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I2310, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          };
                if ( $match ) { $named{'Pugs::Grammar::Rule::variables'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2309} ) && 0 ) )
           &&
              (   ( $pad{I2311} = $pos or 1 ) && 
               ## <alt>
               (
                   ( $pad{I2312} = $pos or 1 )
                   && (
                   (
                     (
                      (   ( $pad{I2313} = $pos or 1 ) && 

                         ## <metasyntax>
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = 
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2313} ) && 0 ) )
                     || ( $bool = 1 )
                     ) 
                   &&
                      (   ( $pad{I2314} = $pos or 1 ) && 
                       ## <constant>
                       ( ( substr( $s, $pos, 2 ) eq ':=' )
                           ? ( $pos += 2 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2314} ) && 0 ) )
                   &&
                     (
                      (   ( $pad{I2315} = $pos or 1 ) && 

                         ## <metasyntax>
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = 
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2315} ) && 0 ) )
                     || ( $bool = 1 )
                     ) 
                   &&
                      (   ( $pad{I2316} = $pos or 1 ) && 
                       do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                                   $grammar->named_capture_body( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'named_capture_body'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2316} ) && 0 ) )
                   &&
                      (   ( $pad{I2317} = $pos or 1 ) && 
                       do { 
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'named_capture' => {'rule' => ${ $::_V6_MATCH_->{'named_capture_body'}}, 'ident' => ${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'}}}});
 } }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       } ||    ( ( $pos = $pad{I2317} ) && 0 ) )
                   )
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2312} ) or 1 )
                   &&                     (   ( $pad{I2318} = $pos or 1 ) && 
                     do { 
                       local $::_V6_SUCCEED = 1;
                       $::_V6_MATCH_ = $m;
                       $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'}});
 } }->( $m ) ); 
                       $bool = $::_V6_SUCCEED;
                       $::_V6_MATCH_ = $m if $bool; 
                       return $m if $bool; 
                     } ||    ( ( $pos = $pad{I2318} ) && 0 ) )
                 )
               )
## </alt>
 ||    ( ( $pos = $pad{I2311} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2308} ) or 1 )
           &&            (
              (   ( $pad{I2319} = $pos or 1 ) && 
               do{
                my $match = 
          do {
            our $I2320;
            our $I2320_sizes;
            unless ( $I2320 ) {
                my $hash = \%Pugs::Grammar::Rule::rule_terms;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I2320_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I2320 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I2320_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I2320->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I2320, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          };
                if ( $match ) { $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2319} ) && 0 ) )
           &&
              (   ( $pad{I2321} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::rule_terms'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2321} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2308} ) or 1 )
           &&            (
              (   ( $pad{I2322} = $pos or 1 ) && 
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:(?![\]\}\)\>\:\?\+\*\|\&]))\X)/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I2322} ) && 0 ) )
           &&
              (   ( $pad{I2323} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'constant' => ${$::_V6_MATCH_}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2323} ) && 0 ) )
           )
         )
       )
## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for term
 # Data::Bind->sub_signature
#  (\&term, );
;
*quant = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       (
           ( $pad{I2324} = $pos or 1 )
           && (
           (
              (   ( $pad{I2325} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 2 ) eq '**' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2325} ) && 0 ) )
           &&
             (
              (   ( $pad{I2326} = $pos or 1 ) && 

                 ## <metasyntax>
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = 
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2326} ) && 0 ) )
             || ( $bool = 1 )
             ) 
           &&
              (   ( $pad{I2327} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq '{' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2327} ) && 0 ) )
           &&
              (   ( $pad{I2328} = $pos or 1 ) && 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                           $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2328} ) && 0 ) )
           &&
              (   ( $pad{I2329} = $pos or 1 ) && 
               ## <constant>
               ( ( substr( $s, $pos, 1 ) eq '}' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2329} ) && 0 ) )
           &&
              (   ( $pad{I2330} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2330} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2324} ) or 1 )
           &&            (
            (   ( $pad{I2331} = $pos or 1 ) && 
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\*\+]))\X)/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I2331} ) && 0 ) )
           || ( $bool = 1 )
           ) 
         )
       )
## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for quant
 # Data::Bind->sub_signature
#  (\&quant, );
;
*quantifier = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2332} = $pos or 1 ) && 
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                            (   ( $pad{I2333} = $pos or 1 ) && 

                               ## <metasyntax>
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match = 
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
 ||    ( ( $pos = $pad{I2333} ) && 0 ) )
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws1'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2332} ) && 0 ) )
       &&
          (   ( $pad{I2334} = $pos or 1 ) && 
           do{
               my $pos1 = $pos;
               do {
                 my $pos = $pos1;
                 my $from = $pos;
                 my @match;
                 my %named;
                 $bool =                      do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
                                (   ( $pad{I2335} = $pos or 1 ) && 
                                 ## <perl5>
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[\}\]\)]))\X)/ )
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 )
                                 ## </perl5>
 ||    ( ( $pos = $pad{I2335} ) && 0 ) );
                           $bool;
                         };
                     } ? 0 : 1;
                 $bool;
               };
           } ||    ( ( $pos = $pad{I2334} ) && 0 ) )
       &&
          (   ( $pad{I2336} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->term( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'term'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2336} ) && 0 ) )
       &&
          (   ( $pad{I2337} = $pos or 1 ) && 
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                            (   ( $pad{I2338} = $pos or 1 ) && 

                               ## <metasyntax>
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match = 
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
 ||    ( ( $pos = $pad{I2338} ) && 0 ) )
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws2'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2337} ) && 0 ) )
       &&
          (   ( $pad{I2339} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->quant( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'quant'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2339} ) && 0 ) )
       &&
          (   ( $pad{I2340} = $pos or 1 ) && 
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                            (   ( $pad{I2341} = $pos or 1 ) && 
                               ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\+]))\X)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>
 ||    ( ( $pos = $pad{I2341} ) && 0 ) )
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'greedy'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2340} ) && 0 ) )
       &&
          (   ( $pad{I2342} = $pos or 1 ) && 
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                            (   ( $pad{I2343} = $pos or 1 ) && 

                               ## <metasyntax>
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match = 
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
 ||    ( ( $pos = $pad{I2343} ) && 0 ) )
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws3'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2342} ) && 0 ) )
       &&
          (   ( $pad{I2344} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if((${ $::_V6_MATCH_->{'quant'}} eq '' && (${ $::_V6_MATCH_->{'greedy'}} eq '' && (${ $::_V6_MATCH_->{'ws1'}} eq '' && (${ $::_V6_MATCH_->{'ws2'}} eq '' && ${ $::_V6_MATCH_->{'ws3'}} eq ''))))) { return(${ $::_V6_MATCH_->{'term'}});
 } 
;
return({'quant' => {'term' => ${ $::_V6_MATCH_->{'term'}}, 'quant' => ${ $::_V6_MATCH_->{'quant'}}, 'greedy' => ${ $::_V6_MATCH_->{'greedy'}}, 'ws1' => ${ $::_V6_MATCH_->{'ws1'}}, 'ws2' => ${ $::_V6_MATCH_->{'ws2'}}, 'ws3' => ${ $::_V6_MATCH_->{'ws3'}}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2344} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for quantifier
 # Data::Bind->sub_signature
#  (\&quantifier, );
;
*concat = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
         (
          (   ( $pad{I2345} = $pos or 1 ) && 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                         $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'quantifier'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2345} ) && 0 ) )
         && do { while (
          (   ( $pad{I2345} = $pos or 1 ) && 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                         $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'quantifier'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2345} ) && 0 ) )) {}; $bool = 1 }
         ) 
       &&
          (   ( $pad{I2346} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $_->()  }  @{ $::_V6_MATCH_->{'quantifier'} };
        return { concat => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2346} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for concat
 # Data::Bind->sub_signature
#  (\&concat, );
;
*conjunctive1 = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
         (
          (   ( $pad{I2347} = $pos or 1 ) && 
             (
               (
                (   ( $pad{I2348} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2348} ) && 0 ) )
               || ( $bool = 1 )
               ) 
             &&
                (   ( $pad{I2349} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2349} ) && 0 ) )
             &&
                (   ( $pad{I2350} = $pos or 1 ) && 
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool =                            do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
                                      (   ( $pad{I2351} = $pos or 1 ) && 
                                       ## <constant>
                                       ( ( substr( $s, $pos, 1 ) eq '&' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I2351} ) && 0 ) );
                                 $bool;
                               };
                           } ? 0 : 1;
                       $bool;
                     };
                 } ||    ( ( $pos = $pad{I2350} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I2347} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
         (
           (   ( $pad{I2352} = $pos or 1 ) && 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                         $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'concat'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2352} ) && 0 ) )
         ) 
       &&
         do { while (
          (   ( $pad{I2353} = $pos or 1 ) && 
             (
                (   ( $pad{I2354} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2354} ) && 0 ) )
             &&
                (   ( $pad{I2355} = $pos or 1 ) && 
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool =                            do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
                                      (   ( $pad{I2356} = $pos or 1 ) && 
                                       ## <constant>
                                       ( ( substr( $s, $pos, 1 ) eq '&' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I2356} ) && 0 ) );
                                 $bool;
                               };
                           } ? 0 : 1;
                       $bool;
                     };
                 } ||    ( ( $pos = $pad{I2355} ) && 0 ) )
             &&
                (   ( $pad{I2357} = $pos or 1 ) && 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                             $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'concat'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2357} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I2353} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I2358} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'concat'} };
        return { conjunctive1 => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2358} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for conjunctive1
 # Data::Bind->sub_signature
#  (\&conjunctive1, );
;
*disjunctive1 = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
         (
          (   ( $pad{I2359} = $pos or 1 ) && 
             (
               (
                (   ( $pad{I2360} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2360} ) && 0 ) )
               || ( $bool = 1 )
               ) 
             &&
                (   ( $pad{I2361} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2361} ) && 0 ) )
             &&
                (   ( $pad{I2362} = $pos or 1 ) && 
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool =                            do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
                                      (   ( $pad{I2363} = $pos or 1 ) && 
                                       ## <constant>
                                       ( ( substr( $s, $pos, 1 ) eq '|' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I2363} ) && 0 ) );
                                 $bool;
                               };
                           } ? 0 : 1;
                       $bool;
                     };
                 } ||    ( ( $pos = $pad{I2362} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I2359} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
         (
           (   ( $pad{I2364} = $pos or 1 ) && 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                         $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2364} ) && 0 ) )
         ) 
       &&
         do { while (
          (   ( $pad{I2365} = $pos or 1 ) && 
             (
                (   ( $pad{I2366} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2366} ) && 0 ) )
             &&
                (   ( $pad{I2367} = $pos or 1 ) && 
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool =                            do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
                                      (   ( $pad{I2368} = $pos or 1 ) && 
                                       ## <constant>
                                       ( ( substr( $s, $pos, 1 ) eq '|' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I2368} ) && 0 ) );
                                 $bool;
                               };
                           } ? 0 : 1;
                       $bool;
                     };
                 } ||    ( ( $pos = $pad{I2367} ) && 0 ) )
             &&
                (   ( $pad{I2369} = $pos or 1 ) && 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                             $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2369} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I2365} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I2370} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive1'} };
        return { alt1 => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2370} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for disjunctive1
 # Data::Bind->sub_signature
#  (\&disjunctive1, );
;
*conjunctive = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
         (
          (   ( $pad{I2371} = $pos or 1 ) && 
             (
               (
                (   ( $pad{I2372} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2372} ) && 0 ) )
               || ( $bool = 1 )
               ) 
             &&
                (   ( $pad{I2373} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2373} ) && 0 ) )
             &&
                (   ( $pad{I2374} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2374} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I2371} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
         (
           (   ( $pad{I2375} = $pos or 1 ) && 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                         $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2375} ) && 0 ) )
         ) 
       &&
         do { while (
          (   ( $pad{I2376} = $pos or 1 ) && 
             (
                (   ( $pad{I2377} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2377} ) && 0 ) )
             &&
                (   ( $pad{I2378} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2378} ) && 0 ) )
             &&
                (   ( $pad{I2379} = $pos or 1 ) && 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                             $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2379} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I2376} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I2380} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'disjunctive1'} };
        return { conjunctive => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2380} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for conjunctive
 # Data::Bind->sub_signature
#  (\&conjunctive, );
;
*rule = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
         (
          (   ( $pad{I2381} = $pos or 1 ) && 
             (
               (
                (   ( $pad{I2382} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2382} ) && 0 ) )
               || ( $bool = 1 )
               ) 
             &&
                (   ( $pad{I2383} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2383} ) && 0 ) )
             &&
                (   ( $pad{I2384} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2384} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I2381} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
         (
           (   ( $pad{I2385} = $pos or 1 ) && 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                         $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2385} ) && 0 ) )
         ) 
       &&
         do { while (
          (   ( $pad{I2386} = $pos or 1 ) && 
             (
                (   ( $pad{I2387} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2387} ) && 0 ) )
             &&
                (   ( $pad{I2388} = $pos or 1 ) && 
                 ## <constant>
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2388} ) && 0 ) )
             &&
                (   ( $pad{I2389} = $pos or 1 ) && 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                             $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2389} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I2386} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I2390} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive'} };
        return { alt => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2390} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for rule
 # Data::Bind->sub_signature
#  (\&rule, );
;
*named_regex = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2391} = $pos or 1 ) && 
           do{
               my $hash = do {
                 my $bool = 1;
                 my $from = $pos;
                 my @match;
                 my %named;
                 $bool = 0 unless
                   ## <alt>
                   (
                       ( $pad{I2392} = $pos or 1 )
                       && (
                        (   ( $pad{I2393} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 5 ) eq 'token' )
                             ? ( $pos += 5 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2393} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2392} ) or 1 )
                       &&                         (   ( $pad{I2394} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 5 ) eq 'regex' )
                             ? ( $pos += 5 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2394} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2392} ) or 1 )
                       &&                         (   ( $pad{I2395} = $pos or 1 ) && 
                         ## <constant>
                         ( ( substr( $s, $pos, 4 ) eq 'rule' )
                             ? ( $pos += 4 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2395} ) && 0 ) )
                     )
                   )
## </alt>
;
                 { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
               };
               my $bool = ${$hash->{'bool'}};
               $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
               $bool;
           } ||    ( ( $pos = $pad{I2391} ) && 0 ) )
       &&
          (   ( $pad{I2396} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2396} ) && 0 ) )
       &&
          (   ( $pad{I2397} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2397} ) && 0 ) )
       &&
         (
          (   ( $pad{I2398} = $pos or 1 ) && 

             ## <metasyntax>
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = 
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2398} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
          (   ( $pad{I2399} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq '{' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2399} ) && 0 ) )
       &&
         (
          (   ( $pad{I2400} = $pos or 1 ) && 

             ## <metasyntax>
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = 
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2400} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
          (   ( $pad{I2401} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2401} ) && 0 ) )
       &&
          (   ( $pad{I2402} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq '}' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2402} ) && 0 ) )
       &&
         (
          (   ( $pad{I2403} = $pos or 1 ) && 
             ## <constant>
             ( ( substr( $s, $pos, 1 ) eq ';' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>
 ||    ( ( $pos = $pad{I2403} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
          (   ( $pad{I2404} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'type' => ${$::_V6_MATCH_->[0]}, 'name' => ${ $::_V6_MATCH_->{'ident'}}, 'ast' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2404} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for named_regex
 # Data::Bind->sub_signature
#  (\&named_regex, );
;
*block = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
          (   ( $pad{I2405} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq '{' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2405} ) && 0 ) )
       &&
          (   ( $pad{I2406} = $pos or 1 ) && 
           do{
               my $hash = do {
                 my $bool = 1;
                 my $from = $pos;
                 my @match;
                 my %named;
                 $bool = 0 unless
                   ## <alt>
                   (
                       ( $pad{I2407} = $pos or 1 )
                       && (
                        (   ( $pad{I2408} = $pos or 1 ) && 

                         ## <metasyntax>
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2408} ) && 0 ) )
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2407} ) or 1 )
                       &&                         (   ( $pad{I2409} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I2409} ) && 0 ) )
                     )
                   )
## </alt>
;
                 { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
               };
               my $bool = ${$hash->{'bool'}};
               $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
               $bool;
           } ||    ( ( $pos = $pad{I2406} ) && 0 ) )
       &&
          (   ( $pad{I2410} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq '}' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2410} ) && 0 ) )
       &&
          (   ( $pad{I2411} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'type' => 'block', 'value' => ${$::_V6_MATCH_->[0]}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2411} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for block
 # Data::Bind->sub_signature
#  (\&block, );
;
*statement = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       (
           ( $pad{I2412} = $pos or 1 )
           && (
           (
              (   ( $pad{I2413} = $pos or 1 ) && 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                           $grammar->block( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'block'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2413} ) && 0 ) )
           &&
              (   ( $pad{I2414} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'block'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2414} ) && 0 ) )
           )
           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2412} ) or 1 )
           &&            (
              (   ( $pad{I2415} = $pos or 1 ) && 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                           $grammar->named_regex( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'named_regex'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2415} ) && 0 ) )
           &&
              (   ( $pad{I2416} = $pos or 1 ) && 
               do { 
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'named_regex'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               } ||    ( ( $pos = $pad{I2416} ) && 0 ) )
           )
         )
       )
## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for statement
 # Data::Bind->sub_signature
#  (\&statement, );
;
*grammar = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
         (
          (   ( $pad{I2417} = $pos or 1 ) && 

             ## <metasyntax>
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = 
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2417} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
          (   ( $pad{I2418} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 7 ) eq 'grammar' )
               ? ( $pos += 7 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2418} ) && 0 ) )
       &&
          (   ( $pad{I2419} = $pos or 1 ) && 

           ## <metasyntax>
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2419} ) && 0 ) )
       &&
          (   ( $pad{I2420} = $pos or 1 ) && 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                       $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2420} ) && 0 ) )
       &&
         (
          (   ( $pad{I2421} = $pos or 1 ) && 

             ## <metasyntax>
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = 
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2421} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
          (   ( $pad{I2422} = $pos or 1 ) && 
           ## <constant>
           ( ( substr( $s, $pos, 1 ) eq ';' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2422} ) && 0 ) )
       &&
         (
          (   ( $pad{I2423} = $pos or 1 ) && 

             ## <metasyntax>
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = 
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2423} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
         do { while (
          (   ( $pad{I2424} = $pos or 1 ) && 
             (
                (   ( $pad{I2425} = $pos or 1 ) && 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                             $grammar->statement( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'statement'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2425} ) && 0 ) )
             &&
               (
                (   ( $pad{I2426} = $pos or 1 ) && 

                   ## <metasyntax>
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = 
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2426} ) && 0 ) )
               || ( $bool = 1 )
               ) 
             ) ||    ( ( $pos = $pad{I2424} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I2427} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({${ $::_V6_MATCH_->{'ident'}} =>  $::_V6_MATCH_->{'statement'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2427} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for grammar
 # Data::Bind->sub_signature
#  (\&grammar, );
;
*spec = ## <global>
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || pos($_[1]) || 0 ) .. length( $s ) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       (
         (
          (   ( $pad{I2428} = $pos or 1 ) && 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                         $grammar->block( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'block'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2428} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
         do { while (
          (   ( $pad{I2429} = $pos or 1 ) && 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match = 
                         $grammar->grammar( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'grammar'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            } ||    ( ( $pos = $pad{I2429} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I2430} = $pos or 1 ) && 
           do { 
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'block' =>  $::_V6_MATCH_->{'block'}, 'grammar' =>  $::_V6_MATCH_->{'grammar'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           } ||    ( ( $pos = $pad{I2430} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for spec
 # Data::Bind->sub_signature
#  (\&spec, );
;

; 1;
