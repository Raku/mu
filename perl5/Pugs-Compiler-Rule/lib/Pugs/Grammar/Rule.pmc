        package Pugs::Grammar::Rule;
        no strict 'refs';
        use Pugs::Runtime::Match;
        use Pugs::Runtime::Regex;
        our %rule_terms;
        our %variables;
*pod_begin = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          ( $pad{I1021} = $pos or 1 )
          && (
            (
              (
                ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ ) ? ( $pos += length($1) or 1 )
                : 0
              )
              && (
                ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && (
                ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && (
                ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && (
                ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1021} ) or 1 )
            && (
              ( substr( $s, $pos++, 1 ) ne '' )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
              }
            )
          )
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for pod_begin
# Data::Bind->sub_signature( \&pod_begin, );
*pod_other = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          ( $pad{I1022} = $pos or 1 )
          && (
            (
              (
                ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ ) ? ( $pos += length($1) or 1 )
                : 0
              )
              && (
                ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && (
                ( substr( $s, $pos, 1 ) eq 'c' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && (
                ( substr( $s, $pos, 1 ) eq 'u' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && (
                ( substr( $s, $pos, 1 ) eq 't' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1022} ) or 1 )
            && (
              ( substr( $s, $pos++, 1 ) ne '' )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
              }
            )
          )
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for pod_other
# Data::Bind->sub_signature( \&pod_other, );
*ws = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          (
            ( $pad{I1023} = $pos or 1 )
            && (
              (
                (
                    ( substr( $s, $pos, 1 ) eq '#' )
                  ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  while ( ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                  $bool = 1;
                }
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1023} ) or 1 )
              && (
                (
                  ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ ) ? ( $pos += length($1) or 1 )
                  : 0
                )
                && (
                  (
                    (
                      ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      (
                        ( $pad{I1024} = $pos or 1 )
                        && (
                          (
                            (
                              ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                            && (
                              ( substr( $s, $pos, 1 ) eq 'E' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'N' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'D' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              while ( ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                              $bool = 1;
                            }
                            && do {
                              while ( ( substr( $s, $pos++, 1 ) ne '' ) ) { }
                              $bool = 1;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1024} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1024} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'k' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'w' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1024} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'p' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1024} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'f' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'r' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1024} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'h' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'a' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq '1' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $prior = $::_V6_PRIOR_;
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                      )
                      || ( $bool = 1 )
                    )
                  )
                  || ( $bool = 1 )
                )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1023} ) or 1 )
              && (
                  ( substr( $s, $pos ) =~ m/^(\s)/ )
                ? ( $pos += length($1) or 1 )
                : 0
              )
            )
          )
          && do {
            while (
              (
                ( $pad{I1023} = $pos or 1 )
                && (
                  (
                    (
                        ( substr( $s, $pos, 1 ) eq '#' )
                      ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && do {
                      while ( ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                      $bool = 1;
                    }
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1023} ) or 1 )
                  && (
                    (
                      ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ ) ? ( $pos += length($1) or 1 )
                      : 0
                    )
                    && (
                      (
                        (
                          ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          (
                            ( $pad{I1024} = $pos or 1 )
                            && (
                              (
                                (
                                  ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = ( !$match != 1 );
                                  $pos = $match->to if $bool;
                                  $match;
                                }
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'E' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'N' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'D' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && do {
                                  while ( ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                                  $bool = 1;
                                }
                                && do {
                                  while ( ( substr( $s, $pos++, 1 ) ne '' ) ) { }
                                  $bool = 1;
                                }
                              )
                            )
                            || (
                              ( ( $bool = 1 ) && ( $pos = $pad{I1024} ) or 1 )
                              && (
                                (
                                  ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = ( !$match != 1 );
                                  $pos = $match->to if $bool;
                                  $match;
                                }
                              )
                            )
                            || (
                              ( ( $bool = 1 ) && ( $pos = $pad{I1024} ) or 1 )
                              && (
                                (
                                  ( substr( $s, $pos, 1 ) eq 'k' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'w' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = ( !$match != 1 );
                                  $pos = $match->to if $bool;
                                  $match;
                                }
                              )
                            )
                            || (
                              ( ( $bool = 1 ) && ( $pos = $pad{I1024} ) or 1 )
                              && (
                                (
                                  ( substr( $s, $pos, 1 ) eq 'p' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = ( !$match != 1 );
                                  $pos = $match->to if $bool;
                                  $match;
                                }
                              )
                            )
                            || (
                              ( ( $bool = 1 ) && ( $pos = $pad{I1024} ) or 1 )
                              && (
                                (
                                  ( substr( $s, $pos, 1 ) eq 'f' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'r' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = ( !$match != 1 );
                                  $pos = $match->to if $bool;
                                  $match;
                                }
                              )
                            )
                            || (
                              ( ( $bool = 1 ) && ( $pos = $pad{I1024} ) or 1 )
                              && (
                                (
                                  ( substr( $s, $pos, 1 ) eq 'h' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'a' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  ( substr( $s, $pos, 1 ) eq '1' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = ( !$match != 1 );
                                  $pos = $match->to if $bool;
                                  $match;
                                }
                              )
                            )
                          )
                          || ( $bool = 1 )
                        )
                      )
                      || ( $bool = 1 )
                    )
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1023} ) or 1 )
                  && (
                      ( substr( $s, $pos ) =~ m/^(\s)/ )
                    ? ( $pos += length($1) or 1 )
                    : 0
                  )
                )
              )
              )
            {
            }
            $bool = 1;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for ws
# Data::Bind->sub_signature( \&ws, );
*ident = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          (
            ( $pad{I1025} = $pos or 1 )
            && (
              (
                ( substr( $s, $pos ) =~ m/^([[:alnum:]])/ ) ? ( $pos += length($1) or 1 )
                : 0
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1025} ) or 1 )
              && (
                ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                : 0
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1025} ) or 1 )
              && (
                ( substr( $s, $pos, 2 ) eq '::' ) ? ( $pos += 2 or 1 )
                : 0
              )
            )
          )
          && do {
            while ( ( ( $pad{I1025} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^([[:alnum:]])/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1025} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1025} ) or 1 ) && ( ( substr( $s, $pos, 2 ) eq '::' ) ? ( $pos += 2 or 1 ) : 0 ) ) ) ) { }
            $bool = 1;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for ident
# Data::Bind->sub_signature( \&ident, );
*literal = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless do {
          while ( ( ( $pad{I1026} = $pos or 1 ) && ( ( ( ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 ) : 0 ) && ( substr( $s, $pos++, 1 ) ne '' ) ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1026} ) or 1 ) && ( ( substr( $s, $pos ) =~ m/^([^\'])/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) ) ) { }
          $bool = 1;
          };
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for literal
# Data::Bind->sub_signature( \&literal, );
*metasyntax = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          (
            (
              ( $pad{I1027} = $pos or 1 )
              && (
                (
                  (
                    ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && ( substr( $s, $pos++, 1 ) ne '' )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1027} ) or 1 )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    my $prior = $::_V6_PRIOR_;
                    my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1027} ) or 1 )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    my $prior = $::_V6_PRIOR_;
                    my $match = $grammar->string_code( $s, { p => $pos, args => {} }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1027} ) or 1 )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq '<' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    my $prior = $::_V6_PRIOR_;
                    my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq '>' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1027} ) or 1 )
                && (
                  ( substr( $s, $pos ) =~ m/^([^\>])/ ) ? ( $pos += length($1) or 1 )
                  : 0
                )
              )
            )
            && do {
              while (
                (
                  ( $pad{I1027} = $pos or 1 )
                  && (
                    (
                      (
                        ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                      && ( substr( $s, $pos++, 1 ) ne '' )
                    )
                  )
                  || (
                    ( ( $bool = 1 ) && ( $pos = $pad{I1027} ) or 1 )
                    && (
                      (
                        ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                      && do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                      }
                      && (
                        ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                    )
                  )
                  || (
                    ( ( $bool = 1 ) && ( $pos = $pad{I1027} ) or 1 )
                    && (
                      (
                        ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                      && do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = $grammar->string_code( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                      }
                      && (
                        ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                    )
                  )
                  || (
                    ( ( $bool = 1 ) && ( $pos = $pad{I1027} ) or 1 )
                    && (
                      (
                        ( substr( $s, $pos, 1 ) eq '<' ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                      && do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                      }
                      && (
                        ( substr( $s, $pos, 1 ) eq '>' ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                    )
                  )
                  || (
                    ( ( $bool = 1 ) && ( $pos = $pad{I1027} ) or 1 )
                    && (
                      ( substr( $s, $pos ) =~ m/^([^\>])/ ) ? ( $pos += length($1) or 1 )
                      : 0
                    )
                  )
                )
                )
              {
              }
              $bool = 1;
            }
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'metasyntax' => ${$::_V6_MATCH_} } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for metasyntax
# Data::Bind->sub_signature( \&metasyntax, );
*string_code = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          (
            ( $pad{I1028} = $pos or 1 )
            && (
              (
                (
                  ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && ( substr( $s, $pos++, 1 ) ne '' )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1028} ) or 1 )
              && (
                (
                  ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = ( !$match != 1 );
                  $pos = $match->to if $bool;
                  $match;
                }
                && (
                  ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                  : 0
                )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1028} ) or 1 )
              && (
                (
                  ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = $grammar->string_code( $s, { p => $pos, args => {} }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = ( !$match != 1 );
                  $pos = $match->to if $bool;
                  $match;
                }
                && (
                  ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                  : 0
                )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1028} ) or 1 )
              && (
                ( substr( $s, $pos ) =~ m/^([^\}])/ ) ? ( $pos += length($1) or 1 )
                : 0
              )
            )
          )
          && do {
            while (
              (
                ( $pad{I1028} = $pos or 1 )
                && (
                  (
                    (
                      ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && ( substr( $s, $pos++, 1 ) ne '' )
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1028} ) or 1 )
                  && (
                    (
                      ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = ( !$match != 1 );
                      $pos = $match->to if $bool;
                      $match;
                    }
                    && (
                      ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1028} ) or 1 )
                  && (
                    (
                      ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = $grammar->string_code( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = ( !$match != 1 );
                      $pos = $match->to if $bool;
                      $match;
                    }
                    && (
                      ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1028} ) or 1 )
                  && (
                    ( substr( $s, $pos ) =~ m/^([^\}])/ ) ? ( $pos += length($1) or 1 )
                    : 0
                  )
                )
              )
              )
            {
            }
            $bool = 1;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for string_code
# Data::Bind->sub_signature( \&string_code, );
*parsed_code = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          do {
            my $prior = $::_V6_PRIOR_;
            my $match = $grammar->string_code( $s, { p => $pos, args => {} }, undef );
            $::_V6_PRIOR_ = $prior;
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
          }
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( '{' . $::_V6_MATCH_ . '}' );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for parsed_code
# Data::Bind->sub_signature( \&parsed_code, );
*named_capture_body = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          ( $pad{I1029} = $pos or 1 )
          && (
            (
              (
                  ( substr( $s, $pos, 1 ) eq '(' )
                ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'rule'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
              && (
                  ( substr( $s, $pos, 1 ) eq ')' )
                ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    return ( { 'capturing_group' => ${ $::_V6_MATCH_->{'rule'} } } );
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1029} ) or 1 )
            && (
              (
                  ( substr( $s, $pos, 1 ) eq '[' )
                ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'rule'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
              && (
                  ( substr( $s, $pos, 1 ) eq ']' )
                ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    return ( ${ $::_V6_MATCH_->{'rule'} } );
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1029} ) or 1 )
            && (
              (
                  ( substr( $s, $pos, 1 ) eq '<' )
                ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'metasyntax'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
              && (
                  ( substr( $s, $pos, 1 ) eq '>' )
                ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    return ( ${ $::_V6_MATCH_->{'metasyntax'} } );
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1029} ) or 1 )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              sub {
                die("invalid alias syntax");
                }
                ->();
              $::_V6_SUCCEED;
            }
          )
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for named_capture_body
# Data::Bind->sub_signature( \&named_capture_body, );
%variables = (
  '$<' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ident( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'ident'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
                ( substr( $s, $pos, 1 ) eq '>' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'match_variable' => '$' . $::_V6_MATCH_->{'ident'} } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '$' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            ( $pad{I1030} = $pos or 1 )
            && (
              (
                (
                  (
                      ( substr( $s, $pos ) =~ m/^([[:digit:]])/ )
                    ? ( $pos += length($1) or 1 )
                    : 0
                  )
                  && do {
                    while ( ( ( substr( $s, $pos ) =~ m/^([[:digit:]])/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                    $bool = 1;
                  }
                )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return ( { 'match_variable' => '$' . $::_V6_MATCH_ } );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1030} ) or 1 )
              && (
                (
                  (
                    ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  || ( $bool = 1 )
                )
                && (
                  (
                    ( $pad{I1031} = $pos or 1 )
                    && (
                      (
                        ( substr( $s, $pos ) =~ m/^([[:alnum:]])/ ) ? ( $pos += length($1) or 1 )
                        : 0
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1031} ) or 1 )
                      && (
                        ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1031} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                      )
                    )
                  )
                  && do {
                    while ( ( ( $pad{I1031} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^([[:alnum:]])/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1031} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1031} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) { }
                    $bool = 1;
                  }
                )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return ( { 'variable' => '$' . $::_V6_MATCH_ } );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '@' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            ( $pad{I1032} = $pos or 1 )
            && (
              (
                (
                  (
                      ( substr( $s, $pos ) =~ m/^([[:digit:]])/ )
                    ? ( $pos += length($1) or 1 )
                    : 0
                  )
                  && do {
                    while ( ( ( substr( $s, $pos ) =~ m/^([[:digit:]])/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                    $bool = 1;
                  }
                )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return ( { 'match_variable' => '@' . $::_V6_MATCH_ } );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1032} ) or 1 )
              && (
                (
                  (
                    ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  || ( $bool = 1 )
                )
                && (
                  (
                    ( $pad{I1033} = $pos or 1 )
                    && (
                      (
                        ( substr( $s, $pos ) =~ m/^([[:alnum:]])/ ) ? ( $pos += length($1) or 1 )
                        : 0
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1033} ) or 1 )
                      && (
                        ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1033} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                      )
                    )
                  )
                  && do {
                    while ( ( ( $pad{I1033} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^([[:alnum:]])/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1033} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1033} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) { }
                    $bool = 1;
                  }
                )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return ( { 'variable' => '@' . $::_V6_MATCH_ } );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '%' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            ( $pad{I1034} = $pos or 1 )
            && (
              (
                (
                  (
                      ( substr( $s, $pos ) =~ m/^([[:digit:]])/ )
                    ? ( $pos += length($1) or 1 )
                    : 0
                  )
                  && do {
                    while ( ( ( substr( $s, $pos ) =~ m/^([[:digit:]])/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                    $bool = 1;
                  }
                )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return ( { 'match_variable' => '%' . $::_V6_MATCH_ } );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1034} ) or 1 )
              && (
                (
                  (
                    ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  || ( $bool = 1 )
                )
                && (
                  (
                    ( $pad{I1035} = $pos or 1 )
                    && (
                      (
                        ( substr( $s, $pos ) =~ m/^([[:alnum:]])/ ) ? ( $pos += length($1) or 1 )
                        : 0
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1035} ) or 1 )
                      && (
                        ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1035} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                      )
                    )
                  )
                  && do {
                    while ( ( ( $pad{I1035} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^([[:alnum:]])/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1035} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1035} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) { }
                    $bool = 1;
                  }
                )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return ( { 'variable' => '%' . $::_V6_MATCH_ } );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
    }
);
%rule_terms = (
  '(' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
                ( substr( $s, $pos, 1 ) eq ')' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'capturing_group' => ${ $::_V6_MATCH_->{'rule'} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '<(' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
                ( substr( $s, $pos, 2 ) eq ')>' )
              ? ( $pos += 2 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'capture_as_result' => ${ $::_V6_MATCH_->{'rule'} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '<after' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
                ( substr( $s, $pos, 1 ) eq '>' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'after' => { 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '<before' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
                ( substr( $s, $pos, 1 ) eq '>' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'before' => { 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '<!before' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
                ( substr( $s, $pos, 1 ) eq '>' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'not_before' => { 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '<!' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'metasyntax'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
                ( substr( $s, $pos, 1 ) eq '>' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'negate' => { 'metasyntax' => ${ $::_V6_MATCH_->{qw(metasyntax)} } } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '<' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'metasyntax'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
                ( substr( $s, $pos, 1 ) eq '>' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( ${ $::_V6_MATCH_->{'metasyntax'} } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '{' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->parsed_code( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'parsed_code'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
                ( substr( $s, $pos, 1 ) eq '}' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'closure' => ${ $::_V6_MATCH_->{'parsed_code'} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '\\' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            ( $pad{I1036} = $pos or 1 )
            && (
              (
                (
                  ( $pad{I1037} = $pos or 1 )
                  && (
                    (
                      ( substr( $s, $pos, 1 ) eq 'x' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                  || (
                    ( ( $bool = 1 ) && ( $pos = $pad{I1037} ) or 1 )
                    && (
                      ( substr( $s, $pos, 1 ) eq 'X' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                  || (
                    ( ( $bool = 1 ) && ( $pos = $pad{I1037} ) or 1 )
                    && (
                      ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                  || (
                    ( ( $bool = 1 ) && ( $pos = $pad{I1037} ) or 1 )
                    && (
                      ( substr( $s, $pos, 1 ) eq 'O' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                )
                && (
                  (
                    ( substr( $s, $pos ) =~ m/^(\d)/ ) ? ( $pos += length($1) or 1 )
                    : 0
                  )
                  && do {
                    while ( ( ( substr( $s, $pos ) =~ m/^(\d)/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                    $bool = 1;
                  }
                )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return ( { 'special_char' => '\\' . $::_V6_MATCH_ } );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1036} ) or 1 )
              && (
                do {
                  my $hash = do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0
                      unless (
                      ( $pad{I1038} = $pos or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq 'x' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                      )
                      || (
                        ( ( $bool = 1 ) && ( $pos = $pad{I1038} ) or 1 )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'X' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                      )
                      || (
                        ( ( $bool = 1 ) && ( $pos = $pad{I1038} ) or 1 )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                      )
                      || (
                        ( ( $bool = 1 ) && ( $pos = $pad{I1038} ) or 1 )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'O' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                      )
                      );
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                  };
                  my $bool = ${ $hash->{'bool'} };
                  $match[0] = Pugs::Runtime::Match->new($hash);
                  $bool;
                }
                && (
                    ( substr( $s, $pos, 1 ) eq '[' )
                  ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  my $hash = do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0
                      unless (
                      (
                          ( substr( $s, $pos ) =~ m/^(\d)/ )
                        ? ( $pos += length($1) or 1 )
                        : 0
                      )
                      && do {
                        while ( ( ( substr( $s, $pos ) =~ m/^(\d)/ ) ? ( $pos += length($1) or 1 ) : 0 ) ) { }
                        $bool = 1;
                      }
                      );
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                  };
                  my $bool = ${ $hash->{'bool'} };
                  $match[1] = Pugs::Runtime::Match->new($hash);
                  $bool;
                }
                && (
                    ( substr( $s, $pos, 1 ) eq ']' )
                  ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return ( { 'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1] } );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1036} ) or 1 )
              && (
                ( substr( $s, $pos++, 1 ) ne '' )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return ( { 'special_char' => '\\' . $::_V6_MATCH_ } );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '.' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'dot' => 1 } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '[' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
                ( substr( $s, $pos, 1 ) eq ']' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( ${ $::_V6_MATCH_->{'rule'} } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':::' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => ':::' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':?' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => ':?' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':+' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => ':+' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '::' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => '::' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => ':' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '$$' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => '$$' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '$' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => '$' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '^^' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => '^^' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '^' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => '^' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '>>' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => '>>' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => '>>' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '<<' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => '<<' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  '' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'colon' => '<<' } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            };
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':i' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'modifier' => 'ignorecase', 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':ignorecase' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'modifier' => 'ignorecase', 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':s' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'modifier' => 'sigspace', 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':sigspace' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'modifier' => 'sigspace', 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':P5' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'modifier' => 'Perl5', 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':Perl5' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'modifier' => 'Perl5', 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':bytes' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'modifier' => 'bytes', 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':codes' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'modifier' => 'codes', 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':graphs' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'modifier' => 'graphs', 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
  },
  ':langs' => do {
    my $rule;
    $rule = sub {

      my $s       = $_[0] || '';
      my $grammar = $_[1] || __PACKAGE__;
      $_[3] = $_[2];
      $_[2] = undef;

      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      for my $pos (
        defined $_[3]{p} && !$_[3]{continue}
        ? $_[3]{p}
        : ( ( $_[3]{p} || 0 ) .. length($s) )
        )
      {
        my %index;
        my @match;
        my %named;
        my $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new(
          {
            str     => \$s,
            from    => \( 0 + $pos ),
            to      => \($pos),
            bool    => \$bool,
            match   => \@match,
            named   => \%named,
            capture => undef,
          }
        );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0
            unless (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                $named{'rule'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return ( { 'modifier' => 'langs', 'rule' => ${ $::_V6_MATCH_->{qw(rule)} } } );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            );
        }
        if ($bool) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          last;
        }
      }    # /for
      $::_V6_MATCH_ = $m;
      return $m;
      }
    }
);
*term = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          ( $pad{I1039} = $pos or 1 )
          && (
            (
              do {
                my $match = do {
                  our $I1040;
                  our $I1040_sizes;
                  unless ($I1040) {
                    my $hash = \%Pugs::Grammar::Rule::variables;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I1040_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I1040 = $hash;
                  }
                  my $match = 0;
                  my $key;
                  for (@$I1040_sizes) {
                    $key = (
                      $pos <= length($s)
                      ? substr( $s, $pos, $_ )
                      : ''
                    );
                    if ( exists $I1040->{$key} ) {

                      #$named{KEY} = $key;
                      #$::_V6_MATCH_ = $m;
                      #print "m: ", Dumper( $::_V6_MATCH_->data )
                      #    if ( $key eq 'until' );
                      $match = Pugs::Runtime::Regex::preprocess_hash( $I1040, $key )->( $s, $grammar, { p => ( $pos + $_ ), args => { KEY => $key } }, undef );
                      last if $match;
                    }
                  }
                  if ($match) {
                    $pos = $match->to;

                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                  }
                  ;    # else { $bool = 0 }
                  $match;
                };
                if ($match) {
                  $named{'Pugs::Grammar::Rule::variables'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
              && (
                ( $pad{I1041} = $pos or 1 )
                && (
                  (
                    (
                      do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                      }
                      || ( $bool = 1 )
                    )
                    && (
                        ( substr( $s, $pos, 2 ) eq ':=' )
                      ? ( $pos += 2 or 1 )
                      : 0
                    )
                    && (
                      do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                      }
                      || ( $bool = 1 )
                    )
                    && do {
                      my $prior = $::_V6_PRIOR_;
                      my $match = $grammar->named_capture_body( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior;
                      if ($match) {
                        $named{'named_capture_body'} = $match;
                        $pos = $match->to;
                        1;
                      }
                      else { 0 }
                    }
                    && do {
                      $::_V6_MATCH_ = $m;
                      local $::_V6_SUCCEED = 1;
                      $m->data->{capture} = \(
                        sub {
                          return ( { 'named_capture' => { 'rule' => ${ $::_V6_MATCH_->{'named_capture_body'} }, 'ident' => ${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'} } } } );
                          }
                          ->()
                      );
                      $bool = $::_V6_SUCCEED;
                      $::_V6_MATCH_ = $m if $bool;
                      return $m if $bool;
                    }
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1041} ) or 1 )
                  && do {
                    $::_V6_MATCH_ = $m;
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \(
                      sub {
                        return ( ${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'} } );
                        }
                        ->()
                    );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool;
                    return $m if $bool;
                  }
                )
              )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1039} ) or 1 )
            && (
              do {
                my $match = do {
                  our $I1042;
                  our $I1042_sizes;
                  unless ($I1042) {
                    my $hash = \%Pugs::Grammar::Rule::rule_terms;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I1042_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I1042 = $hash;
                  }
                  my $match = 0;
                  my $key;
                  for (@$I1042_sizes) {
                    $key = (
                      $pos <= length($s)
                      ? substr( $s, $pos, $_ )
                      : ''
                    );
                    if ( exists $I1042->{$key} ) {

                      #$named{KEY} = $key;
                      #$::_V6_MATCH_ = $m;
                      #print "m: ", Dumper( $::_V6_MATCH_->data )
                      #    if ( $key eq 'until' );
                      $match = Pugs::Runtime::Regex::preprocess_hash( $I1042, $key )->( $s, $grammar, { p => ( $pos + $_ ), args => { KEY => $key } }, undef );
                      last if $match;
                    }
                  }
                  if ($match) {
                    $pos = $match->to;

                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                  }
                  ;    # else { $bool = 0 }
                  $match;
                };
                if ($match) {
                  $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    return ( ${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::rule_terms'} } );
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1039} ) or 1 )
            && (
              (
                  ( substr( $s, $pos ) =~ m/^([^\]\}\)\>\:\?\+\*\|\&])/ )
                ? ( $pos += length($1) or 1 )
                : 0
              )
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    return ( { 'constant' => ${$::_V6_MATCH_} } );
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
          )
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for term
# Data::Bind->sub_signature( \&term, );
*quant = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          ( $pad{I1043} = $pos or 1 )
          && (
            (
              (
                  ( substr( $s, $pos, 2 ) eq '**' )
                ? ( $pos += 2 or 1 )
                : 0
              )
              && (
                do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = ( !$match != 1 );
                  $pos = $match->to if $bool;
                  $match;
                }
                || ( $bool = 1 )
              )
              && (
                  ( substr( $s, $pos, 1 ) eq '{' )
                ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->parsed_code( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'parsed_code'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
              && (
                  ( substr( $s, $pos, 1 ) eq '}' )
                ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    return ( { 'closure' => ${ $::_V6_MATCH_->{'parsed_code'} } } );
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1043} ) or 1 )
            && (
              (
                  ( substr( $s, $pos ) =~ m/^([\?\*\+])/ )
                ? ( $pos += length($1) or 1 )
                : 0
              )
              || ( $bool = 1 )
            )
          )
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for quant
# Data::Bind->sub_signature( \&quant, );
*quantifier = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          do {
            my $match = Pugs::Runtime::Match->new(
              do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0 unless do {
                  my $hash = do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0
                      unless (
                      do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                      }
                      || ( $bool = 1 )
                      );
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                  };
                  my $bool = ${ $hash->{'bool'} };
                  $match[0] = Pugs::Runtime::Match->new($hash);
                  $bool;
                };
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                }
            );
            if ($match) {
              $named{'ws1'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            my $pos1 = $pos;
            do {
              my $pos  = $pos1;
              my $from = $pos;
              my @match;
              my %named;
              my $bool = 1;
              $bool = 0
                unless (
                  ( substr( $s, $pos ) =~ m/^([\}\]\)])/ )
                ? ( $pos += length($1) or 1 )
                : 0
                );
              !$bool;
            };
          }
          && do {
            my $prior = $::_V6_PRIOR_;
            my $match = $grammar->term( $s, { p => $pos, args => {} }, undef );
            $::_V6_PRIOR_ = $prior;
            if ($match) {
              $named{'term'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            my $match = Pugs::Runtime::Match->new(
              do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0 unless do {
                  my $hash = do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0
                      unless (
                      do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                      }
                      || ( $bool = 1 )
                      );
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                  };
                  my $bool = ${ $hash->{'bool'} };
                  $match[0] = Pugs::Runtime::Match->new($hash);
                  $bool;
                };
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                }
            );
            if ($match) {
              $named{'ws2'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            my $prior = $::_V6_PRIOR_;
            my $match = $grammar->quant( $s, { p => $pos, args => {} }, undef );
            $::_V6_PRIOR_ = $prior;
            if ($match) {
              $named{'quant'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            my $match = Pugs::Runtime::Match->new(
              do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0 unless do {
                  my $hash = do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0
                      unless (
                      (
                          ( substr( $s, $pos ) =~ m/^([\?\+])/ )
                        ? ( $pos += length($1) or 1 )
                        : 0
                      )
                      || ( $bool = 1 )
                      );
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                  };
                  my $bool = ${ $hash->{'bool'} };
                  $match[0] = Pugs::Runtime::Match->new($hash);
                  $bool;
                };
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                }
            );
            if ($match) {
              $named{'greedy'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            my $match = Pugs::Runtime::Match->new(
              do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0 unless do {
                  my $hash = do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0
                      unless (
                      do {
                        my $prior = $::_V6_PRIOR_;
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                      }
                      || ( $bool = 1 )
                      );
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                  };
                  my $bool = ${ $hash->{'bool'} };
                  $match[0] = Pugs::Runtime::Match->new($hash);
                  $bool;
                };
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                }
            );
            if ($match) {
              $named{'ws3'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( { 'quant' => { 'term' => ${ $::_V6_MATCH_->{'term'} }, 'quant' => ${ $::_V6_MATCH_->{'quant'} }, 'greedy' => ${ $::_V6_MATCH_->{'greedy'} }, 'ws1' => ${ $::_V6_MATCH_->{'ws1'} }, 'ws2' => ${ $::_V6_MATCH_->{'ws2'} }, 'ws3' => ${ $::_V6_MATCH_->{'ws3'} } } } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for quantifier
# Data::Bind->sub_signature( \&quantifier, );
*concat = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->quantifier( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              if ($match) {
                push @{ $named{'quantifier'} }, $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              while (
                do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = $grammar->quantifier( $s, { p => $pos, args => {} }, undef );
                  $::_V6_PRIOR_ = $prior;
                  if ($match) {
                    push @{ $named{'quantifier'} }, $match;
                    $pos = $match->to;
                    1;
                  }
                  else { 0 }
                }
                )
              {
              }
              $bool = 1;
            }
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                my @a = map { $_->() } @{ $::_V6_MATCH_->{'quantifier'} };
                return { concat => \@a, } if scalar @a > 1;
                return $a[0];
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for concat
# Data::Bind->sub_signature( \&concat, );
*rule = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          (
            (
              (
                do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = ( !$match != 1 );
                  $pos = $match->to if $bool;
                  $match;
                }
                || ( $bool = 1 )
              )
              && (
                  ( substr( $s, $pos, 1 ) eq '|' )
                ? ( $pos += 1 or 1 )
                : 0
              )
            )
            || ( $bool = 1 )
          )
          && do {
            my $prior = $::_V6_PRIOR_;
            my $match = $grammar->concat( $s, { p => $pos, args => {} }, undef );
            $::_V6_PRIOR_ = $prior;
            if ($match) {
              push @{ $named{'concat'} }, $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            while (
              (
                (
                    ( substr( $s, $pos, 1 ) eq '|' )
                  ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = $grammar->concat( $s, { p => $pos, args => {} }, undef );
                  $::_V6_PRIOR_ = $prior;
                  if ($match) {
                    push @{ $named{'concat'} }, $match;
                    $pos = $match->to;
                    1;
                  }
                  else { 0 }
                }
              )
              )
            {
            }
            $bool = 1;
          }
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                my @a = map { $$_ } @{ $::_V6_MATCH_->{'concat'} };
                return { alt => \@a, } if scalar @a > 1;
                return $a[0];
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for rule
# Data::Bind->sub_signature( \&rule, );

1;
