        package Pugs::Grammar::Rule;
        use utf8;
        no strict 'refs';
        use Pugs::Runtime::Match;
        use Pugs::Runtime::Regex;
        our %rule_terms;
        our %variables;

*pod_begin = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1187} = $pos or 1 ) 
           && (
           (
              (   ( $pad{I1188} = $pos or 1 ) && 
               ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )  
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1188} ) && 0 ) )
           &&
              (   ( $pad{I1189} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq '=' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1189} ) && 0 ) )
           &&
              (   ( $pad{I1190} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1190} ) && 0 ) )
           &&
              (   ( $pad{I1191} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq 'n' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1191} ) && 0 ) )
           &&
              (   ( $pad{I1192} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1192} ) && 0 ) )
           &&
             do { while (
              (   ( $pad{I1193} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1193} ) && 0 ) )) {}; $bool = 1 }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1187} ) or 1 ) 
           &&            (
              (   ( $pad{I1194} = $pos or 1 ) && 
               ( substr( $s, $pos++, 1 ) ne '' ) ||    ( ( $pos = $pad{I1194} ) && 0 ) )
           &&
             do { while (
              (   ( $pad{I1195} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1195} ) && 0 ) )) {}; $bool = 1 }
           &&
              (   ( $pad{I1196} = $pos or 1 ) && 
               do { 
                    my $prior = $::_V6_PRIOR_; 
                    my $match = 
                           $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior; 
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               } ||    ( ( $pos = $pad{I1196} ) && 0 ) )
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for pod_begin
 #->sub_signature
#pod_begin, );
;
*pod_other = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1197} = $pos or 1 ) 
           && (
           (
              (   ( $pad{I1198} = $pos or 1 ) && 
               ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )  
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1198} ) && 0 ) )
           &&
              (   ( $pad{I1199} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq '=' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1199} ) && 0 ) )
           &&
              (   ( $pad{I1200} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq 'c' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1200} ) && 0 ) )
           &&
              (   ( $pad{I1201} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq 'u' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1201} ) && 0 ) )
           &&
              (   ( $pad{I1202} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq 't' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1202} ) && 0 ) )
           &&
             do { while (
              (   ( $pad{I1203} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1203} ) && 0 ) )) {}; $bool = 1 }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1197} ) or 1 ) 
           &&            (
              (   ( $pad{I1204} = $pos or 1 ) && 
               ( substr( $s, $pos++, 1 ) ne '' ) ||    ( ( $pos = $pad{I1204} ) && 0 ) )
           &&
             do { while (
              (   ( $pad{I1205} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1205} ) && 0 ) )) {}; $bool = 1 }
           &&
              (   ( $pad{I1206} = $pos or 1 ) && 
               do { 
                    my $prior = $::_V6_PRIOR_; 
                    my $match = 
                           $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior; 
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               } ||    ( ( $pos = $pad{I1206} ) && 0 ) )
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for pod_other
 #->sub_signature
#pod_other, );
;
*ws = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
        (   ( $pad{I1207} = $pos or 1 ) && 
           (
               ( $pad{I1208} = $pos or 1 ) 
               && (
               (
                  (   ( $pad{I1209} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '#' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1209} ) && 0 ) )
               &&
                 do { while (
                  (   ( $pad{I1210} = $pos or 1 ) && 
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     ) ||    ( ( $pos = $pad{I1210} ) && 0 ) )) {}; $bool = 1 }
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1208} ) or 1 ) 
               &&                (
                  (   ( $pad{I1211} = $pos or 1 ) && 
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )  
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1211} ) && 0 ) )
               &&
                 (
                  (   ( $pad{I1212} = $pos or 1 ) && 
                     (
                        (   ( $pad{I1213} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq '=' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1213} ) && 0 ) )
                     &&
                       (
                        (   ( $pad{I1214} = $pos or 1 ) && 
                           (
                               ( $pad{I1215} = $pos or 1 ) 
                               && (
                               (
                                  (   ( $pad{I1216} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'b' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1216} ) && 0 ) )
                               &&
                                  (   ( $pad{I1217} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1217} ) && 0 ) )
                               &&
                                  (   ( $pad{I1218} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'g' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1218} ) && 0 ) )
                               &&
                                  (   ( $pad{I1219} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1219} ) && 0 ) )
                               &&
                                  (   ( $pad{I1220} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'n' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1220} ) && 0 ) )
                               &&
                                  (   ( $pad{I1221} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1221} ) && 0 ) )
                               &&
                                  (   ( $pad{I1222} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'E' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1222} ) && 0 ) )
                               &&
                                  (   ( $pad{I1223} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'N' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1223} ) && 0 ) )
                               &&
                                  (   ( $pad{I1224} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'D' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1224} ) && 0 ) )
                               &&
                                 do { while (
                                  (   ( $pad{I1225} = $pos or 1 ) && 
                                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     ) ||    ( ( $pos = $pad{I1225} ) && 0 ) )) {}; $bool = 1 }
                               &&
                                 do { while (
                                  (   ( $pad{I1226} = $pos or 1 ) && 
                                     ( substr( $s, $pos++, 1 ) ne '' ) ||    ( ( $pos = $pad{I1226} ) && 0 ) )) {}; $bool = 1 }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1215} ) or 1 ) 
                               &&                                (
                                  (   ( $pad{I1227} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'b' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1227} ) && 0 ) )
                               &&
                                  (   ( $pad{I1228} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1228} ) && 0 ) )
                               &&
                                  (   ( $pad{I1229} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'g' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1229} ) && 0 ) )
                               &&
                                  (   ( $pad{I1230} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1230} ) && 0 ) )
                               &&
                                  (   ( $pad{I1231} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'n' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1231} ) && 0 ) )
                               &&
                                  (   ( $pad{I1232} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1232} ) && 0 ) )
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1215} ) or 1 ) 
                               &&                                (
                                  (   ( $pad{I1233} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'k' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1233} ) && 0 ) )
                               &&
                                  (   ( $pad{I1234} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'w' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1234} ) && 0 ) )
                               &&
                                  (   ( $pad{I1235} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1235} ) && 0 ) )
                               &&
                                  (   ( $pad{I1236} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1236} ) && 0 ) )
                               &&
                                  (   ( $pad{I1237} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1237} ) && 0 ) )
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1215} ) or 1 ) 
                               &&                                (
                                  (   ( $pad{I1238} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'p' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1238} ) && 0 ) )
                               &&
                                  (   ( $pad{I1239} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1239} ) && 0 ) )
                               &&
                                  (   ( $pad{I1240} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1240} ) && 0 ) )
                               &&
                                  (   ( $pad{I1241} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1241} ) && 0 ) )
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1215} ) or 1 ) 
                               &&                                (
                                  (   ( $pad{I1242} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'f' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1242} ) && 0 ) )
                               &&
                                  (   ( $pad{I1243} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1243} ) && 0 ) )
                               &&
                                  (   ( $pad{I1244} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'r' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1244} ) && 0 ) )
                               &&
                                  (   ( $pad{I1245} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1245} ) && 0 ) )
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1215} ) or 1 ) 
                               &&                                (
                                  (   ( $pad{I1246} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'h' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1246} ) && 0 ) )
                               &&
                                  (   ( $pad{I1247} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1247} ) && 0 ) )
                               &&
                                  (   ( $pad{I1248} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'a' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1248} ) && 0 ) )
                               &&
                                  (   ( $pad{I1249} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1249} ) && 0 ) )
                               &&
                                  (   ( $pad{I1250} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq '1' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1250} ) && 0 ) )
                               &&
                                  (   ( $pad{I1251} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1251} ) && 0 ) )
                               )
                             )
                           ) ||    ( ( $pos = $pad{I1214} ) && 0 ) )
                       || ( $bool = 1 )
                       ) 
                     ) ||    ( ( $pos = $pad{I1212} ) && 0 ) )
                 || ( $bool = 1 )
                 ) 
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1208} ) or 1 ) 
               &&                 (   ( $pad{I1252} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^(\s)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1252} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1207} ) && 0 ) )
       && do { while (
        (   ( $pad{I1207} = $pos or 1 ) && 
           (
               ( $pad{I1208} = $pos or 1 ) 
               && (
               (
                  (   ( $pad{I1209} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '#' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1209} ) && 0 ) )
               &&
                 do { while (
                  (   ( $pad{I1210} = $pos or 1 ) && 
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     ) ||    ( ( $pos = $pad{I1210} ) && 0 ) )) {}; $bool = 1 }
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1208} ) or 1 ) 
               &&                (
                  (   ( $pad{I1211} = $pos or 1 ) && 
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )  
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1211} ) && 0 ) )
               &&
                 (
                  (   ( $pad{I1212} = $pos or 1 ) && 
                     (
                        (   ( $pad{I1213} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq '=' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1213} ) && 0 ) )
                     &&
                       (
                        (   ( $pad{I1214} = $pos or 1 ) && 
                           (
                               ( $pad{I1215} = $pos or 1 ) 
                               && (
                               (
                                  (   ( $pad{I1216} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'b' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1216} ) && 0 ) )
                               &&
                                  (   ( $pad{I1217} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1217} ) && 0 ) )
                               &&
                                  (   ( $pad{I1218} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'g' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1218} ) && 0 ) )
                               &&
                                  (   ( $pad{I1219} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1219} ) && 0 ) )
                               &&
                                  (   ( $pad{I1220} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'n' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1220} ) && 0 ) )
                               &&
                                  (   ( $pad{I1221} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1221} ) && 0 ) )
                               &&
                                  (   ( $pad{I1222} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'E' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1222} ) && 0 ) )
                               &&
                                  (   ( $pad{I1223} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'N' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1223} ) && 0 ) )
                               &&
                                  (   ( $pad{I1224} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'D' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1224} ) && 0 ) )
                               &&
                                 do { while (
                                  (   ( $pad{I1225} = $pos or 1 ) && 
                                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     ) ||    ( ( $pos = $pad{I1225} ) && 0 ) )) {}; $bool = 1 }
                               &&
                                 do { while (
                                  (   ( $pad{I1226} = $pos or 1 ) && 
                                     ( substr( $s, $pos++, 1 ) ne '' ) ||    ( ( $pos = $pad{I1226} ) && 0 ) )) {}; $bool = 1 }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1215} ) or 1 ) 
                               &&                                (
                                  (   ( $pad{I1227} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'b' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1227} ) && 0 ) )
                               &&
                                  (   ( $pad{I1228} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1228} ) && 0 ) )
                               &&
                                  (   ( $pad{I1229} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'g' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1229} ) && 0 ) )
                               &&
                                  (   ( $pad{I1230} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1230} ) && 0 ) )
                               &&
                                  (   ( $pad{I1231} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'n' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1231} ) && 0 ) )
                               &&
                                  (   ( $pad{I1232} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1232} ) && 0 ) )
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1215} ) or 1 ) 
                               &&                                (
                                  (   ( $pad{I1233} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'k' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1233} ) && 0 ) )
                               &&
                                  (   ( $pad{I1234} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'w' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1234} ) && 0 ) )
                               &&
                                  (   ( $pad{I1235} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1235} ) && 0 ) )
                               &&
                                  (   ( $pad{I1236} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1236} ) && 0 ) )
                               &&
                                  (   ( $pad{I1237} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1237} ) && 0 ) )
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1215} ) or 1 ) 
                               &&                                (
                                  (   ( $pad{I1238} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'p' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1238} ) && 0 ) )
                               &&
                                  (   ( $pad{I1239} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1239} ) && 0 ) )
                               &&
                                  (   ( $pad{I1240} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1240} ) && 0 ) )
                               &&
                                  (   ( $pad{I1241} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1241} ) && 0 ) )
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1215} ) or 1 ) 
                               &&                                (
                                  (   ( $pad{I1242} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'f' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1242} ) && 0 ) )
                               &&
                                  (   ( $pad{I1243} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1243} ) && 0 ) )
                               &&
                                  (   ( $pad{I1244} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'r' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1244} ) && 0 ) )
                               &&
                                  (   ( $pad{I1245} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1245} ) && 0 ) )
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1215} ) or 1 ) 
                               &&                                (
                                  (   ( $pad{I1246} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'h' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1246} ) && 0 ) )
                               &&
                                  (   ( $pad{I1247} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1247} ) && 0 ) )
                               &&
                                  (   ( $pad{I1248} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'a' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1248} ) && 0 ) )
                               &&
                                  (   ( $pad{I1249} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1249} ) && 0 ) )
                               &&
                                  (   ( $pad{I1250} = $pos or 1 ) && 
                                   ( ( substr( $s, $pos, 1 ) eq '1' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   ) ||    ( ( $pos = $pad{I1250} ) && 0 ) )
                               &&
                                  (   ( $pad{I1251} = $pos or 1 ) && 
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   } ||    ( ( $pos = $pad{I1251} ) && 0 ) )
                               )
                             )
                           ) ||    ( ( $pos = $pad{I1214} ) && 0 ) )
                       || ( $bool = 1 )
                       ) 
                     ) ||    ( ( $pos = $pad{I1212} ) && 0 ) )
                 || ( $bool = 1 )
                 ) 
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1208} ) or 1 ) 
               &&                 (   ( $pad{I1252} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^(\s)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1252} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1207} ) && 0 ) )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for ws
 #->sub_signature
#ws, );
;
*ident = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
        (   ( $pad{I1253} = $pos or 1 ) && 
           (
               ( $pad{I1254} = $pos or 1 ) 
               && (
                (   ( $pad{I1255} = $pos or 1 ) && 
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 } ||    ( ( $pos = $pad{I1255} ) && 0 ) )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1254} ) or 1 ) 
               &&                 (   ( $pad{I1256} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '_' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1256} ) && 0 ) )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1254} ) or 1 ) 
               &&                 (   ( $pad{I1257} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 2 ) eq '::' ) 
                     ? ( $pos += 2 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1257} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1253} ) && 0 ) )
       && do { while (
        (   ( $pad{I1253} = $pos or 1 ) && 
           (
               ( $pad{I1254} = $pos or 1 ) 
               && (
                (   ( $pad{I1255} = $pos or 1 ) && 
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 } ||    ( ( $pos = $pad{I1255} ) && 0 ) )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1254} ) or 1 ) 
               &&                 (   ( $pad{I1256} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '_' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1256} ) && 0 ) )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1254} ) or 1 ) 
               &&                 (   ( $pad{I1257} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 2 ) eq '::' ) 
                     ? ( $pos += 2 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1257} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1253} ) && 0 ) )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for ident
 #->sub_signature
#ident, );
;
*special_char = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1258} = $pos or 1 ) 
           && (
           (
              (   ( $pad{I1259} = $pos or 1 ) && 
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                           ( $pad{I1260} = $pos or 1 ) 
                           && (
                            (   ( $pad{I1261} = $pos or 1 ) && 
                             ( ( substr( $s, $pos, 1 ) eq 'c' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             ) ||    ( ( $pos = $pad{I1261} ) && 0 ) )
                           ) 
                         || ( 
                           ( ( $bool = 1 ) && ( $pos = $pad{I1260} ) or 1 ) 
                           &&                             (   ( $pad{I1262} = $pos or 1 ) && 
                             ( ( substr( $s, $pos, 1 ) eq 'C' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             ) ||    ( ( $pos = $pad{I1262} ) && 0 ) )
                         )
                       );
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I1259} ) && 0 ) )
           &&
              (   ( $pad{I1263} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq '[' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1263} ) && 0 ) )
           &&
              (   ( $pad{I1264} = $pos or 1 ) && 
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                        (   ( $pad{I1265} = $pos or 1 ) && 
                           (
                               ( $pad{I1266} = $pos or 1 ) 
                               && (
                                (   ( $pad{I1267} = $pos or 1 ) && 
                                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                             $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'alnum'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1267} ) && 0 ) )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1266} ) or 1 ) 
                               &&                                 (   ( $pad{I1268} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos ) =~ m/^(\s)/ )  
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1268} ) && 0 ) )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1266} ) or 1 ) 
                               &&                                 (   ( $pad{I1269} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos, 1 ) eq ';' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1269} ) && 0 ) )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1266} ) or 1 ) 
                               &&                                 (   ( $pad{I1270} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos, 1 ) eq '(' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1270} ) && 0 ) )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1266} ) or 1 ) 
                               &&                                 (   ( $pad{I1271} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos, 1 ) eq ')' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1271} ) && 0 ) )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1266} ) or 1 ) 
                               &&                                 (   ( $pad{I1272} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos, 1 ) eq '-' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1272} ) && 0 ) )
                             )
                           ) ||    ( ( $pos = $pad{I1265} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I1265} = $pos or 1 ) && 
                           (
                               ( $pad{I1266} = $pos or 1 ) 
                               && (
                                (   ( $pad{I1267} = $pos or 1 ) && 
                                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                             $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'alnum'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1267} ) && 0 ) )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1266} ) or 1 ) 
                               &&                                 (   ( $pad{I1268} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos ) =~ m/^(\s)/ )  
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1268} ) && 0 ) )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1266} ) or 1 ) 
                               &&                                 (   ( $pad{I1269} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos, 1 ) eq ';' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1269} ) && 0 ) )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1266} ) or 1 ) 
                               &&                                 (   ( $pad{I1270} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos, 1 ) eq '(' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1270} ) && 0 ) )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1266} ) or 1 ) 
                               &&                                 (   ( $pad{I1271} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos, 1 ) eq ')' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1271} ) && 0 ) )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1266} ) or 1 ) 
                               &&                                 (   ( $pad{I1272} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos, 1 ) eq '-' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1272} ) && 0 ) )
                             )
                           ) ||    ( ( $pos = $pad{I1265} ) && 0 ) )) {}; $bool = 1 }
                       ) ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I1264} ) && 0 ) )
           &&
              (   ( $pad{I1273} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq ']' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1273} ) && 0 ) )
           &&
              (   ( $pad{I1274} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1274} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1258} ) or 1 ) 
           &&            (
              (   ( $pad{I1275} = $pos or 1 ) && 
               (
                   ( $pad{I1276} = $pos or 1 ) 
                   && (
                    (   ( $pad{I1277} = $pos or 1 ) && 
                     ( ( substr( $s, $pos, 1 ) eq 'x' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     ) ||    ( ( $pos = $pad{I1277} ) && 0 ) )
                   ) 
                 || ( 
                   ( ( $bool = 1 ) && ( $pos = $pad{I1276} ) or 1 ) 
                   &&                     (   ( $pad{I1278} = $pos or 1 ) && 
                     ( ( substr( $s, $pos, 1 ) eq 'X' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     ) ||    ( ( $pos = $pad{I1278} ) && 0 ) )
                 )
               ) ||    ( ( $pos = $pad{I1275} ) && 0 ) )
           &&
             (
              (   ( $pad{I1279} = $pos or 1 ) && 
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1279} ) && 0 ) )
             && do { while (
              (   ( $pad{I1279} = $pos or 1 ) && 
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1279} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I1280} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1280} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1258} ) or 1 ) 
           &&            (
              (   ( $pad{I1281} = $pos or 1 ) && 
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                           ( $pad{I1282} = $pos or 1 ) 
                           && (
                            (   ( $pad{I1283} = $pos or 1 ) && 
                             ( ( substr( $s, $pos, 1 ) eq 'x' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             ) ||    ( ( $pos = $pad{I1283} ) && 0 ) )
                           ) 
                         || ( 
                           ( ( $bool = 1 ) && ( $pos = $pad{I1282} ) or 1 ) 
                           &&                             (   ( $pad{I1284} = $pos or 1 ) && 
                             ( ( substr( $s, $pos, 1 ) eq 'X' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             ) ||    ( ( $pos = $pad{I1284} ) && 0 ) )
                         )
                       );
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I1281} ) && 0 ) )
           &&
              (   ( $pad{I1285} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq '[' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1285} ) && 0 ) )
           &&
              (   ( $pad{I1286} = $pos or 1 ) && 
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                        (   ( $pad{I1287} = $pos or 1 ) && 
                           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                       $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1287} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I1287} = $pos or 1 ) && 
                           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                       $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1287} ) && 0 ) )) {}; $bool = 1 }
                       ) ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I1286} ) && 0 ) )
           &&
              (   ( $pad{I1288} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq ']' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1288} ) && 0 ) )
           &&
              (   ( $pad{I1289} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1289} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1258} ) or 1 ) 
           &&            (
              (   ( $pad{I1290} = $pos or 1 ) && 
               (
                   ( $pad{I1291} = $pos or 1 ) 
                   && (
                    (   ( $pad{I1292} = $pos or 1 ) && 
                     ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     ) ||    ( ( $pos = $pad{I1292} ) && 0 ) )
                   ) 
                 || ( 
                   ( ( $bool = 1 ) && ( $pos = $pad{I1291} ) or 1 ) 
                   &&                     (   ( $pad{I1293} = $pos or 1 ) && 
                     ( ( substr( $s, $pos, 1 ) eq 'O' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     ) ||    ( ( $pos = $pad{I1293} ) && 0 ) )
                 )
               ) ||    ( ( $pos = $pad{I1290} ) && 0 ) )
           &&
             (
              (   ( $pad{I1294} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^(\d)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1294} ) && 0 ) )
             && do { while (
              (   ( $pad{I1294} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^(\d)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1294} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I1295} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1295} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1258} ) or 1 ) 
           &&            (
              (   ( $pad{I1296} = $pos or 1 ) && 
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                           ( $pad{I1297} = $pos or 1 ) 
                           && (
                            (   ( $pad{I1298} = $pos or 1 ) && 
                             ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             ) ||    ( ( $pos = $pad{I1298} ) && 0 ) )
                           ) 
                         || ( 
                           ( ( $bool = 1 ) && ( $pos = $pad{I1297} ) or 1 ) 
                           &&                             (   ( $pad{I1299} = $pos or 1 ) && 
                             ( ( substr( $s, $pos, 1 ) eq 'O' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             ) ||    ( ( $pos = $pad{I1299} ) && 0 ) )
                         )
                       );
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I1296} ) && 0 ) )
           &&
              (   ( $pad{I1300} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq '[' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1300} ) && 0 ) )
           &&
              (   ( $pad{I1301} = $pos or 1 ) && 
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                        (   ( $pad{I1302} = $pos or 1 ) && 
                           ( ( substr( $s, $pos ) =~ m/^(\d)/ )  
                               ? ( $pos += length( $1 ) or 1 )
                               : 0
                           ) ||    ( ( $pos = $pad{I1302} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I1302} = $pos or 1 ) && 
                           ( ( substr( $s, $pos ) =~ m/^(\d)/ )  
                               ? ( $pos += length( $1 ) or 1 )
                               : 0
                           ) ||    ( ( $pos = $pad{I1302} ) && 0 ) )) {}; $bool = 1 }
                       ) ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               } ||    ( ( $pos = $pad{I1301} ) && 0 ) )
           &&
              (   ( $pad{I1303} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq ']' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1303} ) && 0 ) )
           &&
              (   ( $pad{I1304} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1304} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1258} ) or 1 ) 
           &&            (
              (   ( $pad{I1305} = $pos or 1 ) && 
               ( substr( $s, $pos++, 1 ) ne '' ) ||    ( ( $pos = $pad{I1305} ) && 0 ) )
           &&
              (   ( $pad{I1306} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1306} ) && 0 ) )
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for special_char
 #->sub_signature
#special_char, );
;
*literal = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       do { while (
        (   ( $pad{I1307} = $pos or 1 ) && 
           (
               ( $pad{I1308} = $pos or 1 ) 
               && (
               (
                  (   ( $pad{I1309} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1309} ) && 0 ) )
               &&
                  (   ( $pad{I1310} = $pos or 1 ) && 
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1310} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1308} ) or 1 ) 
               &&                 (   ( $pad{I1311} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\']))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1311} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1307} ) && 0 ) )) {}; $bool = 1 };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for literal
 #->sub_signature
#literal, );
;
*double_quoted = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       do { while (
        (   ( $pad{I1312} = $pos or 1 ) && 
           (
               ( $pad{I1313} = $pos or 1 ) 
               && (
               (
                  (   ( $pad{I1314} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1314} ) && 0 ) )
               &&
                  (   ( $pad{I1315} = $pos or 1 ) && 
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1315} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1313} ) or 1 ) 
               &&                 (   ( $pad{I1316} = $pos or 1 ) && 
                 do{ 
                my $match = 
          do {
            our $I1317;
            our $I1317_sizes;
            unless ( $I1317 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1317_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1317 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I1317_sizes ) {
                $key = ( $pos <= length( $s ) 
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I1317->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m; 
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I1317, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          };
                if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1316} ) && 0 ) )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1313} ) or 1 ) 
               &&                 (   ( $pad{I1318} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\"]))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1318} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1312} ) && 0 ) )) {}; $bool = 1 };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for double_quoted
 #->sub_signature
#double_quoted, );
;
*metasyntax = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
        (   ( $pad{I1319} = $pos or 1 ) && 
           (
               ( $pad{I1320} = $pos or 1 ) 
               && (
               (
                  (   ( $pad{I1321} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1321} ) && 0 ) )
               &&
                  (   ( $pad{I1322} = $pos or 1 ) && 
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1322} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1320} ) or 1 ) 
               &&                (
                  (   ( $pad{I1323} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1323} ) && 0 ) )
               &&
                  (   ( $pad{I1324} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1324} ) && 0 ) )
               &&
                  (   ( $pad{I1325} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1325} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1320} ) or 1 ) 
               &&                (
                  (   ( $pad{I1326} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '"' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1326} ) && 0 ) )
               &&
                  (   ( $pad{I1327} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1327} ) && 0 ) )
               &&
                  (   ( $pad{I1328} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '"' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1328} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1320} ) or 1 ) 
               &&                (
                  (   ( $pad{I1329} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '{' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1329} ) && 0 ) )
               &&
                  (   ( $pad{I1330} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1330} ) && 0 ) )
               &&
                  (   ( $pad{I1331} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '}' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1331} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1320} ) or 1 ) 
               &&                (
                  (   ( $pad{I1332} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '<' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1332} ) && 0 ) )
               &&
                  (   ( $pad{I1333} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1333} ) && 0 ) )
               &&
                  (   ( $pad{I1334} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '>' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1334} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1320} ) or 1 ) 
               &&                 (   ( $pad{I1335} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1335} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1319} ) && 0 ) )
       && do { while (
        (   ( $pad{I1319} = $pos or 1 ) && 
           (
               ( $pad{I1320} = $pos or 1 ) 
               && (
               (
                  (   ( $pad{I1321} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1321} ) && 0 ) )
               &&
                  (   ( $pad{I1322} = $pos or 1 ) && 
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1322} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1320} ) or 1 ) 
               &&                (
                  (   ( $pad{I1323} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1323} ) && 0 ) )
               &&
                  (   ( $pad{I1324} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1324} ) && 0 ) )
               &&
                  (   ( $pad{I1325} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1325} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1320} ) or 1 ) 
               &&                (
                  (   ( $pad{I1326} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '"' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1326} ) && 0 ) )
               &&
                  (   ( $pad{I1327} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1327} ) && 0 ) )
               &&
                  (   ( $pad{I1328} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '"' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1328} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1320} ) or 1 ) 
               &&                (
                  (   ( $pad{I1329} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '{' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1329} ) && 0 ) )
               &&
                  (   ( $pad{I1330} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1330} ) && 0 ) )
               &&
                  (   ( $pad{I1331} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '}' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1331} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1320} ) or 1 ) 
               &&                (
                  (   ( $pad{I1332} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '<' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1332} ) && 0 ) )
               &&
                  (   ( $pad{I1333} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1333} ) && 0 ) )
               &&
                  (   ( $pad{I1334} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '>' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1334} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1320} ) or 1 ) 
               &&                 (   ( $pad{I1335} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1335} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1319} ) && 0 ) )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for metasyntax
 #->sub_signature
#metasyntax, );
;
*char_range = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
        (   ( $pad{I1336} = $pos or 1 ) && 
           (
               ( $pad{I1337} = $pos or 1 ) 
               && (
               (
                  (   ( $pad{I1338} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1338} ) && 0 ) )
               &&
                  (   ( $pad{I1339} = $pos or 1 ) && 
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1339} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1337} ) or 1 ) 
               &&                 (   ( $pad{I1340} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1340} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1336} ) && 0 ) )
       && do { while (
        (   ( $pad{I1336} = $pos or 1 ) && 
           (
               ( $pad{I1337} = $pos or 1 ) 
               && (
               (
                  (   ( $pad{I1338} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1338} ) && 0 ) )
               &&
                  (   ( $pad{I1339} = $pos or 1 ) && 
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1339} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1337} ) or 1 ) 
               &&                 (   ( $pad{I1340} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1340} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1336} ) && 0 ) )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for char_range
 #->sub_signature
#char_range, );
;
*char_class = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1341} = $pos or 1 ) 
           && (
           (
            (   ( $pad{I1342} = $pos or 1 ) && 
               do { 
                    my $prior = $::_V6_PRIOR_; 
                    my $match = 
                           $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior; 
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               } ||    ( ( $pos = $pad{I1342} ) && 0 ) )
           && do { while (
            (   ( $pad{I1342} = $pos or 1 ) && 
               do { 
                    my $prior = $::_V6_PRIOR_; 
                    my $match = 
                           $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior; 
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               } ||    ( ( $pos = $pad{I1342} ) && 0 ) )) {}; $bool = 1 }
           ) 
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1341} ) or 1 ) 
           &&            (
              (   ( $pad{I1343} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq '[' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1343} ) && 0 ) )
           &&
              (   ( $pad{I1344} = $pos or 1 ) && 
               do { 
                    my $prior = $::_V6_PRIOR_; 
                    my $match = 
                           $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior; 
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               } ||    ( ( $pos = $pad{I1344} ) && 0 ) )
           &&
              (   ( $pad{I1345} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq ']' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1345} ) && 0 ) )
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for char_class
 #->sub_signature
#char_class, );
;
*string_code = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
        (   ( $pad{I1346} = $pos or 1 ) && 
           (
               ( $pad{I1347} = $pos or 1 ) 
               && (
               (
                  (   ( $pad{I1348} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1348} ) && 0 ) )
               &&
                  (   ( $pad{I1349} = $pos or 1 ) && 
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1349} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1350} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1350} ) && 0 ) )
               &&
                  (   ( $pad{I1351} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1351} ) && 0 ) )
               &&
                  (   ( $pad{I1352} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1352} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1353} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '"' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1353} ) && 0 ) )
               &&
                  (   ( $pad{I1354} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1354} ) && 0 ) )
               &&
                  (   ( $pad{I1355} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '"' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1355} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1356} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '{' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1356} ) && 0 ) )
               &&
                  (   ( $pad{I1357} = $pos or 1 ) && 
                   (
                       ( $pad{I1358} = $pos or 1 ) 
                       && (
                        (   ( $pad{I1359} = $pos or 1 ) && 
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         } ||    ( ( $pos = $pad{I1359} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1358} ) or 1 ) 
                       &&                         (   ( $pad{I1360} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I1360} ) && 0 ) )
                     )
                   ) ||    ( ( $pos = $pad{I1357} ) && 0 ) )
               &&
                  (   ( $pad{I1361} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '}' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1361} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1362} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '(' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1362} ) && 0 ) )
               &&
                  (   ( $pad{I1363} = $pos or 1 ) && 
                   (
                       ( $pad{I1364} = $pos or 1 ) 
                       && (
                        (   ( $pad{I1365} = $pos or 1 ) && 
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         } ||    ( ( $pos = $pad{I1365} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1364} ) or 1 ) 
                       &&                         (   ( $pad{I1366} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I1366} ) && 0 ) )
                     )
                   ) ||    ( ( $pos = $pad{I1363} ) && 0 ) )
               &&
                  (   ( $pad{I1367} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq ')' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1367} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1368} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '<' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1368} ) && 0 ) )
               &&
                  (   ( $pad{I1369} = $pos or 1 ) && 
                   (
                       ( $pad{I1370} = $pos or 1 ) 
                       && (
                        (   ( $pad{I1371} = $pos or 1 ) && 
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         } ||    ( ( $pos = $pad{I1371} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1370} ) or 1 ) 
                       &&                         (   ( $pad{I1372} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I1372} ) && 0 ) )
                     )
                   ) ||    ( ( $pos = $pad{I1369} ) && 0 ) )
               &&
                  (   ( $pad{I1373} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '>' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1373} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1374} = $pos or 1 ) && 
                   (
                       ( $pad{I1375} = $pos or 1 ) 
                       && (
                        (   ( $pad{I1376} = $pos or 1 ) && 
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         } ||    ( ( $pos = $pad{I1376} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1375} ) or 1 ) 
                       &&                         (   ( $pad{I1377} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq '>' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1377} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1375} ) or 1 ) 
                       &&                         (   ( $pad{I1378} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq '=' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1378} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1375} ) or 1 ) 
                       &&                         (   ( $pad{I1379} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq '-' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1379} ) && 0 ) )
                     )
                   ) ||    ( ( $pos = $pad{I1374} ) && 0 ) )
               &&
                  (   ( $pad{I1380} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '>' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1380} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                 (   ( $pad{I1381} = $pos or 1 ) && 
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 } ||    ( ( $pos = $pad{I1381} ) && 0 ) )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                 (   ( $pad{I1382} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1382} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1346} ) && 0 ) )
       && do { while (
        (   ( $pad{I1346} = $pos or 1 ) && 
           (
               ( $pad{I1347} = $pos or 1 ) 
               && (
               (
                  (   ( $pad{I1348} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1348} ) && 0 ) )
               &&
                  (   ( $pad{I1349} = $pos or 1 ) && 
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1349} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1350} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1350} ) && 0 ) )
               &&
                  (   ( $pad{I1351} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1351} ) && 0 ) )
               &&
                  (   ( $pad{I1352} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1352} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1353} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '"' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1353} ) && 0 ) )
               &&
                  (   ( $pad{I1354} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1354} ) && 0 ) )
               &&
                  (   ( $pad{I1355} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '"' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1355} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1356} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '{' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1356} ) && 0 ) )
               &&
                  (   ( $pad{I1357} = $pos or 1 ) && 
                   (
                       ( $pad{I1358} = $pos or 1 ) 
                       && (
                        (   ( $pad{I1359} = $pos or 1 ) && 
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         } ||    ( ( $pos = $pad{I1359} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1358} ) or 1 ) 
                       &&                         (   ( $pad{I1360} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I1360} ) && 0 ) )
                     )
                   ) ||    ( ( $pos = $pad{I1357} ) && 0 ) )
               &&
                  (   ( $pad{I1361} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '}' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1361} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1362} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '(' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1362} ) && 0 ) )
               &&
                  (   ( $pad{I1363} = $pos or 1 ) && 
                   (
                       ( $pad{I1364} = $pos or 1 ) 
                       && (
                        (   ( $pad{I1365} = $pos or 1 ) && 
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         } ||    ( ( $pos = $pad{I1365} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1364} ) or 1 ) 
                       &&                         (   ( $pad{I1366} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I1366} ) && 0 ) )
                     )
                   ) ||    ( ( $pos = $pad{I1363} ) && 0 ) )
               &&
                  (   ( $pad{I1367} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq ')' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1367} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1368} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '<' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1368} ) && 0 ) )
               &&
                  (   ( $pad{I1369} = $pos or 1 ) && 
                   (
                       ( $pad{I1370} = $pos or 1 ) 
                       && (
                        (   ( $pad{I1371} = $pos or 1 ) && 
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         } ||    ( ( $pos = $pad{I1371} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1370} ) or 1 ) 
                       &&                         (   ( $pad{I1372} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I1372} ) && 0 ) )
                     )
                   ) ||    ( ( $pos = $pad{I1369} ) && 0 ) )
               &&
                  (   ( $pad{I1373} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '>' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1373} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                (
                  (   ( $pad{I1374} = $pos or 1 ) && 
                   (
                       ( $pad{I1375} = $pos or 1 ) 
                       && (
                        (   ( $pad{I1376} = $pos or 1 ) && 
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         } ||    ( ( $pos = $pad{I1376} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1375} ) or 1 ) 
                       &&                         (   ( $pad{I1377} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq '>' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1377} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1375} ) or 1 ) 
                       &&                         (   ( $pad{I1378} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq '=' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1378} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1375} ) or 1 ) 
                       &&                         (   ( $pad{I1379} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq '-' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1379} ) && 0 ) )
                     )
                   ) ||    ( ( $pos = $pad{I1374} ) && 0 ) )
               &&
                  (   ( $pad{I1380} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '>' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1380} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                 (   ( $pad{I1381} = $pos or 1 ) && 
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 } ||    ( ( $pos = $pad{I1381} ) && 0 ) )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1347} ) or 1 ) 
               &&                 (   ( $pad{I1382} = $pos or 1 ) && 
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1382} ) && 0 ) )
             )
           ) ||    ( ( $pos = $pad{I1346} ) && 0 ) )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for string_code
 #->sub_signature
#string_code, );
;
*parsed_code = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1383} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1383} ) && 0 ) )
       &&
          (   ( $pad{I1384} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return('{' . $::_V6_MATCH_ . '}');
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1384} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for parsed_code
 #->sub_signature
#parsed_code, );
;
*named_capture_body = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1385} = $pos or 1 ) 
           && (
           (
              (   ( $pad{I1386} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq '(' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1386} ) && 0 ) )
           &&
              (   ( $pad{I1387} = $pos or 1 ) && 
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1387} ) && 0 ) )
           &&
              (   ( $pad{I1388} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq ')' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1388} ) && 0 ) )
           &&
              (   ( $pad{I1389} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'capturing_group' => ${ $::_V6_MATCH_->{'rule'}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1389} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1385} ) or 1 ) 
           &&            (
              (   ( $pad{I1390} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq '[' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1390} ) && 0 ) )
           &&
              (   ( $pad{I1391} = $pos or 1 ) && 
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1391} ) && 0 ) )
           &&
              (   ( $pad{I1392} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq ']' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1392} ) && 0 ) )
           &&
              (   ( $pad{I1393} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'rule'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1393} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1385} ) or 1 ) 
           &&            (
              (   ( $pad{I1394} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq '<' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1394} ) && 0 ) )
           &&
              (   ( $pad{I1395} = $pos or 1 ) && 
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'parse_metasyntax'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1395} ) && 0 ) )
           &&
              (   ( $pad{I1396} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'parse_metasyntax'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1396} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1385} ) or 1 ) 
           &&            (
              (   ( $pad{I1397} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1397} ) && 0 ) )
           &&
              (   ( $pad{I1398} = $pos or 1 ) && 
               do { 
                    my $prior = $::_V6_PRIOR_; 
                    my $match = 
                           $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior; 
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               } ||    ( ( $pos = $pad{I1398} ) && 0 ) )
           &&
              (   ( $pad{I1399} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1399} ) && 0 ) )
           &&
              (   ( $pad{I1400} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'metasyntax' => {'metasyntax' =>  "" . ${$::_V6_MATCH_}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1400} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1385} ) or 1 ) 
           &&             (   ( $pad{I1401} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    sub  { die("invalid alias syntax");
 } ->();
                    $::_V6_SUCCEED;
                } ||    ( ( $pos = $pad{I1401} ) && 0 ) )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for named_capture_body
 #->sub_signature
#named_capture_body, );
;
*parse_metasyntax = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1402} = $pos or 1 ) && 
           do{ 
                my $from = $pos;
                my $bool =                    (
                       ( $pad{I1403} = $pos or 1 ) 
                       && (
                        (   ( $pad{I1404} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq '!' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1404} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1403} ) or 1 ) 
                       &&                         (   ( $pad{I1405} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq '?' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1405} ) && 0 ) )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1403} ) or 1 ) 
                       &&                         (   ( $pad{I1406} = $pos or 1 ) && 
 1 # null constant
 ||    ( ( $pos = $pad{I1406} ) && 0 ) )
                     )
                   );
                my $match = Pugs::Runtime::Match->new( 
                    { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                ); $named{'modifier'} = $match;
                $bool
            } ||    ( ( $pos = $pad{I1402} ) && 0 ) )
       &&
          (   ( $pad{I1407} = $pos or 1 ) && 
           (
               ( $pad{I1408} = $pos or 1 ) 
               && (
               (
                  (   ( $pad{I1409} = $pos or 1 ) && 
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1409} ) && 0 ) )
               &&
                 (
                  (   ( $pad{I1410} = $pos or 1 ) && 
                     do{ 
                         my $hash = do {
                           my $bool = 1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
                             (
                                (   ( $pad{I1411} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1411} ) && 0 ) )
                             &&
                                (   ( $pad{I1412} = $pos or 1 ) && 
                                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                             $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1412} ) && 0 ) )
                             );
                           { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                         };
                         my $bool = ${$hash->{'bool'}};
                         if ( $bool ) {
                             push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                         }
                         $bool;
                     } ||    ( ( $pos = $pad{I1410} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1410} = $pos or 1 ) && 
                     do{ 
                         my $hash = do {
                           my $bool = 1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
                             (
                                (   ( $pad{I1411} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1411} ) && 0 ) )
                             &&
                                (   ( $pad{I1412} = $pos or 1 ) && 
                                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                             $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1412} ) && 0 ) )
                             );
                           { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                         };
                         my $bool = ${$hash->{'bool'}};
                         if ( $bool ) {
                             push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                         }
                         $bool;
                     } ||    ( ( $pos = $pad{I1410} ) && 0 ) )) {}; $bool = 1 }
                 ) 
               &&
                  (   ( $pad{I1413} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '>' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1413} ) && 0 ) )
               &&
                  (   ( $pad{I1414} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { if(${ $::_V6_MATCH_->{'modifier'}} eq '!') { return({'negate' => {'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]}});
 } 
;
return({'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1414} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1408} ) or 1 ) 
               &&                (
                  (   ( $pad{I1415} = $pos or 1 ) && 
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1415} ) && 0 ) )
               &&
                  (   ( $pad{I1416} = $pos or 1 ) && 
                   (
                       ( $pad{I1417} = $pos or 1 ) 
                       && (
                       (
                          (   ( $pad{I1418} = $pos or 1 ) && 
                           do { 
                                my $prior = $::_V6_PRIOR_; 
                                my $match = 
                                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior; 
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           } ||    ( ( $pos = $pad{I1418} ) && 0 ) )
                       &&
                          (   ( $pad{I1419} = $pos or 1 ) && 
                           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1419} ) && 0 ) )
                       &&
                          (   ( $pad{I1420} = $pos or 1 ) && 
                           ( ( substr( $s, $pos, 1 ) eq '>' ) 
                               ? ( $pos += 1 or 1 )
                               : 0
                           ) ||    ( ( $pos = $pad{I1420} ) && 0 ) )
                       &&
                          (   ( $pad{I1421} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { if((${ $::_V6_MATCH_->{'ident'}} eq 'before' || ${ $::_V6_MATCH_->{'ident'}} eq 'after')) { return({${ $::_V6_MATCH_->{'ident'}} => {'rule' => ${ $::_V6_MATCH_->{'rule'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } 
;
return({'metasyntax' => {'metasyntax' => ${ $::_V6_MATCH_->{'ident'}}, 'rule' => ${ $::_V6_MATCH_->{'rule'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1421} ) && 0 ) )
                       )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1417} ) or 1 ) 
                       &&                        (
                          (   ( $pad{I1422} = $pos or 1 ) && 
                           ( ( substr( $s, $pos, 1 ) eq ':' ) 
                               ? ( $pos += 1 or 1 )
                               : 0
                           ) ||    ( ( $pos = $pad{I1422} ) && 0 ) )
                       &&
                         (
                          (   ( $pad{I1423} = $pos or 1 ) && 
                             do { 
                                  my $prior = $::_V6_PRIOR_; 
                                  my $match = 
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior; 
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             } ||    ( ( $pos = $pad{I1423} ) && 0 ) )
                         || ( $bool = 1 )
                         ) 
                       &&
                          (   ( $pad{I1424} = $pos or 1 ) && 
                           do{ 
                my $from = $pos;
                my $bool =                                    do { while (
                                    (   ( $pad{I1425} = $pos or 1 ) && 
                                       (
                                           ( $pad{I1426} = $pos or 1 ) 
                                           && (
                                           (
                                              (   ( $pad{I1427} = $pos or 1 ) && 
                                               ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                                                   ? ( $pos += 1 or 1 )
                                                   : 0
                                               ) ||    ( ( $pos = $pad{I1427} ) && 0 ) )
                                           &&
                                              (   ( $pad{I1428} = $pos or 1 ) && 
                                               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                                           $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1428} ) && 0 ) )
                                           )
                                           ) 
                                         || ( 
                                           ( ( $bool = 1 ) && ( $pos = $pad{I1426} ) or 1 ) 
                                           &&                                             (   ( $pad{I1429} = $pos or 1 ) && 
                                             do{ 
                my $match = 
          do {
            our $I1430;
            our $I1430_sizes;
            unless ( $I1430 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1430_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1430 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I1430_sizes ) {
                $key = ( $pos <= length( $s ) 
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I1430->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m; 
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I1430, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          };
                if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1429} ) && 0 ) )
                                           ) 
                                         || ( 
                                           ( ( $bool = 1 ) && ( $pos = $pad{I1426} ) or 1 ) 
                                           &&                                             (   ( $pad{I1431} = $pos or 1 ) && 
                                             ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )  
                                                 ? ( $pos += length( $1 ) or 1 )
                                                 : 0
                                             ) ||    ( ( $pos = $pad{I1431} ) && 0 ) )
                                         )
                                       ) ||    ( ( $pos = $pad{I1425} ) && 0 ) )) {}; $bool = 1 };
                my $match = Pugs::Runtime::Match->new( 
                    { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                ); $named{'str'} = $match;
                $bool
            } ||    ( ( $pos = $pad{I1424} ) && 0 ) )
                       &&
                          (   ( $pad{I1432} = $pos or 1 ) && 
                           ( ( substr( $s, $pos, 1 ) eq '>' ) 
                               ? ( $pos += 1 or 1 )
                               : 0
                           ) ||    ( ( $pos = $pad{I1432} ) && 0 ) )
                       &&
                          (   ( $pad{I1433} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { if((${ $::_V6_MATCH_->{'ident'}} eq 'before' || ${ $::_V6_MATCH_->{'ident'}} eq 'after')) { return({${ $::_V6_MATCH_->{'ident'}} => {'rule' => {'metasyntax' => {'metasyntax' => '\'' . ${ $::_V6_MATCH_->{'str'}} . '\''}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } 
;
return({'metasyntax' => {'metasyntax' => ${ $::_V6_MATCH_->{'ident'}}, 'string' => ${ $::_V6_MATCH_->{'str'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1433} ) && 0 ) )
                       )
                       ) 
                     || ( 
                       ( ( $bool = 1 ) && ( $pos = $pad{I1417} ) or 1 ) 
                       &&                        (
                          (   ( $pad{I1434} = $pos or 1 ) && 
                           ( ( substr( $s, $pos, 1 ) eq '(' ) 
                               ? ( $pos += 1 or 1 )
                               : 0
                           ) ||    ( ( $pos = $pad{I1434} ) && 0 ) )
                       &&
                          (   ( $pad{I1435} = $pos or 1 ) && 
                           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                       $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1435} ) && 0 ) )
                       &&
                          (   ( $pad{I1436} = $pos or 1 ) && 
                           ( ( substr( $s, $pos, 1 ) eq ')' ) 
                               ? ( $pos += 1 or 1 )
                               : 0
                           ) ||    ( ( $pos = $pad{I1436} ) && 0 ) )
                       &&
                          (   ( $pad{I1437} = $pos or 1 ) && 
                           ( ( substr( $s, $pos, 1 ) eq '>' ) 
                               ? ( $pos += 1 or 1 )
                               : 0
                           ) ||    ( ( $pos = $pad{I1437} ) && 0 ) )
                       &&
                          (   ( $pad{I1438} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'call' => {'method' => ${ $::_V6_MATCH_->{'ident'}}, 'params' => ${ $::_V6_MATCH_->{'parsed_code'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1438} ) && 0 ) )
                       )
                     )
                   ) ||    ( ( $pos = $pad{I1416} ) && 0 ) )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1408} ) or 1 ) 
               &&                (
                  (   ( $pad{I1439} = $pos or 1 ) && 
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'metasyntax'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1439} ) && 0 ) )
               &&
                  (   ( $pad{I1440} = $pos or 1 ) && 
                   ( ( substr( $s, $pos, 1 ) eq '>' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   ) ||    ( ( $pos = $pad{I1440} ) && 0 ) )
               &&
                  (   ( $pad{I1441} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'metasyntax' => {'metasyntax' =>  "" . ${ $::_V6_MATCH_->{'metasyntax'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1441} ) && 0 ) )
               )
             )
           ) ||    ( ( $pos = $pad{I1407} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for parse_metasyntax
 #->sub_signature
#parse_metasyntax, );
;
%variables = ('$<' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1442} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1442} ) && 0 ) )
       &&
          (   ( $pad{I1443} = $pos or 1 ) && 
           ( ( substr( $s, $pos, 1 ) eq '>' ) 
               ? ( $pos += 1 or 1 )
               : 0
           ) ||    ( ( $pos = $pad{I1443} ) && 0 ) )
       &&
          (   ( $pad{I1444} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'match_variable' => '$' .  $::_V6_MATCH_->{'ident'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1444} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'$' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1445} = $pos or 1 ) 
           && (
           (
             (
              (   ( $pad{I1446} = $pos or 1 ) && 
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 } ||    ( ( $pos = $pad{I1446} ) && 0 ) )
             && do { while (
              (   ( $pad{I1446} = $pos or 1 ) && 
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 } ||    ( ( $pos = $pad{I1446} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I1447} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'match_variable' => '$' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1447} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1445} ) or 1 ) 
           &&            (
             (
              (   ( $pad{I1448} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '^' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1448} ) && 0 ) )
             || ( $bool = 1 )
             ) 
           &&
             (
              (   ( $pad{I1449} = $pos or 1 ) && 
                 (
                     ( $pad{I1450} = $pos or 1 ) 
                     && (
                      (   ( $pad{I1451} = $pos or 1 ) && 
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       } ||    ( ( $pos = $pad{I1451} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1450} ) or 1 ) 
                     &&                       (   ( $pad{I1452} = $pos or 1 ) && 
                       ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       ) ||    ( ( $pos = $pad{I1452} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1450} ) or 1 ) 
                     &&                      (
                        (   ( $pad{I1453} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1453} ) && 0 ) )
                     &&
                        (   ( $pad{I1454} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1454} ) && 0 ) )
                     )
                   )
                 ) ||    ( ( $pos = $pad{I1449} ) && 0 ) )
             && do { while (
              (   ( $pad{I1449} = $pos or 1 ) && 
                 (
                     ( $pad{I1450} = $pos or 1 ) 
                     && (
                      (   ( $pad{I1451} = $pos or 1 ) && 
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       } ||    ( ( $pos = $pad{I1451} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1450} ) or 1 ) 
                     &&                       (   ( $pad{I1452} = $pos or 1 ) && 
                       ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       ) ||    ( ( $pos = $pad{I1452} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1450} ) or 1 ) 
                     &&                      (
                        (   ( $pad{I1453} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1453} ) && 0 ) )
                     &&
                        (   ( $pad{I1454} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1454} ) && 0 ) )
                     )
                   )
                 ) ||    ( ( $pos = $pad{I1449} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I1455} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'variable' => '$' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1455} ) && 0 ) )
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'@' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1456} = $pos or 1 ) 
           && (
           (
             (
              (   ( $pad{I1457} = $pos or 1 ) && 
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 } ||    ( ( $pos = $pad{I1457} ) && 0 ) )
             && do { while (
              (   ( $pad{I1457} = $pos or 1 ) && 
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 } ||    ( ( $pos = $pad{I1457} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I1458} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'match_variable' => '@' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1458} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1456} ) or 1 ) 
           &&            (
             (
              (   ( $pad{I1459} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '^' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1459} ) && 0 ) )
             || ( $bool = 1 )
             ) 
           &&
             (
              (   ( $pad{I1460} = $pos or 1 ) && 
                 (
                     ( $pad{I1461} = $pos or 1 ) 
                     && (
                      (   ( $pad{I1462} = $pos or 1 ) && 
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       } ||    ( ( $pos = $pad{I1462} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1461} ) or 1 ) 
                     &&                       (   ( $pad{I1463} = $pos or 1 ) && 
                       ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       ) ||    ( ( $pos = $pad{I1463} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1461} ) or 1 ) 
                     &&                      (
                        (   ( $pad{I1464} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1464} ) && 0 ) )
                     &&
                        (   ( $pad{I1465} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1465} ) && 0 ) )
                     )
                   )
                 ) ||    ( ( $pos = $pad{I1460} ) && 0 ) )
             && do { while (
              (   ( $pad{I1460} = $pos or 1 ) && 
                 (
                     ( $pad{I1461} = $pos or 1 ) 
                     && (
                      (   ( $pad{I1462} = $pos or 1 ) && 
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       } ||    ( ( $pos = $pad{I1462} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1461} ) or 1 ) 
                     &&                       (   ( $pad{I1463} = $pos or 1 ) && 
                       ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       ) ||    ( ( $pos = $pad{I1463} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1461} ) or 1 ) 
                     &&                      (
                        (   ( $pad{I1464} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1464} ) && 0 ) )
                     &&
                        (   ( $pad{I1465} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1465} ) && 0 ) )
                     )
                   )
                 ) ||    ( ( $pos = $pad{I1460} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I1466} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'variable' => '@' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1466} ) && 0 ) )
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'%' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1467} = $pos or 1 ) 
           && (
           (
             (
              (   ( $pad{I1468} = $pos or 1 ) && 
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 } ||    ( ( $pos = $pad{I1468} ) && 0 ) )
             && do { while (
              (   ( $pad{I1468} = $pos or 1 ) && 
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 } ||    ( ( $pos = $pad{I1468} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I1469} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'match_variable' => '%' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1469} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1467} ) or 1 ) 
           &&            (
             (
              (   ( $pad{I1470} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '^' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1470} ) && 0 ) )
             || ( $bool = 1 )
             ) 
           &&
             (
              (   ( $pad{I1471} = $pos or 1 ) && 
                 (
                     ( $pad{I1472} = $pos or 1 ) 
                     && (
                      (   ( $pad{I1473} = $pos or 1 ) && 
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       } ||    ( ( $pos = $pad{I1473} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1472} ) or 1 ) 
                     &&                       (   ( $pad{I1474} = $pos or 1 ) && 
                       ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       ) ||    ( ( $pos = $pad{I1474} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1472} ) or 1 ) 
                     &&                      (
                        (   ( $pad{I1475} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1475} ) && 0 ) )
                     &&
                        (   ( $pad{I1476} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1476} ) && 0 ) )
                     )
                   )
                 ) ||    ( ( $pos = $pad{I1471} ) && 0 ) )
             && do { while (
              (   ( $pad{I1471} = $pos or 1 ) && 
                 (
                     ( $pad{I1472} = $pos or 1 ) 
                     && (
                      (   ( $pad{I1473} = $pos or 1 ) && 
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       } ||    ( ( $pos = $pad{I1473} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1472} ) or 1 ) 
                     &&                       (   ( $pad{I1474} = $pos or 1 ) && 
                       ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       ) ||    ( ( $pos = $pad{I1474} ) && 0 ) )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1472} ) or 1 ) 
                     &&                      (
                        (   ( $pad{I1475} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1475} ) && 0 ) )
                     &&
                        (   ( $pad{I1476} = $pos or 1 ) && 
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1476} ) && 0 ) )
                     )
                   )
                 ) ||    ( ( $pos = $pad{I1471} ) && 0 ) )) {}; $bool = 1 }
             ) 
           &&
              (   ( $pad{I1477} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'variable' => '%' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1477} ) && 0 ) )
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
);
%rule_terms = ('{*}' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1478} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'metasyntax' => {'metasyntax' => 'null'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1478} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'\'' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1479} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1479} ) && 0 ) )
       &&
          (   ( $pad{I1480} = $pos or 1 ) && 
           ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
               ? ( $pos += 1 or 1 )
               : 0
           ) ||    ( ( $pos = $pad{I1480} ) && 0 ) )
       &&
          (   ( $pad{I1481} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'metasyntax' => {'metasyntax' => '\'' . ${$::_V6_MATCH_}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1481} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'(' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1482} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1482} ) && 0 ) )
       &&
          (   ( $pad{I1483} = $pos or 1 ) && 
           ( ( substr( $s, $pos, 1 ) eq ')' ) 
               ? ( $pos += 1 or 1 )
               : 0
           ) ||    ( ( $pos = $pad{I1483} ) && 0 ) )
       &&
          (   ( $pad{I1484} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'capturing_group' => ${ $::_V6_MATCH_->{'rule'}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1484} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<(' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1485} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1485} ) && 0 ) )
       &&
          (   ( $pad{I1486} = $pos or 1 ) && 
           ( ( substr( $s, $pos, 2 ) eq ')>' ) 
               ? ( $pos += 2 or 1 )
               : 0
           ) ||    ( ( $pos = $pad{I1486} ) && 0 ) )
       &&
          (   ( $pad{I1487} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'capture_as_result' => ${ $::_V6_MATCH_->{'rule'}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1487} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<+' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1488} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1488} ) && 0 ) )
       &&
         do { while (
          (   ( $pad{I1489} = $pos or 1 ) && 
             do{ 
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     (
                        (   ( $pad{I1490} = $pos or 1 ) && 
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1490} ) && 0 ) )
                     &&
                        (   ( $pad{I1491} = $pos or 1 ) && 
                         do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1491} ) && 0 ) )
                     );
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             } ||    ( ( $pos = $pad{I1489} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I1492} = $pos or 1 ) && 
           ( ( substr( $s, $pos, 1 ) eq '>' ) 
               ? ( $pos += 1 or 1 )
               : 0
           ) ||    ( ( $pos = $pad{I1492} ) && 0 ) )
       &&
          (   ( $pad{I1493} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1493} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<-' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1494} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1494} ) && 0 ) )
       &&
         do { while (
          (   ( $pad{I1495} = $pos or 1 ) && 
             do{ 
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     (
                        (   ( $pad{I1496} = $pos or 1 ) && 
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1496} ) && 0 ) )
                     &&
                        (   ( $pad{I1497} = $pos or 1 ) && 
                         do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1497} ) && 0 ) )
                     );
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             } ||    ( ( $pos = $pad{I1495} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I1498} = $pos or 1 ) && 
           ( ( substr( $s, $pos, 1 ) eq '>' ) 
               ? ( $pos += 1 or 1 )
               : 0
           ) ||    ( ( $pos = $pad{I1498} ) && 0 ) )
       &&
          (   ( $pad{I1499} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'char_class' => ['-' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1499} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<[' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1500} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_range'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1500} ) && 0 ) )
       &&
          (   ( $pad{I1501} = $pos or 1 ) && 
           ( ( substr( $s, $pos, 1 ) eq ']' ) 
               ? ( $pos += 1 or 1 )
               : 0
           ) ||    ( ( $pos = $pad{I1501} ) && 0 ) )
       &&
         do { while (
          (   ( $pad{I1502} = $pos or 1 ) && 
             do{ 
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     (
                        (   ( $pad{I1503} = $pos or 1 ) && 
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         ) ||    ( ( $pos = $pad{I1503} ) && 0 ) )
                     &&
                        (   ( $pad{I1504} = $pos or 1 ) && 
                         do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1504} ) && 0 ) )
                     );
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             } ||    ( ( $pos = $pad{I1502} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I1505} = $pos or 1 ) && 
           ( ( substr( $s, $pos, 1 ) eq '>' ) 
               ? ( $pos += 1 or 1 )
               : 0
           ) ||    ( ( $pos = $pad{I1505} ) && 0 ) )
       &&
          (   ( $pad{I1506} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'char_class' => ['+[' .  $::_V6_MATCH_->{'char_range'} . ']',
@{($::_V6_MATCH_->[0])}]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1506} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1507} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'parse_metasyntax'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1507} ) && 0 ) )
       &&
          (   ( $pad{I1508} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'parse_metasyntax'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1508} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'{' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1509} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1509} ) && 0 ) )
       &&
          (   ( $pad{I1510} = $pos or 1 ) && 
           ( ( substr( $s, $pos, 1 ) eq '}' ) 
               ? ( $pos += 1 or 1 )
               : 0
           ) ||    ( ( $pos = $pad{I1510} ) && 0 ) )
       &&
          (   ( $pad{I1511} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1511} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'\\' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1512} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'special_char'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1512} ) && 0 ) )
       &&
          (   ( $pad{I1513} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'special_char'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1513} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'.' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1514} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'dot' => 1});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1514} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'[' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1515} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1515} ) && 0 ) )
       &&
          (   ( $pad{I1516} = $pos or 1 ) && 
           ( ( substr( $s, $pos, 1 ) eq ']' ) 
               ? ( $pos += 1 or 1 )
               : 0
           ) ||    ( ( $pos = $pad{I1516} ) && 0 ) )
       &&
          (   ( $pad{I1517} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'rule'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1517} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':::' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1518} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => ':::'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1518} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':?' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1519} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => ':?'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1519} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':+' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1520} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => ':+'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1520} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'::' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1521} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '::'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1521} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1522} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => ':'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1522} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'$$' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1523} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '$$'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1523} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'$' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1524} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '$'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1524} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'^^' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1525} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '^^'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1525} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'^' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1526} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '^'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1526} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'>>' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1527} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '>>'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1527} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1528} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '>>'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1528} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<<' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1529} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '<<'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1529} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
        (   ( $pad{I1530} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '<<'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1530} ) && 0 ) );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':i' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1531} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1531} ) && 0 ) )
       &&
          (   ( $pad{I1532} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1532} ) && 0 ) )
       &&
          (   ( $pad{I1533} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => {'modifier' => 'ignorecase', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1533} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':ignorecase' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1534} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1534} ) && 0 ) )
       &&
          (   ( $pad{I1535} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1535} ) && 0 ) )
       &&
          (   ( $pad{I1536} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => {'modifier' => 'ignorecase', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1536} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':s' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1537} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1537} ) && 0 ) )
       &&
          (   ( $pad{I1538} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1538} ) && 0 ) )
       &&
          (   ( $pad{I1539} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'sigspace', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1539} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':sigspace' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1540} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1540} ) && 0 ) )
       &&
          (   ( $pad{I1541} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1541} ) && 0 ) )
       &&
          (   ( $pad{I1542} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'sigspace', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1542} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':P5' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1543} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1543} ) && 0 ) )
       &&
          (   ( $pad{I1544} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1544} ) && 0 ) )
       &&
          (   ( $pad{I1545} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'Perl5', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1545} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':Perl5' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1546} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1546} ) && 0 ) )
       &&
          (   ( $pad{I1547} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1547} ) && 0 ) )
       &&
          (   ( $pad{I1548} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'Perl5', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1548} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':bytes' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1549} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1549} ) && 0 ) )
       &&
          (   ( $pad{I1550} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1550} ) && 0 ) )
       &&
          (   ( $pad{I1551} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'bytes', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1551} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':codes' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1552} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1552} ) && 0 ) )
       &&
          (   ( $pad{I1553} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1553} ) && 0 ) )
       &&
          (   ( $pad{I1554} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'codes', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1554} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':graphs' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1555} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1555} ) && 0 ) )
       &&
          (   ( $pad{I1556} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1556} ) && 0 ) )
       &&
          (   ( $pad{I1557} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'graphs', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1557} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':langs' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1558} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           } ||    ( ( $pos = $pad{I1558} ) && 0 ) )
       &&
          (   ( $pad{I1559} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1559} ) && 0 ) )
       &&
          (   ( $pad{I1560} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'langs', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1560} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
);
*term = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1561} = $pos or 1 ) 
           && (
           (
              (   ( $pad{I1562} = $pos or 1 ) && 
               do{ 
                my $match = 
          do {
            our $I1563;
            our $I1563_sizes;
            unless ( $I1563 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1563_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1563 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I1563_sizes ) {
                $key = ( $pos <= length( $s ) 
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I1563->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m; 
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I1563, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          };
                if ( $match ) { $named{'Pugs::Grammar::Rule::variables'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1562} ) && 0 ) )
           &&
              (   ( $pad{I1564} = $pos or 1 ) && 
               (
                   ( $pad{I1565} = $pos or 1 ) 
                   && (
                   (
                     (
                      (   ( $pad{I1566} = $pos or 1 ) && 
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         } ||    ( ( $pos = $pad{I1566} ) && 0 ) )
                     || ( $bool = 1 )
                     ) 
                   &&
                      (   ( $pad{I1567} = $pos or 1 ) && 
                       ( ( substr( $s, $pos, 2 ) eq ':=' ) 
                           ? ( $pos += 2 or 1 )
                           : 0
                       ) ||    ( ( $pos = $pad{I1567} ) && 0 ) )
                   &&
                     (
                      (   ( $pad{I1568} = $pos or 1 ) && 
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         } ||    ( ( $pos = $pad{I1568} ) && 0 ) )
                     || ( $bool = 1 )
                     ) 
                   &&
                      (   ( $pad{I1569} = $pos or 1 ) && 
                       do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                   $grammar->named_capture_body( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'named_capture_body'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1569} ) && 0 ) )
                   &&
                      (   ( $pad{I1570} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'named_capture' => {'rule' => ${ $::_V6_MATCH_->{'named_capture_body'}}, 'ident' => ${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'}}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1570} ) && 0 ) )
                   )
                   ) 
                 || ( 
                   ( ( $bool = 1 ) && ( $pos = $pad{I1565} ) or 1 ) 
                   &&                     (   ( $pad{I1571} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1571} ) && 0 ) )
                 )
               ) ||    ( ( $pos = $pad{I1564} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1561} ) or 1 ) 
           &&            (
              (   ( $pad{I1572} = $pos or 1 ) && 
               do{ 
                my $match = 
          do {
            our $I1573;
            our $I1573_sizes;
            unless ( $I1573 ) {
                my $hash = \%Pugs::Grammar::Rule::rule_terms;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1573_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1573 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I1573_sizes ) {
                $key = ( $pos <= length( $s ) 
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I1573->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m; 
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I1573, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          };
                if ( $match ) { $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1572} ) && 0 ) )
           &&
              (   ( $pad{I1574} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::rule_terms'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1574} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1561} ) or 1 ) 
           &&            (
              (   ( $pad{I1575} = $pos or 1 ) && 
               ( ( substr( $s, $pos ) =~ m/^((?:(?![\]\}\)\>\:\?\+\*\|\&]))\X)/ )  
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1575} ) && 0 ) )
           &&
              (   ( $pad{I1576} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'constant' => ${$::_V6_MATCH_}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1576} ) && 0 ) )
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for term
 #->sub_signature
#term, );
;
*quant = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1577} = $pos or 1 ) 
           && (
           (
              (   ( $pad{I1578} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 2 ) eq '**' ) 
                   ? ( $pos += 2 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1578} ) && 0 ) )
           &&
             (
              (   ( $pad{I1579} = $pos or 1 ) && 
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 } ||    ( ( $pos = $pad{I1579} ) && 0 ) )
             || ( $bool = 1 )
             ) 
           &&
              (   ( $pad{I1580} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq '{' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1580} ) && 0 ) )
           &&
              (   ( $pad{I1581} = $pos or 1 ) && 
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1581} ) && 0 ) )
           &&
              (   ( $pad{I1582} = $pos or 1 ) && 
               ( ( substr( $s, $pos, 1 ) eq '}' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1582} ) && 0 ) )
           &&
              (   ( $pad{I1583} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1583} ) && 0 ) )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1577} ) or 1 ) 
           &&            (
            (   ( $pad{I1584} = $pos or 1 ) && 
               ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\*\+]))\X)/ )  
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               ) ||    ( ( $pos = $pad{I1584} ) && 0 ) )
           || ( $bool = 1 )
           ) 
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for quant
 #->sub_signature
#quant, );
;
*quantifier = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
          (   ( $pad{I1585} = $pos or 1 ) && 
           do{ 
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{ 
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                            (   ( $pad{I1586} = $pos or 1 ) && 
                               do { 
                                    my $prior = $::_V6_PRIOR_; 
                                    my $match = 
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior; 
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               } ||    ( ( $pos = $pad{I1586} ) && 0 ) )
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws1'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1585} ) && 0 ) )
       &&
          (   ( $pad{I1587} = $pos or 1 ) && 
           do{ 
               my $pos1 = $pos;
               do {
                 my $pos = $pos1;
                 my $from = $pos;
                 my @match;
                 my %named;
                 $bool =                      do{ 
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
                                (   ( $pad{I1588} = $pos or 1 ) && 
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[\}\]\)]))\X)/ )  
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 ) ||    ( ( $pos = $pad{I1588} ) && 0 ) );
                           $bool;
                         };
                     } ? 0 : 1;
                 $bool;
               };
           } ||    ( ( $pos = $pad{I1587} ) && 0 ) )
       &&
          (   ( $pad{I1589} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->term( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'term'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1589} ) && 0 ) )
       &&
          (   ( $pad{I1590} = $pos or 1 ) && 
           do{ 
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{ 
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                            (   ( $pad{I1591} = $pos or 1 ) && 
                               do { 
                                    my $prior = $::_V6_PRIOR_; 
                                    my $match = 
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior; 
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               } ||    ( ( $pos = $pad{I1591} ) && 0 ) )
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws2'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1590} ) && 0 ) )
       &&
          (   ( $pad{I1592} = $pos or 1 ) && 
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->quant( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'quant'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1592} ) && 0 ) )
       &&
          (   ( $pad{I1593} = $pos or 1 ) && 
           do{ 
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{ 
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                            (   ( $pad{I1594} = $pos or 1 ) && 
                               ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\+]))\X)/ )  
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               ) ||    ( ( $pos = $pad{I1594} ) && 0 ) )
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'greedy'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1593} ) && 0 ) )
       &&
          (   ( $pad{I1595} = $pos or 1 ) && 
           do{ 
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{ 
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                            (   ( $pad{I1596} = $pos or 1 ) && 
                               do { 
                                    my $prior = $::_V6_PRIOR_; 
                                    my $match = 
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior; 
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               } ||    ( ( $pos = $pad{I1596} ) && 0 ) )
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws3'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1595} ) && 0 ) )
       &&
          (   ( $pad{I1597} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { if((${ $::_V6_MATCH_->{'quant'}} eq '' && (${ $::_V6_MATCH_->{'greedy'}} eq '' && (${ $::_V6_MATCH_->{'ws1'}} eq '' && (${ $::_V6_MATCH_->{'ws2'}} eq '' && ${ $::_V6_MATCH_->{'ws3'}} eq ''))))) { return(${ $::_V6_MATCH_->{'term'}});
 } 
;
return({'quant' => {'term' => ${ $::_V6_MATCH_->{'term'}}, 'quant' => ${ $::_V6_MATCH_->{'quant'}}, 'greedy' => ${ $::_V6_MATCH_->{'greedy'}}, 'ws1' => ${ $::_V6_MATCH_->{'ws1'}}, 'ws2' => ${ $::_V6_MATCH_->{'ws2'}}, 'ws3' => ${ $::_V6_MATCH_->{'ws3'}}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1597} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for quantifier
 #->sub_signature
#quantifier, );
;
*concat = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
         (
          (   ( $pad{I1598} = $pos or 1 ) && 
             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'quantifier'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1598} ) && 0 ) )
         && do { while (
          (   ( $pad{I1598} = $pos or 1 ) && 
             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'quantifier'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1598} ) && 0 ) )) {}; $bool = 1 }
         ) 
       &&
          (   ( $pad{I1599} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { 
        my @a = map {  $_->()  }  @{ $::_V6_MATCH_->{'quantifier'} };
        return { concat => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1599} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for concat
 #->sub_signature
#concat, );
;
*conjunctive1 = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
         (
          (   ( $pad{I1600} = $pos or 1 ) && 
             (
               (
                (   ( $pad{I1601} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1601} ) && 0 ) )
               || ( $bool = 1 )
               ) 
             &&
                (   ( $pad{I1602} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1602} ) && 0 ) )
             &&
                (   ( $pad{I1603} = $pos or 1 ) && 
                 do{ 
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool =                            do{ 
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
                                      (   ( $pad{I1604} = $pos or 1 ) && 
                                       ( ( substr( $s, $pos, 1 ) eq '&' ) 
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       ) ||    ( ( $pos = $pad{I1604} ) && 0 ) );
                                 $bool;
                               };
                           } ? 0 : 1;
                       $bool;
                     };
                 } ||    ( ( $pos = $pad{I1603} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I1600} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
         (
           (   ( $pad{I1605} = $pos or 1 ) && 
             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'concat'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1605} ) && 0 ) )
         ) 
       &&
         do { while (
          (   ( $pad{I1606} = $pos or 1 ) && 
             (
                (   ( $pad{I1607} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1607} ) && 0 ) )
             &&
                (   ( $pad{I1608} = $pos or 1 ) && 
                 do{ 
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool =                            do{ 
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
                                      (   ( $pad{I1609} = $pos or 1 ) && 
                                       ( ( substr( $s, $pos, 1 ) eq '&' ) 
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       ) ||    ( ( $pos = $pad{I1609} ) && 0 ) );
                                 $bool;
                               };
                           } ? 0 : 1;
                       $bool;
                     };
                 } ||    ( ( $pos = $pad{I1608} ) && 0 ) )
             &&
                (   ( $pad{I1610} = $pos or 1 ) && 
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'concat'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1610} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I1606} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I1611} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'concat'} };
        return { conjunctive1 => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1611} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for conjunctive1
 #->sub_signature
#conjunctive1, );
;
*disjunctive1 = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
         (
          (   ( $pad{I1612} = $pos or 1 ) && 
             (
               (
                (   ( $pad{I1613} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1613} ) && 0 ) )
               || ( $bool = 1 )
               ) 
             &&
                (   ( $pad{I1614} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1614} ) && 0 ) )
             &&
                (   ( $pad{I1615} = $pos or 1 ) && 
                 do{ 
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool =                            do{ 
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
                                      (   ( $pad{I1616} = $pos or 1 ) && 
                                       ( ( substr( $s, $pos, 1 ) eq '|' ) 
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       ) ||    ( ( $pos = $pad{I1616} ) && 0 ) );
                                 $bool;
                               };
                           } ? 0 : 1;
                       $bool;
                     };
                 } ||    ( ( $pos = $pad{I1615} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I1612} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
         (
           (   ( $pad{I1617} = $pos or 1 ) && 
             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1617} ) && 0 ) )
         ) 
       &&
         do { while (
          (   ( $pad{I1618} = $pos or 1 ) && 
             (
                (   ( $pad{I1619} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1619} ) && 0 ) )
             &&
                (   ( $pad{I1620} = $pos or 1 ) && 
                 do{ 
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool =                            do{ 
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
                                      (   ( $pad{I1621} = $pos or 1 ) && 
                                       ( ( substr( $s, $pos, 1 ) eq '|' ) 
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       ) ||    ( ( $pos = $pad{I1621} ) && 0 ) );
                                 $bool;
                               };
                           } ? 0 : 1;
                       $bool;
                     };
                 } ||    ( ( $pos = $pad{I1620} ) && 0 ) )
             &&
                (   ( $pad{I1622} = $pos or 1 ) && 
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1622} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I1618} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I1623} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive1'} };
        return { alt1 => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1623} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for disjunctive1
 #->sub_signature
#disjunctive1, );
;
*conjunctive = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
         (
          (   ( $pad{I1624} = $pos or 1 ) && 
             (
               (
                (   ( $pad{I1625} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1625} ) && 0 ) )
               || ( $bool = 1 )
               ) 
             &&
                (   ( $pad{I1626} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1626} ) && 0 ) )
             &&
                (   ( $pad{I1627} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1627} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I1624} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
         (
           (   ( $pad{I1628} = $pos or 1 ) && 
             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1628} ) && 0 ) )
         ) 
       &&
         do { while (
          (   ( $pad{I1629} = $pos or 1 ) && 
             (
                (   ( $pad{I1630} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1630} ) && 0 ) )
             &&
                (   ( $pad{I1631} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1631} ) && 0 ) )
             &&
                (   ( $pad{I1632} = $pos or 1 ) && 
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1632} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I1629} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I1633} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'disjunctive1'} };
        return { conjunctive => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1633} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for conjunctive
 #->sub_signature
#conjunctive, );
;
*rule = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
         (
          (   ( $pad{I1634} = $pos or 1 ) && 
             (
               (
                (   ( $pad{I1635} = $pos or 1 ) && 
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   } ||    ( ( $pos = $pad{I1635} ) && 0 ) )
               || ( $bool = 1 )
               ) 
             &&
                (   ( $pad{I1636} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1636} ) && 0 ) )
             &&
                (   ( $pad{I1637} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1637} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I1634} ) && 0 ) )
         || ( $bool = 1 )
         ) 
       &&
         (
           (   ( $pad{I1638} = $pos or 1 ) && 
             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'conjunctive'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1638} ) && 0 ) )
         ) 
       &&
         do { while (
          (   ( $pad{I1639} = $pos or 1 ) && 
             (
                (   ( $pad{I1640} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1640} ) && 0 ) )
             &&
                (   ( $pad{I1641} = $pos or 1 ) && 
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 ) ||    ( ( $pos = $pad{I1641} ) && 0 ) )
             &&
                (   ( $pad{I1642} = $pos or 1 ) && 
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'conjunctive'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            } ||    ( ( $pos = $pad{I1642} ) && 0 ) )
             ) ||    ( ( $pos = $pad{I1639} ) && 0 ) )) {}; $bool = 1 }
       &&
          (   ( $pad{I1643} = $pos or 1 ) && 
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive'} };
        return { alt => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                } ||    ( ( $pos = $pad{I1643} ) && 0 ) )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for rule
 #->sub_signature
#rule, );
;

; 1;
