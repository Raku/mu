# !!! DO NOT EDIT !!!
# This file was generated by Pugs::Compiler::Rule's compile_p6grammar.pl
# script from examples/Grammar.grammar at Tue Jul 22 22:14:35 2008

use strict;
use warnings;

package Pugs::Grammar::Rule;

#use base 'Pugs::Grammar::Base';

use Pugs::Runtime::Match;
use Pugs::Runtime::Regex;
use Pugs::Runtime::Tracer ();

# Code block from grammar spec


use utf8;
no strict 'refs';
no warnings 'redefine';
no warnings 'once';

#use Pugs::Runtime::Match;

our %rule_terms;
our %variables;



# token pod_begin
*pod_begin =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 632 675
           (
               ( $pad{I1955} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 633 652
               (
      
                 ## <group>
                 ## pos: 633 639
                  (   ( $pad{I1956} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I1956} ) && 0 ) )
                 ## </group>
    
               &&
    
                 ## <constant>
                 ## pos: 639 640
                 ( ( substr( $s, $pos, 1 ) eq '=' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 640 641
                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 641 642
                 ( ( substr( $s, $pos, 1 ) eq 'n' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
      
                 ## <group>
                 ## pos: 642 644
                  (   ( $pad{I1957} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 642 643
                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1957} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 644 652
                 do { while (
                  (   ( $pad{I1958} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1958} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1955} ) or 1 )
               &&            ## <concat>
               ## pos: 653 675
               (
      
                 ## <group>
                 ## pos: 653 658
                  (   ( $pad{I1959} = $pos or 1 ) &&
    
                   ## <dot>
                   ## pos: 656 657
                   ( substr( $s, $pos++, 1 ) ne '' )
                   ## </dot>
     ||    ( ( $pos = $pad{I1959} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 658 662
                 do { while (
                  (   ( $pad{I1960} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1960} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 662 675
                  (   ( $pad{I1961} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 662 674
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1961} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token pod_other
*pod_other =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 700 743
           (
               ( $pad{I1962} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 701 720
               (
      
                 ## <group>
                 ## pos: 701 707
                  (   ( $pad{I1963} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I1963} ) && 0 ) )
                 ## </group>
    
               &&
    
                 ## <constant>
                 ## pos: 707 708
                 ( ( substr( $s, $pos, 1 ) eq '=' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 708 709
                 ( ( substr( $s, $pos, 1 ) eq 'c' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 709 710
                 ( ( substr( $s, $pos, 1 ) eq 'u' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
      
                 ## <group>
                 ## pos: 710 712
                  (   ( $pad{I1964} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 710 711
                   ( ( substr( $s, $pos, 1 ) eq 't' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1964} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 712 720
                 do { while (
                  (   ( $pad{I1965} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1965} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1962} ) or 1 )
               &&            ## <concat>
               ## pos: 721 743
               (
      
                 ## <group>
                 ## pos: 721 726
                  (   ( $pad{I1966} = $pos or 1 ) &&
    
                   ## <dot>
                   ## pos: 724 725
                   ( substr( $s, $pos++, 1 ) ne '' )
                   ## </dot>
     ||    ( ( $pos = $pad{I1966} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 726 730
                 do { while (
                  (   ( $pad{I1967} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1967} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 730 743
                  (   ( $pad{I1968} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 730 742
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1968} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token ws
*ws =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 761 1059
           (
            (   ( $pad{I1969} = $pos or 1 ) &&
               ## <alt>
               ## pos: 762 1056
               (
                   ( $pad{I1970} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 768 783
                   (
      
                     ## <group>
                     ## pos: 768 775
                      (   ( $pad{I1971} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 772 774
                       ( ( substr( $s, $pos, 1 ) eq '#' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1971} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 775 783
                     do { while (
                      (   ( $pad{I1972} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
     ||    ( ( $pos = $pad{I1972} ) && 0 ) )) {}; $bool = 1 }
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1970} ) or 1 )
                   &&                ## <concat>
                   ## pos: 784 1044
                   (
      
                     ## <group>
                     ## pos: 784 791
                      (   ( $pad{I1973} = $pos or 1 ) &&
                       ## <perl5>
                       ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                           ? ( $pos += length( $1 ) or 1 )
                           : 0
                       )
                       ## </perl5>
     ||    ( ( $pos = $pad{I1973} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 791 1044
                     (
                      (   ( $pad{I1974} = $pos or 1 ) &&
                         ## <concat>
                         ## pos: 792 1037
                         (
      
                           ## <group>
                           ## pos: 792 795
                            (   ( $pad{I1975} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 793 794
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1975} ) && 0 ) )
                           ## </group>
    
                         &&
                           ## <quant>
                           ## pos: 795 1037
                           (
                            (   ( $pad{I1976} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 796 1022
                               (
                                   ( $pad{I1977} = $pos or 1 )
                                   && (
                                   ## <concat>
                                   ## pos: 810 847
                                   (
      
                                     ## <group>
                                     ## pos: 810 813
                                      (   ( $pad{I1978} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 812 813
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1978} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 813 814
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 814 815
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 815 816
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 816 818
                                      (   ( $pad{I1979} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 816 817
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1979} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 818 824
                                      (   ( $pad{I1980} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 818 823
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1980} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 824 825
                                     ( ( substr( $s, $pos, 1 ) eq 'E' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 825 826
                                     ( ( substr( $s, $pos, 1 ) eq 'N' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 826 828
                                      (   ( $pad{I1981} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 826 827
                                       ( ( substr( $s, $pos, 1 ) eq 'D' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1981} ) && 0 ) )
                                     ## </group>
    
                                   &&
                                     ## <quant>
                                     ## pos: 828 832
                                     do { while (
                                      (   ( $pad{I1982} = $pos or 1 ) &&
                                         ## <perl5>
                                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                             ? ( $pos += length( $1 ) or 1 )
                                             : 0
                                         )
                                         ## </perl5>
     ||    ( ( $pos = $pad{I1982} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   &&
                                     ## <quant>
                                     ## pos: 832 847
                                     do { while (
                                      (   ( $pad{I1983} = $pos or 1 ) &&
    
                                         ## <dot>
                                         ## pos: 832 833
                                         ( substr( $s, $pos++, 1 ) ne '' )
                                         ## </dot>
     ||    ( ( $pos = $pad{I1983} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1977} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 848 882
                                   (
      
                                     ## <group>
                                     ## pos: 848 851
                                      (   ( $pad{I1984} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 850 851
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1984} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 851 852
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 852 853
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 853 854
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 854 857
                                      (   ( $pad{I1985} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 854 855
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1985} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 857 882
                                      (   ( $pad{I1986} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 857 869
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1986} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1977} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 883 917
                                   (
      
                                     ## <group>
                                     ## pos: 883 886
                                      (   ( $pad{I1987} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 885 886
                                       ( ( substr( $s, $pos, 1 ) eq 'k' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1987} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 886 887
                                     ( ( substr( $s, $pos, 1 ) eq 'w' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 887 888
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 888 892
                                      (   ( $pad{I1988} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 888 889
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1988} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 892 917
                                      (   ( $pad{I1989} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 892 904
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1989} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1977} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 918 952
                                   (
      
                                     ## <group>
                                     ## pos: 918 921
                                      (   ( $pad{I1990} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 920 921
                                       ( ( substr( $s, $pos, 1 ) eq 'p' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1990} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 921 922
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 922 927
                                      (   ( $pad{I1991} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 922 923
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1991} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 927 952
                                      (   ( $pad{I1992} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 927 939
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1992} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1977} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 953 987
                                   (
      
                                     ## <group>
                                     ## pos: 953 956
                                      (   ( $pad{I1993} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 955 956
                                       ( ( substr( $s, $pos, 1 ) eq 'f' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1993} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 956 957
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 957 962
                                      (   ( $pad{I1994} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 957 958
                                       ( ( substr( $s, $pos, 1 ) eq 'r' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1994} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 962 987
                                      (   ( $pad{I1995} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 962 974
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1995} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1977} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 988 1022
                                   (
      
                                     ## <group>
                                     ## pos: 988 991
                                      (   ( $pad{I1996} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 990 991
                                       ( ( substr( $s, $pos, 1 ) eq 'h' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1996} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 991 992
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 992 993
                                     ( ( substr( $s, $pos, 1 ) eq 'a' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 993 994
                                     ( ( substr( $s, $pos, 1 ) eq 'd' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 994 997
                                      (   ( $pad{I1997} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 994 995
                                       ( ( substr( $s, $pos, 1 ) eq '1' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1997} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 997 1022
                                      (   ( $pad{I1998} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 997 1009
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1998} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I1976} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
    
                         )
                         ## </concat>
     ||    ( ( $pos = $pad{I1974} ) && 0 ) )
                     || ( $bool = 1 )
                     )
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1970} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1045 1056
                    (   ( $pad{I1999} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1999} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1969} ) && 0 ) )
           && do { while (
            (   ( $pad{I1969} = $pos or 1 ) &&
               ## <alt>
               ## pos: 762 1056
               (
                   ( $pad{I1970} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 768 783
                   (
      
                     ## <group>
                     ## pos: 768 775
                      (   ( $pad{I1971} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 772 774
                       ( ( substr( $s, $pos, 1 ) eq '#' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1971} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 775 783
                     do { while (
                      (   ( $pad{I1972} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
     ||    ( ( $pos = $pad{I1972} ) && 0 ) )) {}; $bool = 1 }
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1970} ) or 1 )
                   &&                ## <concat>
                   ## pos: 784 1044
                   (
      
                     ## <group>
                     ## pos: 784 791
                      (   ( $pad{I1973} = $pos or 1 ) &&
                       ## <perl5>
                       ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                           ? ( $pos += length( $1 ) or 1 )
                           : 0
                       )
                       ## </perl5>
     ||    ( ( $pos = $pad{I1973} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 791 1044
                     (
                      (   ( $pad{I1974} = $pos or 1 ) &&
                         ## <concat>
                         ## pos: 792 1037
                         (
      
                           ## <group>
                           ## pos: 792 795
                            (   ( $pad{I1975} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 793 794
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1975} ) && 0 ) )
                           ## </group>
    
                         &&
                           ## <quant>
                           ## pos: 795 1037
                           (
                            (   ( $pad{I1976} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 796 1022
                               (
                                   ( $pad{I1977} = $pos or 1 )
                                   && (
                                   ## <concat>
                                   ## pos: 810 847
                                   (
      
                                     ## <group>
                                     ## pos: 810 813
                                      (   ( $pad{I1978} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 812 813
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1978} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 813 814
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 814 815
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 815 816
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 816 818
                                      (   ( $pad{I1979} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 816 817
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1979} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 818 824
                                      (   ( $pad{I1980} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 818 823
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1980} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 824 825
                                     ( ( substr( $s, $pos, 1 ) eq 'E' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 825 826
                                     ( ( substr( $s, $pos, 1 ) eq 'N' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 826 828
                                      (   ( $pad{I1981} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 826 827
                                       ( ( substr( $s, $pos, 1 ) eq 'D' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1981} ) && 0 ) )
                                     ## </group>
    
                                   &&
                                     ## <quant>
                                     ## pos: 828 832
                                     do { while (
                                      (   ( $pad{I1982} = $pos or 1 ) &&
                                         ## <perl5>
                                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                             ? ( $pos += length( $1 ) or 1 )
                                             : 0
                                         )
                                         ## </perl5>
     ||    ( ( $pos = $pad{I1982} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   &&
                                     ## <quant>
                                     ## pos: 832 847
                                     do { while (
                                      (   ( $pad{I1983} = $pos or 1 ) &&
    
                                         ## <dot>
                                         ## pos: 832 833
                                         ( substr( $s, $pos++, 1 ) ne '' )
                                         ## </dot>
     ||    ( ( $pos = $pad{I1983} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1977} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 848 882
                                   (
      
                                     ## <group>
                                     ## pos: 848 851
                                      (   ( $pad{I1984} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 850 851
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1984} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 851 852
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 852 853
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 853 854
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 854 857
                                      (   ( $pad{I1985} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 854 855
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1985} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 857 882
                                      (   ( $pad{I1986} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 857 869
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1986} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1977} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 883 917
                                   (
      
                                     ## <group>
                                     ## pos: 883 886
                                      (   ( $pad{I1987} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 885 886
                                       ( ( substr( $s, $pos, 1 ) eq 'k' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1987} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 886 887
                                     ( ( substr( $s, $pos, 1 ) eq 'w' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 887 888
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 888 892
                                      (   ( $pad{I1988} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 888 889
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1988} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 892 917
                                      (   ( $pad{I1989} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 892 904
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1989} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1977} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 918 952
                                   (
      
                                     ## <group>
                                     ## pos: 918 921
                                      (   ( $pad{I1990} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 920 921
                                       ( ( substr( $s, $pos, 1 ) eq 'p' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1990} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 921 922
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 922 927
                                      (   ( $pad{I1991} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 922 923
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1991} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 927 952
                                      (   ( $pad{I1992} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 927 939
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1992} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1977} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 953 987
                                   (
      
                                     ## <group>
                                     ## pos: 953 956
                                      (   ( $pad{I1993} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 955 956
                                       ( ( substr( $s, $pos, 1 ) eq 'f' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1993} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 956 957
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 957 962
                                      (   ( $pad{I1994} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 957 958
                                       ( ( substr( $s, $pos, 1 ) eq 'r' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1994} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 962 987
                                      (   ( $pad{I1995} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 962 974
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1995} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1977} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 988 1022
                                   (
      
                                     ## <group>
                                     ## pos: 988 991
                                      (   ( $pad{I1996} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 990 991
                                       ( ( substr( $s, $pos, 1 ) eq 'h' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1996} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 991 992
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 992 993
                                     ( ( substr( $s, $pos, 1 ) eq 'a' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 993 994
                                     ( ( substr( $s, $pos, 1 ) eq 'd' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 994 997
                                      (   ( $pad{I1997} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 994 995
                                       ( ( substr( $s, $pos, 1 ) eq '1' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1997} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 997 1022
                                      (   ( $pad{I1998} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 997 1009
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1998} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I1976} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
    
                         )
                         ## </concat>
     ||    ( ( $pos = $pad{I1974} ) && 0 ) )
                     || ( $bool = 1 )
                     )
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1970} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1045 1056
                    (   ( $pad{I1999} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1999} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1969} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token ident
*ident =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 1118 1143
           (
            (   ( $pad{I2000} = $pos or 1 ) &&
               ## <alt>
               ## pos: 1119 1140
               (
                   ( $pad{I2001} = $pos or 1 )
                   && (
      
                   ## <group>
                   ## pos: 1119 1129
                    (   ( $pad{I2002} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 1120 1128
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I2002} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2001} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1130 1133
                    (   ( $pad{I2003} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1131 1132
                     ( ( substr( $s, $pos, 1 ) eq '_' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2003} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2001} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1134 1140
                    (   ( $pad{I2004} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1135 1139
                     ( ( substr( $s, $pos, 2 ) eq '::' )
                         ? ( $pos += 2 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2004} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I2000} ) && 0 ) )
           && do { while (
            (   ( $pad{I2000} = $pos or 1 ) &&
               ## <alt>
               ## pos: 1119 1140
               (
                   ( $pad{I2001} = $pos or 1 )
                   && (
      
                   ## <group>
                   ## pos: 1119 1129
                    (   ( $pad{I2002} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 1120 1128
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I2002} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2001} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1130 1133
                    (   ( $pad{I2003} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1131 1132
                     ( ( substr( $s, $pos, 1 ) eq '_' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2003} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2001} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1134 1140
                    (   ( $pad{I2004} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1135 1139
                     ( ( substr( $s, $pos, 2 ) eq '::' )
                         ? ( $pos += 2 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2004} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I2000} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token alnum
*alnum =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 1164 1178
            (   ( $pad{I2005} = $pos or 1 ) &&
             ## <perl5>
             ( ( substr( $s, $pos ) =~ m/^((?:(?=[0-9a-zA-Z]))\X)/ )
                 ? ( $pos += length( $1 ) or 1 )
                 : 0
             )
             ## </perl5>
     ||    ( ( $pos = $pad{I2005} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token alpha
*alpha =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 1199 1210
            (   ( $pad{I2006} = $pos or 1 ) &&
             ## <perl5>
             ( ( substr( $s, $pos ) =~ m/^((?:(?=[a-zA-Z]))\X)/ )
                 ? ( $pos += length( $1 ) or 1 )
                 : 0
             )
             ## </perl5>
     ||    ( ( $pos = $pad{I2006} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token digit
*digit =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 1231 1239
            (   ( $pad{I2007} = $pos or 1 ) &&
             ## <perl5>
             ( ( substr( $s, $pos ) =~ m/^((?:(?=[0-9]))\X)/ )
                 ? ( $pos += length( $1 ) or 1 )
                 : 0
             )
             ## </perl5>
     ||    ( ( $pos = $pad{I2007} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token special_char
*special_char =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 1284 2177
           (
               ( $pad{I2008} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 1285 1473
               (
      
                 ## <group>
                 ## pos: 1285 1296
                  (   ( $pad{I2009} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <alt>
                           ## pos: 1287 1294
                           (
                               ( $pad{I2010} = $pos or 1 )
                               && (
      
                               ## <group>
                               ## pos: 1287 1290
                                (   ( $pad{I2011} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1288 1289
                                 ( ( substr( $s, $pos, 1 ) eq 'c' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I2011} ) && 0 ) )
                               ## </group>
    
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2010} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1291 1294
                                (   ( $pad{I2012} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1292 1293
                                 ( ( substr( $s, $pos, 1 ) eq 'C' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I2012} ) && 0 ) )
                               ## </group>
    
                             )
                           )
                           ## </alt>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I2009} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1296 1299
                  (   ( $pad{I2013} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1296 1298
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2013} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1299 1340
                  (   ( $pad{I2014} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 1300 1338
                           (
                            (   ( $pad{I2015} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 1302 1336
                               (
                                   ( $pad{I2016} = $pos or 1 )
                                   && (
                                   ## <named_capture>
                                   ## pos: 1302 1309
                                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                               $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'alnum'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                   ## </named_capture>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I2016} ) or 1 )
                                   &&                                ## <perl5>
                                   ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                       ? ( $pos += length( $1 ) or 1 )
                                       : 0
                                   )
                                   ## </perl5>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I2016} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1313 1318
                                    (   ( $pad{I2017} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1314 1317
                                     ( ( substr( $s, $pos, 1 ) eq ';' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I2017} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I2016} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1319 1324
                                    (   ( $pad{I2018} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1320 1323
                                     ( ( substr( $s, $pos, 1 ) eq '(' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I2018} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I2016} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1325 1330
                                    (   ( $pad{I2019} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1326 1329
                                     ( ( substr( $s, $pos, 1 ) eq ')' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I2019} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I2016} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1331 1336
                                    (   ( $pad{I2020} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1332 1335
                                     ( ( substr( $s, $pos, 1 ) eq '-' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I2020} ) && 0 ) )
                                   ## </group>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I2015} ) && 0 ) )
                           && do { while (
                            (   ( $pad{I2015} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 1302 1336
                               (
                                   ( $pad{I2016} = $pos or 1 )
                                   && (
                                   ## <named_capture>
                                   ## pos: 1302 1309
                                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                               $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'alnum'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                   ## </named_capture>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I2016} ) or 1 )
                                   &&                                ## <perl5>
                                   ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                       ? ( $pos += length( $1 ) or 1 )
                                       : 0
                                   )
                                   ## </perl5>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I2016} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1313 1318
                                    (   ( $pad{I2017} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1314 1317
                                     ( ( substr( $s, $pos, 1 ) eq ';' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I2017} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I2016} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1319 1324
                                    (   ( $pad{I2018} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1320 1323
                                     ( ( substr( $s, $pos, 1 ) eq '(' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I2018} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I2016} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1325 1330
                                    (   ( $pad{I2019} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1326 1329
                                     ( ( substr( $s, $pos, 1 ) eq ')' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I2019} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I2016} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1331 1336
                                    (   ( $pad{I2020} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1332 1335
                                     ( ( substr( $s, $pos, 1 ) eq '-' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I2020} ) && 0 ) )
                                   ## </group>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I2015} ) && 0 ) )) {}; $bool = 1 }
                           )
                           ## </quant>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I2014} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1340 1385
                  (   ( $pad{I2021} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1340 1342
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2021} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1385 1473
                  (   ( $pad{I2022} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1385 1463
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0]->[0] . $_[0]->[1], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2022} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2008} ) or 1 )
               &&            ## <concat>
               ## pos: 1474 1617
               (
      
                 ## <group>
                 ## pos: 1474 1485
                  (   ( $pad{I2023} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 1476 1483
                   (
                       ( $pad{I2024} = $pos or 1 )
                       && (
      
                       ## <group>
                       ## pos: 1476 1479
                        (   ( $pad{I2025} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1477 1478
                         ( ( substr( $s, $pos, 1 ) eq 'x' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I2025} ) && 0 ) )
                       ## </group>
    
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2024} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 1480 1483
                        (   ( $pad{I2026} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1481 1482
                         ( ( substr( $s, $pos, 1 ) eq 'X' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I2026} ) && 0 ) )
                       ## </group>
    
                     )
                   )
                   ## </alt>
     ||    ( ( $pos = $pad{I2023} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 1485 1535
                 (
                  (   ( $pad{I2027} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 1485 1493
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I2027} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I2027} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 1485 1493
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I2027} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 1535 1617
                  (   ( $pad{I2028} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1535 1608
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2028} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2008} ) or 1 )
               &&            ## <concat>
               ## pos: 1618 1777
               (
      
                 ## <group>
                 ## pos: 1618 1629
                  (   ( $pad{I2029} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <alt>
                           ## pos: 1620 1627
                           (
                               ( $pad{I2030} = $pos or 1 )
                               && (
      
                               ## <group>
                               ## pos: 1620 1623
                                (   ( $pad{I2031} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1621 1622
                                 ( ( substr( $s, $pos, 1 ) eq 'x' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I2031} ) && 0 ) )
                               ## </group>
    
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2030} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1624 1627
                                (   ( $pad{I2032} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1625 1626
                                 ( ( substr( $s, $pos, 1 ) eq 'X' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I2032} ) && 0 ) )
                               ## </group>
    
                             )
                           )
                           ## </alt>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I2029} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1629 1632
                  (   ( $pad{I2033} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1629 1631
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2033} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1632 1644
                  (   ( $pad{I2034} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 1633 1642
                           (
                            (   ( $pad{I2035} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 1633 1641
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I2035} ) && 0 ) )
                           && do { while (
                            (   ( $pad{I2035} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 1633 1641
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I2035} ) && 0 ) )) {}; $bool = 1 }
                           )
                           ## </quant>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I2034} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1644 1689
                  (   ( $pad{I2036} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1644 1646
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2036} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1689 1777
                  (   ( $pad{I2037} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1689 1767
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0]->[0] . $_[0]->[1], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2037} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2008} ) or 1 )
               &&            ## <concat>
               ## pos: 1778 1915
               (
      
                 ## <group>
                 ## pos: 1778 1789
                  (   ( $pad{I2038} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 1780 1787
                   (
                       ( $pad{I2039} = $pos or 1 )
                       && (
      
                       ## <group>
                       ## pos: 1780 1783
                        (   ( $pad{I2040} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1781 1782
                         ( ( substr( $s, $pos, 1 ) eq 'o' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I2040} ) && 0 ) )
                       ## </group>
    
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2039} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 1784 1787
                        (   ( $pad{I2041} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1785 1786
                         ( ( substr( $s, $pos, 1 ) eq 'O' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I2041} ) && 0 ) )
                       ## </group>
    
                     )
                   )
                   ## </alt>
     ||    ( ( $pos = $pad{I2038} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 1789 1833
                 (
                  (   ( $pad{I2042} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I2042} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I2042} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I2042} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 1833 1915
                  (   ( $pad{I2043} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1833 1906
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2043} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2008} ) or 1 )
               &&            ## <concat>
               ## pos: 1916 2069
               (
      
                 ## <group>
                 ## pos: 1916 1927
                  (   ( $pad{I2044} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <alt>
                           ## pos: 1918 1925
                           (
                               ( $pad{I2045} = $pos or 1 )
                               && (
      
                               ## <group>
                               ## pos: 1918 1921
                                (   ( $pad{I2046} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1919 1920
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I2046} ) && 0 ) )
                               ## </group>
    
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2045} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1922 1925
                                (   ( $pad{I2047} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1923 1924
                                 ( ( substr( $s, $pos, 1 ) eq 'O' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I2047} ) && 0 ) )
                               ## </group>
    
                             )
                           )
                           ## </alt>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I2044} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1927 1930
                  (   ( $pad{I2048} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1927 1929
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2048} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1930 1936
                  (   ( $pad{I2049} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 1931 1934
                           (
                            (   ( $pad{I2050} = $pos or 1 ) &&
                               ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>
     ||    ( ( $pos = $pad{I2050} ) && 0 ) )
                           && do { while (
                            (   ( $pad{I2050} = $pos or 1 ) &&
                               ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>
     ||    ( ( $pos = $pad{I2050} ) && 0 ) )) {}; $bool = 1 }
                           )
                           ## </quant>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I2049} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1936 1981
                  (   ( $pad{I2051} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1936 1938
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2051} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1981 2069
                  (   ( $pad{I2052} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1981 2059
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0]->[0] . $_[0]->[1], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2052} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2008} ) or 1 )
               &&            ## <concat>
               ## pos: 2070 2177
               (
      
                 ## <group>
                 ## pos: 2070 2103
                  (   ( $pad{I2053} = $pos or 1 ) &&
    
                   ## <dot>
                   ## pos: 2071 2072
                   ( substr( $s, $pos++, 1 ) ne '' )
                   ## </dot>
     ||    ( ( $pos = $pad{I2053} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 2103 2177
                  (   ( $pad{I2054} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 2103 2176
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2054} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token literal
*literal =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2200 2251
           do { while (
            (   ( $pad{I2055} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2201 2248
               (
                   ( $pad{I2056} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2207 2231
                   (
      
                     ## <group>
                     ## pos: 2207 2212
                      (   ( $pad{I2057} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2209 2211
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2057} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2212 2231
                      (   ( $pad{I2058} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2212 2226
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2058} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2056} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2232 2248
                    (   ( $pad{I2059} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\']))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I2059} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I2055} ) && 0 ) )) {}; $bool = 1 }
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token double_quoted
*double_quoted =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2280 2372
           do { while (
            (   ( $pad{I2060} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2281 2369
               (
                   ( $pad{I2061} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2287 2311
                   (
      
                     ## <group>
                     ## pos: 2287 2292
                      (   ( $pad{I2062} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2289 2291
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2062} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2292 2311
                      (   ( $pad{I2063} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2292 2306
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2063} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2061} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2312 2352
                    (   ( $pad{I2064} = $pos or 1 ) &&
                    ## <metasyntax>
                     ## pos: 2314 2347
                     do{
                    my $match = 
              ## <variable>
              ## pos: 2314 2347
              do {
                our $I2065;
                our $I2065_sizes;
                unless ( $I2065 ) {
                    my $hash = \%Pugs::Grammar::Rule::variables;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I2065_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I2065 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I2065_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I2065->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I2065, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                    ## </metasyntax>
     ||    ( ( $pos = $pad{I2064} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2061} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2353 2369
                    (   ( $pad{I2066} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\"]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I2066} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I2060} ) && 0 ) )) {}; $bool = 1 }
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token metasyntax
*metasyntax =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2398 2576
           (
            (   ( $pad{I2067} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2399 2573
               (
                   ( $pad{I2068} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2405 2429
                   (
      
                     ## <group>
                     ## pos: 2405 2410
                      (   ( $pad{I2069} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2407 2409
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2069} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2410 2429
                      (   ( $pad{I2070} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2410 2424
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2070} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2068} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2430 2458
                   (
      
                     ## <group>
                     ## pos: 2430 2436
                      (   ( $pad{I2071} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2432 2434
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2071} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2436 2451
                      (   ( $pad{I2072} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2436 2446
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2072} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2451 2458
                      (   ( $pad{I2073} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2451 2453
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2073} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2068} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2459 2491
                   (
      
                     ## <group>
                     ## pos: 2459 2465
                      (   ( $pad{I2074} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2461 2463
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2074} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2465 2484
                      (   ( $pad{I2075} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2465 2481
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2075} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2484 2491
                      (   ( $pad{I2076} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2484 2486
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2076} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2068} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2492 2527
                   (
      
                     ## <group>
                     ## pos: 2492 2498
                      (   ( $pad{I2077} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2494 2496
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2077} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2498 2520
                      (   ( $pad{I2078} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2498 2512
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2078} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2520 2527
                      (   ( $pad{I2079} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2520 2522
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2079} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2068} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2528 2556
                   (
      
                     ## <group>
                     ## pos: 2528 2534
                      (   ( $pad{I2080} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2530 2532
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2080} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2534 2549
                      (   ( $pad{I2081} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2534 2547
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2081} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2549 2556
                      (   ( $pad{I2082} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2549 2551
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2082} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2068} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2557 2573
                    (   ( $pad{I2083} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I2083} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I2067} ) && 0 ) )
           && do { while (
            (   ( $pad{I2067} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2399 2573
               (
                   ( $pad{I2068} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2405 2429
                   (
      
                     ## <group>
                     ## pos: 2405 2410
                      (   ( $pad{I2069} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2407 2409
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2069} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2410 2429
                      (   ( $pad{I2070} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2410 2424
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2070} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2068} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2430 2458
                   (
      
                     ## <group>
                     ## pos: 2430 2436
                      (   ( $pad{I2071} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2432 2434
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2071} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2436 2451
                      (   ( $pad{I2072} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2436 2446
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2072} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2451 2458
                      (   ( $pad{I2073} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2451 2453
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2073} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2068} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2459 2491
                   (
      
                     ## <group>
                     ## pos: 2459 2465
                      (   ( $pad{I2074} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2461 2463
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2074} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2465 2484
                      (   ( $pad{I2075} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2465 2481
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2075} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2484 2491
                      (   ( $pad{I2076} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2484 2486
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2076} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2068} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2492 2527
                   (
      
                     ## <group>
                     ## pos: 2492 2498
                      (   ( $pad{I2077} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2494 2496
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2077} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2498 2520
                      (   ( $pad{I2078} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2498 2512
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2078} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2520 2527
                      (   ( $pad{I2079} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2520 2522
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2079} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2068} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2528 2556
                   (
      
                     ## <group>
                     ## pos: 2528 2534
                      (   ( $pad{I2080} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2530 2532
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2080} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2534 2549
                      (   ( $pad{I2081} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2534 2547
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2081} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2549 2556
                      (   ( $pad{I2082} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2549 2551
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2082} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2068} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2557 2573
                    (   ( $pad{I2083} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I2083} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I2067} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token char_range
*char_range =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2602 2653
           (
            (   ( $pad{I2084} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2603 2650
               (
                   ( $pad{I2085} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2609 2633
                   (
      
                     ## <group>
                     ## pos: 2609 2614
                      (   ( $pad{I2086} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2611 2613
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2086} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2614 2633
                      (   ( $pad{I2087} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2614 2628
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2087} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2085} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2634 2650
                    (   ( $pad{I2088} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I2088} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I2084} ) && 0 ) )
           && do { while (
            (   ( $pad{I2084} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2603 2650
               (
                   ( $pad{I2085} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2609 2633
                   (
      
                     ## <group>
                     ## pos: 2609 2614
                      (   ( $pad{I2086} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2611 2613
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2086} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2614 2633
                      (   ( $pad{I2087} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2614 2628
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2087} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2085} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2634 2650
                    (   ( $pad{I2088} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I2088} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I2084} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token char_class
*char_class =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 2679 2738
           (
               ( $pad{I2089} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 2680 2713
               (
      
                 ## <group>
                 ## pos: 2680 2691
                  (   ( $pad{I2090} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2682 2690
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I2090} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 2691 2713
                 do { while (
                  (   ( $pad{I2091} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 2692 2706
                     (
                         ( $pad{I2092} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 2692 2702
                          (   ( $pad{I2093} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 2693 2701
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I2093} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2092} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 2703 2706
                          (   ( $pad{I2094} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 2704 2705
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I2094} ) && 0 ) )
                         ## </group>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I2091} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2089} ) or 1 )
               &&            ## <concat>
               ## pos: 2714 2738
               (
      
                 ## <group>
                 ## pos: 2714 2720
                  (   ( $pad{I2095} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 2716 2718
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2095} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 2720 2735
                  (   ( $pad{I2096} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2720 2733
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I2096} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 2735 2738
                  (   ( $pad{I2097} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 2735 2737
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2097} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token string_code
*string_code =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2788 3072
           (
            (   ( $pad{I2098} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2789 3069
               (
                   ( $pad{I2099} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2795 2819
                   (
      
                     ## <group>
                     ## pos: 2795 2800
                      (   ( $pad{I2100} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2797 2799
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2100} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2800 2819
                      (   ( $pad{I2101} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2800 2814
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2101} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2820 2848
                   (
      
                     ## <group>
                     ## pos: 2820 2826
                      (   ( $pad{I2102} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2822 2824
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2102} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2826 2841
                      (   ( $pad{I2103} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2826 2836
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2103} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2841 2848
                      (   ( $pad{I2104} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2841 2843
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2104} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2849 2881
                   (
      
                     ## <group>
                     ## pos: 2849 2855
                      (   ( $pad{I2105} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2851 2853
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2105} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2855 2874
                      (   ( $pad{I2106} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2855 2871
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2106} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2874 2881
                      (   ( $pad{I2107} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2874 2876
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2107} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2882 2920
                   (
      
                     ## <group>
                     ## pos: 2882 2888
                      (   ( $pad{I2108} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2884 2886
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2108} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2888 2913
                      (   ( $pad{I2109} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2889 2910
                       (
                           ( $pad{I2110} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2889 2905
                            (   ( $pad{I2111} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2890 2904
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I2111} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2110} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2906 2910
                            (   ( $pad{I2112} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I2112} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I2109} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2913 2920
                      (   ( $pad{I2113} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2913 2915
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2113} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2921 2959
                   (
      
                     ## <group>
                     ## pos: 2921 2927
                      (   ( $pad{I2114} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2923 2925
                       ( ( substr( $s, $pos, 1 ) eq '(' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2114} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2927 2952
                      (   ( $pad{I2115} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2928 2949
                       (
                           ( $pad{I2116} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2928 2944
                            (   ( $pad{I2117} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2929 2943
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I2117} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2116} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2945 2949
                            (   ( $pad{I2118} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I2118} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I2115} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2952 2959
                      (   ( $pad{I2119} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2952 2954
                       ( ( substr( $s, $pos, 1 ) eq ')' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2119} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2960 2998
                   (
      
                     ## <group>
                     ## pos: 2960 2966
                      (   ( $pad{I2120} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2962 2964
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2120} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2966 2991
                      (   ( $pad{I2121} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2967 2988
                       (
                           ( $pad{I2122} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2967 2983
                            (   ( $pad{I2123} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2968 2982
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I2123} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2122} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2984 2988
                            (   ( $pad{I2124} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I2124} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I2121} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2991 2998
                      (   ( $pad{I2125} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2991 2993
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2125} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2999 3033
                   (
      
                     ## <group>
                     ## pos: 2999 3026
                      (   ( $pad{I2126} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 3002 3024
                       (
                           ( $pad{I2127} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 3002 3009
                            (   ( $pad{I2128} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 3003 3008
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I2128} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3010 3014
                            (   ( $pad{I2129} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3011 3013
                             ( ( substr( $s, $pos, 1 ) eq '>' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2129} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3015 3019
                            (   ( $pad{I2130} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3016 3018
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2130} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3020 3024
                            (   ( $pad{I2131} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3021 3023
                             ( ( substr( $s, $pos, 1 ) eq '-' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2131} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I2126} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3026 3033
                      (   ( $pad{I2132} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3026 3028
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2132} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3034 3046
                    (   ( $pad{I2133} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 3036 3041
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I2133} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3047 3069
                    (   ( $pad{I2134} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I2134} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I2098} ) && 0 ) )
           && do { while (
            (   ( $pad{I2098} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2789 3069
               (
                   ( $pad{I2099} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2795 2819
                   (
      
                     ## <group>
                     ## pos: 2795 2800
                      (   ( $pad{I2100} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2797 2799
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2100} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2800 2819
                      (   ( $pad{I2101} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2800 2814
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2101} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2820 2848
                   (
      
                     ## <group>
                     ## pos: 2820 2826
                      (   ( $pad{I2102} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2822 2824
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2102} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2826 2841
                      (   ( $pad{I2103} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2826 2836
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2103} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2841 2848
                      (   ( $pad{I2104} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2841 2843
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2104} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2849 2881
                   (
      
                     ## <group>
                     ## pos: 2849 2855
                      (   ( $pad{I2105} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2851 2853
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2105} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2855 2874
                      (   ( $pad{I2106} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2855 2871
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2106} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2874 2881
                      (   ( $pad{I2107} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2874 2876
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2107} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2882 2920
                   (
      
                     ## <group>
                     ## pos: 2882 2888
                      (   ( $pad{I2108} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2884 2886
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2108} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2888 2913
                      (   ( $pad{I2109} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2889 2910
                       (
                           ( $pad{I2110} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2889 2905
                            (   ( $pad{I2111} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2890 2904
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I2111} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2110} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2906 2910
                            (   ( $pad{I2112} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I2112} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I2109} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2913 2920
                      (   ( $pad{I2113} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2913 2915
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2113} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2921 2959
                   (
      
                     ## <group>
                     ## pos: 2921 2927
                      (   ( $pad{I2114} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2923 2925
                       ( ( substr( $s, $pos, 1 ) eq '(' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2114} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2927 2952
                      (   ( $pad{I2115} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2928 2949
                       (
                           ( $pad{I2116} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2928 2944
                            (   ( $pad{I2117} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2929 2943
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I2117} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2116} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2945 2949
                            (   ( $pad{I2118} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I2118} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I2115} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2952 2959
                      (   ( $pad{I2119} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2952 2954
                       ( ( substr( $s, $pos, 1 ) eq ')' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2119} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2960 2998
                   (
      
                     ## <group>
                     ## pos: 2960 2966
                      (   ( $pad{I2120} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2962 2964
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2120} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2966 2991
                      (   ( $pad{I2121} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2967 2988
                       (
                           ( $pad{I2122} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2967 2983
                            (   ( $pad{I2123} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2968 2982
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I2123} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2122} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2984 2988
                            (   ( $pad{I2124} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I2124} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I2121} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2991 2998
                      (   ( $pad{I2125} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2991 2993
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2125} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2999 3033
                   (
      
                     ## <group>
                     ## pos: 2999 3026
                      (   ( $pad{I2126} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 3002 3024
                       (
                           ( $pad{I2127} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 3002 3009
                            (   ( $pad{I2128} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 3003 3008
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I2128} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3010 3014
                            (   ( $pad{I2129} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3011 3013
                             ( ( substr( $s, $pos, 1 ) eq '>' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2129} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3015 3019
                            (   ( $pad{I2130} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3016 3018
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2130} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3020 3024
                            (   ( $pad{I2131} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3021 3023
                             ( ( substr( $s, $pos, 1 ) eq '-' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2131} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I2126} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3026 3033
                      (   ( $pad{I2132} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3026 3028
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2132} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3034 3046
                    (   ( $pad{I2133} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 3036 3041
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I2133} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3047 3069
                    (   ( $pad{I2134} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I2134} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I2098} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token parsed_code
*parsed_code =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 3158 3204
           (
      
             ## <group>
             ## pos: 3158 3177
              (   ( $pad{I2135} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 3158 3172
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I2135} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 3177 3204
              (   ( $pad{I2136} = $pos or 1 ) &&
               ## <closure>
               ## pos: 3177 3203
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return '{' . $_[0] . '}'; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2136} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token named_capture_body
*named_capture_body =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 3238 3729
           (
               ( $pad{I2137} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 3239 3371
               (
      
                 ## <group>
                 ## pos: 3239 3244
                  (   ( $pad{I2138} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3240 3242
                   ( ( substr( $s, $pos, 1 ) eq '(' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2138} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3244 3258
                  (   ( $pad{I2139} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 3244 3250
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I2139} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3258 3262
                  (   ( $pad{I2140} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3258 3260
                   ( ( substr( $s, $pos, 1 ) eq ')' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2140} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3262 3371
                  (   ( $pad{I2141} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3262 3366
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { capturing_group => ${ $_[0]->{qw(rule)} },
                                  _pos => [ $_[0]->from, $_[0]->to ], }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2141} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2137} ) or 1 )
               &&            ## <concat>
               ## pos: 3372 3419
               (
      
                 ## <group>
                 ## pos: 3372 3377
                  (   ( $pad{I2142} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3373 3375
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2142} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3377 3391
                  (   ( $pad{I2143} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 3377 3383
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I2143} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3391 3395
                  (   ( $pad{I2144} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3391 3393
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2144} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3395 3419
                  (   ( $pad{I2145} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3395 3414
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(rule)} } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2145} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2137} ) or 1 )
               &&            ## <concat>
               ## pos: 3420 3481
               (
      
                 ## <group>
                 ## pos: 3420 3425
                  (   ( $pad{I2146} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3421 3423
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2146} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3425 3445
                  (   ( $pad{I2147} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 3425 3443
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parse_metasyntax'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I2147} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3445 3481
                  (   ( $pad{I2148} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3445 3476
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(parse_metasyntax)} } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2148} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2137} ) or 1 )
               &&            ## <concat>
               ## pos: 3482 3695
               (
      
                 ## <group>
                 ## pos: 3482 3487
                  (   ( $pad{I2149} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3483 3485
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2149} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3487 3501
                  (   ( $pad{I2150} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 3487 3497
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I2150} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3501 3512
                  (   ( $pad{I2151} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3501 3503
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2151} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3512 3695
                  (   ( $pad{I2152} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3512 3690
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { metasyntax => {
                            metasyntax => "${$_[0]}",
                            },
                       _pos => [ $_[0]->from, $_[0]->to ],
                    };
            }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2152} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2137} ) or 1 )
               &&   
               ## <group>
               ## pos: 3696 3729
                (   ( $pad{I2153} = $pos or 1 ) &&
                 ## <closure>
                 ## pos: 3697 3728
                 do { 
                   local $::_V6_SUCCEED = 1;
                   $::_V6_MATCH_ = $m;
                   sub { die "invalid alias syntax"; }->( $m );
                   1;
                 }
                 ## </closure>
     ||    ( ( $pos = $pad{I2153} ) && 0 ) )
               ## </group>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token parse_metasyntax
*parse_metasyntax =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 3765 6638
           (
      
             ## <group>
             ## pos: 3765 3809
              (   ( $pad{I2154} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 3765 3804
               do{
                    my $from = $pos;
                    my $bool =                    ## <alt>
                       ## pos: 3781 3803
                       (
                           ( $pad{I2155} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 3781 3786
                            (   ( $pad{I2156} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3782 3785
                             ( ( substr( $s, $pos, 1 ) eq '!' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2156} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2155} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3787 3792
                            (   ( $pad{I2157} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3788 3791
                             ( ( substr( $s, $pos, 1 ) eq '?' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2157} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2155} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3793 3798
                            (   ( $pad{I2158} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3794 3797
                             ( ( substr( $s, $pos, 1 ) eq '.' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2158} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2155} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3799 3803
                            (   ( $pad{I2159} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I2159} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
    ;
                    my $match = Pugs::Runtime::Match->new(
                        { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                    ); $named{'modifier'} = $match;
                    $bool
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2154} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 3809 6638
              (   ( $pad{I2160} = $pos or 1 ) &&
               ## <alt>
               ## pos: 3810 6636
               (
                   ( $pad{I2161} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 3810 4028
                   (
      
                     ## <group>
                     ## pos: 3810 3824
                      (   ( $pad{I2162} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3819 3822
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2162} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3824 3839
                      (   ( $pad{I2163} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 3824 3837
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2163} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3839 3852
                      (   ( $pad{I2164} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3839 3843
                       ( ( substr( $s, $pos, 2 ) eq '}>' )
                           ? ( $pos += 2 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2164} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3852 4028
                      (   ( $pad{I2165} = $pos or 1 ) &&
                       ## <closure>
                       ## pos: 3852 4023
                       do {
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub { return { closure => {
                closure  => ${ $_[0]->{qw(parsed_code)} },
                modifier => ${ $_[0]->{qw(modifier)} },
            },
                _pos => [ $_[0]->from - 1, $_[0]->to ],
            } }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       }
                       ## </closure>
     ||    ( ( $pos = $pad{I2165} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2161} ) or 1 )
                   &&                ## <concat>
                   ## pos: 4029 4522
                   (
      
                     ## <group>
                     ## pos: 4029 4059
                      (   ( $pad{I2166} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 4038 4050
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2166} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 4059 4092
                     (
                      (   ( $pad{I2167} = $pos or 1 ) &&
    
                         ## <capture>
                         do{
                             my $hash = do {
                               my $bool = 1;
                               my $from = $pos;
                               my @match;
                               my %named;
                               $bool = 0 unless
                                 ## <concat>
                                 ## pos: 4060 4081
                                 (
      
                                   ## <group>
                                   ## pos: 4060 4068
                                    (   ( $pad{I2168} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
     ||    ( ( $pos = $pad{I2168} ) && 0 ) )
                                   ## </group>
    
                                 &&
      
                                   ## <group>
                                   ## pos: 4068 4081
                                    (   ( $pad{I2169} = $pos or 1 ) &&
                                     ## <named_capture>
                                     ## pos: 4068 4080
                                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                                 $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                     ## </named_capture>
     ||    ( ( $pos = $pad{I2169} ) && 0 ) )
                                   ## </group>
    
                                 )
                                 ## </concat>
    ;
                               { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                             };
                             my $bool = ${$hash->{'bool'}};
                             if ( $bool ) {
                                 push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                             }
                             $bool;
                         }
                         ## </capture>
     ||    ( ( $pos = $pad{I2167} ) && 0 ) )
                     && do { while (
                      (   ( $pad{I2167} = $pos or 1 ) &&
    
                         ## <capture>
                         do{
                             my $hash = do {
                               my $bool = 1;
                               my $from = $pos;
                               my @match;
                               my %named;
                               $bool = 0 unless
                                 ## <concat>
                                 ## pos: 4060 4081
                                 (
      
                                   ## <group>
                                   ## pos: 4060 4068
                                    (   ( $pad{I2168} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
     ||    ( ( $pos = $pad{I2168} ) && 0 ) )
                                   ## </group>
    
                                 &&
      
                                   ## <group>
                                   ## pos: 4068 4081
                                    (   ( $pad{I2169} = $pos or 1 ) &&
                                     ## <named_capture>
                                     ## pos: 4068 4080
                                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                                 $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                     ## </named_capture>
     ||    ( ( $pos = $pad{I2169} ) && 0 ) )
                                   ## </group>
    
                                 )
                                 ## </concat>
    ;
                               { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                             };
                             my $bool = ${$hash->{'bool'}};
                             if ( $bool ) {
                                 push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                             }
                             $bool;
                         }
                         ## </capture>
     ||    ( ( $pos = $pad{I2167} ) && 0 ) )) {}; $bool = 1 }
                     )
                     ## </quant>
    
                   &&
      
                     ## <group>
                     ## pos: 4092 4103
                      (   ( $pad{I2170} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 4092 4094
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2170} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 4103 4522
                      (   ( $pad{I2171} = $pos or 1 ) &&
                       ## <closure>
                       ## pos: 4103 4517
                       do {
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub {
                if ( ${ $_[0]->{qw(modifier)} } eq '!' ) {
                  return {
                    negate => {
                      char_class => [
                        '+' . $_[0]->{qw(char_class)},
                        @{$_[0]->[0]},   # TODO - stringify
                  ] } }
                }
                return {
                  char_class => [
                    '+' . $_[0]->{qw(char_class)},
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       }
                       ## </closure>
     ||    ( ( $pos = $pad{I2171} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2161} ) or 1 )
                   &&                ## <concat>
                   ## pos: 4523 6411
                   (
      
                     ## <group>
                     ## pos: 4523 4548
                      (   ( $pad{I2172} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 4532 4539
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2172} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 4548 6411
                      (   ( $pad{I2173} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 4549 6405
                       (
                           ( $pad{I2174} = $pos or 1 )
                           && (
                           ## <concat>
                           ## pos: 4549 5166
                           (
      
                             ## <group>
                             ## pos: 4549 4566
                              (   ( $pad{I2175} = $pos or 1 ) &&
                               ## <metasyntax>
                               ## pos: 4560 4565
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match =
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
     ||    ( ( $pos = $pad{I2175} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 4566 4573
                              (   ( $pad{I2176} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 4566 4572
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I2176} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 4573 4586
                              (   ( $pad{I2177} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 4573 4575
                               ( ( substr( $s, $pos, 1 ) eq '>' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I2177} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 4586 5166
                              (   ( $pad{I2178} = $pos or 1 ) &&
                               ## <closure>
                               ## pos: 4586 5157
                               do {
                                 local $::_V6_SUCCEED = 1;
                                 $::_V6_MATCH_ = $m;
                                 $m->data->{capture} = \( sub {
                if  ( ${ $_[0]->{qw(ident)} } eq 'before'
                   || ${ $_[0]->{qw(ident)} } eq 'after'
                    ) {
                    return { ${ $_[0]->{qw(ident)} } => {
                        rule => ${ $_[0]->{qw(rule)} }, modifier => ${ $_[0]->{qw(modifier)} },
                         }, _pos => [ $_[0]->from - 1, $_[0]->to ], }
                }
                return { metasyntax => {
                            metasyntax => ${ $_[0]->{qw(ident)} },
                            rule       => ${ $_[0]->{qw(rule)} },
                            modifier   => ${ $_[0]->{qw(modifier)} },
                        },
                        _pos => [ $_[0]->from - 1, $_[0]->to ],
                    }
              }->( $m ) ); 
                                 $bool = $::_V6_SUCCEED;
                                 $::_V6_MATCH_ = $m if $bool; 
                                 return $m if $bool; 
                               }
                               ## </closure>
     ||    ( ( $pos = $pad{I2178} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2174} ) or 1 )
                           &&                        ## <concat>
                           ## pos: 5167 6146
                           (
      
                             ## <group>
                             ## pos: 5167 5182
                              (   ( $pad{I2179} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 5178 5181
                               ( ( substr( $s, $pos, 1 ) eq ':' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I2179} ) && 0 ) )
                             ## </group>
    
                           &&
                             ## <quant>
                             ## pos: 5182 5199
                             (
                              (   ( $pad{I2180} = $pos or 1 ) &&
                                 ## <metasyntax>
                                 ## pos: 5182 5187
                                 do {
                                      my $prior = $::_V6_PRIOR_;
                                      my $match =
                                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                      $::_V6_PRIOR_ = $prior;
                                      my $bool = (!$match != 1);
                                      $pos = $match->to if $bool;
                                      $match;
                                 }
                                 ## </metasyntax>
     ||    ( ( $pos = $pad{I2180} ) && 0 ) )
                             || ( $bool = 1 )
                             )
                             ## </quant>
    
                           &&
      
                             ## <group>
                             ## pos: 5199 5369
                              (   ( $pad{I2181} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 5199 5358
                               do{
                    my $from = $pos;
                    my $bool =                                    ## <quant>
                                       ## pos: 5210 5357
                                       do { while (
                                        (   ( $pad{I2182} = $pos or 1 ) &&
                                           ## <alt>
                                           ## pos: 5224 5344
                                           (
                                               ( $pad{I2183} = $pos or 1 )
                                               && (
                                               ## <concat>
                                               ## pos: 5238 5270
                                               (
      
                                                 ## <group>
                                                 ## pos: 5238 5243
                                                  (   ( $pad{I2184} = $pos or 1 ) &&
    
                                                   ## <constant>
                                                   ## pos: 5240 5242
                                                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                                                       ? ( $pos += 1 or 1 )
                                                       : 0
                                                   )
                                                   ## </constant>
     ||    ( ( $pos = $pad{I2184} ) && 0 ) )
                                                 ## </group>
    
                                               &&
      
                                                 ## <group>
                                                 ## pos: 5243 5270
                                                  (   ( $pad{I2185} = $pos or 1 ) &&
                                                   ## <named_capture>
                                                   ## pos: 5243 5257
                                                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                                   ## </named_capture>
     ||    ( ( $pos = $pad{I2185} ) && 0 ) )
                                                 ## </group>
    
                                               )
                                               ## </concat>
    
                                               )
                                             || (
                                               ( ( $bool = 1 ) && ( $pos = $pad{I2183} ) or 1 )
                                               &&   
                                               ## <group>
                                               ## pos: 5271 5319
                                                (   ( $pad{I2186} = $pos or 1 ) &&
                                                ## <metasyntax>
                                                 ## pos: 5273 5306
                                                 do{
                    my $match = 
              ## <variable>
              ## pos: 5273 5306
              do {
                our $I2187;
                our $I2187_sizes;
                unless ( $I2187 ) {
                    my $hash = \%Pugs::Grammar::Rule::variables;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I2187_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I2187 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I2187_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I2187->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I2187, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                                ## </metasyntax>
     ||    ( ( $pos = $pad{I2186} ) && 0 ) )
                                               ## </group>
    
                                               )
                                             || (
                                               ( ( $bool = 1 ) && ( $pos = $pad{I2183} ) or 1 )
                                               &&   
                                               ## <group>
                                               ## pos: 5320 5344
                                                (   ( $pad{I2188} = $pos or 1 ) &&
                                                 ## <perl5>
                                                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                                                     ? ( $pos += length( $1 ) or 1 )
                                                     : 0
                                                 )
                                                 ## </perl5>
     ||    ( ( $pos = $pad{I2188} ) && 0 ) )
                                               ## </group>
    
                                             )
                                           )
                                           ## </alt>
     ||    ( ( $pos = $pad{I2182} ) && 0 ) )) {}; $bool = 1 }
                                       ## </quant>
    ;
                    my $match = Pugs::Runtime::Match->new(
                        { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                    ); $named{'str'} = $match;
                    $bool
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I2181} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 5369 5382
                              (   ( $pad{I2189} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 5369 5371
                               ( ( substr( $s, $pos, 1 ) eq '>' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I2189} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 5382 6146
                              (   ( $pad{I2190} = $pos or 1 ) &&
                               ## <closure>
                               ## pos: 5382 6137
                               do {
                                 local $::_V6_SUCCEED = 1;
                                 $::_V6_MATCH_ = $m;
                                 $m->data->{capture} = \( sub {
                if  ( ${ $_[0]->{qw(ident)} } eq 'before'
                   || ${ $_[0]->{qw(ident)} } eq 'after'
                    ) {
                    return { ${ $_[0]->{qw(ident)} } => {
                        rule     => { metasyntax => {
                                    metasyntax => '\'' . ${ $_[0]->{qw(str)} } . '\'',
                                },
                            _pos => [ $_[0]->{qw(str)}->from, $_[0]->{qw(str)}->to ],                   },
                        modifier => ${ $_[0]->{qw(modifier)} },
                        _pos => [ $_[0]->from - 1, $_[0]->to ],
                    } }
                }
                return { metasyntax => {
                    metasyntax => ${ $_[0]->{qw(ident)} },
                    string   => ${ $_[0]->{qw(str)} },
                    modifier => ${ $_[0]->{qw(modifier)} },
                },
                    _pos => [ $_[0]->from - 1, $_[0]->to ],
                }
              }->( $m ) ); 
                                 $bool = $::_V6_SUCCEED;
                                 $::_V6_MATCH_ = $m if $bool; 
                                 return $m if $bool; 
                               }
                               ## </closure>
     ||    ( ( $pos = $pad{I2190} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2174} ) or 1 )
                           &&                        ## <concat>
                           ## pos: 6147 6405
                           (
      
                             ## <group>
                             ## pos: 6147 6162
                              (   ( $pad{I2191} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 6158 6160
                               ( ( substr( $s, $pos, 1 ) eq '(' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I2191} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6162 6177
                              (   ( $pad{I2192} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 6162 6175
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I2192} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6177 6180
                              (   ( $pad{I2193} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 6177 6179
                               ( ( substr( $s, $pos, 1 ) eq ')' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I2193} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6180 6193
                              (   ( $pad{I2194} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 6180 6182
                               ( ( substr( $s, $pos, 1 ) eq '>' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I2194} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6193 6405
                              (   ( $pad{I2195} = $pos or 1 ) &&
                               ## <closure>
                               ## pos: 6193 6396
                               do {
                                 local $::_V6_SUCCEED = 1;
                                 $::_V6_MATCH_ = $m;
                                 $m->data->{capture} = \( sub { return { call => {
                  method   => ${ $_[0]->{qw(ident)} },
                  params   => ${ $_[0]->{qw(parsed_code)} },
                  modifier => ${ $_[0]->{qw(modifier)} },
              },
                  _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
                                 $bool = $::_V6_SUCCEED;
                                 $::_V6_MATCH_ = $m if $bool; 
                                 return $m if $bool; 
                               }
                               ## </closure>
     ||    ( ( $pos = $pad{I2195} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I2173} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2161} ) or 1 )
                   &&                ## <concat>
                   ## pos: 6412 6636
                   (
      
                     ## <group>
                     ## pos: 6412 6435
                      (   ( $pad{I2196} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 6421 6433
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'metasyntax'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I2196} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 6435 6446
                      (   ( $pad{I2197} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 6435 6437
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I2197} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 6446 6636
                      (   ( $pad{I2198} = $pos or 1 ) &&
                       ## <closure>
                       ## pos: 6446 6631
                       do {
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub { return { metasyntax => {
                  metasyntax => "${ $_[0]->{qw(metasyntax)} }",
                  modifier   => ${ $_[0]->{qw(modifier)} },
            },
                  _pos => [ $_[0]->from - 1, $_[0]->to ],
            } }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       }
                       ## </closure>
     ||    ( ( $pos = $pad{I2198} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I2160} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token var1
*var1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 6748 6850
           (
      
             ## <group>
             ## pos: 6748 6756
              (   ( $pad{I2199} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 6748 6755
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2199} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 6756 6767
              (   ( $pad{I2200} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 6756 6758
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2200} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 6767 6850
              (   ( $pad{I2201} = $pos or 1 ) &&
               ## <closure>
               ## pos: 6767 6849
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { match_variable => '$' . $_[0]->{ident}, _pos => [$_[0]->from - 2, $_[0]->to], }; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2201} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'$<'} = sub { var1($_[1], $_[0], $_[2], $_[3]) }; 

# token var2
*var2 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 6942 7166
           (
               ( $pad{I2202} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 6942 7040
               (
                 ## <quant>
                 ## pos: 6942 6960
                 (
                  (   ( $pad{I2203} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 6942 6950
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I2203} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I2203} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 6942 6950
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I2203} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 6960 7040
                  (   ( $pad{I2204} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 6960 7035
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { match_variable => '$' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2204} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2202} ) or 1 )
               &&            ## <concat>
               ## pos: 7041 7166
               (
                 ## <quant>
                 ## pos: 7041 7062
                 (
                  (   ( $pad{I2205} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 7050 7052
                     ( ( substr( $s, $pos, 1 ) eq '^' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2205} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
                 ## <quant>
                 ## pos: 7062 7096
                 (
                  (   ( $pad{I2206} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7063 7085
                     (
                         ( $pad{I2207} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7063 7073
                          (   ( $pad{I2208} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7064 7072
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I2208} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2207} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7074 7077
                          (   ( $pad{I2209} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7075 7076
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I2209} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2207} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7078 7085
                         (
      
                           ## <group>
                           ## pos: 7078 7082
                            (   ( $pad{I2210} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7079 7081
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2210} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7082 7085
                            (   ( $pad{I2211} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7082 7084
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2211} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I2206} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I2206} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7063 7085
                     (
                         ( $pad{I2207} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7063 7073
                          (   ( $pad{I2208} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7064 7072
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I2208} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2207} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7074 7077
                          (   ( $pad{I2209} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7075 7076
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I2209} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2207} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7078 7085
                         (
      
                           ## <group>
                           ## pos: 7078 7082
                            (   ( $pad{I2210} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7079 7081
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2210} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7082 7085
                            (   ( $pad{I2211} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7082 7084
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2211} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I2206} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7096 7166
                  (   ( $pad{I2212} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7096 7165
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { variable => '$' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2212} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'$'} = sub { var2($_[1], $_[0], $_[2], $_[3]) }; 

# token var3
*var3 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 7257 7479
           (
               ( $pad{I2213} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 7257 7354
               (
                 ## <quant>
                 ## pos: 7257 7275
                 (
                  (   ( $pad{I2214} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7257 7265
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I2214} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I2214} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7257 7265
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I2214} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7275 7354
                  (   ( $pad{I2215} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7275 7349
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { match_variable => '@' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2215} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2213} ) or 1 )
               &&            ## <concat>
               ## pos: 7355 7479
               (
                 ## <quant>
                 ## pos: 7355 7376
                 (
                  (   ( $pad{I2216} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 7364 7366
                     ( ( substr( $s, $pos, 1 ) eq '^' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2216} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
                 ## <quant>
                 ## pos: 7376 7410
                 (
                  (   ( $pad{I2217} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7377 7399
                     (
                         ( $pad{I2218} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7377 7387
                          (   ( $pad{I2219} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7378 7386
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I2219} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2218} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7388 7391
                          (   ( $pad{I2220} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7389 7390
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I2220} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2218} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7392 7399
                         (
      
                           ## <group>
                           ## pos: 7392 7396
                            (   ( $pad{I2221} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7393 7395
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2221} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7396 7399
                            (   ( $pad{I2222} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7396 7398
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2222} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I2217} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I2217} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7377 7399
                     (
                         ( $pad{I2218} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7377 7387
                          (   ( $pad{I2219} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7378 7386
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I2219} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2218} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7388 7391
                          (   ( $pad{I2220} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7389 7390
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I2220} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2218} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7392 7399
                         (
      
                           ## <group>
                           ## pos: 7392 7396
                            (   ( $pad{I2221} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7393 7395
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2221} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7396 7399
                            (   ( $pad{I2222} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7396 7398
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2222} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I2217} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7410 7479
                  (   ( $pad{I2223} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7410 7478
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { variable => '@' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2223} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'@'} = sub { var3($_[1], $_[0], $_[2], $_[3]) }; 

# token var4
*var4 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 7570 7790
           (
               ( $pad{I2224} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 7570 7666
               (
                 ## <quant>
                 ## pos: 7570 7588
                 (
                  (   ( $pad{I2225} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7570 7578
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I2225} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I2225} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7570 7578
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I2225} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7588 7666
                  (   ( $pad{I2226} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7588 7661
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { match_variable => '%' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2226} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2224} ) or 1 )
               &&            ## <concat>
               ## pos: 7667 7790
               (
                 ## <quant>
                 ## pos: 7667 7688
                 (
                  (   ( $pad{I2227} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 7676 7678
                     ( ( substr( $s, $pos, 1 ) eq '^' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2227} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
                 ## <quant>
                 ## pos: 7688 7722
                 (
                  (   ( $pad{I2228} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7689 7711
                     (
                         ( $pad{I2229} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7689 7699
                          (   ( $pad{I2230} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7690 7698
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I2230} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2229} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7700 7703
                          (   ( $pad{I2231} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7701 7702
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I2231} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2229} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7704 7711
                         (
      
                           ## <group>
                           ## pos: 7704 7708
                            (   ( $pad{I2232} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7705 7707
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2232} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7708 7711
                            (   ( $pad{I2233} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7708 7710
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2233} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I2228} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I2228} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7689 7711
                     (
                         ( $pad{I2229} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7689 7699
                          (   ( $pad{I2230} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7690 7698
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I2230} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2229} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7700 7703
                          (   ( $pad{I2231} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7701 7702
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I2231} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I2229} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7704 7711
                         (
      
                           ## <group>
                           ## pos: 7704 7708
                            (   ( $pad{I2232} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7705 7707
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2232} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7708 7711
                            (   ( $pad{I2233} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7708 7710
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2233} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I2228} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7722 7790
                  (   ( $pad{I2234} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7722 7789
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { variable => '%' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2234} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'%'} = sub { var4($_[1], $_[0], $_[2], $_[3]) }; 

# token term1
*term1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 7991 8141
            (   ( $pad{I2235} = $pos or 1 ) &&
             ## <closure>
             ## pos: 7991 8140
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { metasyntax => {
                            metasyntax => 'null',
            },
                            _pos => [ $_[0]->from, $_[0]->to ],
            } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2235} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'{*}'} = sub { term1($_[1], $_[0], $_[2], $_[3]) }; 

# token term2
*term2 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8237 8452
           (
      
             ## <group>
             ## pos: 8237 8252
              (   ( $pad{I2236} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 8237 8247
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I2236} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8252 8263
              (   ( $pad{I2237} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 8252 8254
               ( ( substr( $s, $pos, 1 ) eq chr(39) )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2237} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8263 8452
              (   ( $pad{I2238} = $pos or 1 ) &&
               ## <closure>
               ## pos: 8263 8451
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                    metasyntax => {
                        metasyntax => '\'' . ${$_[0]},
                    },
                        _pos => [ $_[0]->from - 1, $_[0]->to ],
                };
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2238} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'\''} = sub { term2($_[1], $_[0], $_[2], $_[3]) }; 

# token term3
*term3 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8547 8663
           (
      
             ## <group>
             ## pos: 8547 8554
              (   ( $pad{I2239} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 8547 8553
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2239} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8554 8565
              (   ( $pad{I2240} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 8554 8556
               ( ( substr( $s, $pos, 1 ) eq ')' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2240} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8565 8663
              (   ( $pad{I2241} = $pos or 1 ) &&
               ## <closure>
               ## pos: 8565 8662
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { capturing_group => ${ $_[0]->{qw(rule)} },
                       _pos => [ $_[0]->from - 1, $_[0]->to ], }; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2241} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'('} = sub { term3($_[1], $_[0], $_[2], $_[3]) }; 

# token term4
*term4 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8757 8878
           (
      
             ## <group>
             ## pos: 8757 8765
              (   ( $pad{I2242} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 8757 8763
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2242} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8765 8778
              (   ( $pad{I2243} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 8765 8769
               ( ( substr( $s, $pos, 2 ) eq ')>' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2243} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8778 8878
              (   ( $pad{I2244} = $pos or 1 ) &&
               ## <closure>
               ## pos: 8778 8877
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { capture_as_result => ${ $_[0]->{qw(rule)} },
                       _pos => [ $_[0]->from - 2, $_[0]->to ], }; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2244} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<('} = sub { term4($_[1], $_[0], $_[2], $_[3]) }; 

# token term5
*term5 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8973 9233
           (
      
             ## <group>
             ## pos: 8973 8994
              (   ( $pad{I2245} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 8973 8985
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2245} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 8994 9027
             do { while (
              (   ( $pad{I2246} = $pos or 1 ) &&
    
                 ## <capture>
                 do{
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         ## <concat>
                         ## pos: 8995 9016
                         (
      
                           ## <group>
                           ## pos: 8995 9003
                            (   ( $pad{I2247} = $pos or 1 ) &&
                             ## <perl5>
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                             ## </perl5>
     ||    ( ( $pos = $pad{I2247} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 9003 9016
                            (   ( $pad{I2248} = $pos or 1 ) &&
                             ## <named_capture>
                             ## pos: 9003 9015
                             do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                         $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                             ## </named_capture>
     ||    ( ( $pos = $pad{I2248} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    ;
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }
                 ## </capture>
     ||    ( ( $pos = $pad{I2246} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 9027 9038
              (   ( $pad{I2249} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9027 9029
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2249} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9038 9233
              (   ( $pad{I2250} = $pos or 1 ) &&
               ## <closure>
               ## pos: 9038 9232
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                _pos => [ $_[0]->from - 2, $_[0]->to ],
                char_class => [
                    '+' . $_[0]->{qw(char_class)},
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2250} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<+'} = sub { term5($_[1], $_[0], $_[2], $_[3]) }; 

# token term6
*term6 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 9328 9588
           (
      
             ## <group>
             ## pos: 9328 9349
              (   ( $pad{I2251} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 9328 9340
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2251} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 9349 9382
             do { while (
              (   ( $pad{I2252} = $pos or 1 ) &&
    
                 ## <capture>
                 do{
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         ## <concat>
                         ## pos: 9350 9371
                         (
      
                           ## <group>
                           ## pos: 9350 9358
                            (   ( $pad{I2253} = $pos or 1 ) &&
                             ## <perl5>
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                             ## </perl5>
     ||    ( ( $pos = $pad{I2253} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 9358 9371
                            (   ( $pad{I2254} = $pos or 1 ) &&
                             ## <named_capture>
                             ## pos: 9358 9370
                             do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                         $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                             ## </named_capture>
     ||    ( ( $pos = $pad{I2254} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    ;
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }
                 ## </capture>
     ||    ( ( $pos = $pad{I2252} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 9382 9393
              (   ( $pad{I2255} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9382 9384
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2255} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9393 9588
              (   ( $pad{I2256} = $pos or 1 ) &&
               ## <closure>
               ## pos: 9393 9587
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                _pos => [ $_[0]->from - 2, $_[0]->to ],
                char_class => [
                    '-' . $_[0]->{qw(char_class)},
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2256} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<-'} = sub { term6($_[1], $_[0], $_[2], $_[3]) }; 

# token term7
*term7 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 9683 9954
           (
      
             ## <group>
             ## pos: 9683 9697
              (   ( $pad{I2257} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 9683 9695
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_range'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2257} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9697 9708
              (   ( $pad{I2258} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9697 9699
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2258} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 9708 9741
             do { while (
              (   ( $pad{I2259} = $pos or 1 ) &&
    
                 ## <capture>
                 do{
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         ## <concat>
                         ## pos: 9709 9730
                         (
      
                           ## <group>
                           ## pos: 9709 9717
                            (   ( $pad{I2260} = $pos or 1 ) &&
                             ## <perl5>
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                             ## </perl5>
     ||    ( ( $pos = $pad{I2260} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 9717 9730
                            (   ( $pad{I2261} = $pos or 1 ) &&
                             ## <named_capture>
                             ## pos: 9717 9729
                             do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                         $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                             ## </named_capture>
     ||    ( ( $pos = $pad{I2261} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    ;
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }
                 ## </capture>
     ||    ( ( $pos = $pad{I2259} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 9741 9752
              (   ( $pad{I2262} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9741 9743
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2262} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9752 9954
              (   ( $pad{I2263} = $pos or 1 ) &&
               ## <closure>
               ## pos: 9752 9953
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                _pos => [ $_[0]->from - 2, $_[0]->to ],
                char_class => [
                    '+[' . $_[0]->{qw(char_range)} . ']',
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2263} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<['} = sub { term7($_[1], $_[0], $_[2], $_[3]) }; 

# token term8
*term8 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10049 10108
           (
      
             ## <group>
             ## pos: 10049 10076
              (   ( $pad{I2264} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10049 10067
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parse_metasyntax'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2264} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10076 10108
              (   ( $pad{I2265} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10076 10107
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return ${ $_[0]->{qw(parse_metasyntax)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2265} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<'} = sub { term8($_[1], $_[0], $_[2], $_[3]) }; 

# token term9
*term9 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10202 10392
           (
      
             ## <group>
             ## pos: 10202 10217
              (   ( $pad{I2266} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10202 10215
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2266} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10217 10228
              (   ( $pad{I2267} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 10217 10219
               ( ( substr( $s, $pos, 1 ) eq '}' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2267} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10228 10392
              (   ( $pad{I2268} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10228 10391
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { closure => {
                closure => ${ $_[0]->{qw(parsed_code)} },
                modifier => 'plain',
            },
                _pos => [$_[0]->from - 1, $_[0]->to],
            } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2268} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'{'} = sub { term9($_[1], $_[0], $_[2], $_[3]) }; 

# token term10
*term10 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10487 10538
           (
      
             ## <group>
             ## pos: 10487 10510
              (   ( $pad{I2269} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10487 10501
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'special_char'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2269} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10510 10538
              (   ( $pad{I2270} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10510 10537
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return ${ $_[0]->{qw(special_char)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2270} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'\\'} = sub { term10($_[1], $_[0], $_[2], $_[3]) }; 

# token term11
*term11 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 10635 10694
            (   ( $pad{I2271} = $pos or 1 ) &&
             ## <closure>
             ## pos: 10635 10693
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { 'dot' => 1, _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2271} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'.'} = sub { term11($_[1], $_[0], $_[2], $_[3]) }; 

# token term12
*term12 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10790 10828
           (
      
             ## <group>
             ## pos: 10790 10797
              (   ( $pad{I2272} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10790 10796
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2272} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10797 10808
              (   ( $pad{I2273} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 10797 10799
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2273} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10808 10828
              (   ( $pad{I2274} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10808 10827
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return ${ $_[0]->{qw(rule)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2274} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'['} = sub { term12($_[1], $_[0], $_[2], $_[3]) }; 

# token term13
*term13 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 10916 10979
            (   ( $pad{I2275} = $pos or 1 ) &&
             ## <closure>
             ## pos: 10916 10978
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':::', _pos => [$_[0]->from - 3, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2275} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':::'} = sub { term13($_[1], $_[0], $_[2], $_[3]) }; 

# token term14
*term14 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11069 11131
            (   ( $pad{I2276} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11069 11130
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':?', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2276} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':?'} = sub { term14($_[1], $_[0], $_[2], $_[3]) }; 

# token term15
*term15 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11220 11282
            (   ( $pad{I2277} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11220 11281
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':+', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2277} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':+'} = sub { term15($_[1], $_[0], $_[2], $_[3]) }; 

# token term16
*term16 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11371 11433
            (   ( $pad{I2278} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11371 11432
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '::', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2278} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'::'} = sub { term16($_[1], $_[0], $_[2], $_[3]) }; 

# token term17
*term17 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11522 11583
            (   ( $pad{I2279} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11522 11582
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2279} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':'} = sub { term17($_[1], $_[0], $_[2], $_[3]) }; 

# token term18
*term18 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11671 11733
            (   ( $pad{I2280} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11671 11732
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '$$', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2280} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'$$'} = sub { term18($_[1], $_[0], $_[2], $_[3]) }; 

# token term19
*term19 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11822 11884
            (   ( $pad{I2281} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11822 11883
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '$', _pos => [$_[0]->from - 1, $_[0]->to],  } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2281} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'$'} = sub { term19($_[1], $_[0], $_[2], $_[3]) }; 

# token term20
*term20 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11972 12034
            (   ( $pad{I2282} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11972 12033
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '^^', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2282} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'^^'} = sub { term20($_[1], $_[0], $_[2], $_[3]) }; 

# token term21
*term21 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 12123 12184
            (   ( $pad{I2283} = $pos or 1 ) &&
             ## <closure>
             ## pos: 12123 12183
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '^', _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2283} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'^'} = sub { term21($_[1], $_[0], $_[2], $_[3]) }; 

# token term22
*term22 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 12272 12334
            (   ( $pad{I2284} = $pos or 1 ) &&
             ## <closure>
             ## pos: 12272 12333
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '>>', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2284} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'>>'} = sub { term22($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{''} = sub { term22($_[1], $_[0], $_[2], $_[3]) }; 

# token term24
*term24 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 12576 12638
            (   ( $pad{I2285} = $pos or 1 ) &&
             ## <closure>
             ## pos: 12576 12637
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '<<', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I2285} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<<'} = sub { term24($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{''} = sub { term24($_[1], $_[0], $_[2], $_[3]) }; 

# token term26
*term26 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 12888 13065
           (
      
             ## <group>
             ## pos: 12888 12894
              (   ( $pad{I2286} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 12888 12893
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I2286} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 12894 12909
              (   ( $pad{I2287} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 12894 12900
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2287} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 12909 13065
              (   ( $pad{I2288} = $pos or 1 ) &&
               ## <closure>
               ## pos: 12909 13064
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                modifier => {
                    modifier => 'ignorecase',
                    rule => ${ $_[0]->{qw(rule)} },
                    }
                },
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2288} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':i'} = sub { term26($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{':ignorecase'} = sub { term26($_[1], $_[0], $_[2], $_[3]) }; 

# token term28
*term28 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 13345 13422
           (
      
             ## <group>
             ## pos: 13345 13351
              (   ( $pad{I2289} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 13345 13350
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I2289} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13351 13366
              (   ( $pad{I2290} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 13351 13357
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2290} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13366 13422
              (   ( $pad{I2291} = $pos or 1 ) &&
               ## <closure>
               ## pos: 13366 13421
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'sigspace', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2291} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':s'} = sub { term28($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{':sigspace'} = sub { term28($_[1], $_[0], $_[2], $_[3]) }; 

# token term30
*term30 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 13701 13775
           (
      
             ## <group>
             ## pos: 13701 13707
              (   ( $pad{I2292} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 13701 13706
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I2292} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13707 13722
              (   ( $pad{I2293} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 13707 13713
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2293} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13722 13775
              (   ( $pad{I2294} = $pos or 1 ) &&
               ## <closure>
               ## pos: 13722 13774
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'Perl5', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2294} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':P5'} = sub { term30($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{':Perl5'} = sub { term30($_[1], $_[0], $_[2], $_[3]) }; 

# token term32
*term32 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14048 14122
           (
      
             ## <group>
             ## pos: 14048 14054
              (   ( $pad{I2295} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14048 14053
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I2295} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14054 14069
              (   ( $pad{I2296} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14054 14060
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2296} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14069 14122
              (   ( $pad{I2297} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14069 14121
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'bytes', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2297} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':bytes'} = sub { term32($_[1], $_[0], $_[2], $_[3]) }; 

# token term33
*term33 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14223 14297
           (
      
             ## <group>
             ## pos: 14223 14229
              (   ( $pad{I2298} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14223 14228
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I2298} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14229 14244
              (   ( $pad{I2299} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14229 14235
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2299} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14244 14297
              (   ( $pad{I2300} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14244 14296
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'codes', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2300} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':codes'} = sub { term33($_[1], $_[0], $_[2], $_[3]) }; 

# token term34
*term34 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14398 14473
           (
      
             ## <group>
             ## pos: 14398 14404
              (   ( $pad{I2301} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14398 14403
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I2301} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14404 14419
              (   ( $pad{I2302} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14404 14410
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2302} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14419 14473
              (   ( $pad{I2303} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14419 14472
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'graphs', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2303} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':graphs'} = sub { term34($_[1], $_[0], $_[2], $_[3]) }; 

# token term35
*term35 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14575 14650
           (
      
             ## <group>
             ## pos: 14575 14581
              (   ( $pad{I2304} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14575 14580
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I2304} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14581 14596
              (   ( $pad{I2305} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14581 14587
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2305} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14596 14650
              (   ( $pad{I2306} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14596 14649
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'langs',  rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2306} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':langs'} = sub { term35($_[1], $_[0], $_[2], $_[3]) }; 

# token term
*term =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 14745 15547
           (
               ( $pad{I2307} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 14746 15224
               (
      
                 ## <group>
                 ## pos: 14746 14789
                  (   ( $pad{I2308} = $pos or 1 ) &&
                  ## <metasyntax>
                   ## pos: 14748 14781
                   do{
                    my $match = 
              ## <variable>
              ## pos: 14748 14781
              do {
                our $I2309;
                our $I2309_sizes;
                unless ( $I2309 ) {
                    my $hash = \%Pugs::Grammar::Rule::variables;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I2309_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I2309 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I2309_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I2309->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I2309, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { $named{'Pugs::Grammar::Rule::variables'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                  ## </metasyntax>
     ||    ( ( $pos = $pad{I2308} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 14789 15224
                  (   ( $pad{I2310} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 14790 15218
                   (
                       ( $pad{I2311} = $pos or 1 )
                       && (
                       ## <concat>
                       ## pos: 14790 15131
                       (
                         ## <quant>
                         ## pos: 14790 14799
                         (
                          (   ( $pad{I2312} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 14792 14797
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I2312} ) && 0 ) )
                         || ( $bool = 1 )
                         )
                         ## </quant>
    
                       &&
      
                         ## <group>
                         ## pos: 14799 14804
                          (   ( $pad{I2313} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 14799 14803
                           ( ( substr( $s, $pos, 2 ) eq ':=' )
                               ? ( $pos += 2 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I2313} ) && 0 ) )
                         ## </group>
    
                       &&
                         ## <quant>
                         ## pos: 14804 14811
                         (
                          (   ( $pad{I2314} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 14804 14809
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I2314} ) && 0 ) )
                         || ( $bool = 1 )
                         )
                         ## </quant>
    
                       &&
      
                         ## <group>
                         ## pos: 14811 14842
                          (   ( $pad{I2315} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 14811 14831
                           do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                       $grammar->named_capture_body( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'named_capture_body'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                           ## </named_capture>
     ||    ( ( $pos = $pad{I2315} ) && 0 ) )
                         ## </group>
    
                       &&
      
                         ## <group>
                         ## pos: 14842 15131
                          (   ( $pad{I2316} = $pos or 1 ) &&
                           ## <closure>
                           ## pos: 14842 15123
                           do {
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub {
                return { named_capture => {
                            rule =>  ${ $_[0]->{qw(named_capture_body)} },
                            ident => ${ $_[0]->{qw(Pugs::Grammar::Rule::variables)} },
                         },
                            _pos => [ $_[0]->from, $_[0]->to ],
                         };
              }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           }
                           ## </closure>
     ||    ( ( $pos = $pad{I2316} ) && 0 ) )
                         ## </group>
    
                       )
                       ## </concat>
    
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2311} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 15132 15218
                        (   ( $pad{I2317} = $pos or 1 ) &&
                         ## <closure>
                         ## pos: 15143 15210
                         do {
                           local $::_V6_SUCCEED = 1;
                           $::_V6_MATCH_ = $m;
                           $m->data->{capture} = \( sub {
                return ${ $_[0]->{qw(Pugs::Grammar::Rule::variables)} }
              }->( $m ) ); 
                           $bool = $::_V6_SUCCEED;
                           $::_V6_MATCH_ = $m if $bool; 
                           return $m if $bool; 
                         }
                         ## </closure>
     ||    ( ( $pos = $pad{I2317} ) && 0 ) )
                       ## </group>
    
                     )
                   )
                   ## </alt>
     ||    ( ( $pos = $pad{I2310} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2307} ) or 1 )
               &&            ## <concat>
               ## pos: 15225 15393
               (
      
                 ## <group>
                 ## pos: 15225 15270
                  (   ( $pad{I2318} = $pos or 1 ) &&
                  ## <metasyntax>
                   ## pos: 15227 15261
                   do{
                    my $match = 
              ## <variable>
              ## pos: 15227 15261
              do {
                our $I2319;
                our $I2319_sizes;
                unless ( $I2319 ) {
                    my $hash = \%Pugs::Grammar::Rule::rule_terms;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I2319_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I2319 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I2319_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I2319->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I2319, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                  ## </metasyntax>
     ||    ( ( $pos = $pad{I2318} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15270 15393
                  (   ( $pad{I2320} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 15270 15388
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub {
                #print "term: ", Dumper( $_[0]->data );
                return ${ $_[0]->{qw(Pugs::Grammar::Rule::rule_terms)} }
            }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2320} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2307} ) or 1 )
               &&            ## <concat>
               ## pos: 15394 15547
               (
      
                 ## <group>
                 ## pos: 15394 15441
                  (   ( $pad{I2321} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:(?![\]\}\)\>\:\?\+\*\|\&]))\X)/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I2321} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15441 15547
                  (   ( $pad{I2322} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 15441 15546
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub {
                return { 'constant' => ${$_[0]},
                         _pos => [ $_[0]->from, $_[0]->to ] }
            }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2322} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token quant
*quant =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 15568 15682
           (
               ( $pad{I2323} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 15569 15660
               (
      
                 ## <group>
                 ## pos: 15569 15577
                  (   ( $pad{I2324} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 15572 15576
                   ( ( substr( $s, $pos, 2 ) eq '**' )
                       ? ( $pos += 2 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2324} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 15577 15584
                 (
                  (   ( $pad{I2325} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 15577 15582
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I2325} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 15584 15588
                  (   ( $pad{I2326} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 15584 15586
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2326} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15588 15603
                  (   ( $pad{I2327} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 15588 15601
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I2327} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15603 15614
                  (   ( $pad{I2328} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 15603 15605
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I2328} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15614 15660
                  (   ( $pad{I2329} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 15614 15655
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { closure => ${ $_[0]->{qw(parsed_code)} } } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2329} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2323} ) or 1 )
               &&            ## <quant>
               ## pos: 15661 15682
               (
                (   ( $pad{I2330} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\*\+]))\X)/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I2330} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token quantifier
*quantifier =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 15708 16474
           (
      
             ## <group>
             ## pos: 15708 15733
              (   ( $pad{I2331} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15708 15728
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15721 15727
                               (
                                (   ( $pad{I2332} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 15721 15726
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
     ||    ( ( $pos = $pad{I2332} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'ws1'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2331} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15733 15768
              (   ( $pad{I2333} = $pos or 1 ) &&
               ## <negate>
               ## pos: 15733 15763
               do{
                   my $pos1 = $pos;
                   do {
                     my $pos = $pos1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 
                         ## <before>
                         ## pos: 15743 15762
                         do{
                             my $pos1 = $pos;
                             do {
                               my $pos = $pos1;
                               my $from = $pos;
                               my @match;
                               my %named;
                               $bool = 0 unless
      
                                   ## <group>
                                   ## pos: 15743 15762
                                    (   ( $pad{I2334} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?:(?=[\}\]\)]))\X)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
     ||    ( ( $pos = $pad{I2334} ) && 0 ) )
                                   ## </group>
    ;
                               $bool;
                             };
                         }
                         ## </before>
     ? 0 : 1;
                     $bool;
                   };
               }
               ## </negate>
     ||    ( ( $pos = $pad{I2333} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15768 15779
              (   ( $pad{I2335} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15768 15774
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->term( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'term'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2335} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15779 15804
              (   ( $pad{I2336} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15779 15799
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15792 15798
                               (
                                (   ( $pad{I2337} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 15792 15797
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
     ||    ( ( $pos = $pad{I2337} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'ws2'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2336} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15804 15816
              (   ( $pad{I2338} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15804 15811
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->quant( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'quant'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2338} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15816 15850
              (   ( $pad{I2339} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15816 15845
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15830 15844
                               (
                                (   ( $pad{I2340} = $pos or 1 ) &&
                                   ## <perl5>
                                   ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\+]))\X)/ )
                                       ? ( $pos += length( $1 ) or 1 )
                                       : 0
                                   )
                                   ## </perl5>
     ||    ( ( $pos = $pad{I2340} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'greedy'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2339} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15850 15875
              (   ( $pad{I2341} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15850 15870
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15863 15869
                               (
                                (   ( $pad{I2342} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 15863 15868
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
     ||    ( ( $pos = $pad{I2342} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'ws3'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2341} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15875 16474
              (   ( $pad{I2343} = $pos or 1 ) &&
               ## <closure>
               ## pos: 15875 16473
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
          if (
                   ${$_[0]->{'quant'}}  eq ''
                && ${$_[0]->{'greedy'}} eq ''
                && ${$_[0]->{'ws1'}}    eq ''
                && ${$_[0]->{'ws2'}}    eq ''
                && ${$_[0]->{'ws3'}}    eq ''
          ) {
              return ${$_[0]->{'term'}};
          }
          return {
            quant => {
                    term    => ${$_[0]->{'term'}},
                    quant   => ${$_[0]->{'quant'}},
                    greedy  => ${$_[0]->{'greedy'}},
                    ws1     => ${$_[0]->{'ws1'}},
                    ws2     => ${$_[0]->{'ws2'}},
                    ws3     => ${$_[0]->{'ws3'}},
                },
            _pos => [$_[0]->from, $_[0]->to],
          }
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2343} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token concat
*concat =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 16496 16705
           (
             ## <quant>
             ## pos: 16496 16514
             (
              (   ( $pad{I2344} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 16496 16508
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'quantifier'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I2344} ) && 0 ) )
             && do { while (
              (   ( $pad{I2344} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 16496 16508
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'quantifier'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I2344} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 16514 16705
              (   ( $pad{I2345} = $pos or 1 ) &&
               ## <closure>
               ## pos: 16514 16704
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $_->()  }  @{ $::_V6_MATCH_->{'quantifier'} };
            return { concat => \@a, _pos => [$_[0]->from, $_[0]->to] }
                if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2345} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token conjunctive1
*conjunctive1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 16733 17013
           (
             ## <quant>
             ## pos: 16733 16767
             (
              (   ( $pad{I2346} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 16734 16759
                 (
                   ## <quant>
                   ## pos: 16734 16742
                   (
                    (   ( $pad{I2347} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 16735 16740
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2347} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 16742 16745
                    (   ( $pad{I2348} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 16742 16744
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2348} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 16745 16759
                    (   ( $pad{I2349} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 16745 16758
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 16754 16757
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 16754 16757
                                          (   ( $pad{I2350} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 16754 16756
                                           ( ( substr( $s, $pos, 1 ) eq '&' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I2350} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I2349} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I2346} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 16767 16785
             (
              (   ( $pad{I2351} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 16767 16775
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'concat'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I2351} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 16785 16834
             do { while (
              (   ( $pad{I2352} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 16786 16826
                 (
      
                   ## <group>
                   ## pos: 16786 16798
                    (   ( $pad{I2353} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 16795 16797
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2353} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 16798 16813
                    (   ( $pad{I2354} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 16798 16811
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 16807 16810
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 16807 16810
                                          (   ( $pad{I2355} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 16807 16809
                                           ( ( substr( $s, $pos, 1 ) eq '&' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I2355} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I2354} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 16813 16826
                    (   ( $pad{I2356} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 16813 16821
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'concat'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I2356} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I2352} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 16834 17013
              (   ( $pad{I2357} = $pos or 1 ) &&
               ## <closure>
               ## pos: 16834 17012
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'concat'} };
            return { conjunctive1 => \@a, _pos => [$_[0]->from, $_[0]->to] }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2357} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token disjunctive1
*disjunctive1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17041 17330
           (
             ## <quant>
             ## pos: 17041 17075
             (
              (   ( $pad{I2358} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17042 17067
                 (
                   ## <quant>
                   ## pos: 17042 17050
                   (
                    (   ( $pad{I2359} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 17043 17048
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2359} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 17050 17053
                    (   ( $pad{I2360} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17050 17052
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2360} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17053 17067
                    (   ( $pad{I2361} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 17053 17066
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 17062 17065
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 17062 17065
                                          (   ( $pad{I2362} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 17062 17064
                                           ( ( substr( $s, $pos, 1 ) eq '|' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I2362} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I2361} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I2358} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17075 17099
             (
              (   ( $pad{I2363} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 17075 17089
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I2363} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17099 17153
             do { while (
              (   ( $pad{I2364} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17100 17145
                 (
      
                   ## <group>
                   ## pos: 17100 17112
                    (   ( $pad{I2365} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17109 17111
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2365} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17112 17126
                    (   ( $pad{I2366} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 17112 17125
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 17121 17124
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 17121 17124
                                          (   ( $pad{I2367} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 17121 17123
                                           ( ( substr( $s, $pos, 1 ) eq '|' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I2367} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I2366} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17126 17145
                    (   ( $pad{I2368} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 17126 17140
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I2368} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I2364} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17153 17330
              (   ( $pad{I2369} = $pos or 1 ) &&
               ## <closure>
               ## pos: 17153 17329
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive1'} };
            return { alt1 => \@a, _pos => [$_[0]->from, $_[0]->to] }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2369} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token conjunctive
*conjunctive =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17357 17631
           (
             ## <quant>
             ## pos: 17357 17380
             (
              (   ( $pad{I2370} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17358 17372
                 (
                   ## <quant>
                   ## pos: 17358 17366
                   (
                    (   ( $pad{I2371} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 17359 17364
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2371} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 17366 17369
                    (   ( $pad{I2372} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17366 17368
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2372} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17369 17372
                    (   ( $pad{I2373} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17369 17371
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2373} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I2370} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17380 17404
             (
              (   ( $pad{I2374} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 17380 17394
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I2374} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17404 17447
             do { while (
              (   ( $pad{I2375} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17405 17439
                 (
      
                   ## <group>
                   ## pos: 17405 17417
                    (   ( $pad{I2376} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17414 17416
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2376} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17417 17420
                    (   ( $pad{I2377} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17417 17419
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2377} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17420 17439
                    (   ( $pad{I2378} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 17420 17434
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I2378} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I2375} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17447 17631
              (   ( $pad{I2379} = $pos or 1 ) &&
               ## <closure>
               ## pos: 17447 17630
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'disjunctive1'} };
            return { conjunctive => \@a, _pos => [$_[0]->from, $_[0]->to] }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2379} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token rule
*rule =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17651 17915
           (
             ## <quant>
             ## pos: 17651 17674
             (
              (   ( $pad{I2380} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17652 17666
                 (
                   ## <quant>
                   ## pos: 17652 17660
                   (
                    (   ( $pad{I2381} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 17653 17658
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2381} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 17660 17663
                    (   ( $pad{I2382} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17660 17662
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2382} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17663 17666
                    (   ( $pad{I2383} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17663 17665
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2383} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I2380} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17674 17697
             (
              (   ( $pad{I2384} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 17674 17687
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I2384} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17697 17739
             do { while (
              (   ( $pad{I2385} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17698 17731
                 (
      
                   ## <group>
                   ## pos: 17698 17710
                    (   ( $pad{I2386} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17707 17709
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2386} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17710 17713
                    (   ( $pad{I2387} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17710 17712
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I2387} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17713 17731
                    (   ( $pad{I2388} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 17713 17726
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I2388} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I2385} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17739 17915
              (   ( $pad{I2389} = $pos or 1 ) &&
               ## <closure>
               ## pos: 17739 17914
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive'} };
            return { alt => \@a, _pos => [$_[0]->from, $_[0]->to], }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2389} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token named_regex
*named_regex =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17942 18162
           (
      
             ## <group>
             ## pos: 17942 17977
              (   ( $pad{I2390} = $pos or 1 ) &&
    
               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       ## pos: 17943 17971
                       (
                           ( $pad{I2391} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 17943 17952
                            (   ( $pad{I2392} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 17944 17951
                             ( ( substr( $s, $pos, 5 ) eq 'token' )
                                 ? ( $pos += 5 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2392} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2391} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 17953 17962
                            (   ( $pad{I2393} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 17954 17961
                             ( ( substr( $s, $pos, 5 ) eq 'regex' )
                                 ? ( $pos += 5 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2393} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2391} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 17963 17971
                            (   ( $pad{I2394} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 17964 17970
                             ( ( substr( $s, $pos, 4 ) eq 'rule' )
                                 ? ( $pos += 4 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I2394} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
    ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
     ||    ( ( $pos = $pad{I2390} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 17977 17983
              (   ( $pad{I2395} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 17977 17982
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I2395} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 17983 17991
              (   ( $pad{I2396} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 17983 17990
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2396} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 17991 17998
             (
              (   ( $pad{I2397} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 17991 17996
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I2397} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17998 18010
              (   ( $pad{I2398} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 17998 18001
               ( ( substr( $s, $pos, 1 ) eq '{' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2398} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 18010 18025
             (
              (   ( $pad{I2399} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 18010 18015
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I2399} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18025 18036
              (   ( $pad{I2400} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 18025 18031
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2400} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18036 18040
              (   ( $pad{I2401} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18036 18039
               ( ( substr( $s, $pos, 1 ) eq '}' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2401} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 18040 18050
             (
              (   ( $pad{I2402} = $pos or 1 ) &&
    
                 ## <constant>
                 ## pos: 18040 18043
                 ( ( substr( $s, $pos, 1 ) eq ';' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
     ||    ( ( $pos = $pad{I2402} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18050 18162
              (   ( $pad{I2403} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18050 18161
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                type => ${ $_[0]->[0] },
                name => ${ $_[0]->{qw(ident)} },
                ast => ${ $_[0]->{qw(rule)} }
            };
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2403} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token verbatim
*verbatim =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 18224 18346
           (
      
             ## <group>
             ## pos: 18224 18229
              (   ( $pad{I2404} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18224 18228
               ( ( substr( $s, $pos, 2 ) eq '%{' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2404} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18229 18255
              (   ( $pad{I2405} = $pos or 1 ) &&
    
               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <quant>
                       ## pos: 18230 18253
                       do { while (
                        (   ( $pad{I2406} = $pos or 1 ) &&
                           ## <concat>
                           ## pos: 18232 18250
                           (
      
                             ## <group>
                             ## pos: 18232 18248
                              (   ( $pad{I2407} = $pos or 1 ) &&
                               ## <negate>
                               ## pos: 18233 18247
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 
                                         ## <before>
                                         ## pos: 18242 18246
                                         do{
                                             my $pos1 = $pos;
                                             do {
                                               my $pos = $pos1;
                                               my $from = $pos;
                                               my @match;
                                               my %named;
                                               $bool = 0 unless
    
                                                   ## <constant>
                                                   ## pos: 18242 18246
                                                   ( ( substr( $s, $pos, 2 ) eq '%}' )
                                                       ? ( $pos += 2 or 1 )
                                                       : 0
                                                   )
                                                   ## </constant>
    ;
                                               $bool;
                                             };
                                         }
                                         ## </before>
     ? 0 : 1;
                                     $bool;
                                   };
                               }
                               ## </negate>
     ||    ( ( $pos = $pad{I2407} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 18248 18250
                              (   ( $pad{I2408} = $pos or 1 ) &&
    
                               ## <dot>
                               ## pos: 18248 18249
                               ( substr( $s, $pos++, 1 ) ne '' )
                               ## </dot>
     ||    ( ( $pos = $pad{I2408} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
     ||    ( ( $pos = $pad{I2406} ) && 0 ) )) {}; $bool = 1 }
                       ## </quant>
    ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
     ||    ( ( $pos = $pad{I2405} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18255 18264
              (   ( $pad{I2409} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18255 18259
               ( ( substr( $s, $pos, 2 ) eq '%}' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2409} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18264 18346
              (   ( $pad{I2410} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18264 18345
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                type => 'block',
                value => ${ $_[0]->[0] }
            };
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2410} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token item
*item =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 18366 18458
           (
               ( $pad{I2411} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 18367 18414
               (
      
                 ## <group>
                 ## pos: 18367 18385
                  (   ( $pad{I2412} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 18368 18378
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->verbatim( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'verbatim'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I2412} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 18385 18414
                  (   ( $pad{I2413} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 18385 18409
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(verbatim)} }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2413} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2411} ) or 1 )
               &&            ## <concat>
               ## pos: 18415 18458
               (
      
                 ## <group>
                 ## pos: 18415 18430
                  (   ( $pad{I2414} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 18416 18429
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->named_regex( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'named_regex'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I2414} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 18430 18458
                  (   ( $pad{I2415} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 18430 18457
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(named_regex)} }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I2415} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token grammar
*grammar =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 18481 18597
           (
             ## <quant>
             ## pos: 18481 18488
             (
              (   ( $pad{I2416} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 18481 18486
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I2416} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18488 18498
              (   ( $pad{I2417} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18488 18497
               ( ( substr( $s, $pos, 7 ) eq 'grammar' )
                   ? ( $pos += 7 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2417} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18498 18504
              (   ( $pad{I2418} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 18498 18503
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I2418} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18504 18512
              (   ( $pad{I2419} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 18504 18511
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I2419} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 18512 18519
             (
              (   ( $pad{I2420} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 18512 18517
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I2420} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18519 18527
              (   ( $pad{I2421} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18519 18522
               ( ( substr( $s, $pos, 1 ) eq ';' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I2421} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 18527 18538
             (
              (   ( $pad{I2422} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 18527 18532
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I2422} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 18538 18561
             do { while (
              (   ( $pad{I2423} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 18539 18554
                 (
      
                   ## <group>
                   ## pos: 18539 18547
                    (   ( $pad{I2424} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 18540 18546
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->item( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'item'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I2424} ) && 0 ) )
                   ## </group>
    
                 &&
                   ## <quant>
                   ## pos: 18547 18554
                   (
                    (   ( $pad{I2425} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 18547 18552
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2425} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I2423} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18561 18597
              (   ( $pad{I2426} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18561 18596
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { ${ $_[0]->{qw(ident)} } => $_[0]->{qw(item)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2426} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token spec
*spec =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 18617 18737
           (
             ## <quant>
             ## pos: 18617 18633
             (
              (   ( $pad{I2427} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 18617 18627
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->verbatim( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'verbatim'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I2427} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 18633 18648
             do { while (
              (   ( $pad{I2428} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 18633 18642
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->grammar( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'grammar'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I2428} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18648 18737
              (   ( $pad{I2429} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18648 18736
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                block => $_[0]->{qw(verbatim)},
                'grammar' => $_[0]->{qw(grammar)} }
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2429} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;



1;
