        package Pugs::Grammar::Rule;
        use utf8;
        no strict 'refs';
        use Pugs::Runtime::Match;
        use Pugs::Runtime::Regex;
        our %rule_terms;
        our %variables;
*pod_begin = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1692} = $pos or 1 ) 
           && (
           (
               ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )  
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
           &&
               ( ( substr( $s, $pos, 1 ) eq '=' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               ( ( substr( $s, $pos, 1 ) eq 'n' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
             do { while (
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )) {}; $bool = 1 }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1692} ) or 1 ) 
           &&            (
               ( substr( $s, $pos++, 1 ) ne '' )
           &&
             do { while (
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )) {}; $bool = 1 }
           &&
               do { 
                    my $prior = $::_V6_PRIOR_; 
                    my $match = 
                           $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                    $::_V6_PRIOR_ = $prior; 
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for pod_begin
 #(\&pod_begin, );
;
*pod_other = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1693} = $pos or 1 ) 
           && (
           (
               ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )  
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
           &&
               ( ( substr( $s, $pos, 1 ) eq '=' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               ( ( substr( $s, $pos, 1 ) eq 'c' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               ( ( substr( $s, $pos, 1 ) eq 'u' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               ( ( substr( $s, $pos, 1 ) eq 't' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
             do { while (
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )) {}; $bool = 1 }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1693} ) or 1 ) 
           &&            (
               ( substr( $s, $pos++, 1 ) ne '' )
           &&
             do { while (
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )) {}; $bool = 1 }
           &&
               do { 
                    my $prior = $::_V6_PRIOR_; 
                    my $match = 
                           $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                    $::_V6_PRIOR_ = $prior; 
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for pod_other
 #(\&pod_other, );
;
*ws = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           (
               ( $pad{I1694} = $pos or 1 ) 
               && (
               (
                   ( ( substr( $s, $pos, 1 ) eq '#' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               &&
                 do { while (
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )) {}; $bool = 1 }
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1694} ) or 1 ) 
               &&                (
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )  
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
               &&
                 (
                     (
                         ( ( substr( $s, $pos, 1 ) eq '=' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     &&
                       (
                           (
                               ( $pad{I1695} = $pos or 1 ) 
                               && (
                               (
                                   ( ( substr( $s, $pos, 1 ) eq 'b' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'g' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'n' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->ws( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'E' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'N' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'D' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                 do { while (
                                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )) {}; $bool = 1 }
                               &&
                                 do { while (
                                     ( substr( $s, $pos++, 1 ) ne '' )) {}; $bool = 1 }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1695} ) or 1 ) 
                               &&                                (
                                   ( ( substr( $s, $pos, 1 ) eq 'b' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'g' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'n' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1695} ) or 1 ) 
                               &&                                (
                                   ( ( substr( $s, $pos, 1 ) eq 'k' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'w' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1695} ) or 1 ) 
                               &&                                (
                                   ( ( substr( $s, $pos, 1 ) eq 'p' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1695} ) or 1 ) 
                               &&                                (
                                   ( ( substr( $s, $pos, 1 ) eq 'f' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'r' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1695} ) or 1 ) 
                               &&                                (
                                   ( ( substr( $s, $pos, 1 ) eq 'h' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'a' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq '1' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               )
                             )
                           )
                       || ( $bool = 1 )
                       ) 
                     )
                 || ( $bool = 1 )
                 ) 
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1694} ) or 1 ) 
               &&                  ( ( substr( $s, $pos ) =~ m/^(\s)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
             )
           )
       && do { while (
           (
               ( $pad{I1694} = $pos or 1 ) 
               && (
               (
                   ( ( substr( $s, $pos, 1 ) eq '#' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               &&
                 do { while (
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )) {}; $bool = 1 }
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1694} ) or 1 ) 
               &&                (
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )  
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
               &&
                 (
                     (
                         ( ( substr( $s, $pos, 1 ) eq '=' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     &&
                       (
                           (
                               ( $pad{I1695} = $pos or 1 ) 
                               && (
                               (
                                   ( ( substr( $s, $pos, 1 ) eq 'b' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'g' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'n' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->ws( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'E' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'N' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'D' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                 do { while (
                                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )  
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )) {}; $bool = 1 }
                               &&
                                 do { while (
                                     ( substr( $s, $pos++, 1 ) ne '' )) {}; $bool = 1 }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1695} ) or 1 ) 
                               &&                                (
                                   ( ( substr( $s, $pos, 1 ) eq 'b' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'g' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'n' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1695} ) or 1 ) 
                               &&                                (
                                   ( ( substr( $s, $pos, 1 ) eq 'k' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'w' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'i' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1695} ) or 1 ) 
                               &&                                (
                                   ( ( substr( $s, $pos, 1 ) eq 'p' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1695} ) or 1 ) 
                               &&                                (
                                   ( ( substr( $s, $pos, 1 ) eq 'f' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'r' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1695} ) or 1 ) 
                               &&                                (
                                   ( ( substr( $s, $pos, 1 ) eq 'h' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'e' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'a' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq 'd' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   ( ( substr( $s, $pos, 1 ) eq '1' ) 
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                               &&
                                   do { 
                                        my $prior = $::_V6_PRIOR_; 
                                        my $match = 
                                               $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                        $::_V6_PRIOR_ = $prior; 
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                               )
                             )
                           )
                       || ( $bool = 1 )
                       ) 
                     )
                 || ( $bool = 1 )
                 ) 
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1694} ) or 1 ) 
               &&                  ( ( substr( $s, $pos ) =~ m/^(\s)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
             )
           )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for ws
 #(\&ws, );
;
*ident = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           (
               ( $pad{I1696} = $pos or 1 ) 
               && (
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1696} ) or 1 ) 
               &&                  ( ( substr( $s, $pos, 1 ) eq '_' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1696} ) or 1 ) 
               &&                  ( ( substr( $s, $pos, 2 ) eq '::' ) 
                     ? ( $pos += 2 or 1 )
                     : 0
                 )
             )
           )
       && do { while (
           (
               ( $pad{I1696} = $pos or 1 ) 
               && (
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1696} ) or 1 ) 
               &&                  ( ( substr( $s, $pos, 1 ) eq '_' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1696} ) or 1 ) 
               &&                  ( ( substr( $s, $pos, 2 ) eq '::' ) 
                     ? ( $pos += 2 or 1 )
                     : 0
                 )
             )
           )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for ident
 #(\&ident, );
;
*special_char = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1697} = $pos or 1 ) 
           && (
           (
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                           ( $pad{I1698} = $pos or 1 ) 
                           && (
                             ( ( substr( $s, $pos, 1 ) eq 'c' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                           ) 
                         || ( 
                           ( ( $bool = 1 ) && ( $pos = $pad{I1698} ) or 1 ) 
                           &&                              ( ( substr( $s, $pos, 1 ) eq 'C' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                         )
                       );
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
           &&
               ( ( substr( $s, $pos, 1 ) eq '[' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                           (
                               ( $pad{I1699} = $pos or 1 ) 
                               && (
                                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                             $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'alnum'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1699} ) or 1 ) 
                               &&                                  ( ( substr( $s, $pos ) =~ m/^(\s)/ )  
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1699} ) or 1 ) 
                               &&                                  ( ( substr( $s, $pos, 1 ) eq ';' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1699} ) or 1 ) 
                               &&                                  ( ( substr( $s, $pos, 1 ) eq '(' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1699} ) or 1 ) 
                               &&                                  ( ( substr( $s, $pos, 1 ) eq ')' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1699} ) or 1 ) 
                               &&                                  ( ( substr( $s, $pos, 1 ) eq '-' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                             )
                           )
                       && do { while (
                           (
                               ( $pad{I1699} = $pos or 1 ) 
                               && (
                                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                             $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'alnum'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1699} ) or 1 ) 
                               &&                                  ( ( substr( $s, $pos ) =~ m/^(\s)/ )  
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1699} ) or 1 ) 
                               &&                                  ( ( substr( $s, $pos, 1 ) eq ';' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1699} ) or 1 ) 
                               &&                                  ( ( substr( $s, $pos, 1 ) eq '(' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1699} ) or 1 ) 
                               &&                                  ( ( substr( $s, $pos, 1 ) eq ')' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                               ) 
                             || ( 
                               ( ( $bool = 1 ) && ( $pos = $pad{I1699} ) or 1 ) 
                               &&                                  ( ( substr( $s, $pos, 1 ) eq '-' ) 
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                             )
                           )) {}; $bool = 1 }
                       ) ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
           &&
               ( ( substr( $s, $pos, 1 ) eq ']' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1697} ) or 1 ) 
           &&            (
               (
                   ( $pad{I1700} = $pos or 1 ) 
                   && (
                     ( ( substr( $s, $pos, 1 ) eq 'x' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                   ) 
                 || ( 
                   ( ( $bool = 1 ) && ( $pos = $pad{I1700} ) or 1 ) 
                   &&                      ( ( substr( $s, $pos, 1 ) eq 'X' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 )
               )
           &&
             (
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->xdigit( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
             && do { while (
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->xdigit( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }) {}; $bool = 1 }
             ) 
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1697} ) or 1 ) 
           &&            (
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                           ( $pad{I1701} = $pos or 1 ) 
                           && (
                             ( ( substr( $s, $pos, 1 ) eq 'x' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                           ) 
                         || ( 
                           ( ( $bool = 1 ) && ( $pos = $pad{I1701} ) or 1 ) 
                           &&                              ( ( substr( $s, $pos, 1 ) eq 'X' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                         )
                       );
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
           &&
               ( ( substr( $s, $pos, 1 ) eq '[' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                       $grammar->xdigit( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                       && do { while (
                           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                       $grammar->xdigit( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }) {}; $bool = 1 }
                       ) ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
           &&
               ( ( substr( $s, $pos, 1 ) eq ']' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1697} ) or 1 ) 
           &&            (
               (
                   ( $pad{I1702} = $pos or 1 ) 
                   && (
                     ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                   ) 
                 || ( 
                   ( ( $bool = 1 ) && ( $pos = $pad{I1702} ) or 1 ) 
                   &&                      ( ( substr( $s, $pos, 1 ) eq 'O' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 )
               )
           &&
             (
                 ( ( substr( $s, $pos ) =~ m/^(\d)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
             && do { while (
                 ( ( substr( $s, $pos ) =~ m/^(\d)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )) {}; $bool = 1 }
             ) 
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1697} ) or 1 ) 
           &&            (
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                           ( $pad{I1703} = $pos or 1 ) 
                           && (
                             ( ( substr( $s, $pos, 1 ) eq 'o' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                           ) 
                         || ( 
                           ( ( $bool = 1 ) && ( $pos = $pad{I1703} ) or 1 ) 
                           &&                              ( ( substr( $s, $pos, 1 ) eq 'O' ) 
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                         )
                       );
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
           &&
               ( ( substr( $s, $pos, 1 ) eq '[' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               do{ 
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       (
                           ( ( substr( $s, $pos ) =~ m/^(\d)/ )  
                               ? ( $pos += length( $1 ) or 1 )
                               : 0
                           )
                       && do { while (
                           ( ( substr( $s, $pos ) =~ m/^(\d)/ )  
                               ? ( $pos += length( $1 ) or 1 )
                               : 0
                           )) {}; $bool = 1 }
                       ) ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
           &&
               ( ( substr( $s, $pos, 1 ) eq ']' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1697} ) or 1 ) 
           &&            (
               ( substr( $s, $pos++, 1 ) ne '' )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for special_char
 #(\&special_char, );
;
*literal = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       do { while (
           (
               ( $pad{I1704} = $pos or 1 ) 
               && (
               (
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               &&
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1704} ) or 1 ) 
               &&                  ( ( substr( $s, $pos ) =~ m/^((?:(?![\']))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
             )
           )) {}; $bool = 1 };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for literal
 #(\&literal, );
;
*metasyntax = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
         (
             (
                 ( $pad{I1705} = $pos or 1 ) 
                 && (
                 (
                     ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 &&
                     do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                 $grammar->special_char( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                 )
                 ) 
               || ( 
                 ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 ) 
                 &&                  (
                     ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 &&
                     do { 
                          my $prior = $::_V6_PRIOR_; 
                          my $match = 
                                 $grammar->literal( $s, { p => $pos, args => {} }, undef );
                          $::_V6_PRIOR_ = $prior; 
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                 &&
                     ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 )
                 ) 
               || ( 
                 ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 ) 
                 &&                  (
                     ( ( substr( $s, $pos, 1 ) eq '{' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 &&
                     do { 
                          my $prior = $::_V6_PRIOR_; 
                          my $match = 
                                 $grammar->string_code( $s, { p => $pos, args => {} }, undef );
                          $::_V6_PRIOR_ = $prior; 
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                 &&
                     ( ( substr( $s, $pos, 1 ) eq '}' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 )
                 ) 
               || ( 
                 ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 ) 
                 &&                  (
                     ( ( substr( $s, $pos, 1 ) eq '<' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 &&
                     do { 
                          my $prior = $::_V6_PRIOR_; 
                          my $match = 
                                 $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                          $::_V6_PRIOR_ = $prior; 
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                 &&
                     ( ( substr( $s, $pos, 1 ) eq '>' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 )
                 ) 
               || ( 
                 ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 ) 
                 &&                    ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )  
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
               )
             )
         && do { while (
             (
                 ( $pad{I1705} = $pos or 1 ) 
                 && (
                 (
                     ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 &&
                     do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                 $grammar->special_char( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                 )
                 ) 
               || ( 
                 ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 ) 
                 &&                  (
                     ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 &&
                     do { 
                          my $prior = $::_V6_PRIOR_; 
                          my $match = 
                                 $grammar->literal( $s, { p => $pos, args => {} }, undef );
                          $::_V6_PRIOR_ = $prior; 
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                 &&
                     ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 )
                 ) 
               || ( 
                 ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 ) 
                 &&                  (
                     ( ( substr( $s, $pos, 1 ) eq '{' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 &&
                     do { 
                          my $prior = $::_V6_PRIOR_; 
                          my $match = 
                                 $grammar->string_code( $s, { p => $pos, args => {} }, undef );
                          $::_V6_PRIOR_ = $prior; 
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                 &&
                     ( ( substr( $s, $pos, 1 ) eq '}' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 )
                 ) 
               || ( 
                 ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 ) 
                 &&                  (
                     ( ( substr( $s, $pos, 1 ) eq '<' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 &&
                     do { 
                          my $prior = $::_V6_PRIOR_; 
                          my $match = 
                                 $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                          $::_V6_PRIOR_ = $prior; 
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                 &&
                     ( ( substr( $s, $pos, 1 ) eq '>' ) 
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                 )
                 ) 
               || ( 
                 ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 ) 
                 &&                    ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )  
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
               )
             )) {}; $bool = 1 }
         ) 
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'metasyntax' => ${$::_V6_MATCH_}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for metasyntax
 #(\&metasyntax, );
;
*char_range = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           (
               ( $pad{I1706} = $pos or 1 ) 
               && (
               (
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               &&
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1706} ) or 1 ) 
               &&                  ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
             )
           )
       && do { while (
           (
               ( $pad{I1706} = $pos or 1 ) 
               && (
               (
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               &&
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1706} ) or 1 ) 
               &&                  ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
             )
           )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for char_range
 #(\&char_range, );
;
*char_class = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1707} = $pos or 1 ) 
           && (
           (
               do { 
                    my $prior = $::_V6_PRIOR_; 
                    my $match = 
                           $grammar->alpha( $s, { p => $pos, args => {} }, undef );
                    $::_V6_PRIOR_ = $prior; 
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
           && do { while (
               do { 
                    my $prior = $::_V6_PRIOR_; 
                    my $match = 
                           $grammar->alpha( $s, { p => $pos, args => {} }, undef );
                    $::_V6_PRIOR_ = $prior; 
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }) {}; $bool = 1 }
           ) 
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1707} ) or 1 ) 
           &&            (
               ( ( substr( $s, $pos, 1 ) eq '[' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               do { 
                    my $prior = $::_V6_PRIOR_; 
                    my $match = 
                           $grammar->char_range( $s, { p => $pos, args => {} }, undef );
                    $::_V6_PRIOR_ = $prior; 
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
           &&
               ( ( substr( $s, $pos, 1 ) eq ']' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for char_class
 #(\&char_class, );
;
*string_code = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           (
               ( $pad{I1708} = $pos or 1 ) 
               && (
               (
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               &&
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 ) 
               &&                (
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               &&
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->literal( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
               &&
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 ) 
               &&                (
                   ( ( substr( $s, $pos, 1 ) eq '{' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               &&
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->string_code( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
               &&
                   ( ( substr( $s, $pos, 1 ) eq '}' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 ) 
               &&                  ( ( substr( $s, $pos ) =~ m/^((?:(?![\}]))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
             )
           )
       && do { while (
           (
               ( $pad{I1708} = $pos or 1 ) 
               && (
               (
                   ( ( substr( $s, $pos, 1 ) eq '\\' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               &&
                   do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                               $grammar->special_char( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 ) 
               &&                (
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               &&
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->literal( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
               &&
                   ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 ) 
               &&                (
                   ( ( substr( $s, $pos, 1 ) eq '{' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               &&
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->string_code( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
               &&
                   ( ( substr( $s, $pos, 1 ) eq '}' ) 
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
               )
               ) 
             || ( 
               ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 ) 
               &&                  ( ( substr( $s, $pos ) =~ m/^((?:(?![\}]))\X)/ )  
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
             )
           )) {}; $bool = 1 }
       ) ;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for string_code
 #(\&string_code, );
;
*parsed_code = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->string_code( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return('{' . $::_V6_MATCH_ . '}');
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for parsed_code
 #(\&parsed_code, );
;
*named_capture_body = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1709} = $pos or 1 ) 
           && (
           (
               ( ( substr( $s, $pos, 1 ) eq '(' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
           &&
               ( ( substr( $s, $pos, 1 ) eq ')' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'capturing_group' => ${ $::_V6_MATCH_->{'rule'}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1709} ) or 1 ) 
           &&            (
               ( ( substr( $s, $pos, 1 ) eq '[' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
           &&
               ( ( substr( $s, $pos, 1 ) eq ']' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'rule'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1709} ) or 1 ) 
           &&            (
               ( ( substr( $s, $pos, 1 ) eq '<' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'metasyntax'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
           &&
               ( ( substr( $s, $pos, 1 ) eq '>' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'metasyntax'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1709} ) or 1 ) 
           && do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    sub  { die("invalid alias syntax");
 } ->();
                    $::_V6_SUCCEED;
                }
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for named_capture_body
 #(\&named_capture_body, );
;
%variables = ('$<' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ident( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           ( ( substr( $s, $pos, 1 ) eq '>' ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'match_variable' => '$' .  $::_V6_MATCH_->{'ident'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'$' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1710} = $pos or 1 ) 
           && (
           (
             (
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
             && do { while (
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }) {}; $bool = 1 }
             ) 
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'match_variable' => '$' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1710} ) or 1 ) 
           &&            (
             (
                 ( ( substr( $s, $pos, 1 ) eq '^' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             || ( $bool = 1 )
             ) 
           &&
             (
                 (
                     ( $pad{I1711} = $pos or 1 ) 
                     && (
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1711} ) or 1 ) 
                     &&                        ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1711} ) or 1 ) 
                     &&                      (
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     &&
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     )
                   )
                 )
             && do { while (
                 (
                     ( $pad{I1711} = $pos or 1 ) 
                     && (
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1711} ) or 1 ) 
                     &&                        ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1711} ) or 1 ) 
                     &&                      (
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     &&
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     )
                   )
                 )) {}; $bool = 1 }
             ) 
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'variable' => '$' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'@' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1712} = $pos or 1 ) 
           && (
           (
             (
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
             && do { while (
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }) {}; $bool = 1 }
             ) 
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'match_variable' => '@' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1712} ) or 1 ) 
           &&            (
             (
                 ( ( substr( $s, $pos, 1 ) eq '^' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             || ( $bool = 1 )
             ) 
           &&
             (
                 (
                     ( $pad{I1713} = $pos or 1 ) 
                     && (
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1713} ) or 1 ) 
                     &&                        ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1713} ) or 1 ) 
                     &&                      (
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     &&
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     )
                   )
                 )
             && do { while (
                 (
                     ( $pad{I1713} = $pos or 1 ) 
                     && (
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1713} ) or 1 ) 
                     &&                        ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1713} ) or 1 ) 
                     &&                      (
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     &&
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     )
                   )
                 )) {}; $bool = 1 }
             ) 
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'variable' => '@' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'%' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1714} = $pos or 1 ) 
           && (
           (
             (
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
             && do { while (
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->digit( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }) {}; $bool = 1 }
             ) 
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'match_variable' => '%' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1714} ) or 1 ) 
           &&            (
             (
                 ( ( substr( $s, $pos, 1 ) eq '^' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             || ( $bool = 1 )
             ) 
           &&
             (
                 (
                     ( $pad{I1715} = $pos or 1 ) 
                     && (
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1715} ) or 1 ) 
                     &&                        ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1715} ) or 1 ) 
                     &&                      (
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     &&
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     )
                   )
                 )
             && do { while (
                 (
                     ( $pad{I1715} = $pos or 1 ) 
                     && (
                       do { 
                            my $prior = $::_V6_PRIOR_; 
                            my $match = 
                                   $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                            $::_V6_PRIOR_ = $prior; 
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1715} ) or 1 ) 
                     &&                        ( ( substr( $s, $pos, 1 ) eq '_' ) 
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                     ) 
                   || ( 
                     ( ( $bool = 1 ) && ( $pos = $pad{I1715} ) or 1 ) 
                     &&                      (
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     &&
                         ( ( substr( $s, $pos, 1 ) eq ':' ) 
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                     )
                   )
                 )) {}; $bool = 1 }
             ) 
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'variable' => '%' . $::_V6_MATCH_});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
);
%rule_terms = ('\'' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->literal( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           ( ( substr( $s, $pos, 1 ) eq chr(39) ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'metasyntax' => '\'' . ${$::_V6_MATCH_}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'(' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           ( ( substr( $s, $pos, 1 ) eq ')' ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'capturing_group' => ${ $::_V6_MATCH_->{'rule'}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<(' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           ( ( substr( $s, $pos, 2 ) eq ')>' ) 
               ? ( $pos += 2 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'capture_as_result' => ${ $::_V6_MATCH_->{'rule'}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<after' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           ( ( substr( $s, $pos, 1 ) eq '>' ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'after' => {'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<before' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           ( ( substr( $s, $pos, 1 ) eq '>' ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'before' => {'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<!before' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           ( ( substr( $s, $pos, 1 ) eq '>' ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'not_before' => {'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<!' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1716} = $pos or 1 ) 
           && (
           (
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->char_class( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
           &&
             (
                 do{ 
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         (
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                         &&
                             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                         $grammar->char_class( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                         );
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }
             && do { while (
                 do{ 
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         (
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                         &&
                             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                         $grammar->char_class( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                         );
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }) {}; $bool = 1 }
             ) 
           &&
               ( ( substr( $s, $pos, 1 ) eq '>' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'negate' => {'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1716} ) or 1 ) 
           &&            (
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'metasyntax'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
           &&
               ( ( substr( $s, $pos, 1 ) eq '>' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'negate' => ${ $::_V6_MATCH_->{'metasyntax'}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<+' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->char_class( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
         do { while (
             do{ 
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     (
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                     &&
                         do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                     $grammar->char_class( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                     );
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             }) {}; $bool = 1 }
       &&
           ( ( substr( $s, $pos, 1 ) eq '>' ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<-' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->char_class( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
         do { while (
             do{ 
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     (
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                     &&
                         do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                     $grammar->char_class( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                     );
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             }) {}; $bool = 1 }
       &&
           ( ( substr( $s, $pos, 1 ) eq '>' ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'char_class' => ['-' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<[' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->char_range( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_range'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           ( ( substr( $s, $pos, 1 ) eq ']' ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
         do { while (
             do{ 
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     (
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                     &&
                         do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                     $grammar->char_class( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                     );
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             }) {}; $bool = 1 }
       &&
           ( ( substr( $s, $pos, 1 ) eq '>' ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'char_class' => ['+[' .  $::_V6_MATCH_->{'char_range'} . ']',
@{($::_V6_MATCH_->[0])}]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1717} = $pos or 1 ) 
           && (
           (
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->char_class( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
           &&
             (
                 do{ 
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         (
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                         &&
                             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                         $grammar->char_class( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                         );
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }
             && do { while (
                 do{ 
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         (
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )  
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                         &&
                             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                         $grammar->char_class( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                         );
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }) {}; $bool = 1 }
             ) 
           &&
               ( ( substr( $s, $pos, 1 ) eq '>' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1717} ) or 1 ) 
           &&            (
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'metasyntax'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
           &&
               ( ( substr( $s, $pos, 1 ) eq '>' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'metasyntax'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'{' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->parsed_code( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           ( ( substr( $s, $pos, 1 ) eq '}' ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'\\' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->special_char( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'special_char'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'special_char'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'.' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'dot' => 1});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'[' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           ( ( substr( $s, $pos, 1 ) eq ']' ) 
               ? ( $pos += 1 or 1 )
               : 0
           )
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'rule'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':::' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => ':::'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':?' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => ':?'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':+' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => ':+'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'::' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '::'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => ':'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'$$' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '$$'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'$' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '$'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'^^' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '^^'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'^' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '^'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'>>' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '>>'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '>>'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'<<' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '<<'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
'' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'colon' => '<<'});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                };
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':i' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => {'modifier' => 'ignorecase', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':ignorecase' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => {'modifier' => 'ignorecase', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':s' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'sigspace', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':sigspace' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'sigspace', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':P5' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'Perl5', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':Perl5' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'Perl5', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':bytes' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'bytes', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':codes' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'codes', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':graphs' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'graphs', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
,
':langs' => do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2]; 
              $_[2] = undef;
            
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->ws( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->rule( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'modifier' => 'langs', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
);
*term = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1718} = $pos or 1 ) 
           && (
           (
               do{ 
                my $match = 
          do {
            our $I1719;
            our $I1719_sizes;
            unless ( $I1719 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1719_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1719 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I1719_sizes ) {
                $key = ( $pos <= length( $s ) 
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I1719->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m; 
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I1719, $key )->( $s, $grammar, { p => ( $pos + $_ ), args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          };
                if ( $match ) { $named{'Pugs::Grammar::Rule::variables'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
           &&
               (
                   ( $pad{I1720} = $pos or 1 ) 
                   && (
                   (
                     (
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->ws( $s, { p => $pos, args => {} }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                     || ( $bool = 1 )
                     ) 
                   &&
                       ( ( substr( $s, $pos, 2 ) eq ':=' ) 
                           ? ( $pos += 2 or 1 )
                           : 0
                       )
                   &&
                     (
                         do { 
                              my $prior = $::_V6_PRIOR_; 
                              my $match = 
                                     $grammar->ws( $s, { p => $pos, args => {} }, undef );
                              $::_V6_PRIOR_ = $prior; 
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                     || ( $bool = 1 )
                     ) 
                   &&
                       do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                                   $grammar->named_capture_body( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'named_capture_body'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
                   &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'named_capture' => {'rule' => ${ $::_V6_MATCH_->{'named_capture_body'}}, 'ident' => ${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'}}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
                   )
                   ) 
                 || ( 
                   ( ( $bool = 1 ) && ( $pos = $pad{I1720} ) or 1 ) 
                   && do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
                 )
               )
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1718} ) or 1 ) 
           &&            (
               do{ 
                my $match = 
          do {
            our $I1721;
            our $I1721_sizes;
            unless ( $I1721 ) {
                my $hash = \%Pugs::Grammar::Rule::rule_terms;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1721_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1721 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I1721_sizes ) {
                $key = ( $pos <= length( $s ) 
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I1721->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m; 
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I1721, $key )->( $s, $grammar, { p => ( $pos + $_ ), args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          };
                if ( $match ) { $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return(${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::rule_terms'}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1718} ) or 1 ) 
           &&            (
               ( ( substr( $s, $pos ) =~ m/^((?:(?![\]\}\)\>\:\?\+\*\|\&]))\X)/ )  
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'constant' => ${$::_V6_MATCH_}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for term
 #(\&term, );
;
*quant = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           ( $pad{I1722} = $pos or 1 ) 
           && (
           (
               ( ( substr( $s, $pos, 2 ) eq '**' ) 
                   ? ( $pos += 2 or 1 )
                   : 0
               )
           &&
             (
                 do { 
                      my $prior = $::_V6_PRIOR_; 
                      my $match = 
                             $grammar->ws( $s, { p => $pos, args => {} }, undef );
                      $::_V6_PRIOR_ = $prior; 
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
             || ( $bool = 1 )
             ) 
           &&
               ( ( substr( $s, $pos, 1 ) eq '{' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
               do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                           $grammar->parsed_code( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
           &&
               ( ( substr( $s, $pos, 1 ) eq '}' ) 
                   ? ( $pos += 1 or 1 )
                   : 0
               )
           &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
           )
           ) 
         || ( 
           ( ( $bool = 1 ) && ( $pos = $pad{I1722} ) or 1 ) 
           &&            (
               ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\*\+]))\X)/ )  
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
           || ( $bool = 1 )
           ) 
         )
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for quant
 #(\&quant, );
;
*quantifier = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
           do{ 
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{ 
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                               do { 
                                    my $prior = $::_V6_PRIOR_; 
                                    my $match = 
                                           $grammar->ws( $s, { p => $pos, args => {} }, undef );
                                    $::_V6_PRIOR_ = $prior; 
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws1'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           do{ 
               my $pos1 = $pos;
               do {
                 my $pos = $pos1;
                 my $from = $pos;
                 my @match;
                 my %named;
                 my $bool = 1;
                 $bool = 0 unless
                       ( ( substr( $s, $pos ) =~ m/^((?:(?=[\}\]\)]))\X)/ )  
                           ? ( $pos += length( $1 ) or 1 )
                           : 0
                       );
                 ! $bool;
               };
           }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->term( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'term'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           do{ 
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{ 
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                               do { 
                                    my $prior = $::_V6_PRIOR_; 
                                    my $match = 
                                           $grammar->ws( $s, { p => $pos, args => {} }, undef );
                                    $::_V6_PRIOR_ = $prior; 
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws2'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                       $grammar->quant( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { $named{'quant'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           do{ 
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{ 
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                               ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\+]))\X)/ )  
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'greedy'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
           do{ 
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless                    do{ 
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           (
                               do { 
                                    my $prior = $::_V6_PRIOR_; 
                                    my $match = 
                                           $grammar->ws( $s, { p => $pos, args => {} }, undef );
                                    $::_V6_PRIOR_ = $prior; 
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                           || ( $bool = 1 )
                           ) ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws3'} = $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { return({'quant' => {'term' => ${ $::_V6_MATCH_->{'term'}}, 'quant' => ${ $::_V6_MATCH_->{'quant'}}, 'greedy' => ${ $::_V6_MATCH_->{'greedy'}}, 'ws1' => ${ $::_V6_MATCH_->{'ws1'}}, 'ws2' => ${ $::_V6_MATCH_->{'ws2'}}, 'ws3' => ${ $::_V6_MATCH_->{'ws3'}}}});
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for quantifier
 #(\&quantifier, );
;
*concat = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
         (
             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->quantifier( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'quantifier'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
         && do { while (
             do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->quantifier( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'quantifier'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }) {}; $bool = 1 }
         ) 
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { 
        my @a = map {  $_->()  }  @{ $::_V6_MATCH_->{'quantifier'} };
        return { concat => \@a ,}  if scalar @a > 1;
        return $a[0];;
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for concat
 #(\&concat, );
;
*conjunctive1 = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
         (
             (
               (
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
               || ( $bool = 1 )
               ) 
             &&
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             )
         || ( $bool = 1 )
         ) 
       &&
         (
              do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->concat( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'concat'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
         ) 
       &&
         do { while (
             (
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             &&
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->concat( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'concat'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
             )) {}; $bool = 1 }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'concat'} };
        return { conjunctive1 => \@a ,}  if scalar @a > 1;
        return $a[0];;
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for conjunctive1
 #(\&conjunctive1, );
;
*disjunctive1 = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
         (
             (
               (
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
               || ( $bool = 1 )
               ) 
             &&
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             )
         || ( $bool = 1 )
         ) 
       &&
         (
              do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->conjunctive1( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
         ) 
       &&
         do { while (
             (
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             &&
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->conjunctive1( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
             )) {}; $bool = 1 }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive1'} };
        return { alt1 => \@a ,}  if scalar @a > 1;
        return $a[0];;
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for disjunctive1
 #(\&disjunctive1, );
;
*conjunctive = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
         (
             (
               (
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
               || ( $bool = 1 )
               ) 
             &&
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             &&
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             )
         || ( $bool = 1 )
         ) 
       &&
         (
              do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->disjunctive1( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
         ) 
       &&
         do { while (
             (
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             &&
                 ( ( substr( $s, $pos, 1 ) eq '&' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             &&
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->disjunctive1( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
             )) {}; $bool = 1 }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'disjunctive1'} };
        return { conjunctive => \@a ,}  if scalar @a > 1;
        return $a[0];;
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for conjunctive
 #(\&conjunctive, );
;
*rule = do { my $rule; $rule = sub {
  
              $_[3] = $_[2]; 
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} && ! $_[3]{continue} 
        ? $_[3]{p} 
        : ( ( $_[3]{p} || 0 ) .. length( $s ) ) ) {
    my %index; 
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( { 
      str => \$s, from => \(0+$pos), to => \($pos), 
      bool => \$bool, match => \@match, named => \%named, capture => undef, 
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior; 
      $bool = 0 unless
       (
         (
             (
               (
                   do { 
                        my $prior = $::_V6_PRIOR_; 
                        my $match = 
                               $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        $::_V6_PRIOR_ = $prior; 
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
               || ( $bool = 1 )
               ) 
             &&
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             &&
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             )
         || ( $bool = 1 )
         ) 
       &&
         (
              do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                         $grammar->conjunctive( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'conjunctive'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
         ) 
       &&
         do { while (
             (
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             &&
                 ( ( substr( $s, $pos, 1 ) eq '|' ) 
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
             &&
                 do { 
                my $prior = $::_V6_PRIOR_; 
                my $match = 
                             $grammar->conjunctive( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior; 
                if ( $match ) { push @{$named{'conjunctive'}}, $match;
                    $pos = $match->to; 
                    1 
                } 
                else { 0 }
            }
             )) {}; $bool = 1 }
       &&
do { 
                    $::_V6_MATCH_ = $m; 
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \( sub  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive'} };
        return { alt => \@a ,}  if scalar @a > 1;
        return $a[0];;
 } ->() );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool; 
                    return $m if $bool;
                }
       );
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub { 
        local $main::_V6_PRIOR_ = $prior; 
        $rule->(@_);
      };
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
;## Signature for rule
 #(\&rule, );
;

; 1;
