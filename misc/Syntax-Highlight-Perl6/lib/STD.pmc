# Emulate context vars by localizing 'our' vars living in main
our $ACTIONS;
our $BORG;
our $CORE;
our $CORESETTING;
our $CTX;
our $CURPAD;
our $CURPKG;
our $DELIM;
our $GLOBAL;
our $GOAL;
our $INTERPOLATION;
our $INVOCANT_IS;
our $INVOCANT_OK;
our $IN_DECL;
our $IN_META;
our $IN_REDUCE;
our $MULTINESS;
our $ORIG;
our $PKGDECL;
our $PKGNAME;
our $QUASI_QUASH;
our $REALLYADD;
our $SCOPE;
our $SIGIL;
our $UNIT;
our $VAR;
our $VOID;
our $begin_compunit;
our $endargs;
our $endsym;
our $ignoreaccent;
our $ignorecase;
our $ratchet;
our $sigspace;
our $sym;
our $zone;
our %LANG;
our %MYSTERY;
our @MEMOS;
our @PKGS;

our $moreinput;
our $DEBUG;

our %INSTANTIATED;
require 'mangle.pl';
use utf8;

package STD;
use 5.010;
use strict;
use warnings;
no warnings 'qw', 'recursion';
use Cursor; # for base class as well as DEBUG constants
use Moose ':all' => { -prefix => "moose_" };
moose_extends('Cursor');
my $retree;
use utf8;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

sub BUILD {
my $self = shift;
$self->_AUTOLEXpeek('termish',$retree);
}

use YAML::Syck;


# braided languages
local %::LANG;
local $::PKGDECL = "";
local $::PKGNAME = "";
local @::PKGS = ();
local $::GOAL = "(eof)";
local $::ACTIONS;
local $::IN_DECL;
local $::IN_REDUCE = 0;
local $::INTERPOLATION = '';
local $::IN_META = 0;
local $::QUASI_QUASH;
local $::SCOPE = "";
local $::SIGIL;
local %::MYSTERY;
local $::ORIG;
local @::MEMOS;
local $::VOID;
local $::INVOCANT_OK;
local $::INVOCANT_IS;
local $::CURPAD;
local $::REALLYADD = 0;
local $::BORG;
local $::MULTINESS = '';

local $::CORE;
local $::CORESETTING = "CORE";
local $::GLOBAL;
local $::CURPKG;
local $::UNIT;

# random rule for debugging, please ignore
## token foo
##      token foo {
##         <?before [<ident>|<number>]> [<ident>|<number>]
##      }

sub foo__PEEK { $_[0]->_AUTOLEXpeek('foo',$retree) }
sub foo {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "foo", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'foo_02') {
$C->deb("Fate passed to foo_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'foo_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("foo_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['ident'], sub {
my $C = shift;
$C->ident
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'foo_03') {
$C->deb("Fate passed to foo_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'foo_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("foo_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['ident'], sub {
my $C = shift;
$C->ident
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

# =begin comment overview
# 
# This file is designed to be either preprocessed into a grammar with
# action statements or used as-is without any preprocessing.  The {*}
# notation is a no-op action block, but can be identified uniquely via a
# combination of the preceding token or rule name plus any additional text
# following a #= comment.  We put this into a comment rather than using
# a macro so that bootstrap compilers don't have to worry about macros
# yet, and to keep the main grammar relatively uncluttered by action
# statements.  Note that the preprocessor can certainly generate accesses
# to the match state within the action block, so we need not mention it
# explicitly.
# 
# Also, some rules are named by syntactic category plus an additonal symbol
# specified in adverbial form, either in bare :name form or in :sym<name>
# form.  (It does not matter which form you use for identifier symbols,
# except that to specify a symbol "sym" you must use the :sym<sym> form
# of adverb.)  If you use the <sym> rule within the rule, it will parse the
# symbol at that point.  At the final reduction point of a rule, if $sym
# has been set, that is used as the final symbol name for the rule.  This
# need not match the symbol specified as part the rule name; that is just
# for disambiguating the name.  However, if no $sym is set, the original
# symbol will be used by default.
# 
# Note that rules automatically get an implicit {*} at their return, so
# for the TOP rule the implicit action name is also simply "TOP".
# 
# Another nod toward preprocessing is that blocks that contain nested braces
# are delimited by double braces so that the preprocessor does not need to
# understand Perl 6 code.
# 
# This grammar relies on transitive longest-token semantics, though
# initially we made a feeble attempt to order rules so a procedural
# interpretation of alternation could usually produce a correct parse.
# (This is becoming less true over time.)
# 
# =end comment overview

## method TOP ($STOP = undef)
sub TOP {
my $self = shift;
my $STOP = shift() // undef;


if (defined $STOP) {
local $::GOAL = $STOP;
$self->unitstop($STOP)->comp_unit;
}
else {
$self->comp_unit;
}
}

#  Absolute:
#    MY          # $stash = mypad()
#    OUR         # $stash = $?PACKAGE;
#    CORE        # $stash = $::CORE
#    GLOBAL      # $stash = CORE::<GLOBAL>
#    PROCESS     # $stash = CORE::<PROCESS>
#    COMPILING   # $stash = compiling($rest) # compiler's run time
#    CALLER      # ctx = ctx.caller # user's run time
#    CONTEXT     # ctx = ctx.context # user's run time
#
#  Relative:
#    OUTER       # $stash = $stash<OUTER>
#    UNIT        # $stash = $stash.scanouter(:unit)
#    SETTING     # $stash = UNIT::<OUTER>
#    PARENT      # $stash = $stash<PARENT>
#
#    SUPER       # (give up, pass to dispatcher?)

## method newpad
sub newpad {
my $self = shift;


my $outer = $CURPAD->{'MY'};
my $my = { file => $COMPILING::FILE, line => $self->lineof($self->{'_pos'}), stash => (
$::CURPAD = {
OUTER => $outer,
}),
};
$CURPAD->{'MY'} = $my;
$self;
}

## method finishpad($siggy = $*CURPAD.{'$?GOTSIG'}//0)
sub finishpad {
my $self = shift;
my $siggy = shift() // $CURPAD->{'$?GOTSIG'}//0;


my $line = $self->lineof($self->{'_pos'});
$CURPAD->{'$_'} //= { name => '$_', file => $COMPILING::FILE, line => $line };
$CURPAD->{'$/'} //= { name => '$/', file => $COMPILING::FILE, line => $line };
$CURPAD->{'$!'} //= { name => '$!', file => $COMPILING::FILE, line => $line };
if (not $siggy) {
$CURPAD->{'@_'} = { name => '@_', file => $COMPILING::FILE, line => $line };
$CURPAD->{'%_'} = { name => '%_', file => $COMPILING::FILE, line => $line };
$CURPAD->{'$?GOTSIG'} = '';
}
$self;
}

## method is_name ($n, $curpad = $*CURPAD)
sub is_name {
my $self = shift;
my $n = shift;
my $curpad = shift() // $::CURPAD;


my $name = $n;
# say "is_name $name";

my $curpkg = $::CURPKG;
return 1 if $name =~ qr/\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING';
return 1 if $components[0] eq 'CALLER';
return 1 if $components[0] eq 'CONTEXT';
if ($curpkg = $self->find_top_pkg($components[0])) {
# say "Found lexical package " ~ @components[0];
shift @components;
}
else {
# say "Looking for GLOBAL::<$name>";
$curpkg = $GLOBAL->{'stash'};
}
while (@components > 1) {
my $pkg = shift @components;
$curpkg = $curpkg->{$pkg}{'stash'};
return 0 unless $curpkg;
# say "Found $pkg okay, now in ";
}
}
$name = shift(@components)//'';
return 1 if $name eq '';
my $pad = $curpad;
while ($pad) {
return 1 if $pad->{$name};
$pad = $pad->{'OUTER'}{'stash'};
}
return 1 if $curpkg->{$name};
return 1 if $GLOBAL->{'stash'}{$name};
return 0;
}

## method find_stab ($n, $curpad = $*CURPAD)
sub find_stab {
my $self = shift;
my $n = shift;
my $curpad = shift() // $::CURPAD;


my $name = $n;
# say "find_stab $name";

my $curpkg = $::CURPKG;
return () if $name =~ qr/\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return () if $components[0] eq 'CALLER';
return () if $components[0] eq 'CONTEXT';
if ($curpkg = $self->find_top_pkg($components[0])) {
# say "Found lexical package " ~ @components[0];
shift @components;
}
else {
# say "Looking for GLOBAL::<$name>";
$curpkg = $GLOBAL->{'stash'};
}
while (@components > 1) {
my $pkg = shift @components;
$curpkg = $curpkg->{$pkg}{'stash'};
return () unless $curpkg;
# say "Found $pkg okay, now in ";
}
}
$name = shift(@components)//'';
return () if $name eq '';

my $pad = $curpad;
while ($pad) {
return $_ if $_ = $pad->{$name}{'stash'};
$pad = $pad->{'OUTER'}{'stash'};
}
return $_ if $_ = $curpkg->{$name}{'stash'};
return $_ if $_ = $GLOBAL->{'stash'}{$name}{'stash'};
return ();
}

## method find_top_pkg ($name)
sub find_top_pkg {
my $self = shift;
my $name = shift;


# say "find_top_pkg $name";
if ($name eq 'OUR') {
return $::CURPKG;
}
elsif ($name eq 'MY') {
return $::CURPAD;
}
elsif ($name eq 'CORE') {
return $CORE->{'stash'};
}
elsif ($name eq 'UNIT') {
return $UNIT->{'stash'};
}
# everything is somewhere in lexical scope (we hope)
my $pad = $::CURPAD;
while ($pad) {
return $pad->{$name}{'stash'} if $pad->{$name};
$pad = $pad->{'OUTER'}{'stash'} // 0;
}
return 0;
}

## method add_name ($name)
sub add_name {
my $self = shift;
my $name = shift;


my $scope = $::SCOPE // 'our';
# say "Adding $::SCOPE $name in $::PKGNAME";
if ($scope eq 'augment' or $scope eq 'supersede') {
$self->is_name($name) or $self->worry("Can't $scope something that doesn't exist");
}
else {
if ($scope eq 'our') {
$self->add_our_name($name);
}
else {
$self->add_my_name($name);
}
}
$self;
}

## method add_my_name ($n)
sub add_my_name {
my $self = shift;
my $n = shift;


my $name = $n;
# say "add_my_name $name";
return $self if $name =~ qr/\:\:\(/;
my $curpkg = $::CURPAD;
my @components = $self->canonicalize_name($name);
while (@components > 1) {
my $pkg = shift @components;
$curpkg->{$pkg} //= { stub => 1 };
$curpkg->{"&$pkg"} //= $curpkg->{$pkg};
$curpkg = $curpkg->{$pkg}{'stash'} //= { 'PARENT' => $curpkg };
# say "Adding new package $pkg in $curpkg ";
}
$name = shift @components;
return $self unless defined $name and $name ne '';
return $self if $name eq '$' or $name eq '@' or $name eq '%';
if (exists $curpkg->{$name}) {
if ($curpkg->{$name}{'stub'}) {
$curpkg->{$name} = {
name => $name,
file => $COMPILING::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
};
}
elsif ($::SCOPE eq 'use') {}
elsif ($::MULTINESS eq 'multi' and $curpkg->{$name}{'mult'} ne 'only') {}
elsif (($curpkg->{$name}{'mult'}//'') eq 'proto') {}
elsif ($::PKGDECL eq 'role') {}
else {
my $old = $curpkg->{$name};
my $ofile = $old->{'file'} // '';
my $oline = $old->{'line'} // '???';
my $loc = '';
if ($ofile) {
if ($ofile ne $COMPILING::FILE) {
$loc = " (from $ofile line $oline)";
}
else {
$loc = " (from line $oline)";
}
}
if ($name =~ qr/^\w/) {
$self->panic("Illegal redeclaration of lexical symbol $name$loc");
}
elsif ($name =~ s/^\&//) {
$self->panic("Illegal redeclaration of lexical routine $name$loc");
}
else {  # XXX eventually check for conformant arrays here
$self->worry("Useless redeclaration of lexical variable $name$loc");
}
}
}
else {
$curpkg->{$name} = {
name => $name,
file => $COMPILING::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
};
if ($name =~ qr/^\w/) {
$curpkg->{"&$name"} //= $curpkg->{$name};
$curpkg->{$name}{'stash'} //= { 'PARENT' => $curpkg };
}
}
$self;
}

## method add_our_name ($n)
sub add_our_name {
my $self = shift;
my $n = shift;


my $name = $n;
# say "add_our_name $name " ~ $::PKGNAME;
return $self if $name =~ qr/\:\:\(/;
my $curpkg = $::CURPKG;
# say "curpkg $curpkg global $GLOBAL ", join ' ', %$::GLOBAL;
$name =~ s/\:ver\<.*?\>//;
$name =~ s/\:auth\<.*?\>//;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
my $c = $self->find_top_pkg($components[0]);
if ($c) {
shift @components;
$curpkg = $c;
}
}
while (@components > 1) {
my $pkg = shift @components;
$curpkg->{$pkg} //= { stub => 1 };
$curpkg->{"&$pkg"} //= $curpkg->{$pkg};
$curpkg = $curpkg->{$pkg}{'stash'} //= { 'PARENT' => $curpkg };
# say "Adding new package $pkg in $curpkg ";
}
$name = shift @components;
return $self unless defined $name and $name ne '';
if (exists $curpkg->{$name}) {
if ($curpkg->{$name}{'stub'}) {
$curpkg->{$name} = {
name => $name,
file => $COMPILING::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
};
}
elsif ($::SCOPE eq 'use') {}
elsif ($::MULTINESS eq 'multi' and $curpkg->{$name}{'mult'} ne 'only') {}
elsif ($curpkg->{$name}{'mult'} eq 'proto') {}
elsif ($::PKGDECL eq 'role') {}
else {
my $old = $curpkg->{$name};
my $ofile = $old->{'file'} // '';
my $oline = $old->{'line'} // '???';
my $loc = '';
if ($ofile) {
if ($ofile ne $COMPILING::FILE) {
$loc = " (from $ofile line $oline)";
}
else {
$loc = " (from line $oline)";
}
}
if ($name =~ qr/^\w/) {
$self->panic("Illegal redeclaration of package symbol $name$loc");
}
elsif ($name =~ s/^\&//) {
$self->panic("Illegal redeclaration of package routine $name$loc");
}
else {  # XXX eventually check for conformant arrays here
# (redeclaration of identical package vars is not useless)
}
}
}
else {
$curpkg->{$name} = {
name => $name,
file => $COMPILING::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
};
if ($name =~ qr/^\w/) {
$curpkg->{"&$name"} //= { name => "&$name", file => $COMPILING::FILE, line => $self->line };
$curpkg->{$name}{'stash'} //= { 'PARENT' => $curpkg };
}
}
$self->add_my_name($n) if $curpkg == $::CURPKG;   # the lexical alias
$self;
}

## method add_mystery ($name,$pos)
sub add_mystery {
my $self = shift;
my $name = shift;
my $pos = shift;


if (not $self->is_known($name)) {
# say "add_mystery $name";
# say "Mystery $name $::CURPAD";
$::MYSTERY{$name}->{'pad'} = $::CURPAD;
$::MYSTERY{$name}->{'line'} .= $self->lineof($pos) . ' ';
}
else {
# say "$name is known";
}
$self;
}

## method load_setting ($setting)
sub load_setting {
my $self = shift;
my $setting = shift;


@PKGS = ();

# XXX CORE   === SETTING for now
$::CORE = $self->load_pad($setting);
$::CURPAD = $CORE->{'stash'};
$CURPAD->{'MY'} = $::CORE;
$GLOBAL->{'stash'}{'CORE'} = $GLOBAL->{'stash'}{'SETTING'} = $::CORE;
$::GLOBAL = $CORE->{'stash'}{'GLOBAL'};
$::CURPKG = $GLOBAL->{'stash'};
}

## method is_known ($n, $curpad = $*CURPAD)
sub is_known {
my $self = shift;
my $n = shift;
my $curpad = shift() // $::CURPAD;


my $name = $n;
# say "is_known $name";
return 1 if $::QUASI_QUASH;
return 1 if $CURPKG->{$name};
my $curpkg = $::CURPKG;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING';
return 1 if $components[0] eq 'CALLER';
return 1 if $components[0] eq 'CONTEXT';
if ($curpkg = $self->find_top_pkg($components[0])) {
# say "Found lexical package " ~ @components[0];
shift @components;
}
else {
# say "Looking for GLOBAL::<$name>";
$curpkg = $GLOBAL->{'stash'};
}
while (@components > 1) {
my $pkg = shift @components;
# say "Looking for $pkg in $curpkg ", join ' ', keys(%$curpkg);
$curpkg = $curpkg->{$pkg}{'stash'};
return 0 unless $curpkg;
# say "Found $pkg okay, now in $curpkg ";
}
}

$name = shift(@components)//'';
# say "Final component is $name";
return 1 if $name eq '';
return 1 if $curpkg->{$name};

my $pad = $curpad;
while ($pad) {
return 1 if $pad->{$name};
$pad = $pad->{'OUTER'}{'stash'};
}

return 0;
}


## method add_routine ($name)
sub add_routine {
my $self = shift;
my $name = shift;


my $vname = '&' . $name;
$self->add_name($vname);
$self;
}

## method add_variable ($name)
sub add_variable {
my $self = shift;
my $name = shift;


if (($::SCOPE//'') eq 'our') {
$self->add_our_variable($name);
}
else {
$self->add_my_variable($name);
}
$self;
}

## method add_my_variable ($n)
sub add_my_variable {
my $self = shift;
my $n = shift;


my $name = $n;
# say "add_my_variable $name";
if (substr($name, 0, 1) eq '&') {
$self->add_my_name($name);
if ($name =~ s/\:\(.*//) {
$self->add_my_name($name);
}
return $self;
}
$self->add_my_name($name);
$self;
}

## method add_our_variable ($name)
sub add_our_variable {
my $self = shift;
my $name = shift;


$self->add_our_name($name);
$self;
}

## method check_variable ($variable)
sub check_variable {
my $self = shift;
my $variable = shift;


my $name = $variable->Str;
# say "check_variable $name";
my ($sigil, $twigil, $first) = $name =~ qr/(\W)(\W?)(.?)/;
given ($twigil) {
when ('') {
my $ok = 0;
$ok = 1 if $name =~ qr/::/;
$ok ||= $::IN_DECL;
$ok ||= $sigil eq '&';
$ok ||= $first lt 'A';
$ok ||= $self->is_known($name);
if (not $ok) {
$variable->worry("Variable $name is not predeclared");
}
}
when ('^') {
local $::MULTINESS = 'multi';
my $siggy = $CURPAD->{'$?GOTSIG'}//'';
if ($siggy) { $variable->panic("Placeholder variable $name cannot override existing signature $siggy"); }
$self->add_my_variable($name);
}
when (':') {
local $::MULTINESS = 'multi';
$self->add_my_variable($name);
}
when ('~') {
return $::LANG{substr($name,2)};
}
when ('?') {
if ($name =~ qr/\:\:/) {
my ($first) = $self->canonicalize_name($name);
$variable->worry("Unrecognized variable: $name") unless $first =~ qr/^(CALLER|CONTEXT|OUTER|MY|SETTING|CORE)$/;
}
else {
# search upward through languages to STD
my $v = $variable->lookup_compiler_var($name);
$variable->{'value'} = $v if $v;
}
}
}
$self;
}

## method lookup_compiler_var($name)
sub lookup_compiler_var {
my $self = shift;
my $name = shift;



# see if they did "constant $?FOO = something" earlier
my $lex = $CURPAD->{$name};
if (defined $lex) {
if (exists $lex->{'thunk'}) {
return $lex->{'thunk'}->();
}
else {
return $lex->{'value'};
}
}

given ($name) {
when ('$?FILE')     { return $COMPILING::FILE; }
when ('$?LINE')     { return $self->lineof($self->{'_pos'}); }
when ('$?POSITION') { return $self->{'_pos'}; }

when ('$?LANG')    { return \%::LANG; }

when ('$?SCOPE')    { return $::CURPAD; }

when ('$?PACKAGE')  { return $::CURPKG; }
when ('$?MODULE')   { return $::CURPKG; } #  XXX should scan
when ('$?CLASS')    { return $::CURPKG; } #  XXX should scan
when ('$?ROLE')     { return $::CURPKG; } #  XXX should scan
when ('$?GRAMMAR')  { return $::CURPKG; } #  XXX should scan

when ('$?PACKAGENAME') { return $::PKGNAME; }

when ('$?OS')       { return 'unimpl'; }
when ('$?DISTRO')   { return 'unimpl'; }
when ('$?VM')       { return 'unimpl'; }
when ('$?XVM')      { return 'unimpl'; }
when ('$?PERL')     { return 'unimpl'; }

when ('$?USAGE')    { return 'unimpl'; }

when ('&?ROUTINE')  { return 'unimpl'; }
when ('&?BLOCK')    { return 'unimpl'; }

when ('%?CONFIG')    { return 'unimpl'; }
when ('%?DEEPMAGIC') { return 'unimpl'; }

# (derived grammars should default to nextsame, terminating here)
default { $self->worry("Unrecognized variable: $name"); return 0; }
}
}

# The internal precedence levels are *not* part of the public interface.
# The current values are mere implementation; they may change at any time.
# Users should specify precedence only in relation to existing levels.

our %term            = ('dba' => ('term')            , 'prec' => 'z=');
our %methodcall      = ('dba' => ('methodcall')      , 'prec' => 'y=', 'assoc' => 'unary', 'uassoc' => 'left', 'fiddly' => 1);
our %autoincrement   = ('dba' => ('autoincrement')   , 'prec' => 'x=', 'assoc' => 'unary', 'uassoc' => 'non');
our %exponentiation  = ('dba' => ('exponentiation')  , 'prec' => 'w=', 'assoc' => 'right');
our %symbolic_unary  = ('dba' => ('symbolic unary')  , 'prec' => 'v=', 'assoc' => 'unary', 'uassoc' => 'left');
our %multiplicative  = ('dba' => ('multiplicative')  , 'prec' => 'u=', 'assoc' => 'left');
our %additive        = ('dba' => ('additive')        , 'prec' => 't=', 'assoc' => 'left');
our %replication     = ('dba' => ('replication')     , 'prec' => 's=', 'assoc' => 'left');
our %concatenation   = ('dba' => ('concatenation')   , 'prec' => 'r=', 'assoc' => 'list');
our %junctive_and    = ('dba' => ('junctive and')    , 'prec' => 'q=', 'assoc' => 'list');
our %junctive_or     = ('dba' => ('junctive or')     , 'prec' => 'p=', 'assoc' => 'list');
our %named_unary     = ('dba' => ('named unary')     , 'prec' => 'o=', 'assoc' => 'unary', 'uassoc' => 'left');
our %nonchaining     = ('dba' => ('nonchaining')     , 'prec' => 'n=', 'assoc' => 'non', 'diffy' => 1);
our %chaining        = ('dba' => ('chaining')        , 'prec' => 'm=', 'assoc' => 'chain', 'diffy' => 1, 'iffy' => 1);
our %tight_and       = ('dba' => ('tight and')       , 'prec' => 'l=', 'assoc' => 'list');
our %tight_or        = ('dba' => ('tight or')        , 'prec' => 'k=', 'assoc' => 'list');
our %conditional     = ('dba' => ('conditional')     , 'prec' => 'j=', 'assoc' => 'right', 'fiddly' => 1);
our %item_assignment = ('dba' => ('item assignment') , 'prec' => 'i=', 'assoc' => 'right', 'fiddly' => 1);
our %loose_unary     = ('dba' => ('loose unary')     , 'prec' => 'h=', 'assoc' => 'unary', 'uassoc' => 'left');
our %comma           = ('dba' => ('comma')           , 'prec' => 'g=', 'assoc' => 'list', 'nextterm' => 'nulltermish', 'fiddly' => 1);
our %list_infix      = ('dba' => ('list infix')      , 'prec' => 'f=', 'assoc' => 'list');
our %list_assignment = ('dba' => ('list assignment') , 'prec' => 'i=', 'assoc' => 'right', 'sub' => 'e=', 'fiddly' => 1);
our %list_prefix     = ('dba' => ('list prefix')     , 'prec' => 'e=', 'assoc' => 'unary', 'uassoc' => 'left');
our %loose_and       = ('dba' => ('loose and')       , 'prec' => 'd=', 'assoc' => 'list');
our %loose_or        = ('dba' => ('loose or')        , 'prec' => 'c=', 'assoc' => 'list');
our %sequencer       = ('dba' => ('sequencer')       , 'prec' => 'b=', 'assoc' => 'list', 'nextterm' => 'statement', 'fiddly' => 1);
our %LOOSEST         = ('dba' => ('LOOSEST')         , 'prec' => 'a=!');
our %terminator      = ('dba' => ('terminator')      , 'prec' => 'a=', 'assoc' => 'list');

# "epsilon" tighter than terminator
#constant $LOOSEST = %LOOSEST<prec>;
my $LOOSEST = "a=!"; # XXX preceding line is busted
my $item_assignment_prec = 'i=';
my $methodcall_prec = 'y=';


{ package STD::PrecOp;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;

# This is hopefully called on a match to mix in operator info by type.
##     method coerce (Match $m)
sub coerce {
my $self = shift;
my $m = shift;


# $m but= ::?CLASS;
my $var = (ref($self)||$self) . '::o';
my $d = do { no strict 'refs'; \%{$var}}; 
if (not $d->{'transparent'}) {
for (keys(%$d)) { $m->{'O'}{$_} //= $d->{$_} };
$m->deb("coercing to " . $self) if $::DEBUG & DEBUG::EXPR;
}
$m->{'O'}{'kind'} = (ref($self)||$self);
return $m;
}

} ## end role

{ package STD::Transparent;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp)); our %o = ('transparent' => 1);
} ## end class

{ package STD::Term;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %term;
} ## end class
{ package STD::Methodcall;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %methodcall;
} ## end class
{ package STD::Autoincrement;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %autoincrement;
} ## end class
{ package STD::Exponentiation;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %exponentiation;
} ## end class
{ package STD::Symbolic_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %symbolic_unary;
} ## end class
{ package STD::Multiplicative;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %multiplicative;
} ## end class
{ package STD::Additive;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %additive;
} ## end class
{ package STD::Replication;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %replication;
} ## end class
{ package STD::Concatenation;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %concatenation;
} ## end class
{ package STD::Junctive_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %junctive_and;
} ## end class
{ package STD::Junctive_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %junctive_or;
} ## end class
{ package STD::Named_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %named_unary;
} ## end class
{ package STD::Nonchaining;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %nonchaining;
} ## end class
{ package STD::Chaining;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %chaining;
} ## end class
{ package STD::Tight_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %tight_and;
} ## end class
{ package STD::Tight_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %tight_or;
} ## end class
{ package STD::Conditional;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %conditional;
} ## end class
{ package STD::Item_assignment;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %item_assignment;
} ## end class
{ package STD::Loose_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_unary;
} ## end class
{ package STD::Comma;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %comma;
} ## end class
{ package STD::List_infix;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_infix;
} ## end class
{ package STD::List_assignment;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_assignment;
} ## end class
{ package STD::List_prefix;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_prefix;
} ## end class
{ package STD::Loose_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_and;
} ## end class
{ package STD::Loose_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_or;
} ## end class
{ package STD::Sequencer;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %sequencer;
} ## end class
{ package STD::Terminator;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %terminator;
} ## end class

# Categories are designed to be easily extensible in derived grammars
# by merely adding more rules in the same category.  The rules within
# a given category start with the category name followed by a differentiating
# adverbial qualifier to serve (along with the category) as the longer name.

# The endsym context, if specified, says what to implicitly check for in each
# rule right after the initial <sym>.  Normally this is used to make sure
# there's appropriate whitespace.  # Note that endsym isn't called if <sym>
# isn't called.

local $::endsym = "null";
local $::endargs = -1;

#proto token category { <...> }
sub category__PEEK { $_[0]->_AUTOLEXpeek('category:*',$retree); }
sub category {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'category') {
$C->deb("Fate passed to category: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'category:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("category trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "category", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_000category (:$sym is context<rw> = 'category')
##      token category:category { <sym> }

sub category__S_000category__PEEK { $_[0]->_AUTOLEXpeek('category__S_000category',$retree) }
sub category__S_000category {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'category';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_000category", 
$C->_PATTERN(qr/\Gcategory/)
);
}

## token category__S_001sigil (:$sym is context<rw> = 'sigil')
##      token category:sigil { <sym> }

sub category__S_001sigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_001sigil',$retree) }
sub category__S_001sigil {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_001sigil", 
$C->_PATTERN(qr/\Gsigil/)
);
}
#proto token sigil { <...> }
sub sigil__PEEK { $_[0]->_AUTOLEXpeek('sigil:*',$retree); }
sub sigil {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'sigil') {
$C->deb("Fate passed to sigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'sigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "sigil", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_002twigil (:$sym is context<rw> = 'twigil')
##      token category:twigil { <sym> }

sub category__S_002twigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_002twigil',$retree) }
sub category__S_002twigil {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'twigil';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_002twigil", 
$C->_PATTERN(qr/\Gtwigil/)
);
}
#proto token twigil { <...> }
sub twigil__PEEK { $_[0]->_AUTOLEXpeek('twigil:*',$retree); }
sub twigil {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'twigil') {
$C->deb("Fate passed to twigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'twigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("twigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "twigil", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_003special_variable (:$sym is context<rw> = 'special_variable')
##      token category:special_variable { <sym> }

sub category__S_003special_variable__PEEK { $_[0]->_AUTOLEXpeek('category__S_003special_variable',$retree) }
sub category__S_003special_variable {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'special_variable';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_003special_variable", 
$C->_PATTERN(qr/\Gspecial_variable/)
);
}
#proto token special_variable { <...> }
sub special_variable__PEEK { $_[0]->_AUTOLEXpeek('special_variable:*',$retree); }
sub special_variable {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'special_variable') {
$C->deb("Fate passed to special_variable: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "special_variable", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_004version (:$sym is context<rw> = 'version')
##      token category:version { <sym> }

sub category__S_004version__PEEK { $_[0]->_AUTOLEXpeek('category__S_004version',$retree) }
sub category__S_004version {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'version';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_004version", 
$C->_PATTERN(qr/\Gversion/)
);
}
#proto token version { <...> }
sub version__PEEK { $_[0]->_AUTOLEXpeek('version:*',$retree); }
sub version {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'version') {
$C->deb("Fate passed to version: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'version:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("version trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "version", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_005module_name (:$sym is context<rw> = 'module_name')
##      token category:module_name { <sym> }

sub category__S_005module_name__PEEK { $_[0]->_AUTOLEXpeek('category__S_005module_name',$retree) }
sub category__S_005module_name {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'module_name';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_005module_name", 
$C->_PATTERN(qr/\Gmodule_name/)
);
}
#proto token module_name { <...> }
sub module_name__PEEK { $_[0]->_AUTOLEXpeek('module_name:*',$retree); }
sub module_name {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'module_name') {
$C->deb("Fate passed to module_name: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'module_name:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("module_name trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "module_name", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_006noun (:$sym is context<rw> = 'noun')
##      token category:noun { <sym> }

sub category__S_006noun__PEEK { $_[0]->_AUTOLEXpeek('category__S_006noun',$retree) }
sub category__S_006noun {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'noun';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_006noun", 
$C->_PATTERN(qr/\Gnoun/)
);
}
#proto token noun { <...> }
sub noun__PEEK { $_[0]->_AUTOLEXpeek('noun:*',$retree); }
sub noun {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'noun') {
$C->deb("Fate passed to noun: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'noun:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("noun trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "noun", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_007value (:$sym is context<rw> = 'value')
##      token category:value { <sym> }

sub category__S_007value__PEEK { $_[0]->_AUTOLEXpeek('category__S_007value',$retree) }
sub category__S_007value {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'value';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_007value", 
$C->_PATTERN(qr/\Gvalue/)
);
}
#proto token value { <...> }
sub value__PEEK { $_[0]->_AUTOLEXpeek('value:*',$retree); }
sub value {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'value') {
$C->deb("Fate passed to value: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'value:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("value trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "value", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_008term (:$sym is context<rw> = 'term')
##      token category:term { <sym> }

sub category__S_008term__PEEK { $_[0]->_AUTOLEXpeek('category__S_008term',$retree) }
sub category__S_008term {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'term';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_008term", 
$C->_PATTERN(qr/\Gterm/)
);
}
#proto token term { <...> }
sub term__PEEK { $_[0]->_AUTOLEXpeek('term:*',$retree); }
sub term {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'term') {
$C->deb("Fate passed to term: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "term", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_009number (:$sym is context<rw> = 'number')
##      token category:number { <sym> }

sub category__S_009number__PEEK { $_[0]->_AUTOLEXpeek('category__S_009number',$retree) }
sub category__S_009number {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'number';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_009number", 
$C->_PATTERN(qr/\Gnumber/)
);
}
#proto token number { <...> }
sub number__PEEK { $_[0]->_AUTOLEXpeek('number:*',$retree); }
sub number {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'number') {
$C->deb("Fate passed to number: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'number:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("number trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "number", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_010quote (:$sym is context<rw> = 'quote')
##      token category:quote { <sym> }

sub category__S_010quote__PEEK { $_[0]->_AUTOLEXpeek('category__S_010quote',$retree) }
sub category__S_010quote {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_010quote", 
$C->_PATTERN(qr/\Gquote/)
);
}
#proto token quote () { <...> }
sub quote__PEEK { $_[0]->_AUTOLEXpeek('quote:*',$retree); }
sub quote {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quote') {
$C->deb("Fate passed to quote: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quote", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_011prefix (:$sym is context<rw> = 'prefix')
##      token category:prefix { <sym> }

sub category__S_011prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_011prefix',$retree) }
sub category__S_011prefix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_011prefix", 
$C->_PATTERN(qr/\Gprefix/)
);
}
#proto token prefix is unary is defequiv(%symbolic_unary) { <...> }
sub prefix__PEEK { $_[0]->_AUTOLEXpeek('prefix:*',$retree); }
sub prefix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix') {
$C->deb("Fate passed to prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_012infix (:$sym is context<rw> = 'infix')
##      token category:infix { <sym> }

sub category__S_012infix__PEEK { $_[0]->_AUTOLEXpeek('category__S_012infix',$retree) }
sub category__S_012infix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_012infix", 
$C->_PATTERN(qr/\Ginfix/)
);
}
#proto token infix is binary is defequiv(%additive) { <...> }
sub infix__PEEK { $_[0]->_AUTOLEXpeek('infix:*',$retree); }
sub infix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix') {
$C->deb("Fate passed to infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_013postfix (:$sym is context<rw> = 'postfix')
##      token category:postfix { <sym> }

sub category__S_013postfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_013postfix',$retree) }
sub category__S_013postfix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postfix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_013postfix", 
$C->_PATTERN(qr/\Gpostfix/)
);
}
#proto token postfix is unary is defequiv(%autoincrement) { <...> }
sub postfix__PEEK { $_[0]->_AUTOLEXpeek('postfix:*',$retree); }
sub postfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postfix') {
$C->deb("Fate passed to postfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_014dotty (:$sym is context<rw> = 'dotty')
##      token category:dotty { <sym> }

sub category__S_014dotty__PEEK { $_[0]->_AUTOLEXpeek('category__S_014dotty',$retree) }
sub category__S_014dotty {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'dotty';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_014dotty", 
$C->_PATTERN(qr/\Gdotty/)
);
}
#proto token dotty (:$endsym is context = 'unspacey') { <...> }
sub dotty__PEEK { $_[0]->_AUTOLEXpeek('dotty:*',$retree); }
sub dotty {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'dotty') {
$C->deb("Fate passed to dotty: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dotty:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "dotty", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_015circumfix (:$sym is context<rw> = 'circumfix')
##      token category:circumfix { <sym> }

sub category__S_015circumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_015circumfix',$retree) }
sub category__S_015circumfix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'circumfix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_015circumfix", 
$C->_PATTERN(qr/\Gcircumfix/)
);
}
#proto token circumfix { <...> }
sub circumfix__PEEK { $_[0]->_AUTOLEXpeek('circumfix:*',$retree); }
sub circumfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'circumfix') {
$C->deb("Fate passed to circumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'circumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("circumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "circumfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_016postcircumfix (:$sym is context<rw> = 'postcircumfix')
##      token category:postcircumfix { <sym> }

sub category__S_016postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_016postcircumfix',$retree) }
sub category__S_016postcircumfix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postcircumfix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_016postcircumfix", 
$C->_PATTERN(qr/\Gpostcircumfix/)
);
}
#proto token postcircumfix is unary { <...> }  # unary as far as EXPR knows...
sub postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix:*',$retree); }
sub postcircumfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postcircumfix') {
$C->deb("Fate passed to postcircumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postcircumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postcircumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postcircumfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_017quote_mod (:$sym is context<rw> = 'quote_mod')
##      token category:quote_mod { <sym> }

sub category__S_017quote_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_017quote_mod',$retree) }
sub category__S_017quote_mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote_mod';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_017quote_mod", 
$C->_PATTERN(qr/\Gquote_mod/)
);
}
#proto token quote_mod { <...> }
sub quote_mod__PEEK { $_[0]->_AUTOLEXpeek('quote_mod:*',$retree); }
sub quote_mod {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quote_mod') {
$C->deb("Fate passed to quote_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote_mod:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quote_mod", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_018trait_mod (:$sym is context<rw> = 'trait_mod')
##      token category:trait_mod { <sym> }

sub category__S_018trait_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_018trait_mod',$retree) }
sub category__S_018trait_mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'trait_mod';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_018trait_mod", 
$C->_PATTERN(qr/\Gtrait_mod/)
);
}
#proto token trait_mod (:$endsym is context = 'spacey') { <...> }
sub trait_mod__PEEK { $_[0]->_AUTOLEXpeek('trait_mod:*',$retree); }
sub trait_mod {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'trait_mod') {
$C->deb("Fate passed to trait_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_mod:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "trait_mod", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_019type_declarator (:$sym is context<rw> = 'type_declarator')
##      token category:type_declarator { <sym> }

sub category__S_019type_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_019type_declarator',$retree) }
sub category__S_019type_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'type_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_019type_declarator", 
$C->_PATTERN(qr/\Gtype_declarator/)
);
}
#proto token type_declarator (:$endsym is context = 'spacey') { <...> }
sub type_declarator__PEEK { $_[0]->_AUTOLEXpeek('type_declarator:*',$retree); }
sub type_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'type_declarator') {
$C->deb("Fate passed to type_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'type_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "type_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_020scope_declarator (:$sym is context<rw> = 'scope_declarator')
##      token category:scope_declarator { <sym> }

sub category__S_020scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_020scope_declarator',$retree) }
sub category__S_020scope_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'scope_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_020scope_declarator", 
$C->_PATTERN(qr/\Gscope_declarator/)
);
}
#proto token scope_declarator (:$endsym is context = 'nofun') { <...> }
sub scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator:*',$retree); }
sub scope_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'scope_declarator') {
$C->deb("Fate passed to scope_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'scope_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scope_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "scope_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_021package_declarator (:$sym is context<rw> = 'package_declarator')
##      token category:package_declarator { <sym> }

sub category__S_021package_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_021package_declarator',$retree) }
sub category__S_021package_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'package_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_021package_declarator", 
$C->_PATTERN(qr/\Gpackage_declarator/)
);
}
#proto token package_declarator (:$endsym is context = 'spacey') { <...> }
sub package_declarator__PEEK { $_[0]->_AUTOLEXpeek('package_declarator:*',$retree); }
sub package_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'package_declarator') {
$C->deb("Fate passed to package_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'package_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("package_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "package_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_022multi_declarator (:$sym is context<rw> = 'multi_declarator')
##      token category:multi_declarator { <sym> }

sub category__S_022multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_022multi_declarator',$retree) }
sub category__S_022multi_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'multi_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_022multi_declarator", 
$C->_PATTERN(qr/\Gmulti_declarator/)
);
}
#proto token multi_declarator (:$endsym is context = 'spacey') { <...> }
sub multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator:*',$retree); }
sub multi_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'multi_declarator') {
$C->deb("Fate passed to multi_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'multi_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("multi_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "multi_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_023routine_declarator (:$sym is context<rw> = 'routine_declarator')
##      token category:routine_declarator { <sym> }

sub category__S_023routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_023routine_declarator',$retree) }
sub category__S_023routine_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'routine_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_023routine_declarator", 
$C->_PATTERN(qr/\Groutine_declarator/)
);
}
#proto token routine_declarator (:$endsym is context = 'endid') { <...> }
sub routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator:*',$retree); }
sub routine_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'routine_declarator') {
$C->deb("Fate passed to routine_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "routine_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_024regex_declarator (:$sym is context<rw> = 'regex_declarator')
##      token category:regex_declarator { <sym> }

sub category__S_024regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_024regex_declarator',$retree) }
sub category__S_024regex_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'regex_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_024regex_declarator", 
$C->_PATTERN(qr/\Gregex_declarator/)
);
}
#proto token regex_declarator (:$endsym is context = 'spacey') { <...> }
sub regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator:*',$retree); }
sub regex_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'regex_declarator') {
$C->deb("Fate passed to regex_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "regex_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_025statement_prefix (:$sym is context<rw> = 'statement_prefix')
##      token category:statement_prefix { <sym> }

sub category__S_025statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_025statement_prefix',$retree) }
sub category__S_025statement_prefix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_prefix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_025statement_prefix", 
$C->_PATTERN(qr/\Gstatement_prefix/)
);
}
#proto rule  statement_prefix () { <...> }
sub statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix:*',$retree); }
sub statement_prefix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_prefix') {
$C->deb("Fate passed to statement_prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_prefix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_026statement_control (:$sym is context<rw> = 'statement_control')
##      token category:statement_control { <sym> }

sub category__S_026statement_control__PEEK { $_[0]->_AUTOLEXpeek('category__S_026statement_control',$retree) }
sub category__S_026statement_control {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_control';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_026statement_control", 
$C->_PATTERN(qr/\Gstatement_control/)
);
}
#proto rule  statement_control (:$endsym is context = 'spacey') { <...> }
sub statement_control__PEEK { $_[0]->_AUTOLEXpeek('statement_control:*',$retree); }
sub statement_control {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_control') {
$C->deb("Fate passed to statement_control: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_control", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_027statement_mod_cond (:$sym is context<rw> = 'statement_mod_cond')
##      token category:statement_mod_cond { <sym> }

sub category__S_027statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('category__S_027statement_mod_cond',$retree) }
sub category__S_027statement_mod_cond {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_mod_cond';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_027statement_mod_cond", 
$C->_PATTERN(qr/\Gstatement_mod_cond/)
);
}
#proto rule  statement_mod_cond (:$endsym is context = 'nofun') { <...> }
sub statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond:*',$retree); }
sub statement_mod_cond {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_mod_cond') {
$C->deb("Fate passed to statement_mod_cond: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_cond:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_cond trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_mod_cond", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_028statement_mod_loop (:$sym is context<rw> = 'statement_mod_loop')
##      token category:statement_mod_loop { <sym> }

sub category__S_028statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('category__S_028statement_mod_loop',$retree) }
sub category__S_028statement_mod_loop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_mod_loop';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_028statement_mod_loop", 
$C->_PATTERN(qr/\Gstatement_mod_loop/)
);
}
#proto rule  statement_mod_loop (:$endsym is context = 'nofun') { <...> }
sub statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop:*',$retree); }
sub statement_mod_loop {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_mod_loop') {
$C->deb("Fate passed to statement_mod_loop: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_loop:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_loop trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_mod_loop", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_029infix_prefix_meta_operator (:$sym is context<rw> = 'infix_prefix_meta_operator')
##      token category:infix_prefix_meta_operator { <sym> }

sub category__S_029infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_029infix_prefix_meta_operator',$retree) }
sub category__S_029infix_prefix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_prefix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_029infix_prefix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_prefix_meta_operator/)
);
}
#proto token infix_prefix_meta_operator is binary { <...> }
sub infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator:*',$retree); }
sub infix_prefix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_prefix_meta_operator') {
$C->deb("Fate passed to infix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_prefix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_030infix_postfix_meta_operator (:$sym is context<rw> = 'infix_postfix_meta_operator')
##      token category:infix_postfix_meta_operator { <sym> }

sub category__S_030infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_030infix_postfix_meta_operator',$retree) }
sub category__S_030infix_postfix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_postfix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_030infix_postfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_postfix_meta_operator/)
);
}
#proto token infix_postfix_meta_operator ($op) is binary { <...> }
sub infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator:*',$retree); }
sub infix_postfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_postfix_meta_operator') {
$C->deb("Fate passed to infix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_postfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_031infix_circumfix_meta_operator (:$sym is context<rw> = 'infix_circumfix_meta_operator')
##      token category:infix_circumfix_meta_operator { <sym> }

sub category__S_031infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_031infix_circumfix_meta_operator',$retree) }
sub category__S_031infix_circumfix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_circumfix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_031infix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_circumfix_meta_operator/)
);
}
#proto token infix_circumfix_meta_operator is binary { <...> }
sub infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator:*',$retree); }
sub infix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_circumfix_meta_operator') {
$C->deb("Fate passed to infix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_circumfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_032postfix_prefix_meta_operator (:$sym is context<rw> = 'postfix_prefix_meta_operator')
##      token category:postfix_prefix_meta_operator { <sym> }

sub category__S_032postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_032postfix_prefix_meta_operator',$retree) }
sub category__S_032postfix_prefix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postfix_prefix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_032postfix_prefix_meta_operator", 
$C->_PATTERN(qr/\Gpostfix_prefix_meta_operator/)
);
}
#proto token postfix_prefix_meta_operator is unary { <...> }
sub postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator:*',$retree); }
sub postfix_prefix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postfix_prefix_meta_operator') {
$C->deb("Fate passed to postfix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postfix_prefix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_033prefix_postfix_meta_operator (:$sym is context<rw> = 'prefix_postfix_meta_operator')
##      token category:prefix_postfix_meta_operator { <sym> }

sub category__S_033prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_033prefix_postfix_meta_operator',$retree) }
sub category__S_033prefix_postfix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix_postfix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_033prefix_postfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_postfix_meta_operator/)
);
}
#proto token prefix_postfix_meta_operator is unary { <...> }
sub prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator:*',$retree); }
sub prefix_postfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix_postfix_meta_operator') {
$C->deb("Fate passed to prefix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix_postfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_034prefix_circumfix_meta_operator (:$sym is context<rw> = 'prefix_circumfix_meta_operator')
##      token category:prefix_circumfix_meta_operator { <sym> }

sub category__S_034prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_034prefix_circumfix_meta_operator',$retree) }
sub category__S_034prefix_circumfix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix_circumfix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_034prefix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_circumfix_meta_operator/)
);
}
#proto token prefix_circumfix_meta_operator is unary { <...> }
sub prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator:*',$retree); }
sub prefix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix_circumfix_meta_operator') {
$C->deb("Fate passed to prefix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix_circumfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_035terminator (:$sym is context<rw> = 'terminator')
##      token category:terminator { <sym> }

sub category__S_035terminator__PEEK { $_[0]->_AUTOLEXpeek('category__S_035terminator',$retree) }
sub category__S_035terminator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'terminator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_035terminator", 
$C->_PATTERN(qr/\Gterminator/)
);
}
#proto token terminator { <...> }
sub terminator__PEEK { $_[0]->_AUTOLEXpeek('terminator:*',$retree); }
sub terminator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'terminator') {
$C->deb("Fate passed to terminator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'terminator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("terminator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "terminator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token unspacey
##      token unspacey { <.unsp>? }

sub unspacey__PEEK { $_[0]->_AUTOLEXpeek('unspacey',$retree) }
sub unspacey {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unspacey", 
$C->_OPTr(sub { my $C=shift;
$C->unsp
})
);
}
## token endid
##      token endid { <?before <-[ \- \' \w ]> > }

sub endid__PEEK { $_[0]->_AUTOLEXpeek('endid',$retree) }
sub endid {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "endid", 
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[^\-\'\w]/)
})
);
}
## token spacey
##      token spacey { <?before <[ \s \# ]> > }

sub spacey__PEEK { $_[0]->_AUTOLEXpeek('spacey',$retree) }
sub spacey {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "spacey", 
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\s\#]/)
})
);
}
## token nofun
##      token nofun { <!before '(' | '.(' | '\\' > }

sub nofun__PEEK { $_[0]->_AUTOLEXpeek('nofun',$retree) }
sub nofun {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nofun", 
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'nofun_01') {
$C->deb("Fate passed to nofun_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'nofun_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nofun_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_EXACT('.(')
},
sub { my $C=shift;
$C->_EXACT('\\')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
);
}

# Lexical routines

## token ws
##      token ws {
##          :my @stub = return self if @*MEMOS[self.pos]<ws> :exists;
##          :my $startpos = self.pos;
##      
##          :dba('whitespace')
##          [
##              | \h+ <![#\s\\]> { @*MEMOS[$.pos]<ws> = $startpos; }   # common case
##              | <?before \w> <?after \w> :::
##                  { @*MEMOS[$startpos]<ws> = undef; }
##                  <.panic: "Whitespace is required between alphanumeric tokens">        # must \s+ between words
##          ]
##          ||
##          [
##          | <.unsp>
##          | <.vws> <.heredoc>
##          | <.unv>
##          | $ { $.moreinput }
##          ]*
##      
##          {{
##              if ($.pos == $startpos) {
##                  @*MEMOS[$.pos]<ws> = undef;
##              }
##              else {
##                  @*MEMOS[$.pos]<ws> = $startpos;
##                  @*MEMOS[$.pos]<endstmt> = @*MEMOS[$startpos]<endstmt>
##                      if @*MEMOS[$startpos]<endstmt> :exists;
##              }
##          }}
##      }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $::MEMOS[$self->{'_pos'}]{'ws'};
my $startpos = $self->{'_pos'};


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "ws", 
do { my @gather;
eval { push @gather, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_01') {
$C->deb("Fate passed to ws_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[#\s\\]/)
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]{'ws'} = $startpos; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Whitespace is required between alphanumeric tokens")
}, scalar(do {
$::MEMOS[$startpos]{'ws'} = undef; 
}, $C))
}, $C->_COMMITRULE())
}, $C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
scalar(do {

if (($C->{'_pos'} == $startpos)) {
$::MEMOS[$C->{'_pos'}]{'ws'} = undef;
}
else {
$::MEMOS[$C->{'_pos'}]{'ws'} = $startpos;
$::MEMOS[$C->{'_pos'}]{'endstmt'} = $::MEMOS[$startpos]{'endstmt'}
if exists $::MEMOS[$startpos]{'endstmt'};
}

}, $C)
}, $C->_STARr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_05') {
$C->deb("Fate passed to ws_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->heredoc
}, $C->vws)
},
sub { my $C=shift;
$C->unv
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$C->moreinput 
}, $C)
}, $C->_PATTERN(qr/\G\z/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))} or do { die $@ if $@ };
@gather;
}
);
}

## token unsp
##      token unsp {
##          \\ <?before [\s|'#'] >
##          :dba('unspace')
##          [
##          | <.vws>                     {*}                             #= vwhite
##          | <.unv>                  {*}                                #= unv
##          | $ { $.moreinput }
##          ]*
##      }

sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp',$retree) }
sub unsp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unsp", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_02') {
$C->deb("Fate passed to unsp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_03') {
$C->deb("Fate passed to unsp_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->vws)) {
$C->_REDUCE($S, 'unsp', 'vwhite');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->unv)) {
$C->_REDUCE($S, 'unsp', 'unv');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token vws
##      token vws {
##          :dba('vertical whitespace')
##          \v
##          [ '#DEBUG -1' { say "DEBUG"; $STD::DEBUG = $*DEBUG = -1; } ]?
##      }

sub vws__PEEK { $_[0]->_AUTOLEXpeek('vws',$retree) }
sub vws {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "vws", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\n]/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('#DEBUG -1'))) {
scalar(do {
say "DEBUG"; $STD::DEBUG = $::DEBUG = -1; 
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# We provide two mechanisms here:
# 1) define $*moreinput, or
# 2) override moreinput method
## method moreinput ()
sub moreinput {
my $self = shift;


$::moreinput->() if $::moreinput;
}

## token unv
##      token unv {
##         :dba('horizontal whitespace')
##         [
##         | \h+                 {*}                                    #= hwhite
##         | <?before '='> ^^ <.pod_comment>  {*}                    #= pod
##         | \h* '#' [
##               |  <?opener>
##                  [ <!after ^^ . > || <.panic: "Can't use embedded comments in column 1"> ]
##                  <.quibble($.cursor_fresh( %*LANG<Q> ))>   {*}                               #= embedded
##               | {} \N*            {*}                                 #= end
##               ]
##          ]
##      }

sub unv__PEEK { $_[0]->_AUTOLEXpeek('unv',$retree) }
sub unv {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unv", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_01') {
$C->deb("Fate passed to unv_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
$C->_REDUCE($S, 'unv', 'hwhite');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:^)/))) {
do {
if (my ($C) = ($C->pod_comment)) {
$C->_REDUCE($S, 'unv', 'pod');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('#'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_03') {
$C->deb("Fate passed to unv_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->opener
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=(?s:.))(?m:^)/)
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Can't use embedded comments in column 1")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->quibble($C->cursor_fresh( $::LANG{'Q'} )))) {
$C->_REDUCE($S, 'unv', 'embedded');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))) {
$C->_REDUCE($S, 'unv', 'end');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token ident
##      token ident {
##          <.alpha> \w*
##      }

sub ident__PEEK { $_[0]->_AUTOLEXpeek('ident',$retree) }
sub ident {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "ident", 
$C->_PATTERN(qr/\G[_[:alpha:]]((?:\w)*+)/)
);
}

## token apostrophe
##      token apostrophe {
##          <[ ' \- ]>
##      }

sub apostrophe__PEEK { $_[0]->_AUTOLEXpeek('apostrophe',$retree) }
sub apostrophe {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "apostrophe", 
$C->_PATTERN(qr/\G['\-]/)
);
}

## token identifier
##      token identifier {
##          <.ident> [ <.apostrophe> <.ident> ]*
##      }

sub identifier__PEEK { $_[0]->_AUTOLEXpeek('identifier',$retree) }
sub identifier {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "identifier", 
do {
if (my ($C) = ($C->ident)) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->apostrophe)) {
$C->ident;
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# XXX We need to parse the pod eventually to support $= variables.

## token pod_comment
##      token pod_comment {
##          ^^ '=' <.unsp>?
##          [
##          | 'begin' \h+ <identifier> ::
##              [
##              ||  .*? "\n=" <.unsp>? 'end' \h+ $<identifier>  \N*          {*} #= tagged
##              ||  <?{ $<identifier>.Str eq 'END'}> .*                           {*} #= end
##              || { my $id = $<identifier>.Str; self.panic("=begin $id without matching =end $id"); }
##              ]
##          | 'begin'  :: \h* [ $$ || '#' || <.panic: "Unrecognized token after =begin"> ]
##              [ .*?  "\n=" <.unsp>? 'end'  \N* || { self.panic("=begin without matching =end"); } ]   {*}       #= anon
##              
##          | 'for'  :: \h* [ <identifier> || $$ || '#' || <.panic: "Unrecognized token after =for"> ]
##              [.*?  ^^ \h* $$ || .*]
##          | :: 
##              [ <?before .*? ^^ '=cut'  > <.panic: "Obsolete pod format, please use =begin/=end instead"> ]?
##              \N*                                           {*}       #= misc
##          ]
##      }

sub pod_comment__PEEK { $_[0]->_AUTOLEXpeek('pod_comment',$retree) }
sub pod_comment {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "pod_comment", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pod_comment_01') {
$C->deb("Fate passed to pod_comment_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pod_comment_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pod_comment_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment', 'tagged')
}, $C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}, $C->_PATTERN(qr/\G\b/))
}, $C->_BACKREFn('identifier'))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G\n=/))
}, $C->_SCANf())} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment', 'end')
}, $C->_SCANg())
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'identifier'}->Str eq 'END';
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
my $M = $C;  my $id = $M->{'identifier'}->Str; $self->panic("=begin $id without matching =end $id"); ;
}, $C)} or do { die $@ if $@ };
@gather;
}
})
}, $C->_COMMITBRANCH())
}, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))
}, $C->_EXACT('begin'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment', 'anon')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G\n=/))
}, $C->_SCANf())} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
$self->panic("=begin without matching =end"); 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?m:$)/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_EXACT('#')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unrecognized token after =begin")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('begin'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?m:$)/)
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_PATTERN(qr/\G(?m:^)/))
}, $C->_SCANf())} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SCANg()} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUME(['identifier'], sub {
my $C = shift;
$C->identifier
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_PATTERN(qr/\G(?m:$)/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_EXACT('#')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unrecognized token after =for")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('for'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment', 'misc')
}, $C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Obsolete pod format, please use =begin/=end instead")
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G\b/)
}, $C->_EXACT('=cut'))
}, $C->_PATTERN(qr/\G(?m:^)/))
}, $C->_SCANf())
}))
})
}))
}, $C->_COMMITBRANCH())
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_EXACT('='))
}, $C->_PATTERN(qr/\G(?m:^)/))
);
}

# Top-level rules

# Note: we only check for the stopper.  We don't check for ^ because
# we might be embedded in something else.
## rule comp_unit
##      rule comp_unit {
##          :my $begin_compunit is context = 1;
##          :my $endargs        is context<rw> = -1;
##          :my %LANG is context;
##          :my $PKGDECL is context = "";
##          :my $PKGNAME is context = "GLOBAL";
##          :my @PKGS is context<rw> = ();
##          :my $IN_DECL is context<rw>;
##          :my $INTERPOLATION is context<rw> = '';
##          :my $IN_META is context<rw> = 0;
##          :my $QUASI_QUASH is context<rw>;
##          :my $SCOPE is context = "";
##          :my $SIGIL is context<rw>;
##          :my %MYSTERY is context<rw> = ();
##          :my @MEMOS is context;
##          :my $VOID is context<rw>;
##          :my $INVOCANT_OK is context<rw>;
##          :my $INVOCANT_IS is context<rw>;
##          :my $CURPAD is context<rw>;
##          :my $REALLYADD is context<rw> = 0;
##          :my $MULTINESS is context = '';
##      
##          :my $CORE is context;
##          :my $CORESETTING is context = "CORE";
##          :my $GLOBAL is context;
##          :my $CURPKG is context;
##          :my $UNIT is context;
##          {{
##      
##              %*LANG<MAIN>    = ::STD ;
##              %*LANG<Q>       = ::STD::Q ;
##              %*LANG<Quasi>   = ::STD::Quasi ;
##              %*LANG<Regex>   = ::STD::Regex ;
##              %*LANG<Trans>   = ::STD::Trans ;
##              %*LANG<P5Regex> = ::STD::P5Regex ;
##      
##              @COMPILING::WORRIES = ();
##              self.load_setting($*CORESETTING);
##              $*UNIT = self.newpad;
##              self.finishpad(1);
##          }}
##          <statementlist>
##          [ <?unitstopper> || <.panic: "Can't understand next input--giving up"> ]
##      #    { $<CORE> = $*CORE; }
##          # "CHECK" time...
##          {{
##              if @COMPILING::WORRIES {
##                  warn "Potential difficulties:\n  " ~ join( "\n  ", @COMPILING::WORRIES) ~ "\n";
##              }
##              my $m = $.explain_mystery();
##              warn $m if $m;
##          }}
##      }

sub comp_unit__PEEK { $_[0]->_AUTOLEXpeek('comp_unit',$retree) }
sub comp_unit {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::begin_compunit = 1;
local $::endargs = -1;
local %::LANG;
local $::PKGDECL = "";
local $::PKGNAME = "GLOBAL";
local @::PKGS = ();
local $::IN_DECL;
local $::INTERPOLATION = '';
local $::IN_META = 0;
local $::QUASI_QUASH;
local $::SCOPE = "";
local $::SIGIL;
local %::MYSTERY = ();
local @::MEMOS;
local $::VOID;
local $::INVOCANT_OK;
local $::INVOCANT_IS;
local $::CURPAD;
local $::REALLYADD = 0;
local $::MULTINESS = '';
local $::CORE;
local $::CORESETTING = "CORE";
local $::GLOBAL;
local $::CURPKG;
local $::UNIT;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "comp_unit", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {


$::LANG{'MAIN'}    = 'STD' ;
$::LANG{'Q'}       = 'STD::Q' ;
$::LANG{'Quasi'}   = 'STD::Quasi' ;
$::LANG{'Regex'}   = 'STD::Regex' ;
$::LANG{'Trans'}   = 'STD::Trans' ;
$::LANG{'P5Regex'} = 'STD::P5Regex' ;

@COMPILING::WORRIES = ();
$self->load_setting($::CORESETTING);
$::UNIT = $self->newpad;
$self->finishpad(1);

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->unitstopper
}))) {
$C->ws;
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Can't understand next input--giving up"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

if (@COMPILING::WORRIES) {
warn "Potential difficulties:\n  " . join( "\n  ", @COMPILING::WORRIES) . "\n";
}
my $m = $C->explain_mystery();
warn $m if $m;

}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## method explain_mystery()
sub explain_mystery {
my $self = shift;


my %post_types;
my %unk_types;
my %unk_routines;
my $m = '';
for (keys(%::MYSTERY)) {
my $p = $::MYSTERY{$_}->{'pad'};
if ($self->is_name($_, $p)) {
# types may not be post-declared
$post_types{$_} = $::MYSTERY{$_};
next;
}

next if $self->is_known($_, $p) or $self->is_known('&' . $_, $p);

# just a guess, but good enough to improve error reporting
if ($_ lt 'a') {
$unk_types{$_} = $::MYSTERY{$_};
}
else {
$unk_routines{$_} = $::MYSTERY{$_};
}
}
if (%post_types) {
my @tmp = sort keys(%post_types);
$m .= "Illegally post-declared type" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t$_ used at " . $post_types{$_}->{'line'} . "\n";
}
}
if (%unk_types) {
my @tmp = sort keys(%unk_types);
$m .= "Undeclared name" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t$_ used at " . $unk_types{$_}->{'line'} . "\n";
}
}
if (%unk_routines) {
my @tmp = sort keys(%unk_routines);
$m .= "Undeclared routine" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t$_ used at " . $unk_routines{$_}->{'line'} . "\n";
}
}
$m;
}

# Note: because of the possibility of placeholders we can't determine arity of
# the block syntactically, so this must be determined via semantic analysis.
# Also, pblocks used in an if/unless statement do not treat $_ as a placeholder,
# while most other blocks treat $_ as equivalent to $^x.  Therefore the first
# possible place to check arity is not here but in the rule that calls this
# rule.  (Could also be done in a later pass.)

## token pblock ($CURPAD is context<rw> = $*CURPAD)
##      token pblock ($CURPAD is context<rw> = $*CURPAD) {
##          :dba('parameterized block')
##          [<?before <.lambda> | '{' > ||
##              {{
##                  if $*BORG and $*BORG.<block> {
##                      if $*BORG.<name> {
##                          my $m = "Function '" ~ $BORG.<name> ~ "' needs parens to avoid gobbling block" ~ $*BORG.<culprit>.locmess;
##                          $*BORG.<block>.panic($m ~ "\nMissing block (apparently gobbled by '" ~ $BORG.<name> ~ "')");
##                      }
##                      else {
##                          my $m = "Expression needs parens to avoid gobbling block" ~ $*BORG.<culprit>.locmess;
##                          $*BORG.<block>.panic($m ~ "\nMissing block (apparently gobbled by expression)");
##                      }
##                  }
##                  elsif %*MYSTERY {
##                      $.panic("Missing block (apparently gobbled by undeclared routine?)");
##                  }
##                  else {
##                      $.panic("Missing block");
##                  }
##              }}
##          ]
##          [
##          | <lambda>
##              <.newpad>
##              <signature>
##              <blockoid>
##          | <?before '{'>
##              <.newpad>
##              <blockoid>
##          ]
##      }

sub pblock__PEEK { $_[0]->_AUTOLEXpeek('pblock',$retree) }
sub pblock {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "pblock", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_02') {
$C->deb("Fate passed to pblock_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pblock_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pblock_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->lambda
},
sub { my $C=shift;
$C->_EXACT('{')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {

if ($::BORG and $BORG->{'block'}) {
if ($BORG->{'name'}) {
my $m = "Function '" . $BORG->{'name'} . "' needs parens to avoid gobbling block" . $BORG->{'culprit'}->locmess;
$BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by '" . $BORG->{'name'} . "')");
}
else {
my $m = "Expression needs parens to avoid gobbling block" . $BORG->{'culprit'}->locmess;
$BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by expression)");
}
}
elsif (%::MYSTERY) {
$C->panic("Missing block (apparently gobbled by undeclared routine?)");
}
else {
$C->panic("Missing block");
}

}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_04') {
$C->deb("Fate passed to pblock_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pblock_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pblock_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['lambda'], sub {
my $C = shift;
$C->lambda
}))) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->newpad)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token lambda
##      token lambda { '->' | '<->' }

sub lambda__PEEK { $_[0]->_AUTOLEXpeek('lambda',$retree) }
sub lambda {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "lambda", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'lambda_00') {
$C->deb("Fate passed to lambda_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'lambda_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("lambda_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('->')
},
sub { my $C=shift;
$C->_EXACT('<->')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

# Look for an expression followed by a required lambda.
## token xblock
##      token xblock {
##          :my $GOAL is context = '{';
##          :my $BORG is context = {};
##          <EXPR>
##          { $BORG.<culprit> //= $<EXPR>.cursor(self.pos) }
##          <.ws>
##          <pblock>
##      }

sub xblock__PEEK { $_[0]->_AUTOLEXpeek('xblock',$retree) }
sub xblock {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL = '{';
local $::BORG = {};


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "xblock", 
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $BORG->{'culprit'} //= $M->{'EXPR'}->cursor($self->{'_pos'}) ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token block ($CURPAD is context<rw> = $*CURPAD)
##      token block ($CURPAD is context<rw> = $*CURPAD) {
##          :dba('scoped block')
##          <?before '{' >
##          <.newpad>
##          <blockoid>
##      }

sub block__PEEK { $_[0]->_AUTOLEXpeek('block',$retree) }
sub block {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "block", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->newpad)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token blockoid
##      token blockoid {
##          # temporize braided languages
##          :temp %*LANG;
##      
##          <.finishpad>
##          [
##          | '{' ~ '}' <statementlist>
##          | <?terminator> <.panic: 'Missing block'>
##          | <?> <.panic: "Malformed block">
##          ]
##      
##          [
##          | <?before \h* $$>  # (usual case without comments)
##              { @*MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt simple 
##          | \h* <?before <[\\,:]>> {*}                         #= normal 
##          | <.unv>? $$
##              { @*MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt complex
##          | {} <.unsp>? { @*MEMOS[$.pos]<endargs> = 1; } {*}             #= endargs
##          ]
##      }

sub blockoid__PEEK { $_[0]->_AUTOLEXpeek('blockoid',$retree) }
sub blockoid {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local %::LANG = %::LANG;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "blockoid", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blockoid_02') {
$C->deb("Fate passed to blockoid_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'blockoid_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("blockoid_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid', 'endstmt simple ')
}, scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} = 2; 
}, $C))
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?m:$)/)
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid', 'normal ')
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\\,:]/)
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid', 'endstmt complex')
}, scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} = 2; 
}, $C))
}, $C->_PATTERN(qr/\G(?m:$)/))
}, $C->_OPTr(sub { my $C=shift;
$C->unv
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid', 'endargs')
}, scalar(do {
$::MEMOS[$C->{'_pos'}]{'endargs'} = 1; 
}, $C))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, scalar(do {

}, $C))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blockoid_01') {
$C->deb("Fate passed to blockoid_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'blockoid_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("blockoid_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}' , 'blockoid')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic('Missing block')
}, $C->before( sub { my $C=shift;
$C->terminator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Malformed block")
}, $C->before( sub { my $C=shift;
$C
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->finishpad)
);
}

## token regex_block
##      token regex_block {
##          # temporize braided languages
##          :temp %*LANG;
##      
##          :my $lang = %*LANG<Regex>;
##          :my $GOAL is context = '}';
##      
##          [ <quotepair> <.ws>
##              {
##                  my $kv = $<quotepair>[*-1];
##                  $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                      or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##              }
##          ]*
##      
##          '{'
##          <nibble( $.cursor_fresh($lang).unbalanced('}') )>
##          [ '}' || <.panic: "Unable to parse regex; couldn't find right brace"> ]
##      
##          [
##          | <?before \h* $$>  # (usual case without comments)
##              { @*MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt simple 
##          | \h* <?before <[\\,:]>> {*}                         #= normal 
##          | <.unv>? $$
##              { @*MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt complex
##          | {} <.unsp>? { @*MEMOS[$.pos]<endargs> = 1; }   {*}           #= endargs
##          ]
##      }

sub regex_block__PEEK { $_[0]->_AUTOLEXpeek('regex_block',$retree) }
sub regex_block {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local %::LANG = %::LANG;
my $lang = $::LANG{'Regex'};
local $::GOAL = '}';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "regex_block", 
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{'quotepair'}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh($lang)->unbalanced('}') )
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_block_04') {
$C->deb("Fate passed to regex_block_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_block_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_block_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[\x20\t\r])*+)(?m:$)/)
}))) {
do {
if (my ($C) = (scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} = 2; 
}, $C))) {
$C->_REDUCE($S, 'regex_block', 'endstmt simple ');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\\,:]/)
}))) {
$C->_REDUCE($S, 'regex_block', 'normal ');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unv
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:$)/))) {
do {
if (my ($C) = (scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} = 2; 
}, $C))) {
$C->_REDUCE($S, 'regex_block', 'endstmt complex');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = (scalar(do {
$::MEMOS[$C->{'_pos'}]{'endargs'} = 1; 
}, $C))) {
$C->_REDUCE($S, 'regex_block', 'endargs');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# statement semantics
## rule statementlist
##      rule statementlist {
##          :my $INVOCANT_OK is context<rw> = 0;
##          :dba('statement list')
##      
##          [
##          | $
##          | <?before <[\)\]\}]> >
##          | [<statement><eat_terminator> ]*
##          ]
##      }

sub statementlist__PEEK { $_[0]->_AUTOLEXpeek('statementlist',$retree) }
sub statementlist {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK = 0;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "statementlist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statementlist_01') {
$C->deb("Fate passed to statementlist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statementlist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statementlist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\)\]\}]/))) {
$C->ws;
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# embedded semis, context-dependent semantics
## rule semilist
##      rule semilist {
##          :my $INVOCANT_OK is context<rw> = 0;
##          :dba('semicolon list')
##          [
##          | <?before <[\)\]\}]> >
##          | [<statement><eat_terminator> ]*
##          ]
##      }

sub semilist__PEEK { $_[0]->_AUTOLEXpeek('semilist',$retree) }
sub semilist {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK = 0;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "semilist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'semilist_01') {
$C->deb("Fate passed to semilist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'semilist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("semilist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\)\]\}]/))) {
$C->ws;
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token label
##      token label {
##          :my $label;
##          <identifier> ':' <?before \s> <.ws>
##      
##          [ <?{ $.is_name($label = $<identifier>.Str) }>
##            <.panic("Illegal redeclaration of '$label'")>
##          ]?
##      
##          # add label as a pseudo type
##          {{ $.add_my_name($label); }}
##      
##      }

sub label__PEEK { $_[0]->_AUTOLEXpeek('label',$retree) }
sub label {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $label;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "label", 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $C->is_name($label = $M->{'identifier'}->Str) ;
})
}))) {
$C->panic("Illegal redeclaration of '$label'");
}
else {
();
}
}
})
}))) {
scalar(do {
$C->add_my_name($label); 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement
##      token statement {
##          :my $endargs is context = -1;
##          :my $INTERPOLATION is context<rw> = 0;
##          <!before <[\)\]\}]> >
##      
##          # this could either be a statement that follows a declaration
##          # or a statement that is within the block of a code declaration
##          <!!{ $ = %*LANG<MAIN>.bless($); }>
##      
##          [
##          | <label> <statement>                        {*}            #= label
##          | <statement_control>                        {*}            #= control
##          | <EXPR> {*}                                                #= expr
##              :dba('statement end')
##              [
##              || <?{ (@*MEMOS[$.pos]<endstmt> // 0) == 2 }>   # no mod after end-line curly
##              ||
##                  :dba('statement modifier')
##                  <.ws>
##                  [
##                  | <statement_mod_loop> {*}                              #= mod loop
##                      {{
##                          my $sp = $<EXPR><statement_prefix>;
##                          if $sp and $sp<sym> eq 'do' {
##                             my $s = $<statement_mod_loop>[0]<sym>;
##                             $.obs("do...$s" ,"repeat...$s");
##                          }
##                      }}
##                  | <statement_mod_cond> {*}                              #= mod cond
##                      :dba('statement modifier loop')
##                      [
##                      || <?{ (@*MEMOS[$.pos]<endstmt> // 0) == 2 }>
##                      || <.ws> <statement_mod_loop>? {*}                  #= mod condloop
##                      ]
##                  ]?
##              ]
##              {*}                                                     #= modexpr
##          | <?before ';'> {*}                                         #= null
##          ]
##      
##          # Is there more on same line after a block?
##          [ <?{ (@*MEMOS[@*MEMOS[$.pos]<ws>//$.pos]<endargs>//0) == 1 }>
##              \h*
##              <!before ';' | ')' | ']' | '}' >
##              <!infixstopper>
##              <.panic: "Statements must be separated with semicolon">
##          ]?
##      }

sub statement__PEEK { $_[0]->_AUTOLEXpeek('statement',$retree) }
sub statement {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::endargs = -1;
local $::INTERPOLATION = 0;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'statement_mod_loop'} = [];
$C->{'statement_mod_cond'} = [];

$self->_MATCHIFYr($S, "statement", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$C = $::LANG{'MAIN'}->bless($C); 
})
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_02') {
$C->deb("Fate passed to statement_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['label'], sub {
my $C = shift;
$C->label
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_REDUCE($S, 'statement', 'label');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
}))) {
$C->_REDUCE($S, 'statement', 'control');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement', 'expr'))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]{'endstmt'} // 0) == 2 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_05') {
$C->deb("Fate passed to statement_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement', 'mod loop'))) {
scalar(do {
my $M = $C; 
my $sp = $M->{'EXPR'}{'statement_prefix'};
if ($sp and $sp->{'sym'} eq 'do') {
my $s = $M->{'statement_mod_loop'}[0]{'sym'};
$C->obs("do...$s" ,"repeat...$s");
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_cond'], sub {
my $C = shift;
$C->statement_mod_cond
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement', 'mod cond'))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]{'endstmt'} // 0) == 2 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
})
}))) {
$C->_REDUCE($S, 'statement', 'mod condloop');
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'statement', 'modexpr');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(';')
}))) {
$C->_REDUCE($S, 'statement', 'null');
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$::MEMOS[$C->{'_pos'}]{'ws'}//$C->{'_pos'}]{'endargs'}//0) == 1 
})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_10') {
$C->deb("Fate passed to statement_10: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_10', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_10 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(';')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('}')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
$C->panic("Statements must be separated with semicolon");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token eat_terminator
##      token eat_terminator {
##          [
##          || ';'
##          || <?{ @*MEMOS[$.pos]<endstmt> }> <.ws>
##          || <?terminator>
##          || $
##          || {{ if @*MEMOS[$.pos]<ws> { $.pos = @*MEMOS[$.pos]<ws>; } }}   # undo any line transition
##              <.panic: "Syntax error">
##          ]
##      }

sub eat_terminator__PEEK { $_[0]->_AUTOLEXpeek('eat_terminator',$retree) }
sub eat_terminator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "eat_terminator", 
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(';')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} 
})
}))) {
$C->ws;
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->before( sub { my $C=shift;
$C->terminator
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_PATTERN(qr/\G\z/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
if ($::MEMOS[$C->{'_pos'}]{'ws'}) { $C->{'_pos'} = $::MEMOS[$C->{'_pos'}]{'ws'}; } 
}, $C))) {
$C->panic("Syntax error");
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
})
);
}

## token statement_control__S_036need (:$endsym is context = 'spacey', :$sym is context<rw> = 'need')
##      token statement_control:need {
##          :my $longname;
##          <sym>:s
##          [
##          |<version>
##          |<module_name>
##              {{
##                  my $SCOPE is context = 'use';
##                  $longname = $<module_name>[*-1]<longname>.Str;
##                  $.do_imports($longname, '');
##              }}
##          ] ** ','
##      }

sub statement_control__S_036need__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_036need',$retree) }
sub statement_control__S_036need {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'need';
my $longname;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'version'} = [];
$C->{'module_name'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_036need", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gneed/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_036need_01') {
$C->deb("Fate passed to statement_control__S_036need_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_036need_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_036need_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
local $::SCOPE = 'use';
$longname = $M->{'module_name'}[-1]{'longname'}->Str;
$C->do_imports($longname, '');
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_control__S_037use (:$endsym is context = 'spacey', :$sym is context<rw> = 'use')
##      token statement_control:use {
##          :my $longname;
##          :my $SCOPE is context = 'use';
##          <sym> <.ws>
##          [
##          | <version>
##          | <module_name>
##              {{
##                  $longname = $<module_name><longname>.Str;
##              }}
##              [
##              || <.spacey> <arglist>
##                  {{
##                      # XXX cheat on import list for now
##                      $.do_imports($longname, $<arglist>);
##                  }}
##              || {{ $.do_imports($longname, ''); }}
##              ]
##          ]
##          <.ws>
##      }

sub statement_control__S_037use__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_037use',$retree) }
sub statement_control__S_037use {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'use';
my $longname;
local $::SCOPE = 'use';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_037use", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guse/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_037use_01') {
$C->deb("Fate passed to statement_control__S_037use_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_037use_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_037use_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$longname = $M->{'module_name'}{'longname'}->Str;
;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C; 
# XXX cheat on import list for now
$C->do_imports($longname, $M->{'arglist'});
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
$C->do_imports($longname, ''); 
}, $C)} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_038no (:$endsym is context = 'spacey', :$sym is context<rw> = 'no')
##      token statement_control:no {
##          <sym> <.ws>
##          <module_name>[<.spacey><arglist>]?
##          <.ws>
##      }

sub statement_control__S_038no__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_038no',$retree) }
sub statement_control__S_038no {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'no';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_038no", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gno/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
});
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_039if (:$endsym is context = 'spacey', :$sym is context<rw> = 'if')
##      token statement_control:if {
##          <sym> :s
##          <xblock>
##          [
##              [ <!before 'else'\s*'if'> || <.panic: "Please use 'elsif'"> ]
##              'elsif'<?spacey> <elsif=xblock>       {*}                #= elsif
##          ]*
##          [
##              'else'<?spacey> <else=pblock>       {*}             #= else
##          ]?
##      }

sub statement_control__S_039if__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_039if',$retree) }
sub statement_control__S_039if {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'if';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'else'} = [];
$C->{'elsif'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_039if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('else'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
$C->_EXACT('if');
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Please use 'elsif'"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('elsif'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['elsif'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_039if', 'elsif'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('else'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['else'], sub {
my $C = shift;
$C->pblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_039if', 'else'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_040unless (:$endsym is context = 'spacey', :$sym is context<rw> = 'unless')
##      token statement_control:unless {
##          <sym> :s
##          <xblock>
##          [ <!before 'else'> || <.panic: "unless does not take \"else\" in Perl 6; please rewrite using \"if\""> ]
##      }

sub statement_control__S_040unless__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_040unless',$retree) }
sub statement_control__S_040unless {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'unless';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_040unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('else')
})
}))) {
$C->ws;
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("unless does not take \"else\" in Perl 6; please rewrite using \"if\""))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_041while (:$endsym is context = 'spacey', :$sym is context<rw> = 'while')
##      token statement_control:while {
##          <sym> :s
##          [ <?before '(' ['my'? '$'\w+ '=']? '<' '$'?\w+ '>' ')'>   #'
##              <.panic: "This appears to be Perl 5 code"> ]?
##          <xblock>
##      }

sub statement_control__S_041while__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_041while',$retree) }
sub statement_control__S_041while {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'while';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_041while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT('=');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('$')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_042until (:$endsym is context = 'spacey', :$sym is context<rw> = 'until')
##      token statement_control:until {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_042until__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_042until',$retree) }
sub statement_control__S_042until {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'until';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_042until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_043repeat (:$endsym is context = 'spacey', :$sym is context<rw> = 'repeat')
##      token statement_control:repeat {
##          <sym> :s
##          [
##              | ('while'|'until')
##                <xblock>
##              | <block>                      {*}                      #= block wu
##                ('while'|'until') <EXPR>         {*}                      #= expr wu
##          ]
##      }

sub statement_control__S_043repeat__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_043repeat',$retree) }
sub statement_control__S_043repeat {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'repeat';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_043repeat", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grepeat/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_043repeat_01') {
$C->deb("Fate passed to statement_control__S_043repeat_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_043repeat_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_043repeat_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_043repeat_02') {
$C->deb("Fate passed to statement_control__S_043repeat_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_043repeat_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_043repeat_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_043repeat', 'block wu'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_043repeat_03') {
$C->deb("Fate passed to statement_control__S_043repeat_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_043repeat_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_043repeat_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_043repeat', 'expr wu'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_control__S_044loop (:$endsym is context = 'spacey', :$sym is context<rw> = 'loop')
##      token statement_control:loop {
##          <sym> :s
##          $<eee> = (
##              '('
##                  <e1=EXPR>? ';'   {*}                            #= e1
##                  <e2=EXPR>? ';'   {*}                            #= e2
##                  <e3=EXPR>?       {*}                            #= e3
##              ')'                      {*}                            #= eee
##          )?
##          <block>                     {*}                             #= block
##      }

sub statement_control__S_044loop__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_044loop',$retree) }
sub statement_control__S_044loop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'loop';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_044loop", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gloop/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['eee'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e1','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop', 'e1'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e2','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop', 'e2'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e3','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop', 'e3'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(')'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop', 'eee'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop', 'block'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_045for (:$endsym is context = 'spacey', :$sym is context<rw> = 'for')
##      token statement_control:for {
##          <sym> :s
##          [ <?before 'my'? '$'\w+ '(' >
##              <.panic: "This appears to be Perl 5 code"> ]?
##          [ <?before '(' <.EXPR>? ';' <.EXPR>? ';' <.EXPR>? ')' >
##              <.obs('C-style "for (;;)" loop', '"loop (;;)"')> ]?
##          <xblock>
##      }

sub statement_control__S_045for__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_045for',$retree) }
sub statement_control__S_045for {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'for';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_045for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(')'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->obs('C-style "for (;;)" loop', '"loop (;;)"'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_control__S_046given (:$endsym is context = 'spacey', :$sym is context<rw> = 'given')
##      token statement_control:given {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_046given__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_046given',$retree) }
sub statement_control__S_046given {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'given';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_046given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_control__S_047when (:$endsym is context = 'spacey', :$sym is context<rw> = 'when')
##      token statement_control:when {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_047when__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_047when',$retree) }
sub statement_control__S_047when {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'when';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_047when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_048default (:$endsym is context = 'spacey', :$sym is context<rw> = 'default')
##      rule statement_control:default {<sym> <block> }

sub statement_control__S_048default__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_048default',$retree) }
sub statement_control__S_048default {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'default';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_048default", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdefault/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_control__S_049BEGIN (:$endsym is context = 'spacey', :$sym is context<rw> = 'BEGIN')
##      rule statement_control:BEGIN   {<sym> <block> }

sub statement_control__S_049BEGIN__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_049BEGIN',$retree) }
sub statement_control__S_049BEGIN {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'BEGIN';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_049BEGIN", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GBEGIN/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_050CHECK (:$endsym is context = 'spacey', :$sym is context<rw> = 'CHECK')
##      rule statement_control:CHECK   {<sym> <block> }

sub statement_control__S_050CHECK__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_050CHECK',$retree) }
sub statement_control__S_050CHECK {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CHECK';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_050CHECK", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCHECK/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_051INIT (:$endsym is context = 'spacey', :$sym is context<rw> = 'INIT')
##      rule statement_control:INIT    {<sym> <block> }

sub statement_control__S_051INIT__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_051INIT',$retree) }
sub statement_control__S_051INIT {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'INIT';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_051INIT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GINIT/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_052END (:$endsym is context = 'spacey', :$sym is context<rw> = 'END')
##      rule statement_control:END     {<sym> <block> }

sub statement_control__S_052END__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_052END',$retree) }
sub statement_control__S_052END {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'END';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_052END", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GEND/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_053START (:$endsym is context = 'spacey', :$sym is context<rw> = 'START')
##      rule statement_control:START   {<sym> <block> }

sub statement_control__S_053START__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_053START',$retree) }
sub statement_control__S_053START {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'START';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_053START", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GSTART/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_054ENTER (:$endsym is context = 'spacey', :$sym is context<rw> = 'ENTER')
##      rule statement_control:ENTER   {<sym> <block> }

sub statement_control__S_054ENTER__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_054ENTER',$retree) }
sub statement_control__S_054ENTER {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'ENTER';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_054ENTER", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GENTER/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_055LEAVE (:$endsym is context = 'spacey', :$sym is context<rw> = 'LEAVE')
##      rule statement_control:LEAVE   {<sym> <block> }

sub statement_control__S_055LEAVE__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_055LEAVE',$retree) }
sub statement_control__S_055LEAVE {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'LEAVE';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_055LEAVE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLEAVE/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_056KEEP (:$endsym is context = 'spacey', :$sym is context<rw> = 'KEEP')
##      rule statement_control:KEEP    {<sym> <block> }

sub statement_control__S_056KEEP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_056KEEP',$retree) }
sub statement_control__S_056KEEP {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'KEEP';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_056KEEP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GKEEP/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_057UNDO (:$endsym is context = 'spacey', :$sym is context<rw> = 'UNDO')
##      rule statement_control:UNDO    {<sym> <block> }

sub statement_control__S_057UNDO__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_057UNDO',$retree) }
sub statement_control__S_057UNDO {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'UNDO';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_057UNDO", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GUNDO/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_058FIRST (:$endsym is context = 'spacey', :$sym is context<rw> = 'FIRST')
##      rule statement_control:FIRST   {<sym> <block> }

sub statement_control__S_058FIRST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_058FIRST',$retree) }
sub statement_control__S_058FIRST {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'FIRST';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_058FIRST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GFIRST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_059NEXT (:$endsym is context = 'spacey', :$sym is context<rw> = 'NEXT')
##      rule statement_control:NEXT    {<sym> <block> }

sub statement_control__S_059NEXT__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_059NEXT',$retree) }
sub statement_control__S_059NEXT {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'NEXT';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_059NEXT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GNEXT/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_060LAST (:$endsym is context = 'spacey', :$sym is context<rw> = 'LAST')
##      rule statement_control:LAST    {<sym> <block> }

sub statement_control__S_060LAST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_060LAST',$retree) }
sub statement_control__S_060LAST {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'LAST';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_060LAST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLAST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_061PRE (:$endsym is context = 'spacey', :$sym is context<rw> = 'PRE')
##      rule statement_control:PRE     {<sym> <block> }

sub statement_control__S_061PRE__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_061PRE',$retree) }
sub statement_control__S_061PRE {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'PRE';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_061PRE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPRE/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_062POST (:$endsym is context = 'spacey', :$sym is context<rw> = 'POST')
##      rule statement_control:POST    {<sym> <block> }

sub statement_control__S_062POST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_062POST',$retree) }
sub statement_control__S_062POST {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'POST';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_062POST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPOST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_063CATCH (:$endsym is context = 'spacey', :$sym is context<rw> = 'CATCH')
##      rule statement_control:CATCH   {<sym> <block> }

sub statement_control__S_063CATCH__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_063CATCH',$retree) }
sub statement_control__S_063CATCH {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CATCH';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_063CATCH", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCATCH/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_064CONTROL (:$endsym is context = 'spacey', :$sym is context<rw> = 'CONTROL')
##      rule statement_control:CONTROL {<sym> <block> }

sub statement_control__S_064CONTROL__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_064CONTROL',$retree) }
sub statement_control__S_064CONTROL {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CONTROL';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_064CONTROL", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCONTROL/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_065TEMP (:$endsym is context = 'spacey', :$sym is context<rw> = 'TEMP')
##      rule statement_control:TEMP    {<sym> <block> }

sub statement_control__S_065TEMP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_065TEMP',$retree) }
sub statement_control__S_065TEMP {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'TEMP';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_065TEMP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GTEMP/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule term__S_066BEGIN (:$sym is context<rw> = 'BEGIN')
##      rule term:BEGIN   {<sym> <block> }

sub term__S_066BEGIN__PEEK { $_[0]->_AUTOLEXpeek('term__S_066BEGIN',$retree) }
sub term__S_066BEGIN {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'BEGIN';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_066BEGIN", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GBEGIN/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_067CHECK (:$sym is context<rw> = 'CHECK')
##      rule term:CHECK   {<sym> <block> }

sub term__S_067CHECK__PEEK { $_[0]->_AUTOLEXpeek('term__S_067CHECK',$retree) }
sub term__S_067CHECK {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'CHECK';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_067CHECK", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCHECK/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_068INIT (:$sym is context<rw> = 'INIT')
##      rule term:INIT    {<sym> <block> }

sub term__S_068INIT__PEEK { $_[0]->_AUTOLEXpeek('term__S_068INIT',$retree) }
sub term__S_068INIT {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'INIT';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_068INIT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GINIT/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_069START (:$sym is context<rw> = 'START')
##      rule term:START   {<sym> <block> }

sub term__S_069START__PEEK { $_[0]->_AUTOLEXpeek('term__S_069START',$retree) }
sub term__S_069START {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'START';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_069START", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GSTART/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_070ENTER (:$sym is context<rw> = 'ENTER')
##      rule term:ENTER   {<sym> <block> }

sub term__S_070ENTER__PEEK { $_[0]->_AUTOLEXpeek('term__S_070ENTER',$retree) }
sub term__S_070ENTER {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ENTER';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_070ENTER", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GENTER/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_071FIRST (:$sym is context<rw> = 'FIRST')
##      rule term:FIRST   {<sym> <block> }

sub term__S_071FIRST__PEEK { $_[0]->_AUTOLEXpeek('term__S_071FIRST',$retree) }
sub term__S_071FIRST {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'FIRST';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_071FIRST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GFIRST/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule modifier_expr
##      rule modifier_expr { <EXPR> }

sub modifier_expr__PEEK { $_[0]->_AUTOLEXpeek('modifier_expr',$retree) }
sub modifier_expr {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "modifier_expr", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_cond__S_072if (:$endsym is context = 'nofun', :$sym is context<rw> = 'if')
##      rule statement_mod_cond:if     {<sym> <modifier_expr> }

sub statement_mod_cond__S_072if__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_072if',$retree) }
sub statement_mod_cond__S_072if {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'if';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_072if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_cond__S_073unless (:$endsym is context = 'nofun', :$sym is context<rw> = 'unless')
##      rule statement_mod_cond:unless {<sym> <modifier_expr> }

sub statement_mod_cond__S_073unless__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_073unless',$retree) }
sub statement_mod_cond__S_073unless {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'unless';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_073unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_cond__S_074when (:$endsym is context = 'nofun', :$sym is context<rw> = 'when')
##      rule statement_mod_cond:when   {<sym> <modifier_expr> }

sub statement_mod_cond__S_074when__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_074when',$retree) }
sub statement_mod_cond__S_074when {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'when';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_074when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_loop__S_075while (:$endsym is context = 'nofun', :$sym is context<rw> = 'while')
##      rule statement_mod_loop:while {<sym> <modifier_expr> }

sub statement_mod_loop__S_075while__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_075while',$retree) }
sub statement_mod_loop__S_075while {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'while';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_075while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_loop__S_076until (:$endsym is context = 'nofun', :$sym is context<rw> = 'until')
##      rule statement_mod_loop:until {<sym> <modifier_expr> }

sub statement_mod_loop__S_076until__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_076until',$retree) }
sub statement_mod_loop__S_076until {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'until';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_076until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_loop__S_077for (:$endsym is context = 'nofun', :$sym is context<rw> = 'for')
##      rule statement_mod_loop:for   {<sym> <modifier_expr> }

sub statement_mod_loop__S_077for__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_077for',$retree) }
sub statement_mod_loop__S_077for {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'for';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_077for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_loop__S_078given (:$endsym is context = 'nofun', :$sym is context<rw> = 'given')
##      rule statement_mod_loop:given {<sym> <modifier_expr> }

sub statement_mod_loop__S_078given__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_078given',$retree) }
sub statement_mod_loop__S_078given {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'given';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_078given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token def_module_name
##      token def_module_name {
##          <longname>
##          [ :dba('generic role')
##              <?{ ($*PKGDECL//'') eq 'role' }>
##              <.newpad>
##              '[' ~ ']' <signature>
##              { $*IN_DECL = 0; }
##              <.finishpad>
##          ]?
##      }

sub def_module_name__PEEK { $_[0]->_AUTOLEXpeek('def_module_name',$retree) }
sub def_module_name {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'signature'} = [];

$self->_MATCHIFY($S, "def_module_name", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->finishpad
}, scalar(do {
$::IN_DECL = 0; 
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'generic role')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
}, $C->newpad)
}, $C->before( sub { my $C=shift;
(($C) x !!do {
($::PKGDECL//'') eq 'role' 
})
}))
})
})
}, $C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
);
}

## token module_name__S_079normal (:$sym is context<rw> = 'normal')
##      token module_name:normal {
##          <longname>
##          [ <?before '['> :dba('generic role') '[' ~ ']' <arglist> ]?
##      }

sub module_name__S_079normal__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_079normal',$retree) }
sub module_name__S_079normal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'normal';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "module_name__S_079normal", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'generic role')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['arglist'], sub {
my $C = shift;
$C->arglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
}, $C->before(sub { my $C=shift;
$C->_EXACT('[')
}))
})
})
}, $C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
);
}

## token module_name__S_080deprecated (:$sym is context<rw> = 'deprecated')
##      token module_name:deprecated { 'v6-alpha' }

sub module_name__S_080deprecated__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_080deprecated',$retree) }
sub module_name__S_080deprecated {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'deprecated';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "module_name__S_080deprecated", 
$C->_EXACT('v6-alpha')
);
}

## token vnum
##      token vnum {
##          \d+ | '*'
##      }

sub vnum__PEEK { $_[0]->_AUTOLEXpeek('vnum',$retree) }
sub vnum {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "vnum", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'vnum_00') {
$C->deb("Fate passed to vnum_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'vnum_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("vnum_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token version__S_081v (:$sym is context<rw> = <v>)
##      token version:sym<v> {
##          'v' <?before \d+> :: <vnum> ** '.' '+'?
##      }

sub version__S_081v__PEEK { $_[0]->_AUTOLEXpeek('version__S_081v',$retree) }
sub version__S_081v {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(v);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'vnum'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "version__S_081v", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('+')
})
}, $C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('.')
}, sub { my $C=shift;
$C->_SUBSUME(['vnum'], sub {
my $C = shift;
$C->vnum
})
}))
}, $C->_COMMITBRANCH())
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
}))
}, $C->_EXACT('v'))
);
}

###################################################

## token PRE
##      token PRE {
##          :dba('prefix or meta-prefix')
##          [
##          | <prefix>
##              { $<O> = $<prefix><O>; $<sym> = $<prefix><sym> }
##                                                          {*}         #= prefix
##          | <prefix_circumfix_meta_operator>
##              { $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.Str }
##                                                          {*}         #= precircum
##          ]
##          # XXX assuming no precedence change
##          
##          <prefix_postfix_meta_operator>*                 {*}         #= prepost
##          <.ws>
##      }

sub PRE__PEEK { $_[0]->_AUTOLEXpeek('PRE',$retree) }
sub PRE {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'prefix_postfix_meta_operator'} = [];

$self->_MATCHIFYr($S, "PRE", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'PRE_01') {
$C->deb("Fate passed to PRE_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'PRE_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("PRE_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix'], sub {
my $C = shift;
$C->prefix
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{'O'} = $M->{'prefix'}{'O'}; $M->{'sym'} = $M->{'prefix'}{'sym'} ;
}, $C))) {
$C->_REDUCE($S, 'PRE', 'prefix');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix_circumfix_meta_operator'], sub {
my $C = shift;
$C->prefix_circumfix_meta_operator
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{'O'} = $M->{'prefix_circumfix_meta_operator'}{'O'}; $M->{'sym'} = $M->{'prefix_circumfix_meta_operator'}->Str ;
}, $C))) {
$C->_REDUCE($S, 'PRE', 'precircum');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['prefix_postfix_meta_operator'], sub {
my $C = shift;
$C->prefix_postfix_meta_operator
})
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'PRE', 'prepost'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# (for when you want to tell EXPR that infix already parsed the term)
## token nullterm
##      token nullterm {
##          <?>
##      }

sub nullterm__PEEK { $_[0]->_AUTOLEXpeek('nullterm',$retree) }
sub nullterm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nullterm", 
$C->before( sub { my $C=shift;
$C
})
);
}

## token nulltermish
##      token nulltermish {
##          :dba('null term')
##          [
##          | <?stdstopper>
##          | <noun=termish>
##              {
##                  $.<PRE>  = $<noun><PRE>:delete;
##                  $.<POST> = $<noun><POST>:delete;
##                  $.<~CAPS> = $<noun><~CAPS>;
##              }
##          | <?>
##          ]
##      }

sub nulltermish__PEEK { $_[0]->_AUTOLEXpeek('nulltermish',$retree) }
sub nulltermish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nulltermish", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'nulltermish_01') {
$C->deb("Fate passed to nulltermish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'nulltermish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nulltermish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->termish
}))) {
scalar(do {
my $M = $C; 
$C->{'PRE'}  = delete $M->{'noun'}{'PRE'};
$C->{'POST'} = delete $M->{'noun'}{'POST'};
$C->{'~CAPS'} = $M->{'noun'}{'~CAPS'};
;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token termish
##      token termish {
##          :my $SCOPE is context<rw> = "our";
##          :my $VAR is context<rw>;
##          :dba('prefix or noun')
##          [
##          | <PRE>+ <noun>
##          | <noun>
##          ]
##      
##          # also queue up any postfixes
##          :dba('postfix')
##          [
##          || <?{ $*INTERPOLATION }>
##              [
##              || <?{ $*INTERPOLATION eq '$' }> [ <POST>+! <?after <[ \] } > ) ]> > ]?
##              ||                                 <POST>+! <?after <[ \] } > ) ]> > 
##              || { $VAR = 0; }
##              ]
##          || <!{ $*INTERPOLATION }>
##              <POST>*
##          ]
##          {
##              self.check_variable($VAR) if $VAR;
##              $.<~CAPS> = $<noun><~CAPS>;
##          }
##      }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::SCOPE = "our";
local $::VAR;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'PRE'} = [];
$C->{'POST'} = [];

$self->_MATCHIFY($S, "termish", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C; 
$self->check_variable($VAR) if $VAR;
$C->{'~CAPS'} = $M->{'noun'}{'~CAPS'};
;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
})
})
}, $C->_PLUSg(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
}))
})
})
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::INTERPOLATION eq '$' 
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
})
})
}, $C->_PLUSg(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
$VAR = 0; 
}, $C)} or do { die $@ if $@ };
@gather;
}
})
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::INTERPOLATION 
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
})
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::INTERPOLATION 
})
}))} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_01') {
$C->deb("Fate passed to termish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'termish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("termish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['noun'], sub {
my $C = shift;
$C->noun
})
}, $C->_PLUSr(sub { my $C=shift;
$C->_SUBSUME(['PRE'], sub {
my $C = shift;
$C->PRE
})
}))
},
sub { my $C=shift;
$C->_SUBSUME(['noun'], sub {
my $C = shift;
$C->noun
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

## token noun__S_082fatarrow (:$sym is context<rw> = 'fatarrow')
##      token noun:fatarrow           { <fatarrow> }

sub noun__S_082fatarrow__PEEK { $_[0]->_AUTOLEXpeek('noun__S_082fatarrow',$retree) }
sub noun__S_082fatarrow {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'fatarrow';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_082fatarrow", 
$C->_SUBSUMEr(['fatarrow'], sub {
my $C = shift;
$C->fatarrow
})
);
}
## token noun__S_083variable (:$sym is context<rw> = 'variable')
##      token noun:variable           { <variable> { $*VAR = $<variable> } }

sub noun__S_083variable__PEEK { $_[0]->_AUTOLEXpeek('noun__S_083variable',$retree) }
sub noun__S_083variable {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'variable';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_083variable", 
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;  $::VAR = $M->{'variable'} ;
}, $C);
}
else {
();
}
}
);
}
## token noun__S_084package_declarator (:$sym is context<rw> = 'package_declarator')
##      token noun:package_declarator { <package_declarator> }

sub noun__S_084package_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_084package_declarator',$retree) }
sub noun__S_084package_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'package_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_084package_declarator", 
$C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
})
);
}
## token noun__S_085scope_declarator (:$sym is context<rw> = 'scope_declarator')
##      token noun:scope_declarator   { <scope_declarator> }

sub noun__S_085scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_085scope_declarator',$retree) }
sub noun__S_085scope_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'scope_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_085scope_declarator", 
$C->_SUBSUMEr(['scope_declarator'], sub {
my $C = shift;
$C->scope_declarator
})
);
}
## token noun__S_086multi_declarator (:$sym is context<rw> = 'multi_declarator')
##      token noun:multi_declarator   { <?before 'multi'|'proto'|'only'> <multi_declarator> }

sub noun__S_086multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_086multi_declarator',$retree) }
sub noun__S_086multi_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'multi_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_086multi_declarator", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'noun__S_086multi_declarator_01') {
$C->deb("Fate passed to noun__S_086multi_declarator_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'noun__S_086multi_declarator_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("noun__S_086multi_declarator_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('multi')
},
sub { my $C=shift;
$C->_EXACT('proto')
},
sub { my $C=shift;
$C->_EXACT('only')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
});
}
else {
();
}
}
);
}
## token noun__S_087routine_declarator (:$sym is context<rw> = 'routine_declarator')
##      token noun:routine_declarator { <routine_declarator> }

sub noun__S_087routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_087routine_declarator',$retree) }
sub noun__S_087routine_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'routine_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_087routine_declarator", 
$C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
);
}
## token noun__S_088regex_declarator (:$sym is context<rw> = 'regex_declarator')
##      token noun:regex_declarator   { <regex_declarator> }

sub noun__S_088regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_088regex_declarator',$retree) }
sub noun__S_088regex_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'regex_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_088regex_declarator", 
$C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
);
}
## token noun__S_089type_declarator (:$sym is context<rw> = 'type_declarator')
##      token noun:type_declarator    { <type_declarator> }

sub noun__S_089type_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_089type_declarator',$retree) }
sub noun__S_089type_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'type_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_089type_declarator", 
$C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
);
}
## token noun__S_090circumfix (:$sym is context<rw> = 'circumfix')
##      token noun:circumfix          { <circumfix> }

sub noun__S_090circumfix__PEEK { $_[0]->_AUTOLEXpeek('noun__S_090circumfix',$retree) }
sub noun__S_090circumfix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'circumfix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_090circumfix", 
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
);
}
## token noun__S_091dotty (:$sym is context<rw> = 'dotty')
##      token noun:dotty              { <dotty> }

sub noun__S_091dotty__PEEK { $_[0]->_AUTOLEXpeek('noun__S_091dotty',$retree) }
sub noun__S_091dotty {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'dotty';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_091dotty", 
$C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
})
);
}
## token noun__S_092value (:$sym is context<rw> = 'value')
##      token noun:value              { <value> }

sub noun__S_092value__PEEK { $_[0]->_AUTOLEXpeek('noun__S_092value',$retree) }
sub noun__S_092value {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'value';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_092value", 
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
);
}
## token noun__S_093capterm (:$sym is context<rw> = 'capterm')
##      token noun:capterm            { <capterm> }

sub noun__S_093capterm__PEEK { $_[0]->_AUTOLEXpeek('noun__S_093capterm',$retree) }
sub noun__S_093capterm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'capterm';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_093capterm", 
$C->_SUBSUMEr(['capterm'], sub {
my $C = shift;
$C->capterm
})
);
}
## token noun__S_094sigterm (:$sym is context<rw> = 'sigterm')
##      token noun:sigterm            { <sigterm> }

sub noun__S_094sigterm__PEEK { $_[0]->_AUTOLEXpeek('noun__S_094sigterm',$retree) }
sub noun__S_094sigterm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigterm';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_094sigterm", 
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
);
}
## token noun__S_095term (:$sym is context<rw> = 'term')
##      token noun:term               { <term> }

sub noun__S_095term__PEEK { $_[0]->_AUTOLEXpeek('noun__S_095term',$retree) }
sub noun__S_095term {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'term';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_095term", 
$C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
})
);
}
## token noun__S_096statement_prefix (:$sym is context<rw> = 'statement_prefix')
##      token noun:statement_prefix   { <statement_prefix> }

sub noun__S_096statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('noun__S_096statement_prefix',$retree) }
sub noun__S_096statement_prefix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_prefix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_096statement_prefix", 
$C->_SUBSUMEr(['statement_prefix'], sub {
my $C = shift;
$C->statement_prefix
})
);
}
## token noun__S_097colonpair (:$sym is context<rw> = 'colonpair')
##      token noun:colonpair          { [ <colonpair> <.ws> ]+ }

sub noun__S_097colonpair__PEEK { $_[0]->_AUTOLEXpeek('noun__S_097colonpair',$retree) }
sub noun__S_097colonpair {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'colonpair';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_097colonpair", 
$C->_PLUSr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
})
})
);
}


## token fatarrow
##      token fatarrow {
##          <key=identifier> \h* '=>' <.ws> <val=EXPR(item %item_assignment)>
##      }

sub fatarrow__PEEK { $_[0]->_AUTOLEXpeek('fatarrow',$retree) }
sub fatarrow {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "fatarrow", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['key'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('=>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['val'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token colonpair
##      token colonpair {
##          :my $key;
##          :my $value;
##      
##          ':'
##          :dba('colon pair')
##          [
##          | '!' <identifier>
##              { $key = $<identifier>.Str; $value = 0; }
##              {*}                                                     #= false
##          | $<num> = [\d+] <identifier>
##          | <identifier>
##              { $key = $<identifier>.Str; }
##              [
##              || <.unsp>? <postcircumfix> { $value = $<postcircumfix>; }
##              || { $value = 1; }
##              ]
##              {*}                                                     #= value
##          | :dba('signature') '(' ~ ')' <fakesignature>
##          | <postcircumfix>
##              { $key = ""; $value = $<postcircumfix>; }
##              {*}                                                     #= structural
##          | $<var> = (<sigil> {} <twigil>? <desigilname>)
##              { $key = $<var><desigilname>.Str; $value = $<var>; }
##              {*}                                                     #= varname
##          ]
##          { $<k> = $key; $<v> = $value; }
##      }

sub colonpair__PEEK { $_[0]->_AUTOLEXpeek('colonpair',$retree) }
sub colonpair {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "colonpair", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'k'} = $key; $M->{'v'} = $value; ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'colonpair_01') {
$C->deb("Fate passed to colonpair_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'colonpair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("colonpair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; $value = 0; ;
}, $C))) {
$C->_REDUCE($S, 'colonpair', 'false');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['num'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; ;
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{'postcircumfix'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
$value = 1; 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'colonpair', 'value');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'signature')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'colonpair', 'structural')
}, scalar(do {
my $M = $C;  $key = ""; $value = $M->{'postcircumfix'}; ;
}, $C))
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'colonpair', 'varname')
}, scalar(do {
my $M = $C;  $key = $M->{'var'}{'desigilname'}->Str; $value = $M->{'var'}; ;
}, $C))
},     $C->_SUBSUME(['var'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
}, scalar(do {

}, $C))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
})}
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_EXACT(':'))
);
}

## token quotepair
##      token quotepair {
##          :my $key;
##          :my $value;
##      
##          ':'
##          :dba('colon pair (restricted)')
##          [
##          | '!' <identifier>
##              { $key = $<identifier>.Str; $value = 0; }
##              {*}                                                     #= false
##          | <identifier>
##              { $key = $<identifier>.Str; }
##              [
##              || <.unsp>? <?before '('> <postcircumfix> { $value = $<postcircumfix>; }
##              || { $value = 1; }
##              ]
##              {*}                                                     #= value
##          | $<n>=(\d+) $<id>=(<[a..z]>+)
##              { $key = $<id>.Str; $value = $<n>.Str; }
##              {*}                                                     #= nth
##          ]
##          { $<k> = $key; $<v> = $value; }
##      }

sub quotepair__PEEK { $_[0]->_AUTOLEXpeek('quotepair',$retree) }
sub quotepair {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quotepair", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quotepair_01') {
$C->deb("Fate passed to quotepair_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quotepair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quotepair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; $value = 0; ;
}, $C))) {
$C->_REDUCE($S, 'quotepair', 'false');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; ;
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{'postcircumfix'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
$value = 1; 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'quotepair', 'value');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['n'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['id'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[a-z])++)/)
})}
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'id'}->Str; $value = $M->{'n'}->Str; ;
}, $C))) {
$C->_REDUCE($S, 'quotepair', 'nth');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
my $M = $C;  $M->{'k'} = $key; $M->{'v'} = $value; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infixish ($in_meta = $*IN_META)
##      token infixish ($in_meta = $*IN_META) {
##          :my $infix;
##          :my $IN_META is context<rw> = $in_meta;
##          <!stdstopper>
##          <!infixstopper>
##          :dba('infix or meta-infix')
##          [
##          | <colonpair> {
##                  $<fake> = 1;
##                  $<sym> = ':';
##                  %<O><prec> = %item_assignment<prec>;  # actual test is non-inclusive!
##                  %<O><assoc> = 'unary';
##                  %<O><kind> = 'ADVERB';
##              }
##          | '[' ~ ']' <infixish(1)> { $<O> = $<infixish><O>; $<sym> = $<infixish><sym>; }
##          | <infix_circumfix_meta_operator>
##              { $<O> = $<infix_circumfix_meta_operator><O>;
##                $<sym> = $<infix_circumfix_meta_operator><sym>; }
##          | <infix_prefix_meta_operator>
##              { $<O> = $<infix_prefix_meta_operator><O>;
##                $<sym> = $<infix_prefix_meta_operator><sym>; }
##          | <infix> <!before '='>
##                 { $<O> = $<infix>.<O>; $<sym> = $<infix>.<sym>; }
##          | <infix> <?before '='> <?{ $infix = $<infix>; }> <infix_postfix_meta_operator($infix)>
##                 { $<O> = $<infix_postfix_meta_operator>.<O>; $<sym> = $<infix_postfix_meta_operator>.<sym>; }
##          ]
##      }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $in_meta = shift() // $::IN_META;
my $infix;
local $::IN_META = $in_meta;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "infixish", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixish_01') {
$C->deb("Fate passed to infixish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
scalar(do {
my $M = $C; 
$M->{'fake'} = 1;
$M->{'sym'} = ':';
$M->{'O'}{'prec'} = $item_assignment{'prec'};  # actual test is non-inclusive!
$M->{'O'}{'assoc'} = 'unary';
$M->{'O'}{'kind'} = 'ADVERB';
;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; $M->{'sym'} = $M->{'infixish'}{'sym'}; ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'infix or meta-infix')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix_circumfix_meta_operator'}{'O'};
$M->{'sym'} = $M->{'infix_circumfix_meta_operator'}{'sym'}; ;
}, $C)
}, $C->_SUBSUME(['infix_circumfix_meta_operator'], sub {
my $C = shift;
$C->infix_circumfix_meta_operator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix_prefix_meta_operator'}{'O'};
$M->{'sym'} = $M->{'infix_prefix_meta_operator'}{'sym'}; ;
}, $C)
}, $C->_SUBSUME(['infix_prefix_meta_operator'], sub {
my $C = shift;
$C->infix_prefix_meta_operator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix'}->{'O'}; $M->{'sym'} = $M->{'infix'}->{'sym'}; ;
}, $C)
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('=')
})
}))
}, $C->_SUBSUME(['infix'], sub {
my $C = shift;
$C->infix
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix_postfix_meta_operator'}->{'O'}; $M->{'sym'} = $M->{'infix_postfix_meta_operator'}->{'sym'}; ;
}, $C)
}, $C->_SUBSUME(['infix_postfix_meta_operator'], sub {
my $C = shift;
$C->infix_postfix_meta_operator($infix)
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $infix = $M->{'infix'}; ;
})
}))
}, $C->before(sub { my $C=shift;
$C->_EXACT('=')
}))
}, $C->_SUBSUME(['infix'], sub {
my $C = shift;
$C->infix
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))
);
}

# doing fancy as one rule simplifies LTM
## token dotty__S_098DotStar (:$endsym is context = 'unspacey'  , :$sym is context<rw> = <.*> --> Methodcall)
##      token dotty:sym<.*> ( --> Methodcall) {
##          ('.' [ <[+*?=]> | '^' '!'? ]) :: <.unspacey> <dottyop>
##          { $<sym> = $0.Str; }
##      }

sub dotty__S_098DotStar__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_098DotStar',$retree) }
sub dotty__S_098DotStar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'unspacey'  ;
local $sym = $args{sym} // q(.*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "dotty__S_098DotStar",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'sym'} = $C->{'0'}->Str; ;
}, $C)
}, $C->_SUBSUME(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))
}, $C->unspacey)
}, $C->_COMMITBRANCH())
},     $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dotty__S_098DotStar_02') {
$C->deb("Fate passed to dotty__S_098DotStar_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dotty__S_098DotStar_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty__S_098DotStar_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G[+*?=]/)
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('^'))) {
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('!')
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
})}
}))
);
}

## token dotty__S_099Dot (:$endsym is context = 'unspacey'  , :$sym is context<rw> = <.> --> Methodcall)
##      token dotty:sym<.> ( --> Methodcall) {
##          <sym> <dottyop>
##      }

sub dotty__S_099Dot__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_099Dot',$retree) }
sub dotty__S_099Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'unspacey'  ;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "dotty__S_099Dot",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\./))) {
do {
if (my ($C) = ($C->unspacey)) {
$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token privop ( --> Methodcall)
##      token privop ( --> Methodcall) {
##          '!' <methodop>
##      }

sub privop__PEEK { $_[0]->_AUTOLEXpeek('privop',$retree) }
sub privop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "privop",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('!'))) {
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
});
}
else {
();
}
}
);
}

## token dottyopish
##      token dottyopish {
##          <noun=dottyop>
##      }

sub dottyopish__PEEK { $_[0]->_AUTOLEXpeek('dottyopish',$retree) }
sub dottyopish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "dottyopish", 
$C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->dottyop
})
);
}

## token dottyop
##      token dottyop {
##          :dba('dotty method or postfix')
##          [
##          | <methodop>
##          | <colonpair>
##          | <!alpha> <postop> { $<O> = $<postop><O>; $<sym> = $<postop><sym>; }  # only non-alpha postfixes have dotty form
##          ]
##      }

sub dottyop__PEEK { $_[0]->_AUTOLEXpeek('dottyop',$retree) }
sub dottyop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "dottyop", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dottyop_01') {
$C->deb("Fate passed to dottyop_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dottyop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dottyop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postop'}{'O'}; $M->{'sym'} = $M->{'postop'}{'sym'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# Note, this rule mustn't do anything irreversible because it's used
# as a lookahead by the quote interpolator.

## token POST
##      token POST {
##          <!stdstopper>
##      
##          # last whitespace didn't end here
##          <!{ @*MEMOS[$.pos]<ws> }>
##      
##          [ <.unsp> | '\\' ]?
##      
##          [ ['.' <.unsp>?]? <postfix_prefix_meta_operator> <.unsp>? ]*
##      
##          :dba('postfix')
##          [
##          | <dotty>  { $<O> = $<dotty><O>;  $<sym> = $<dotty><sym>;  $<~CAPS> = $<dotty><~CAPS>; }
##          | <privop> { $<O> = $<privop><O>; $<sym> = $<privop><sym>; $<~CAPS> = $<privop><~CAPS>; }
##          | <postop> { $<O> = $<postop><O>; $<sym> = $<postop><sym>; $<~CAPS> = $<postop><~CAPS>; }
##          ]
##          { $*SIGIL = '@'; }
##      }

sub POST__PEEK { $_[0]->_AUTOLEXpeek('POST',$retree) }
sub POST {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'postfix_prefix_meta_operator'} = [];

$self->_MATCHIFYr($S, "POST", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{'_pos'}]{'ws'} 
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_01') {
$C->deb("Fate passed to POST_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'POST_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
$C->_EXACT('\\')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix_prefix_meta_operator'], sub {
my $C = shift;
$C->postfix_prefix_meta_operator
}))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_04') {
$C->deb("Fate passed to POST_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'POST_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'dotty'}{'O'};  $M->{'sym'} = $M->{'dotty'}{'sym'};  $M->{'~CAPS'} = $M->{'dotty'}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['privop'], sub {
my $C = shift;
$C->privop
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'privop'}{'O'}; $M->{'sym'} = $M->{'privop'}{'sym'}; $M->{'~CAPS'} = $M->{'privop'}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postop'}{'O'}; $M->{'sym'} = $M->{'postop'}{'sym'}; $M->{'~CAPS'} = $M->{'postop'}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::SIGIL = '@'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## method can_meta ($op, $meta)
sub can_meta {
my $self = shift;
my $op = shift;
my $meta = shift;


!$op->{'O'}{'fiddly'} || $self->panic("Can't " . $meta . " a " . $op->{'O'}{'dba'} . " because it's too fiddly");
$self;
}

## regex prefix_circumfix_meta_operator__S_100reduce ( :$sym is context<rw> = 'reduce' --> List_prefix)
##      regex prefix_circumfix_meta_operator:reduce (--> List_prefix) {
##          :my $IN_REDUCE is context<rw> = 1;
##          <?before '['\S+']'>
##          $<s> = (
##              '['
##              [
##              || <op=infixish(1)> ']' [''|<?>]
##              || \\<op=infixish(1)> ']' [''|<?>]
##              || <!>
##              ]
##          ) <?before <[ \s ( ]> >
##      
##          <.can_meta($<s><op>, "reduce")>
##      
##          [
##          || <!{ $<s><op><O><diffy> }>
##          || <?{ $<s><op><O><assoc> eq 'chain' }>
##          || <.panic("Can't reduce a " ~ $<s><op><O><dba> ~ " operator because it's diffy and not chaining")>
##          ]
##      
##          { $<O> = $<s><op><O>; $<O><prec>:delete; $<O><assoc> = 'unary'; $<O><uassoc> = 'left'; }
##          { $<sym> = $<s>.Str; }
##      
##      }

sub prefix_circumfix_meta_operator__S_100reduce__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator__S_100reduce',$retree) }
sub prefix_circumfix_meta_operator__S_100reduce {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'reduce';
local $::IN_REDUCE = 1;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "prefix_circumfix_meta_operator__S_100reduce",  Cursor::lazymap sub { STD::List_prefix->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'sym'} = $M->{'s'}->Str; ;
}, $C)
}, scalar(do {
my $M = $C;  $M->{'O'} = $M->{'s'}{'op'}{'O'}; delete $M->{'O'}{'prec'}; $M->{'O'}{'assoc'} = 'unary'; $M->{'O'}{'uassoc'} = 'left'; ;
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'s'}{'op'}{'O'}{'diffy'} ;
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'s'}{'op'}{'O'}{'assoc'} eq 'chain' ;
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do { my $M = $C;
$C->panic("Can't reduce a " . $M->{'s'}{'op'}{'O'}{'dba'} . " operator because it's diffy and not chaining")
; }} or do { die $@ if $@ };
@gather;
}
}))
}, do { my $M = $C;
$C->can_meta($M->{'s'}{'op'}, "reduce")
; })
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\s(]/)
}))
},     $C->_SUBSUME(['s'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_100reduce_04') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_100reduce_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_100reduce_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_100reduce_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish(1)
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_100reduce_06') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_100reduce_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_100reduce_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_100reduce_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish(1)
}))
}, $C->_EXACT('\\'))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C
})} or do { die $@ if $@ };
@gather;
}
})
}, $C->_EXACT('['))
})}
}))
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT(']')
}, $C->_PLUSg(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))
}, $C->_EXACT('['))
}))
);
}

## token prefix_postfix_meta_operator__S_101Fre (:$sym is context<rw> = <  >)
##      token prefix_postfix_meta_operator:sym<  >    { <sym> | '<<' }

sub prefix_postfix_meta_operator__S_101Fre__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator__S_101Fre',$retree) }
sub prefix_postfix_meta_operator__S_101Fre {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix_postfix_meta_operator__S_101Fre", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_postfix_meta_operator__S_101Fre_00') {
$C->deb("Fate passed to prefix_postfix_meta_operator__S_101Fre_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator__S_101Fre_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator__S_101Fre_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G/)
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token postfix_prefix_meta_operator__S_102Nch (:$sym is context<rw> = <  >)
##      token postfix_prefix_meta_operator:sym<  >    {
##          [ <sym> | '>>' ]
##          # require >>.( on interpolated hypercall so infix:$s($a,$b) {...} dwims
##          [<!{ $*INTERPOLATION }> || <!before '('> ]
##      }

sub postfix_prefix_meta_operator__S_102Nch__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator__S_102Nch',$retree) }
sub postfix_prefix_meta_operator__S_102Nch {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix_prefix_meta_operator__S_102Nch", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postfix_prefix_meta_operator__S_102Nch_01') {
$C->deb("Fate passed to postfix_prefix_meta_operator__S_102Nch_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator__S_102Nch_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator__S_102Nch_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G/)
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::INTERPOLATION 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}

## token infix_prefix_meta_operator__S_103Bang (  :$sym is context<rw> = <!> --> Transparent)
##      token infix_prefix_meta_operator:sym<!> ( --> Transparent) {
##          <sym> <!before '!'> {} <infixish(1)>
##      
##          [
##          || <?{ $<infixish>.Str eq '=' }>
##             { $ = ::Chaining.coerce($); }
##             
##          || <.can_meta($<infixish>, "negate")>    
##             <?{ $<infixish><O><iffy> }>
##             <?{ $<O> = $<infixish><O>; }>
##              
##          || <.panic("Can't negate a " ~ $<infixish><O><dba> ~ " operator because it's not iffy enough")>
##          ]
##      }

sub infix_prefix_meta_operator__S_103Bang__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_103Bang',$retree) }
sub infix_prefix_meta_operator__S_103Bang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_103Bang",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('!')
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'infixish'}->Str eq '=' ;
})
}))) {
scalar(do {
$C = 'STD::Chaining'->coerce($C); 
}, $C);
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "negate")
; })) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'infixish'}{'O'}{'iffy'} ;
})
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do { my $M = $C;
$C->panic("Can't negate a " . $M->{'infixish'}{'O'}{'dba'} . " operator because it's not iffy enough")
; }} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_prefix_meta_operator__S_104R (  :$sym is context<rw> = <R> --> Transparent)
##      token infix_prefix_meta_operator:sym<R> ( --> Transparent) {
##          <sym> {} <infixish(1)>
##          <.can_meta($<infixish>, "reverse")>
##          <?{ $<O> = $<infixish><O>; }>
##      }

sub infix_prefix_meta_operator__S_104R__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_104R',$retree) }
sub infix_prefix_meta_operator__S_104R {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(R);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_104R",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\GR/))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "reverse")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

#method lex1 (Str $s) {
#    self.<O>{$s}++ and self.panic("Nested $s metaoperators not allowed");
#    self;
#}

## token infix_prefix_meta_operator__S_105X (  :$sym is context<rw> = <X> --> List_infix)
##      token infix_prefix_meta_operator:sym<X> ( --> List_infix) {
##          <sym> {}
##          [ <infixish(1)>
##              [X <.panic: "Old form of XopX found">]?
##              <.can_meta($<infixish>[0], "cross")>
##              <?{ $<O> = $<infixish>[0]<O>; $<O><prec>:delete; $<sym> ~= $<infixish>[0].Str }>
##          ]?
##      }

sub infix_prefix_meta_operator__S_105X__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_105X',$retree) }
sub infix_prefix_meta_operator__S_105X {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(X);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'infixish'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_105X",  map { STD::List_infix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\GX/))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('X'))) {
$C->panic("Old form of XopX found");
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}[0], "cross")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}[0]{'O'}; delete $M->{'O'}{'prec'}; $M->{'sym'} .= $M->{'infixish'}[0]->Str ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_circumfix_meta_operator__S_106Fre_Nch (  :$sym is context<rw> = < > --> Transparent)
##      token infix_circumfix_meta_operator:sym< > ( --> Transparent) {
##          [
##          | ''
##          | ''
##          ]
##          {} <infixish(1)> [ '' | '' ]
##          <.can_meta($<infixish>, "hyper")>
##          <?{ $<O> := $<infixish><O>; }>
##      }

sub infix_circumfix_meta_operator__S_106Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_106Fre_Nch',$retree) }
sub infix_circumfix_meta_operator__S_106Fre_Nch {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_106Fre_Nch",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_106Fre_Nch_01') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_106Fre_Nch_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_106Fre_Nch_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_106Fre_Nch_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_106Fre_Nch_02') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_106Fre_Nch_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_106Fre_Nch_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_106Fre_Nch_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_circumfix_meta_operator__S_107LtLt_GtGt (  :$sym is context<rw> = << >> --> Transparent)
##      token infix_circumfix_meta_operator:sym<< >> ( --> Transparent) {
##          [
##          | '<<'
##          | '>>'
##          ]
##          {} <infixish(1)> [ '<<' | '>>' ]
##          <.can_meta($<infixish>, "hyper")>
##          <?{ $<O> := $<infixish><O>; }>
##      }

sub infix_circumfix_meta_operator__S_107LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_107LtLt_GtGt',$retree) }
sub infix_circumfix_meta_operator__S_107LtLt_GtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_107LtLt_GtGt",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_107LtLt_GtGt_01') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_107LtLt_GtGt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_107LtLt_GtGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_107LtLt_GtGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_107LtLt_GtGt_02') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_107LtLt_GtGt_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_107LtLt_GtGt_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_107LtLt_GtGt_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_postfix_meta_operator__S_108Equal ($op  , :$sym is context<rw> = <=> --> Item_assignment)
##      token infix_postfix_meta_operator:sym<=> ($op --> Item_assignment) {
##          '='
##          <.can_meta($op, "make assignment out of")>
##          [ <!{ $op<O><diffy> }> || <.panic("Can't make assignment out of a " ~ $op<O><dba> ~ " operator because it's diffy")> ]
##          { $<O> = $op<O>; $<O><prec>:delete; $<O><fiddly> = 1; }
##      }

sub infix_postfix_meta_operator__S_108Equal__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator__S_108Equal',$retree) }
sub infix_postfix_meta_operator__S_108Equal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $op = shift;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_postfix_meta_operator__S_108Equal",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->can_meta($op, "make assignment out of"))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$op->{'O'}{'diffy'} 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Can't make assignment out of a " . $op->{'O'}{'dba'} . " operator because it's diffy")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $op->{'O'}; delete $M->{'O'}{'prec'}; $M->{'O'}{'fiddly'} = 1; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_109Paren_Thesis (  :$sym is context<rw> = <( )> --> Methodcall)
##      token postcircumfix:sym<( )> ( --> Methodcall)
##          { :dba('argument list') '(' ~ ')' <semiarglist> }

sub postcircumfix__S_109Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_109Paren_Thesis',$retree) }
sub postcircumfix__S_109Paren_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_109Paren_Thesis",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

## token postcircumfix__S_110Bra_Ket (  :$sym is context<rw> = <[ ]> --> Methodcall)
##      token postcircumfix:sym<[ ]> ( --> Methodcall)
##          { :dba('subscript') '[' ~ ']' <semilist> { $<semilist>.Str ~~ /^\s*\-[1]\s*$/ and $.obs("[-1] subscript to access final element","[*-1]") } }

sub postcircumfix__S_110Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_110Bra_Ket',$retree) }
sub postcircumfix__S_110Bra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_110Bra_Ket",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'semilist'}->Str =~ qr/^\s*\-[1]\s*$/ and $C->obs("[-1] subscript to access final element","[*-1]") ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'subscript')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
);
}

## token postcircumfix__S_111Cur_Ly (  :$sym is context<rw> = <{ }> --> Methodcall)
##      token postcircumfix:sym<{ }> ( --> Methodcall)
##          { :dba('subscript') '{' ~ '}' <semilist> }

sub postcircumfix__S_111Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_111Cur_Ly',$retree) }
sub postcircumfix__S_111Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_111Cur_Ly",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}' , 'subscript')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
);
}

## token postcircumfix__S_112Lt_Gt (  :$sym is context<rw> = < > --> Methodcall)
##      token postcircumfix:sym< > ( --> Methodcall)
##          { '<' <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))> [ '>' || <.panic: "Unable to parse quote-words subscript; couldn't find right angle quote"> ] }

sub postcircumfix__S_112Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_112Lt_Gt',$retree) }
sub postcircumfix__S_112Lt_Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_112Lt_Gt",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_113LtLt_GtGt (  :$sym is context<rw> = << >> --> Methodcall)
##      token postcircumfix:sym<< >> ( --> Methodcall)
##          { '<<' <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> [ '>>' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] }

sub postcircumfix__S_113LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_113LtLt_GtGt',$retree) }
sub postcircumfix__S_113LtLt_GtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_113LtLt_GtGt",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>>')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_114Fre_Nch (  :$sym is context<rw> = < > --> Methodcall)
##      token postcircumfix:sym< > ( --> Methodcall)
##          { '' <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('',''))> [ '' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] }

sub postcircumfix__S_114Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_114Fre_Nch',$retree) }
sub postcircumfix__S_114Fre_Nch {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_114Fre_Nch",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('',''))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postop
##      token postop {
##          | <postfix>         { $<O> := $<postfix><O>; $<sym> := $<postfix><sym>; }
##          | <postcircumfix>   { $<O> := $<postcircumfix><O>; $<sym> := $<postcircumfix><sym>; }
##      }

sub postop__PEEK { $_[0]->_AUTOLEXpeek('postop',$retree) }
sub postop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "postop", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postop_00') {
$C->deb("Fate passed to postop_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postop_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postop_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix'], sub {
my $C = shift;
$C->postfix
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postfix'}{'O'}; $M->{'sym'} = $M->{'postfix'}{'sym'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postcircumfix'}{'O'}; $M->{'sym'} = $M->{'postcircumfix'}{'sym'}; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token methodop
##      token methodop {
##          [
##          | <longname>
##          | <?before '$' | '@' | '&' > <variable> { $*VAR = $<variable> }
##          | <?before <[ ' " ]> >
##              [ <!{$*INTERPOLATION}> || <!before '"' <-["]>*? \s > ] # dwim on "$foo."
##              <quote>
##              { $<quote> ~~ /\W/ or $.panic("Useless use of quotes") }
##          ] <.unsp>? 
##      
##          :dba('method arguments')
##          [
##          | ':' <?before \s> <!{ $*INTERPOLATION }> <arglist>
##          | <?[\\(]> <args>
##          ]?
##      }

sub methodop__PEEK { $_[0]->_AUTOLEXpeek('methodop',$retree) }
sub methodop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'args'} = [];

$self->_MATCHIFY($S, "methodop", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_07') {
$C->deb("Fate passed to methodop_07: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_07', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_07 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['arglist'], sub {
my $C = shift;
$C->arglist
})
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::INTERPOLATION 
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
}, $C->_EXACT(':'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['args'], sub {
my $C = shift;
$C->args
})
}, $C->before( sub { my $C=shift;
$C->_PATTERN(qr/\G[\\(]/)
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_01') {
$C->deb("Fate passed to methodop_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUME(['longname'], sub {
my $C = shift;
$C->longname
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $::VAR = $M->{'variable'} ;
}, $C)
}, $C->_SUBSUME(['variable'], sub {
my $C = shift;
$C->variable
}))
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_02') {
$C->deb("Fate passed to methodop_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('$')
},
sub { my $C=shift;
$C->_EXACT('@')
},
sub { my $C=shift;
$C->_EXACT('&')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'quote'} =~ qr/\W/ or $C->panic("Useless use of quotes") ;
}, $C)
}, $C->_SUBSUME(['quote'], sub {
my $C = shift;
$C->quote
}))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::INTERPOLATION
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G\s/)
}, $C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[^"]/)
}))
}, $C->_EXACT('"'))
})
})} or do { die $@ if $@ };
@gather;
}
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G['"]/)
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

## token semiarglist
##      token semiarglist {
##          <arglist> ** ';'
##          <.ws>
##      }

sub semiarglist__PEEK { $_[0]->_AUTOLEXpeek('semiarglist',$retree) }
sub semiarglist {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];

$self->_MATCHIFYr($S, "semiarglist", 
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(';')
}, sub { my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->ws;
}
else {
();
}
}
);
}

## token arglist
##      token arglist {
##          :my $inv_ok = $*INVOCANT_OK;
##          :my StrPos $endargs is context<rw> = 0;
##          :my $GOAL is context = 'endargs';
##          :my $INTERPOLATION is context<rw> = 0;
##          <.ws>
##          :dba('argument list')
##          [
##          | <?stdstopper>
##          | <EXPR(item %list_infix)> {{
##                  my $delims = $<EXPR><delims>;
##                  for @$delims {
##                      if ($_.<sym> // '') eq ':' {
##                          if $inv_ok {
##                              $*INVOCANT_IS = $<EXPR><list>[0];
##                          }
##                      }
##                  }
##              }}
##          ]
##      }

sub arglist__PEEK { $_[0]->_AUTOLEXpeek('arglist',$retree) }
sub arglist {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $inv_ok = $::INVOCANT_OK;
local $::endargs = 0;
local $::GOAL = 'endargs';
local $::INTERPOLATION = 0;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "arglist", 
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'arglist_01') {
$C->deb("Fate passed to arglist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'arglist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("arglist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%list_infix)
}))) {
scalar(do {
my $M = $C; 
my $delims = $M->{'EXPR'}{'delims'};
for (@$delims) {
if (($_->{'sym'} // '') eq ':') {
if ($inv_ok) {
$::INVOCANT_IS = $M->{'EXPR'}{'list'}[0];
}
}
}
;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token circumfix__S_115Cur_Ly (  :$sym is context<rw> = <{ }> --> Term)
##      token circumfix:sym<{ }> ( --> Term) {
##          <?before '{' | <.lambda> >
##          <pblock>
##          {{
##              if $*BORG {
##                  $*BORG.<block> = $<pblock>;
##              }
##          }}
##      }

sub circumfix__S_115Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_115Cur_Ly',$retree) }
sub circumfix__S_115Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "circumfix__S_115Cur_Ly",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'circumfix__S_115Cur_Ly_01') {
$C->deb("Fate passed to circumfix__S_115Cur_Ly_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'circumfix__S_115Cur_Ly_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("circumfix__S_115Cur_Ly_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->lambda
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))) {
scalar(do {
my $M = $C; 
if ($::BORG) {
$BORG->{'block'} = $M->{'pblock'};
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token constant_declarator
##      token constant_declarator {
##          :my $IN_DECL is context<rw> = 1;
##          <identifier>
##          <?{ $*SCOPE eq 'constant' }>
##          <!{ $.is_name($<identifier>.Str) }>
##          { $*IN_DECL = 0; self.add_name($<identifier>.Str) }
##          <.ws>
##      
##          <trait>*
##      }

sub constant_declarator__PEEK { $_[0]->_AUTOLEXpeek('constant_declarator',$retree) }
sub constant_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = 1;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "constant_declarator", 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::SCOPE eq 'constant' 
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $C->is_name($M->{'identifier'}->Str) ;
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::IN_DECL = 0; $self->add_name($M->{'identifier'}->Str) ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token variable_declarator
##      token variable_declarator {
##          :my $IN_DECL is context<rw> = 1;
##          <variable>
##          { $*IN_DECL = 0; self.add_variable($<variable>.Str) }
##          [   # Is it a shaped array or hash declaration?
##            #  <?{ $<sigil> eq '@' | '%' }>
##              <.unsp>?
##              $<shape> = [
##              | '(' ~ ')' <signature>
##              | :dba('shape definition') '[' ~ ']' <semilist>
##              | :dba('shape definition') '{' ~ '}' <semilist>
##              | <?before '<'> <postcircumfix>
##              ]*
##          ]?
##          <.ws>
##      
##          <trait>*
##      }

sub variable_declarator__PEEK { $_[0]->_AUTOLEXpeek('variable_declarator',$retree) }
sub variable_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = 1;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'signature'} = [];
$C->{'shape'} = [];
$C->{'postcircumfix'} = [];
$C->{'semilist'} = [];

$self->_MATCHIFY($S, "variable_declarator", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
})
}, $C->ws)
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['shape'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_declarator_02') {
$C->deb("Fate passed to variable_declarator_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_declarator_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_declarator_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'variable_declarator')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'shape definition')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}' , 'shape definition')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
}, $C->before(sub { my $C=shift;
$C->_EXACT('<')
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
})
}))
}, scalar(do {
my $M = $C;  $::IN_DECL = 0; $self->add_variable($M->{'variable'}->Str) ;
}, $C))
}, $C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))
);
}

## rule scoped
##      rule scoped {
##          :dba('scoped declarator')
##          [
##          | <declarator>
##          | <regex_declarator>
##          | <package_declarator>
##          | <typename>+
##              {
##                  my $t = $<typename>;
##                  @$t > 1 and $.panic("Multiple prefix constraints not yet supported")
##              }
##              <multi_declarator>
##          | <multi_declarator>
##          ]
##          || <?before <[A..Z]>><longname>{{
##                  my $t = $<longname>.Str;
##                  if not $.is_known($t) {
##                      $.panic("In \"$*SCOPE\" declaration, typename $t must be predeclared (or marked as declarative with :: prefix)");
##                  }
##              }}
##              <!> # drop through
##          || <.panic: "Malformed $*SCOPE">
##      }

sub scoped__PEEK { $_[0]->_AUTOLEXpeek('scoped',$retree) }
sub scoped {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'typename'} = [];

$self->_MATCHIFYr($S, "scoped", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'scoped_01') {
$C->deb("Fate passed to scoped_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'scoped_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scoped_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{'typename'};
@$t > 1 and $C->panic("Multiple prefix constraints not yet supported")
;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{'longname'}->Str;
if (not $C->is_known($t)) {
$C->panic("In \"$::SCOPE\" declaration, typename $t must be predeclared (or marked as declarative with :: prefix)");
}
;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed $::SCOPE"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}


## token scope_declarator__S_116my (:$endsym is context = 'nofun', :$sym is context<rw> = 'my')
##      token scope_declarator:my        { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_116my__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_116my',$retree) }
sub scope_declarator__S_116my {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'my';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_116my", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmy/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_117our (:$endsym is context = 'nofun', :$sym is context<rw> = 'our')
##      token scope_declarator:our       { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_117our__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_117our',$retree) }
sub scope_declarator__S_117our {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'our';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_117our", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gour/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_118state (:$endsym is context = 'nofun', :$sym is context<rw> = 'state')
##      token scope_declarator:state     { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_118state__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_118state',$retree) }
sub scope_declarator__S_118state {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'state';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_118state", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gstate/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_119constant (:$endsym is context = 'nofun', :$sym is context<rw> = 'constant')
##      token scope_declarator:constant  { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_119constant__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_119constant',$retree) }
sub scope_declarator__S_119constant {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'constant';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_119constant", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gconstant/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_120has (:$endsym is context = 'nofun', :$sym is context<rw> = 'has')
##      token scope_declarator:has       { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_120has__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_120has',$retree) }
sub scope_declarator__S_120has {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'has';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_120has", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghas/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_121augment (:$endsym is context = 'nofun', :$sym is context<rw> = 'augment')
##      token scope_declarator:augment   { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_121augment__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_121augment',$retree) }
sub scope_declarator__S_121augment {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'augment';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_121augment", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gaugment/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_122supersede (:$endsym is context = 'nofun', :$sym is context<rw> = 'supersede')
##      token scope_declarator:supersede { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_122supersede__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_122supersede',$retree) }
sub scope_declarator__S_122supersede {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'supersede';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_122supersede", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsupersede/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token package_declarator__S_123class (:$endsym is context = 'spacey', :$sym is context<rw> = 'class')
##      token package_declarator:class {
##          :my $PKGDECL is context = 'class';
##          <sym> <package_def>
##      }

sub package_declarator__S_123class__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_123class',$retree) }
sub package_declarator__S_123class {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'class';
local $::PKGDECL = 'class';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_123class", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gclass/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_124grammar (:$endsym is context = 'spacey', :$sym is context<rw> = 'grammar')
##      token package_declarator:grammar {
##          :my $PKGDECL is context = 'grammar';
##          <sym> <package_def>
##      }

sub package_declarator__S_124grammar__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_124grammar',$retree) }
sub package_declarator__S_124grammar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'grammar';
local $::PKGDECL = 'grammar';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_124grammar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggrammar/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_125module (:$endsym is context = 'spacey', :$sym is context<rw> = 'module')
##      token package_declarator:module {
##          :my $PKGDECL is context = 'module';
##          <sym> <package_def>
##      }

sub package_declarator__S_125module__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_125module',$retree) }
sub package_declarator__S_125module {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'module';
local $::PKGDECL = 'module';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_125module", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmodule/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_126package (:$endsym is context = 'spacey', :$sym is context<rw> = 'package')
##      token package_declarator:package {
##          :my $PKGDECL is context = 'package';
##          <sym> <package_def>
##      }

sub package_declarator__S_126package__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_126package',$retree) }
sub package_declarator__S_126package {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'package';
local $::PKGDECL = 'package';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_126package", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gpackage/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_127role (:$endsym is context = 'spacey', :$sym is context<rw> = 'role')
##      token package_declarator:role {
##          :my $PKGDECL is context = 'role';
##          <sym> <package_def>
##      }

sub package_declarator__S_127role__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_127role',$retree) }
sub package_declarator__S_127role {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'role';
local $::PKGDECL = 'role';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_127role", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grole/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_128knowhow (:$endsym is context = 'spacey', :$sym is context<rw> = 'knowhow')
##      token package_declarator:knowhow {
##          :my $PKGDECL is context = 'knowhow';
##          <sym> <package_def>
##      }

sub package_declarator__S_128knowhow__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_128knowhow',$retree) }
sub package_declarator__S_128knowhow {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'knowhow';
local $::PKGDECL = 'knowhow';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_128knowhow", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gknowhow/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_129slang (:$endsym is context = 'spacey', :$sym is context<rw> = 'slang')
##      token package_declarator:slang {
##          :my $PKGDECL is context = 'slang';
##          <sym> <package_def>
##      }

sub package_declarator__S_129slang__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_129slang',$retree) }
sub package_declarator__S_129slang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'slang';
local $::PKGDECL = 'slang';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_129slang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gslang/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_130require (:$endsym is context = 'spacey', :$sym is context<rw> = 'require')
##      token package_declarator:require {   # here because of declarational aspects
##          <sym> <.ws>
##          [
##          || <module_name> <EXPR>?
##          || <EXPR>
##          ]
##      }

sub package_declarator__S_130require__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_130require',$retree) }
sub package_declarator__S_130require {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'require';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_130require", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grequire/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
});
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_131trusts (:$endsym is context = 'spacey', :$sym is context<rw> = 'trusts')
##      token package_declarator:trusts {
##          <sym> <.ws>
##          <module_name>
##      }

sub package_declarator__S_131trusts__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_131trusts',$retree) }
sub package_declarator__S_131trusts {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'trusts';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_131trusts", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtrusts/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_132does (:$endsym is context = 'spacey', :$sym is context<rw> = 'does')
##      token package_declarator:does {
##          <sym> <.ws>
##          <typename>
##      }

sub package_declarator__S_132does__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_132does',$retree) }
sub package_declarator__S_132does {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'does';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_132does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule package_def
##      rule package_def {
##          :my $longname;
##          [
##              [
##                  <def_module_name>{
##                      $longname = $<def_module_name>[0]<longname>;
##                      $.add_name($longname.Str);
##                  }
##              ]?
##              <trait>*
##              [
##              || <?before '{'>
##                  {{
##                      # figure out the actual full package name (nested in outer package)
##                      my $pkg = $*PKGNAME || "GLOBAL";
##                      my $shortname;
##                      if $longname {
##                           $shortname = $longname.<name>.Str;
##                      }
##                      else {
##                          $shortname = '_anon_';
##                      }
##                      $*PKGNAME = $pkg ~ '::' ~ $shortname;
##                      my $newpkg = $*CURPKG.{$shortname}<stash> //= {};
##                      $newpkg.<PARENT> = $*CURPKG;
##                      $*CURPKG = $newpkg;
##                      push @PKGS, $pkg;
##                      # say "adding $newpkg " ~ $*PKGNAME;
##                  }}
##      
##                  <block>
##                  {{
##                      $*PKGNAME = pop(@PKGS);
##                      $*CURPKG = $*CURPKG.<PARENT>;
##                  }}
##                  {*}                                                     #= block
##              || <?before ';'>
##                  [
##                  || <?{ $*begin_compunit }>
##                      {{
##                          $longname orelse $.panic("Compilation unit cannot be anonymous");
##                          my $shortname = $longname.<name>.Str;
##                          $*PKGNAME = $shortname;
##                          my $newpkg = $*CURPKG.{$shortname}<stash> //= {};
##                          $newpkg.<PARENT> = $*CURPKG;
##                          $*CURPKG = $newpkg;
##                          $*begin_compunit = 0;
##                      }}
##                      {*}                                                     #= semi
##                  || <.panic: "Too late for semicolon form of " ~ $*PKGDECL ~ " definition">
##                  ]
##              || <.panic: "Unable to parse " ~ $*PKGDECL ~ " definition">
##              ]
##          ] || <.panic: "Malformed $*PKGDECL">
##      }

sub package_def__PEEK { $_[0]->_AUTOLEXpeek('package_def',$retree) }
sub package_def {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $longname;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'def_module_name'} = [];

$self->_MATCHIFYr($S, "package_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['def_module_name'], sub {
my $C = shift;
$C->def_module_name
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$longname = $M->{'def_module_name'}[0]{'longname'};
$C->add_name($longname->Str);
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

# figure out the actual full package name (nested in outer package)
my $pkg = $::PKGNAME || "GLOBAL";
my $shortname;
if ($longname) {
$shortname = $longname->{'name'}->Str;
}
else {
$shortname = '_anon_';
}
$::PKGNAME = $pkg . '::' . $shortname;
my $newpkg = $CURPKG->{$shortname}{'stash'} //= {};
$newpkg->{'PARENT'} = $::CURPKG;
$::CURPKG = $newpkg;
push @PKGS, $pkg;
# say "adding $newpkg " ~ $::PKGNAME;

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

$::PKGNAME = pop(@PKGS);
$::CURPKG = $CURPKG->{'PARENT'};

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'package_def', 'block'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(';')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::begin_compunit 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

$longname or $C->panic("Compilation unit cannot be anonymous");
my $shortname = $longname->{'name'}->Str;
$::PKGNAME = $shortname;
my $newpkg = $CURPKG->{$shortname}{'stash'} //= {};
$newpkg->{'PARENT'} = $::CURPKG;
$::CURPKG = $newpkg;
$::begin_compunit = 0;

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'package_def', 'semi'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Too late for semicolon form of " . $::PKGDECL . " definition"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Unable to parse " . $::PKGDECL . " definition"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed $::PKGDECL"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## token declarator
##      token declarator {
##          [
##          | <constant_declarator>
##          | <variable_declarator>
##          | '(' ~ ')' <signature> <trait>*
##          | <routine_declarator>
##          | <regex_declarator>
##          | <type_declarator>
##          ]
##      }

sub declarator__PEEK { $_[0]->_AUTOLEXpeek('declarator',$retree) }
sub declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];

$self->_MATCHIFY($S, "declarator", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'declarator_01') {
$C->deb("Fate passed to declarator_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'declarator_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("declarator_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['constant_declarator'], sub {
my $C = shift;
$C->constant_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['variable_declarator'], sub {
my $C = shift;
$C->variable_declarator
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
})
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'declarator')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
$C->_SUBSUME(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
},
sub { my $C=shift;
$C->_SUBSUME(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub { my $C=shift;
$C->_SUBSUME(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token multi_declarator__S_133multi (:$endsym is context = 'spacey', :$sym is context<rw> = 'multi')
##      token multi_declarator:multi {
##          :my $MULTINESS is context = 'multi';
##          <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed multi'> ]
##      }

sub multi_declarator__S_133multi__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_133multi',$retree) }
sub multi_declarator__S_133multi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'multi';
local $::MULTINESS = 'multi';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_133multi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmulti/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic('Malformed multi')} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_134proto (:$endsym is context = 'spacey', :$sym is context<rw> = 'proto')
##      token multi_declarator:proto {
##          :my $MULTINESS is context = 'proto';
##          <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed proto'> ]
##      }

sub multi_declarator__S_134proto__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_134proto',$retree) }
sub multi_declarator__S_134proto {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'proto';
local $::MULTINESS = 'proto';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_134proto", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gproto/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic('Malformed proto')} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_135only (:$endsym is context = 'spacey', :$sym is context<rw> = 'only')
##      token multi_declarator:only {
##          :my $MULTINESS is context = 'only';
##          <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed only'> ]
##      }

sub multi_declarator__S_135only__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_135only',$retree) }
sub multi_declarator__S_135only {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'only';
local $::MULTINESS = 'only';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_135only", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gonly/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic('Malformed only')} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_136null (:$endsym is context = 'spacey', :$sym is context<rw> = 'null')
##      token multi_declarator:null {
##          :my $MULTINESS is context = '';
##          <declarator>
##      }

sub multi_declarator__S_136null__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_136null',$retree) }
sub multi_declarator__S_136null {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'null';
local $::MULTINESS = '';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_136null", 
$C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
);
}

## token routine_declarator__S_137sub (:$endsym is context = 'endid', :$sym is context<rw> = 'sub')
##      token routine_declarator:sub       { <sym> <routine_def> }

sub routine_declarator__S_137sub__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_137sub',$retree) }
sub routine_declarator__S_137sub {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'endid';
local $sym = $args{sym} // 'sub';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_137sub", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsub/))) {
do {
if (my ($C) = ($C->endid)) {
$C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token routine_declarator__S_138method (:$endsym is context = 'endid', :$sym is context<rw> = 'method')
##      token routine_declarator:method    { <sym> <method_def> }

sub routine_declarator__S_138method__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_138method',$retree) }
sub routine_declarator__S_138method {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'endid';
local $sym = $args{sym} // 'method';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_138method", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmethod/))) {
do {
if (my ($C) = ($C->endid)) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token routine_declarator__S_139submethod (:$endsym is context = 'endid', :$sym is context<rw> = 'submethod')
##      token routine_declarator:submethod { <sym> <method_def> }

sub routine_declarator__S_139submethod__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_139submethod',$retree) }
sub routine_declarator__S_139submethod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'endid';
local $sym = $args{sym} // 'submethod';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_139submethod", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubmethod/))) {
do {
if (my ($C) = ($C->endid)) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token routine_declarator__S_140macro (:$endsym is context = 'endid', :$sym is context<rw> = 'macro')
##      token routine_declarator:macro     { <sym> <macro_def> }

sub routine_declarator__S_140macro__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_140macro',$retree) }
sub routine_declarator__S_140macro {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'endid';
local $sym = $args{sym} // 'macro';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_140macro", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmacro/))) {
do {
if (my ($C) = ($C->endid)) {
$C->_SUBSUMEr(['macro_def'], sub {
my $C = shift;
$C->macro_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token regex_declarator__S_141regex (:$endsym is context = 'spacey', :$sym is context<rw> = 'regex')
##      token regex_declarator:regex { <sym>       <regex_def> }

sub regex_declarator__S_141regex__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_141regex',$retree) }
sub regex_declarator__S_141regex {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'regex';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_141regex", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gregex/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token regex_declarator__S_142token (:$endsym is context = 'spacey', :$sym is context<rw> = 'token')
##      token regex_declarator:token { <sym>       <regex_def> }

sub regex_declarator__S_142token__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_142token',$retree) }
sub regex_declarator__S_142token {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'token';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_142token", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtoken/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token regex_declarator__S_143rule (:$endsym is context = 'spacey', :$sym is context<rw> = 'rule')
##      token regex_declarator:rule  { <sym>       <regex_def> }

sub regex_declarator__S_143rule__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_143rule',$retree) }
sub regex_declarator__S_143rule {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'rule';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_143rule", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grule/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# Most of these special variable rules are there simply to catch old p5 brainos

## token special_variable__S_144Dollar_a2_ (:$sym is context<rw> = <$>)
##      token special_variable:sym<$> { <sym> }

sub special_variable__S_144Dollar_a2___PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_144Dollar_a2_',$retree) }
sub special_variable__S_144Dollar_a2_ {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_144Dollar_a2_", 
$C->_PATTERN(qr/\G\$/)
);
}

## token special_variable__S_145DollarBang (:$sym is context<rw> = <$!>)
##      token special_variable:sym<$!> { <sym> <!before \w> }

sub special_variable__S_145DollarBang__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_145DollarBang',$retree) }
sub special_variable__S_145DollarBang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_145DollarBang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\!/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
});
}
else {
();
}
}
);
}

## token special_variable__S_146DollarBangCur_Ly (:$sym is context<rw> = <$!{ }>)
##      token special_variable:sym<$!{ }> {
##          # XXX the backslashes are necessary here for bootstrapping, not for P6...
##          ( '$!{' :: (.*?) '}' )
##          <.obs($0.Str ~ " variable", 'smart match against $!')>
##      }

sub special_variable__S_146DollarBangCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_146DollarBangCur_Ly',$retree) }
sub special_variable__S_146DollarBangCur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($!{ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_146DollarBangCur_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
$C->obs($C->{'0'}->Str . " variable", 'smart match against $!')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('$!{'))
})}
}))
);
}

## token special_variable__S_147DollarSlash (:$sym is context<rw> = <$/>)
##      token special_variable:sym<$/> {
##          <sym>
##          # XXX assuming nobody ever wants to assign $/ directly anymore...
##          [ <?before \h* '=' <![=]> >
##              <.obs('$/ variable as input record separator',
##                   "filehandle's :irs attribute")>
##          ]?
##      }

sub special_variable__S_147DollarSlash__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_147DollarSlash',$retree) }
sub special_variable__S_147DollarSlash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($/);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_147DollarSlash", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\//))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[=]/)
});
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->obs('$/ variable as input record separator',
"filehandle's :irs attribute");
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token special_variable__S_148DollarTilde (:$sym is context<rw> = <$~>)
##      token special_variable:sym<$~> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$~ variable', 'Form module')>
##      }

sub special_variable__S_148DollarTilde__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_148DollarTilde',$retree) }
sub special_variable__S_148DollarTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_148DollarTilde", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$~ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_148DollarTilde_01') {
$C->deb("Fate passed to special_variable__S_148DollarTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_148DollarTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_148DollarTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\~/))
);
}

## token special_variable__S_149DollarGrave (:$sym is context<rw> = <$`>)
##      token special_variable:sym<$`> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$` variable', 'explicit pattern before <(')>
##      }

sub special_variable__S_149DollarGrave__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_149DollarGrave',$retree) }
sub special_variable__S_149DollarGrave {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($`);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_149DollarGrave", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$` variable', 'explicit pattern before <(')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_149DollarGrave_01') {
$C->deb("Fate passed to special_variable__S_149DollarGrave_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_149DollarGrave_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_149DollarGrave_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\`/))
);
}

## token special_variable__S_150DollarAt (:$sym is context<rw> = <$@>)
##      token special_variable:sym<$@> {
##          <sym> ::
##          <.obs('$@ variable as eval error', '$!')>
##      }

sub special_variable__S_150DollarAt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_150DollarAt',$retree) }
sub special_variable__S_150DollarAt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($@);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_150DollarAt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$@ variable as eval error', '$!')
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\@/))
);
}

## token special_variable__S_151DollarSharp (:$sym is context<rw> = <$#>)
##      token special_variable:sym<$#> {
##          <sym> ::
##          [
##          || (\w+) <.obs("\$#" ~ $0.Str ~ " variable", '@' ~ $0.Str ~ '.end')>
##          || <.obs('$# variable', '.fmt')>
##          ]
##      }

sub special_variable__S_151DollarSharp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_151DollarSharp',$retree) }
sub special_variable__S_151DollarSharp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($#);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_151DollarSharp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->obs("\$#" . $C->{'0'}->Str . " variable", '@' . $C->{'0'}->Str . '.end')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->obs('$# variable', '.fmt')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\#/))
);
}
## token special_variable__S_152DollarDollar (:$sym is context<rw> = <$$>)
##      token special_variable:sym<$$> {
##          <sym> <!alpha> :: <?before \s | ',' | <terminator> >
##          <.obs('$$ variable', '$*PID')>
##      }

sub special_variable__S_152DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_152DollarDollar',$retree) }
sub special_variable__S_152DollarDollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($$);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_152DollarDollar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$$ variable', '$::PID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_152DollarDollar_01') {
$C->deb("Fate passed to special_variable__S_152DollarDollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_152DollarDollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_152DollarDollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))
}, $C->_PATTERN(qr/\G\$\$/))
);
}
## token special_variable__S_153DollarPercent (:$sym is context<rw> = <$%>)
##      token special_variable:sym<$%> {
##          <sym> ::
##          <.obs('$% variable', 'Form module')>
##      }

sub special_variable__S_153DollarPercent__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_153DollarPercent',$retree) }
sub special_variable__S_153DollarPercent {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($%);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_153DollarPercent", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$% variable', 'Form module')
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\%/))
);
}

# Note: this works because placeholders are restricted to lowercase
## token special_variable__S_154DollarCaretX (:$sym is context<rw> = <$^X>)
##      token special_variable:sym<$^X> {
##          <sigil> '^' $<letter> = [<[A..Z]>] \W
##          <.obscaret($<sigil>.Str ~ '^' ~ $<letter>.Str, $<sigil>, $<letter>.Str)>
##      }

sub special_variable__S_154DollarCaretX__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_154DollarCaretX',$retree) }
sub special_variable__S_154DollarCaretX {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($^X);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_154DollarCaretX", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_EXACT('^'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['letter'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) {
do { my $M = $C;
$C->obscaret($M->{'sigil'}->Str . '^' . $M->{'letter'}->Str, $M->{'sigil'}, $M->{'letter'}->Str)
; };
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token special_variable__S_155DollarCaret (:$sym is context<rw> = <$^>)
##      token special_variable:sym<$^> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$^ variable', 'Form module')>
##      }

sub special_variable__S_155DollarCaret__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_155DollarCaret',$retree) }
sub special_variable__S_155DollarCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_155DollarCaret", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$^ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_155DollarCaret_01') {
$C->deb("Fate passed to special_variable__S_155DollarCaret_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_155DollarCaret_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_155DollarCaret_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\^/))
);
}

## token special_variable__S_156DollarAmp (:$sym is context<rw> = <$&>)
##      token special_variable:sym<$&> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$& variable', '$/ or $()')>
##      }

sub special_variable__S_156DollarAmp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_156DollarAmp',$retree) }
sub special_variable__S_156DollarAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_156DollarAmp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$& variable', '$/ or $()')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_156DollarAmp_01') {
$C->deb("Fate passed to special_variable__S_156DollarAmp_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_156DollarAmp_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_156DollarAmp_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\&/))
);
}

## token special_variable__S_157DollarStar (:$sym is context<rw> = <$*>)
##      token special_variable:sym<$*> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$* variable', '^^ and $$')>
##      }

sub special_variable__S_157DollarStar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_157DollarStar',$retree) }
sub special_variable__S_157DollarStar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_157DollarStar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$* variable', '^^ and $$')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_157DollarStar_01') {
$C->deb("Fate passed to special_variable__S_157DollarStar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_157DollarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_157DollarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\*/))
);
}

## token special_variable__S_158DollarThesis (:$sym is context<rw> = <$)>)
##      token special_variable:sym<$)> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$) variable', '$*EGID')>
##      }

sub special_variable__S_158DollarThesis__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_158DollarThesis',$retree) }
sub special_variable__S_158DollarThesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[$)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_158DollarThesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$) variable', '$::EGID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_158DollarThesis_01') {
$C->deb("Fate passed to special_variable__S_158DollarThesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_158DollarThesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_158DollarThesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\)/))
);
}

## token special_variable__S_159DollarMinus (:$sym is context<rw> = <$->)
##      token special_variable:sym<$-> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$- variable', 'Form module')>
##      }

sub special_variable__S_159DollarMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_159DollarMinus',$retree) }
sub special_variable__S_159DollarMinus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_159DollarMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$- variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_159DollarMinus_01') {
$C->deb("Fate passed to special_variable__S_159DollarMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_159DollarMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_159DollarMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\-/))
);
}

## token special_variable__S_160DollarEqual (:$sym is context<rw> = <$=>)
##      token special_variable:sym<$=> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$= variable', 'Form module')>
##      }

sub special_variable__S_160DollarEqual__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_160DollarEqual',$retree) }
sub special_variable__S_160DollarEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_160DollarEqual", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$= variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_160DollarEqual_01') {
$C->deb("Fate passed to special_variable__S_160DollarEqual_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_160DollarEqual_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_160DollarEqual_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\=/))
);
}

## token special_variable__S_161AtPlus (:$sym is context<rw> = <@+>)
##      token special_variable:sym<@+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_161AtPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_161AtPlus',$retree) }
sub special_variable__S_161AtPlus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_161AtPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('@+ variable', '.to method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_161AtPlus_01') {
$C->deb("Fate passed to special_variable__S_161AtPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_161AtPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_161AtPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\@\+/))
);
}

## token special_variable__S_162PercentPlus (:$sym is context<rw> = <%+>)
##      token special_variable:sym<%+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('%+ variable', '.to method')>
##      }

sub special_variable__S_162PercentPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_162PercentPlus',$retree) }
sub special_variable__S_162PercentPlus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_162PercentPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('%+ variable', '.to method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_162PercentPlus_01') {
$C->deb("Fate passed to special_variable__S_162PercentPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_162PercentPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_162PercentPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\%\+/))
);
}

## token special_variable__S_163DollarPlusBra_Ket (:$sym is context<rw> = <$+[ ]>)
##      token special_variable:sym<$+[ ]> {
##          '$+['
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_163DollarPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_163DollarPlusBra_Ket',$retree) }
sub special_variable__S_163DollarPlusBra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($+[ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_163DollarPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$+['))) {
$C->obs('@+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_164AtPlusBra_Ket (:$sym is context<rw> = <@+[ ]>)
##      token special_variable:sym<@+[ ]> {
##          '@+['
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_164AtPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_164AtPlusBra_Ket',$retree) }
sub special_variable__S_164AtPlusBra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@+[ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_164AtPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@+['))) {
$C->obs('@+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_165AtPlusCur_Ly (:$sym is context<rw> = <@+{ }>)
##      token special_variable:sym<@+{ }> {
##          '@+{'
##          <.obs('%+ variable', '.to method')>
##      }

sub special_variable__S_165AtPlusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_165AtPlusCur_Ly',$retree) }
sub special_variable__S_165AtPlusCur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@+{ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_165AtPlusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@+{'))) {
$C->obs('%+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_166AtMinus (:$sym is context<rw> = <@->)
##      token special_variable:sym<@-> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_166AtMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_166AtMinus',$retree) }
sub special_variable__S_166AtMinus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_166AtMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('@- variable', '.from method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_166AtMinus_01') {
$C->deb("Fate passed to special_variable__S_166AtMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_166AtMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_166AtMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\@\-/))
);
}

## token special_variable__S_167PercentMinus (:$sym is context<rw> = <%->)
##      token special_variable:sym<%-> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('%- variable', '.from method')>
##      }

sub special_variable__S_167PercentMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_167PercentMinus',$retree) }
sub special_variable__S_167PercentMinus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_167PercentMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('%- variable', '.from method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_167PercentMinus_01') {
$C->deb("Fate passed to special_variable__S_167PercentMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_167PercentMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_167PercentMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\%\-/))
);
}

## token special_variable__S_168DollarMinusBra_Ket (:$sym is context<rw> = <$-[ ]>)
##      token special_variable:sym<$-[ ]> {
##          '$-['
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_168DollarMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_168DollarMinusBra_Ket',$retree) }
sub special_variable__S_168DollarMinusBra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($-[ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_168DollarMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$-['))) {
$C->obs('@- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_169AtMinusBra_Ket (:$sym is context<rw> = <@-[ ]>)
##      token special_variable:sym<@-[ ]> {
##          '@-['
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_169AtMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_169AtMinusBra_Ket',$retree) }
sub special_variable__S_169AtMinusBra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@-[ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_169AtMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@-['))) {
$C->obs('@- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_170PercentMinusCur_Ly (:$sym is context<rw> = <%-{ }>)
##      token special_variable:sym<%-{ }> {
##          '@-{'
##          <.obs('%- variable', '.from method')>
##      }

sub special_variable__S_170PercentMinusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_170PercentMinusCur_Ly',$retree) }
sub special_variable__S_170PercentMinusCur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(%-{ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_170PercentMinusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@-{'))) {
$C->obs('%- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_171DollarPlus (:$sym is context<rw> = <$+>)
##      token special_variable:sym<$+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$+ variable', 'Form module')>
##      }

sub special_variable__S_171DollarPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_171DollarPlus',$retree) }
sub special_variable__S_171DollarPlus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_171DollarPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$+ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_171DollarPlus_01') {
$C->deb("Fate passed to special_variable__S_171DollarPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_171DollarPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_171DollarPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\+/))
);
}

## token special_variable__S_172DollarCurCaret_Ly (:$sym is context<rw> = <${^ }>)
##      token special_variable:sym<${^ }> {
##          ( <sigil> '{^' :: (.*?) '}' )
##          <.obscaret($0.Str, $<sigil>, $0.{0}.Str)>
##      }

sub special_variable__S_172DollarCurCaret_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_172DollarCurCaret_Ly',$retree) }
sub special_variable__S_172DollarCurCaret_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(${^ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_172DollarCurCaret_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
do { my $M = $C;
$C->obscaret($C->{'0'}->Str, $M->{'sigil'}, $C->{'0'}.{0}->Str)
; }
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{^'))
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
})}
}))
);
}

# XXX should eventually rely on multi instead of nested cases here...
## method obscaret (Str $var, Str $sigil, Str $name)
sub obscaret {
my $self = shift;
my $var = shift;
my $sigil = shift;
my $name = shift;


my $repl;
given ($sigil) {
when ('$') {
given ($name) {
when ('MATCH')         { $repl = '$/' }
when ('PREMATCH')      { $repl = 'an explicit pattern before <(' }
when ('POSTMATCH')     { $repl = 'an explicit pattern after )>' }
when ('ENCODING')      { $repl = '$?ENCODING' }
when ('UNICODE')       { $repl = '$?UNICODE' }  # XXX ???
when ('TAINT')         { $repl = '$::TAINT' }
when ('OPEN')          { $repl = 'filehandle introspection' }
when ('N')             { $repl = '$-1' } # XXX ???
when ('L')             { $repl = 'Form module' }
when ('A')             { $repl = 'Form module' }
when ('E')             { $repl = '$!.extended_os_error' }
when ('C')             { $repl = 'COMPILING namespace' }
when ('D')             { $repl = '$::DEBUGGING' }
when ('F')             { $repl = '$::SYSTEM_FD_MAX' }
when ('H')             { $repl = '$?FOO variables' }
when ('I')             { $repl = '$::INPLACE' } # XXX ???
when ('O')             { $repl = '$?OS or $::OS' }
when ('P')             { $repl = 'whatever debugger Perl 6 comes with' }
when ('R')             { $repl = 'an explicit result variable' }
when ('S')             { $repl = 'the context function' } # XXX ???
when ('T')             { $repl = '$::BASETIME' }
when ('V')             { $repl = '$::PERL_VERSION' }
when ('W')             { $repl = '$::WARNING' }
when ('X')             { $repl = '$::EXECUTABLE_NAME' }
default { $repl = "a global form such as $sigil*$name" }
}
}
when ('%') {
given ($name) {
when ('H')             { $repl = '$?FOO variables' }
default { $repl = "a global form such as $sigil*$name" }
}
}
default { $repl = "a global form such as $sigil*$name" }
};
return $self->obs("$var variable", $repl);
}

## token special_variable__S_173ColonColonCur_Ly (:$sym is context<rw> = <::{ }>)
##      token special_variable:sym<::{ }> {
##          '::' <?before '{'>
##      }

sub special_variable__S_173ColonColonCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_173ColonColonCur_Ly',$retree) }
sub special_variable__S_173ColonColonCur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(::{ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_173ColonColonCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('::'))) {
$C->before(sub { my $C=shift;
$C->_EXACT('{')
});
}
else {
();
}
}
);
}

## token special_variable__S_174DollarCur_Ly (:$sym is context<rw> = <${ }>)
##      token special_variable:sym<${ }> {
##          ( <[$@%]> '{' :: (.*?) '}' )
##          <.obs("" ~ $0.Str ~ " variable", "\{" ~ $<sigil>.Str ~ "}(" ~ $0.{0}.Str ~ ")")>
##      }

sub special_variable__S_174DollarCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_174DollarCur_Ly',$retree) }
sub special_variable__S_174DollarCur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(${ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_174DollarCur_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
do { my $M = $C;
$C->obs("" . $C->{'0'}->Str . " variable", "\{" . $M->{'sigil'}->Str . "}(" . $C->{'0'}.{0}->Str . ")")
; }
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
}, $C->_PATTERN(qr/\G[$@%]/))
})}
}))
);
}

## token special_variable__S_175DollarBra (:$sym is context<rw> = <$[>)
##      token special_variable:sym<$[> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$[ variable', 'user-defined array indices')>
##      }

sub special_variable__S_175DollarBra__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_175DollarBra',$retree) }
sub special_variable__S_175DollarBra {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($[);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_175DollarBra", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$[ variable', 'user-defined array indices')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_175DollarBra_01') {
$C->deb("Fate passed to special_variable__S_175DollarBra_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_175DollarBra_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_175DollarBra_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\[/))
);
}

## token special_variable__S_176DollarKet (:$sym is context<rw> = <$]>)
##      token special_variable:sym<$]> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$] variable', '$*PERL_VERSION')>
##      }

sub special_variable__S_176DollarKet__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_176DollarKet',$retree) }
sub special_variable__S_176DollarKet {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($]);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_176DollarKet", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$] variable', '$::PERL_VERSION')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_176DollarKet_01') {
$C->deb("Fate passed to special_variable__S_176DollarKet_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_176DollarKet_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_176DollarKet_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\]/))
);
}

## token special_variable__S_177DollarBack (:$sym is context<rw> = <$\\>)
##      token special_variable:sym<$\\> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$\\ variable', "the filehandle's :ors attribute")>
##      }

sub special_variable__S_177DollarBack__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_177DollarBack',$retree) }
sub special_variable__S_177DollarBack {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_177DollarBack", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$\\ variable', "the filehandle's :ors attribute")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_177DollarBack_01') {
$C->deb("Fate passed to special_variable__S_177DollarBack_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_177DollarBack_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_177DollarBack_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\\/))
);
}

## token special_variable__S_178DollarVert (:$sym is context<rw> = <$|>)
##      token special_variable:sym<$|> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$| variable', ':autoflush on open')>
##      }

sub special_variable__S_178DollarVert__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_178DollarVert',$retree) }
sub special_variable__S_178DollarVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_178DollarVert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$| variable', ':autoflush on open')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_178DollarVert_01') {
$C->deb("Fate passed to special_variable__S_178DollarVert_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_178DollarVert_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_178DollarVert_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\|/))
);
}

## token special_variable__S_179DollarColon (:$sym is context<rw> = <$:>)
##      token special_variable:sym<$:> {
##          <sym> <?before <[\x20\t\n\],=)}]> >
##          <.obs('$: variable', 'Form module')>
##      }

sub special_variable__S_179DollarColon__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_179DollarColon',$retree) }
sub special_variable__S_179DollarColon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($:);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_179DollarColon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\:/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\n\],=)}]/)
}))) {
$C->obs('$: variable', 'Form module');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token special_variable__S_180DollarSemi (:$sym is context<rw> = <$;>)
##      token special_variable:sym<$;> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$; variable', 'real multidimensional hashes')>
##      }

sub special_variable__S_180DollarSemi__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_180DollarSemi',$retree) }
sub special_variable__S_180DollarSemi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($;);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_180DollarSemi", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$; variable', 'real multidimensional hashes')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_180DollarSemi_01') {
$C->deb("Fate passed to special_variable__S_180DollarSemi_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_180DollarSemi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_180DollarSemi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\;/))
);
}

## token special_variable__S_181DollarSingle (:$sym is context<rw> = <$'>)
##      token special_variable:sym<$'> { #'
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")>
##      }

sub special_variable__S_181DollarSingle__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_181DollarSingle',$retree) }
sub special_variable__S_181DollarSingle {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($');


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_181DollarSingle", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$' . "'" . 'variable', "explicit pattern after )\x3E")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_181DollarSingle_01') {
$C->deb("Fate passed to special_variable__S_181DollarSingle_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_181DollarSingle_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_181DollarSingle_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\'/))
);
}

## token special_variable__S_182DollarDouble (:$sym is context<rw> = <$">)
##      token special_variable:sym<$"> {
##          <sym> <!{ $*INTERPOLATION }>
##          :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$" variable', '.join() method')>
##      }

sub special_variable__S_182DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_182DollarDouble',$retree) }
sub special_variable__S_182DollarDouble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($");


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_182DollarDouble", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$" variable', '.join() method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_182DollarDouble_01') {
$C->deb("Fate passed to special_variable__S_182DollarDouble_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_182DollarDouble_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_182DollarDouble_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::INTERPOLATION 
})
}))
}, $C->_PATTERN(qr/\G\$\"/))
);
}

## token special_variable__S_183DollarComma (:$sym is context<rw> = <$,>)
##      token special_variable:sym<$,> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$, variable', ".join() method")>
##      }

sub special_variable__S_183DollarComma__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_183DollarComma',$retree) }
sub special_variable__S_183DollarComma {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[$,];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_183DollarComma", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$, variable', ".join() method")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_183DollarComma_01') {
$C->deb("Fate passed to special_variable__S_183DollarComma_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_183DollarComma_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_183DollarComma_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\,/))
);
}

## token special_variable__S_184DollarLt (:$sym is context<rw> = ['$<'])
##      token special_variable:sym['$<'] {
##          <sym> :: <!before \s* \w+ \s* '>' >
##          <.obs('$< variable', '$*UID')>
##      }

sub special_variable__S_184DollarLt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_184DollarLt',$retree) }
sub special_variable__S_184DollarLt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // ['$<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_184DollarLt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$< variable', '$::UID')
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('>')
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
}, $C->_PATTERN(qr/\G((?:\w)++)/))
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
})
}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\[\'\$\<\'\]/))
);
}

## token special_variable__S_185DollarGt (:$sym is context<rw> = \$>)
##      token special_variable:sym\$> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$> variable', '$*EUID')>
##      }

sub special_variable__S_185DollarGt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_185DollarGt',$retree) }
sub special_variable__S_185DollarGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['\$>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_185DollarGt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$> variable', '$::EUID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_185DollarGt_01') {
$C->deb("Fate passed to special_variable__S_185DollarGt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_185DollarGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_185DollarGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\>/))
);
}

## token special_variable__S_186DollarDot (:$sym is context<rw> = <$.>)
##      token special_variable:sym<$.> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$. variable', "filehandle's .line method")>
##      }

sub special_variable__S_186DollarDot__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_186DollarDot',$retree) }
sub special_variable__S_186DollarDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_186DollarDot", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$. variable', "filehandle's .line method")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_186DollarDot_01') {
$C->deb("Fate passed to special_variable__S_186DollarDot_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_186DollarDot_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_186DollarDot_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\./))
);
}

## token special_variable__S_187DollarQuestion (:$sym is context<rw> = <$?>)
##      token special_variable:sym<$?> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$? variable as child error', '$!')>
##      }

sub special_variable__S_187DollarQuestion__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_187DollarQuestion',$retree) }
sub special_variable__S_187DollarQuestion {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_187DollarQuestion", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$? variable as child error', '$!')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_187DollarQuestion_01') {
$C->deb("Fate passed to special_variable__S_187DollarQuestion_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_187DollarQuestion_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_187DollarQuestion_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\?/))
);
}

# desigilname should only follow a sigil/twigil

## token desigilname
##      token desigilname {
##          [
##          | <?before '$' > <variable> { $*VAR = $<variable> }
##          | <longname>
##          ]
##      }

sub desigilname__PEEK { $_[0]->_AUTOLEXpeek('desigilname',$retree) }
sub desigilname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "desigilname", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'desigilname_01') {
$C->deb("Fate passed to desigilname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'desigilname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("desigilname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;  $::VAR = $M->{'variable'} ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token variable
##      token variable {
##          :my $IN_META is context<rw> = 0;
##          :my $sigil = '';
##          :my $twigil = '';
##          :my $name;
##          <?before <sigil> {
##              $sigil = $<sigil>.Str;
##              $*SIGIL ||= $sigil;
##          }> {}
##          [
##          || <sigil> <twigil>? <?before '::' [ '{' | '<' | '(' ]> <longname> # XXX
##          || '&'
##              [
##              | <twigil>? <sublongname> { $name = $<sublongname>.Str } {*}                                   #= subnoun
##              | '[' ~ ']' <infixish(1)>
##              ]
##          || '$::' <name>? # XXX
##          || '$:' <name> # XXX
##          || [
##              | <sigil> <twigil>? <desigilname> { $name = $<desigilname>.Str } {*}                                    #= desigilname
##              | <special_variable> {*}                                    #= special
##              | <sigil> $<index>=[\d+] {*}                                #= $0
##              # Note: $() can also parse as contextualizer in an expression; should have same effect
##              | <sigil> <?before '<' | '('> <postcircumfix> {*}           #= $()
##              | <sigil> <?{ $*IN_DECL }> {*}                              #= anondecl
##              | <?> {{
##                  if $*INTERPOLATION {
##                      return ();
##                  }
##                  else {
##                      $.panic("Anonymous variable requires declarator");
##                  }
##                }}
##              ]
##          ]
##      
##          { my $t = $<twigil>; $twigil = $t.[0].Str if @$t; }
##          [ <?{ $twigil eq '.' }>
##              [<.unsp> | '\\' | <?> ] <?before '('> <postcircumfix> {*}          #= methcall
##          ]?
##      }

sub variable__PEEK { $_[0]->_AUTOLEXpeek('variable',$retree) }
sub variable {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_META = 0;
my $sigil = '';
my $twigil = '';
my $name;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'name'} = [];
$C->{'postcircumfix'} = [];
$C->{'twigil'} = [];

$self->_MATCHIFY($S, "variable", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', 'methcall')
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->before(sub { my $C=shift;
$C->_EXACT('(')
}))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_14') {
$C->deb("Fate passed to variable_14: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_14', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_14 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
$C->_EXACT('\\')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$twigil eq '.' 
})
}))
})
})
}, scalar(do {
my $M = $C;  my $t = $M->{'twigil'}; $twigil = $t->[0]->Str if @$t; ;
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_04') {
$C->deb("Fate passed to variable_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_06') {
$C->deb("Fate passed to variable_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['sublongname'], sub {
my $C = shift;
$C->sublongname
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $name = $M->{'sublongname'}->Str ;
}, $C))) {
$C->_REDUCE($S, 'variable', 'subnoun');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'variable')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('&'))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->name
})
})
}, $C->_EXACT('$::'))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->name
})
}, $C->_EXACT('$:'))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_10') {
$C->deb("Fate passed to variable_10: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_10', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_10 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', 'desigilname')
}, scalar(do {
my $M = $C;  $name = $M->{'desigilname'}->Str ;
}, $C))
}, $C->_SUBSUME(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', 'special')
}, $C->_SUBSUME(['special_variable'], sub {
my $C = shift;
$C->special_variable
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', '$C<0>')
},     $C->_SUBSUME(['index'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', '$()')
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_12') {
$C->deb("Fate passed to variable_12: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_12', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_12 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', 'anondecl')
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::IN_DECL 
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {

if ($::INTERPOLATION) {
return ();
}
else {
$C->panic("Anonymous variable requires declarator");
}

}, $C)
}, $C->before( sub { my $C=shift;
$C
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} or do { die $@ if $@ };
@gather;
}
}))
}, scalar(do {

}, $C))
}, $C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
scalar(do {
my $M = $C; 
$sigil = $M->{'sigil'}->Str;
$::SIGIL ||= $sigil;
;
}, $C);
}
else {
();
}
}
}))
);
}



# Note, don't reduce on a bare sigil unless you don't want a twigil or
# you otherwise don't care what the longest token is.

## token sigil__S_188Dollar (:$sym is context<rw> = <$>)
##      token sigil:sym<$>  { <sym> }

sub sigil__S_188Dollar__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_188Dollar',$retree) }
sub sigil__S_188Dollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_188Dollar", 
$C->_PATTERN(qr/\G\$/)
);
}
## token sigil__S_189AtAt (:$sym is context<rw> = <@@>)
##      token sigil:sym<@@> { <sym> }

sub sigil__S_189AtAt__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_189AtAt',$retree) }
sub sigil__S_189AtAt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@@);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_189AtAt", 
$C->_PATTERN(qr/\G\@\@/)
);
}
## token sigil__S_190At (:$sym is context<rw> = <@>)
##      token sigil:sym<@>  { <sym> }

sub sigil__S_190At__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_190At',$retree) }
sub sigil__S_190At {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_190At", 
$C->_PATTERN(qr/\G\@/)
);
}
## token sigil__S_191Percent (:$sym is context<rw> = <%>)
##      token sigil:sym<%>  { <sym> }

sub sigil__S_191Percent__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_191Percent',$retree) }
sub sigil__S_191Percent {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_191Percent", 
$C->_PATTERN(qr/\G\%/)
);
}
## token sigil__S_192Amp (:$sym is context<rw> = <&>)
##      token sigil:sym<&>  { <sym> }

sub sigil__S_192Amp__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_192Amp',$retree) }
sub sigil__S_192Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_192Amp", 
$C->_PATTERN(qr/\G\&/)
);
}

## token twigil__S_193Dot (:$sym is context<rw> = <.>)
##      token twigil:sym<.> { <sym> }

sub twigil__S_193Dot__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_193Dot',$retree) }
sub twigil__S_193Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_193Dot", 
$C->_PATTERN(qr/\G\./)
);
}
## token twigil__S_194Bang (:$sym is context<rw> = <!>)
##      token twigil:sym<!> { <sym> }

sub twigil__S_194Bang__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_194Bang',$retree) }
sub twigil__S_194Bang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_194Bang", 
$C->_PATTERN(qr/\G\!/)
);
}
## token twigil__S_195Caret (:$sym is context<rw> = <^>)
##      token twigil:sym<^> { <sym> }

sub twigil__S_195Caret__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_195Caret',$retree) }
sub twigil__S_195Caret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_195Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
## token twigil__S_196Colon (:$sym is context<rw> = <:>)
##      token twigil:sym<:> { <sym> <!before ':'> }

sub twigil__S_196Colon__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_196Colon',$retree) }
sub twigil__S_196Colon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_196Colon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(':')
})
});
}
else {
();
}
}
);
}
## token twigil__S_197Star (:$sym is context<rw> = <*>)
##      token twigil:sym<*> { <sym> }

sub twigil__S_197Star__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_197Star',$retree) }
sub twigil__S_197Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_197Star", 
$C->_PATTERN(qr/\G\*/)
);
}
## token twigil__S_198Plus (:$sym is context<rw> = <+>)
##      token twigil:sym<+> { <sym> <!!worry: "The + twigil is deprecated, use the * twigil instead"> }

sub twigil__S_198Plus__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_198Plus',$retree) }
sub twigil__S_198Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_198Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->worry("The + twigil is deprecated, use the * twigil instead")
})
});
}
else {
();
}
}
);
}
## token twigil__S_199Question (:$sym is context<rw> = <?>)
##      token twigil:sym<?> { <sym> }

sub twigil__S_199Question__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_199Question',$retree) }
sub twigil__S_199Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_199Question", 
$C->_PATTERN(qr/\G\?/)
);
}
## token twigil__S_200Equal (:$sym is context<rw> = <=>)
##      token twigil:sym<=> { <sym> }

sub twigil__S_200Equal__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_200Equal',$retree) }
sub twigil__S_200Equal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_200Equal", 
$C->_PATTERN(qr/\G\=/)
);
}
## token twigil__S_201Tilde (:$sym is context<rw> = <~>)
##      token twigil:sym<~> { <sym> }

sub twigil__S_201Tilde__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_201Tilde',$retree) }
sub twigil__S_201Tilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_201Tilde", 
$C->_PATTERN(qr/\G\~/)
);
}

## token deflongname
##      token deflongname {
##          :dba('new name to be defined')
##          <name>
##          [
##          | <colonpair>+ { $.add_macro($<name>) if $*IN_DECL; }
##          | { $.add_routine($<name>.Str) if $*IN_DECL; }
##          ]
##      }

sub deflongname__PEEK { $_[0]->_AUTOLEXpeek('deflongname',$retree) }
sub deflongname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "deflongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'deflongname_01') {
$C->deb("Fate passed to deflongname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'deflongname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("deflongname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{'name'}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
scalar(do {
my $M = $C;  $C->add_routine($M->{'name'}->Str) if $::IN_DECL; ;
}, $C)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token longname
##      token longname {
##          <name> <colonpair>*
##      }

sub longname__PEEK { $_[0]->_AUTOLEXpeek('longname',$retree) }
sub longname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "longname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
});
}
else {
();
}
}
);
}

## token name
##      token name {
##          [
##          | <identifier> <morename>*
##          | <morename>+
##          ]
##      }

sub name__PEEK { $_[0]->_AUTOLEXpeek('name',$retree) }
sub name {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'morename'} = [];

$self->_MATCHIFYr($S, "name", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'name_01') {
$C->deb("Fate passed to name_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'name_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("name_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token morename
##      token morename {
##          :my $INTERPOLATION is context<rw> = 0;
##          '::'
##          [
##              <?before '(' | <alpha> >
##              [
##              | <identifier>
##              | :dba('indirect name') '(' ~ ')' <EXPR>
##              ]
##          ]?
##      }

sub morename__PEEK { $_[0]->_AUTOLEXpeek('morename',$retree) }
sub morename {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INTERPOLATION = 0;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'identifier'} = [];
$C->{'EXPR'} = [];

$self->_MATCHIFY($S, "morename", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_03') {
$C->deb("Fate passed to morename_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'indirect name')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_02') {
$C->deb("Fate passed to morename_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
})
})
}, $C->_EXACT('::'))
);
}

## token subshortname
##      token subshortname {
##          [
##          | <category>
##              [ <colonpair>+ { $.add_macro($<category>) if $*IN_DECL; } ]?
##          | <desigilname>
##          ]
##      }

sub subshortname__PEEK { $_[0]->_AUTOLEXpeek('subshortname',$retree) }
sub subshortname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "subshortname", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'subshortname_01') {
$C->deb("Fate passed to subshortname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'subshortname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("subshortname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{'category'}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token sublongname
##      token sublongname {
##          <subshortname> <sigterm>?
##      }

sub sublongname__PEEK { $_[0]->_AUTOLEXpeek('sublongname',$retree) }
sub sublongname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sigterm'} = [];

$self->_MATCHIFYr($S, "sublongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['subshortname'], sub {
my $C = shift;
$C->subshortname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
});
}
else {
();
}
}
);
}

## token value__S_202quote (:$sym is context<rw> = 'quote')
##      token value:quote   { <quote> }

sub value__S_202quote__PEEK { $_[0]->_AUTOLEXpeek('value__S_202quote',$retree) }
sub value__S_202quote {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "value__S_202quote", 
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
);
}
## token value__S_203number (:$sym is context<rw> = 'number')
##      token value:number  { <number> }

sub value__S_203number__PEEK { $_[0]->_AUTOLEXpeek('value__S_203number',$retree) }
sub value__S_203number {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'number';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "value__S_203number", 
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
);
}
## token value__S_204version (:$sym is context<rw> = 'version')
##      token value:version { <version> }

sub value__S_204version__PEEK { $_[0]->_AUTOLEXpeek('value__S_204version',$retree) }
sub value__S_204version {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'version';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "value__S_204version", 
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
);
}

# Note: call this only to use existing type, not to declare type
## token typename
##      token typename {
##          [
##          | '::?'<identifier>                 # parse ::?CLASS as special case
##          | <longname>
##            <?{{
##              my $longname = $<longname>.Str;
##              if substr($longname, 0, 2) eq '::' {
##                  $.add_my_name(substr($longname, 2));
##              }
##              else {
##                  $.is_name($longname)
##              }
##            }}>
##          ]
##          # parametric type?
##          <.unsp>? [ <?before '['> <postcircumfix> ]?
##          <.ws> [ 'of' <.ws> <typename> ]?
##      }

sub typename__PEEK { $_[0]->_AUTOLEXpeek('typename',$retree) }
sub typename {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'typename'} = [];
$C->{'postcircumfix'} = [];

$self->_MATCHIFYr($S, "typename", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'typename_01') {
$C->deb("Fate passed to typename_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'typename_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("typename_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
my $longname = $M->{'longname'}->Str;
if (substr($longname, 0, 2) eq '::') {
$C->add_my_name(substr($longname, 2));
}
else {
$C->is_name($longname)
}
;
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('of'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token numish
##      token numish {
##          [
##          | <integer>
##          | <dec_number>
##          | <rad_number>
##          | 'NaN' 
##          | 'Inf' 
##          | '+Inf' 
##          | '-Inf' 
##          ]
##      }

sub numish__PEEK { $_[0]->_AUTOLEXpeek('numish',$retree) }
sub numish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "numish", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'numish_01') {
$C->deb("Fate passed to numish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'numish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("numish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['dec_number'], sub {
my $C = shift;
$C->dec_number
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('NaN'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('Inf'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('+Inf'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-Inf'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token number__S_205rational (:$sym is context<rw> = 'rational')
##      token number:rational { <nu=integer>'/'<de=integer> }

sub number__S_205rational__PEEK { $_[0]->_AUTOLEXpeek('number__S_205rational',$retree) }
sub number__S_205rational {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rational';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "number__S_205rational", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['nu'], sub {
my $C = shift;
$C->integer
}))) {
do {
if (my ($C) = ($C->_EXACT('/'))) {
$C->_SUBSUMEr(['de'], sub {
my $C = shift;
$C->integer
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token number__S_206complex (:$sym is context<rw> = 'complex')
##      token number:complex { <re=numish>'+'<im=numish>'\\'?'i' | <im=numish>'\\'?'i' }

sub number__S_206complex__PEEK { $_[0]->_AUTOLEXpeek('number__S_206complex',$retree) }
sub number__S_206complex {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'complex';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "number__S_206complex", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'number__S_206complex_00') {
$C->deb("Fate passed to number__S_206complex_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'number__S_206complex_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("number__S_206complex_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['re'], sub {
my $C = shift;
$C->numish
}))) {
do {
if (my ($C) = ($C->_EXACT('+'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['im'], sub {
my $C = shift;
$C->numish
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('\\')
}))) {
$C->_EXACT('i');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['im'], sub {
my $C = shift;
$C->numish
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('\\')
}))) {
$C->_EXACT('i');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}
## token number__S_207numish (:$sym is context<rw> = 'numish')
##      token number:numish { <numish> }

sub number__S_207numish__PEEK { $_[0]->_AUTOLEXpeek('number__S_207numish',$retree) }
sub number__S_207numish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'numish';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "number__S_207numish", 
$C->_SUBSUMEr(['numish'], sub {
my $C = shift;
$C->numish
})
);
}

## token integer
##      token integer {
##          [
##          | 0 [ b <[01]>+           [ _ <[01]>+ ]*
##              | o <[0..7]>+         [ _ <[0..7]>+ ]*
##              | x <[0..9a..fA..F]>+ [ _ <[0..9a..fA..F]>+ ]*
##              | d \d+               [ _ \d+]*
##              | \d+[_\d+]*
##                  <!!{ $.worry("Leading 0 does not indicate octal in Perl 6") }>
##              ]
##          | \d+[_\d+]*
##          ]
##          <!!before ['.' <?before \s | ',' | '=' | <terminator> > <.panic: "Decimal point must be followed by digit">]? >
##      }

sub integer__PEEK { $_[0]->_AUTOLEXpeek('integer',$retree) }
sub integer {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "integer", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_01') {
$C->deb("Fate passed to integer_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_02') {
$C->deb("Fate passed to integer_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('b'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[01])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[01])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('o'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-7])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-7])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('x'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('d'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$C->worry("Leading 0 does not indicate octal in Perl 6") 
})
})
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_11') {
$C->deb("Fate passed to integer_11: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_11', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_11 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->panic("Decimal point must be followed by digit");
}
else {
();
}
};
}
else {
();
}
}
})
})
})
})
});
}
else {
();
}
}
);
}

## token radint
##      token radint {
##          [
##          | <integer>
##          | <?before ':'> <rad_number> <?{
##                              defined $<rad_number><intpart>
##                              and
##                              not defined $<rad_number><fracpart>
##                          }>
##          ]
##      }

sub radint__PEEK { $_[0]->_AUTOLEXpeek('radint',$retree) }
sub radint {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "radint", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'radint_01') {
$C->deb("Fate passed to radint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'radint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("radint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
defined $M->{'rad_number'}{'intpart'}
and
not defined $M->{'rad_number'}{'fracpart'}
;
})
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token escale
##      token escale {
##          <[Ee]> <[+\-]>? \d+[_\d+]*
##      }

sub escale__PEEK { $_[0]->_AUTOLEXpeek('escale',$retree) }
sub escale {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "escale", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[Ee]/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[+\-])?+)/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# careful to distinguish from both integer and 42.method
## token dec_number
##      token dec_number {
##          :dba('decimal number')
##          [
##          | $<coeff> = [           '.' \d+[_\d+]* ] <escale>?
##          | $<coeff> = [\d+[_\d+]* '.' \d+[_\d+]* ] <escale>?
##          | $<coeff> = [\d+[_\d+]*                ] <escale>
##          ]
##          <!!before [ '.' <?before \d> <.panic: "Number contains two decimal points (missing 'v' for version number?)">]? >
##      }

sub dec_number__PEEK { $_[0]->_AUTOLEXpeek('dec_number',$retree) }
sub dec_number {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'escale'} = [];

$self->_MATCHIFYr($S, "dec_number", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dec_number_01') {
$C->deb("Fate passed to dec_number_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dec_number_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dec_number_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
})
}))) {
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
}))) {
$C->panic("Number contains two decimal points (missing 'v' for version number?)");
}
else {
();
}
};
}
else {
();
}
}
})
})
})
})
});
}
else {
();
}
}
);
}

## token rad_number
##      token rad_number {
##          ':' $<radix> = [\d+] <.unsp>?      # XXX optional dot here?
##          {}           # don't recurse in lexer
##          :dba('number in radix notation')
##          [
##          || '<'
##                  $<intpart> = [ <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]
##                  $<fracpart> = [ '.' <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]?
##                  [ '*' <base=radint> '**' <exp=radint> ]?
##             '>'
##      #      { make radcalc($<radix>, $<intpart>, $<fracpart>, $<base>, $<exp>) }
##          || <?before '['> <postcircumfix>
##          || <?before '('> <postcircumfix>
##          ]
##      }

sub rad_number__PEEK { $_[0]->_AUTOLEXpeek('rad_number',$retree) }
sub rad_number {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'exp'} = [];
$C->{'base'} = [];

$self->_MATCHIFYr($S, "rad_number", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['radix'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['intpart'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['fracpart'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
})
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['base'], sub {
my $C = shift;
$C->radint
}))) {
do {
if (my ($C) = ($C->_EXACT('**'))) {
$C->_SUBSUMEr(['exp'], sub {
my $C = shift;
$C->radint
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token octints
##      token octints { [<.ws><octint><.ws>] ** ',' }

sub octints__PEEK { $_[0]->_AUTOLEXpeek('octints',$retree) }
sub octints {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'octint'} = [];

$self->_MATCHIFYr($S, "octints", 
$C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
})
);
}

## token octint
##      token octint {
##          <[ 0..7 ]>+ [ _ <[ 0..7 ]>+ ]*
##      }

sub octint__PEEK { $_[0]->_AUTOLEXpeek('octint',$retree) }
sub octint {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "octint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-7])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-7])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token hexints
##      token hexints { [<.ws><hexint><.ws>] ** ',' }

sub hexints__PEEK { $_[0]->_AUTOLEXpeek('hexints',$retree) }
sub hexints {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'hexint'} = [];

$self->_MATCHIFYr($S, "hexints", 
$C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
})
);
}

## token hexint
##      token hexint {
##          <[ 0..9 a..f A..F ]>+ [ _ <[ 0..9 a..f A..F ]>+ ]*
##      }

sub hexint__PEEK { $_[0]->_AUTOLEXpeek('hexint',$retree) }
sub hexint {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "hexint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

our @herestub_queue;

{ package STD::Herestub;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_has 'delim' => (is => 'rw');    moose_has 'orignode' => (is => 'rw');    moose_has 'lang' => (is => 'rw');} ## end class

{ package STD::herestop;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##     token stopper
##          token stopper { ^^ {*} $<ws>=(\h*?) $*DELIM \h* <.unv>?? $$ \v? }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "stopper", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G((?:[\n])?+)/)
}, $C->_PATTERN(qr/\G(?m:$)/))
}, $C->_OPTf(sub { my $C=shift;
$C->unv
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_EXACT($::DELIM))
},     $C->_SUBSUME(['ws'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
})
})}
}))
}, $C->_REDUCE($S, 'stopper'))
}, $C->_PATTERN(qr/\G(?m:^)/))
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        text: "^^"
      - !!perl/hash:RE_method_internal 
        args: $S, 'stopper'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 0
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: stopper
              i: 0
              min: 1
              r: 1
              s: 0
              text: \h
            min: 0
            quant: 
              - "*"
              - "?"
              - ''
              - 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        var: ws
      - !!perl/hash:RE_var 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        var: $*DELIM
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: stopper
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: stopper
          i: 0
          min: 12345
          name: unv
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - "?"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        text: $$
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: stopper
          i: 0
          min: 1
          r: 1
          s: 0
          text: \v
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
RETREE_END
}
} ## end role

# XXX be sure to temporize @herestub_queue on reentry to new line of heredocs

## method heredoc ()
sub heredoc {
my $self = shift;


local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
return if $self->peek;
my $here = $self;
while (my $herestub = shift @herestub_queue) {
local $::DELIM = $herestub->delim;
my $lang = $herestub->lang->mixin( 'STD::herestop' );
my $doc;
if (($doc) = $here->nibble($lang)) {
$here = $doc->trim_heredoc();
$herestub->orignode->{'doc'} = $doc;
}
else {
$self->panic("Ending delimiter $::DELIM not found");
}
}
return $self->cursor($here->{'_pos'});  # return to initial type
}

#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}

#proto token escape { <...> }
sub escape__PEEK { $_[0]->_AUTOLEXpeek('escape:*',$retree); }
sub escape {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'escape') {
$C->deb("Fate passed to escape: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'escape:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "escape", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}

## token starter
##      token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
## token escape__S_208none (:$sym is context<rw> = 'none')
##      token escape:none { <!> }

sub escape__S_208none__PEEK { $_[0]->_AUTOLEXpeek('escape__S_208none',$retree) }
sub escape__S_208none {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'none';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_208none", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

## token babble ($l)
##      token babble ($l) {
##          :my $lang = $l;
##          :my $start;
##          :my $stop;
##      
##          <.ws>
##          [ <quotepair> <.ws>
##              {
##                  my $kv = $<quotepair>[*-1];
##                  $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                      or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##              }
##          ]*
##      
##          {
##              ($start,$stop) = $.peek_delimiters();
##              $lang = $start ne $stop ?? $lang.balanced($start,$stop)
##                                      !! $lang.unbalanced($stop);
##              $<B> = [$lang,$start,$stop];
##          }
##      }

sub babble__PEEK { $_[0]->_AUTOLEXpeek('babble',$retree) }
sub babble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang = $l;
my $start;
my $stop;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "babble", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{'quotepair'}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
($start,$stop) = $C->peek_delimiters();
$lang = $start ne $stop ? $lang->balanced($start,$stop)
: $lang->unbalanced($stop);
$M->{'B'} = [$lang,$start,$stop];
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quibble ($l)
##      token quibble ($l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <nibble($lang)> $stop
##      
##          {{
##              if $lang<_herelang> {
##                  push @herestub_queue,
##                      ::Herestub.new(
##                          delim => $<nibble><nibbles>[0]<TEXT>,
##                          orignode => $,
##                          lang => $lang<_herelang>,
##                      );
##              }
##          }}
##      }

sub quibble__PEEK { $_[0]->_AUTOLEXpeek('quibble',$retree) }
sub quibble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{'babble'}{'B'}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
scalar(do {
my $M = $C; 
if ($lang->{'_herelang'}) {
push @herestub_queue,
'STD::Herestub'->new(
delim => $M->{'nibble'}{'nibbles'}[0]{'TEXT'},
orignode => $C,
lang => $lang->{'_herelang'},
);
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token sibble ($l, $lang2)
##      token sibble ($l, $lang2) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <left=nibble($lang)> $stop 
##          [ <?{ $start ne $stop }>
##              <.ws>
##              [ '=' || <.panic: "Missing '='"> ]
##              <.ws>
##              <right=EXPR(item %item_assignment)>
##          || 
##              { $lang = $lang2.unbalanced($stop); }
##              <right=nibble($lang)> $stop
##          ]
##      }

sub sibble__PEEK { $_[0]->_AUTOLEXpeek('sibble',$retree) }
sub sibble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "sibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{'babble'}{'B'}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('=')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Missing '='")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token tribble ($l, $lang2 = $l)
##      token tribble ($l, $lang2 = $l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <left=nibble($lang)> $stop 
##          [ <?{ $start ne $stop }>
##              <.ws> <quibble($lang2)>
##          || 
##              { $lang = $lang2.unbalanced($stop); }
##              <right=nibble($lang)> $stop
##          ]
##      }

sub tribble__PEEK { $_[0]->_AUTOLEXpeek('tribble',$retree) }
sub tribble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift() // $l;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "tribble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{'babble'}{'B'}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($lang2)
});
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quasiquibble ($l)
##      token quasiquibble ($l) {
##          :my ($lang, $start, $stop);
##          :my $QUASI_QUASH is context = 0; # :COMPILING sets true
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          [
##          || <?{ $start eq '{' }> [ :lang($lang) <block> ]
##          || $start [ :lang($lang) <statementlist> ] $stop
##          ]
##      }

sub quasiquibble__PEEK { $_[0]->_AUTOLEXpeek('quasiquibble',$retree) }
sub quasiquibble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my ($lang, $start, $stop);
local $::QUASI_QUASH = 0;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quasiquibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{'babble'}{'B'}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start eq '{' 
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
});
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# note: polymorphic over many quote languages, we hope
## token nibbler
##      token nibbler {
##          :my $text = '';
##          :my $from = self.pos;
##          :my $to = $from;
##          :my @nibbles = ();
##          :my $multiline = 0;
##          :my $nibble;
##          { $<_from> = self.pos; }
##          [ <!before <stopper> >
##              [
##              || <starter> <nibbler> <stopper>
##                              {{
##                                  push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );
##      
##                                  my $n = $<nibbler>[*-1]<nibbles>;
##                                  my @n = @$n;
##      
##                                  push @nibbles, $<starter>;
##                                  push @nibbles, @n;
##                                  push @nibbles, $<stopper>;
##      
##                                  $text = '';
##                                  $to = $from = $.pos;
##                              }}
##              || <escape>     {{
##                                  push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to ), $<escape>[*-1];
##                                  $text = '';
##                                  $to = $from = $.pos;
##                              }}
##              || .
##                              {{
##                                  my $ch = substr($*ORIG, $.pos-1, 1);
##                                  $text ~= $ch;
##                                  $to = $.pos;
##                                  if $ch ~~ "\n" {
##                                      $multiline++;
##                                  }
##                              }}
##              ]
##          ]*
##          {{
##              push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );
##              $<nibbles> = \@nibbles;
##              $<_pos> = $.pos;
##              $<nibbler> :delete;
##              $<escape> :delete;
##              $<starter> :delete;
##              $<stopper> :delete;
##              $COMPILING::LAST_NIBBLE = $;
##              $COMPILING::LAST_NIBBLE_MULTILINE = $ if $multiline;
##          }}
##      }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $text = '';
my $from = $self->{'_pos'};
my $to = $from;
my @nibbles = ();
my $multiline = 0;
my $nibble;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'nibbler'} = [];
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'escape'} = [];

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{'_from'} = $self->{'_pos'}; ;
}, $C))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->cursor_singleton(TEXT => $text, _from => $from, _pos => $to );

my $n = $M->{'nibbler'}[-1]{'nibbles'};
my @n = @$n;

push @nibbles, $M->{'starter'};
push @nibbles, @n;
push @nibbles, $M->{'stopper'};

$text = '';
$to = $from = $C->{'_pos'};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['escape'], sub {
my $C = shift;
$C->escape
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->cursor_singleton(TEXT => $text, _from => $from, _pos => $to ), $M->{'escape'}[-1];
$text = '';
$to = $from = $C->{'_pos'};
;
}, $C);
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->_PATTERN(qr/\G(?s:.)/))) {
scalar(do {

my $ch = substr($::ORIG, $C->{'_pos'}-1, 1);
$text .= $ch;
$to = $C->{'_pos'};
if ($ch =~ "\n") {
$multiline++;
}

}, $C);
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->cursor_singleton(TEXT => $text, _from => $from, _pos => $to );
$M->{'nibbles'} = \@nibbles;
$M->{'_pos'} = $C->{'_pos'};
delete $M->{'nibbler'};
delete $M->{'escape'};
delete $M->{'starter'};
delete $M->{'stopper'};
$COMPILING::LAST_NIBBLE = $C;
$COMPILING::LAST_NIBBLE_MULTILINE = $C if $multiline;
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

# and this is what makes nibbler polymorphic...
## method nibble ($lang)
sub nibble {
my $self = shift;
my $lang = shift;


$self->cursor_fresh($lang)->nibbler;
}


## token quote__S_209Single_Single (:$sym is context<rw> = <' '>)
##      token quote:sym<' '>   { "'" <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:q).unbalanced("'"))> "'" }

sub quote__S_209Single_Single__PEEK { $_[0]->_AUTOLEXpeek('quote__S_209Single_Single',$retree) }
sub quote__S_209Single_Single {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(' ')];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_209Single_Single", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G'/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->unbalanced("'"))
}))) {
$C->_PATTERN(qr/\G'/);
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_210Double_Double (:$sym is context<rw> = <" ">)
##      token quote:sym<" ">   { '"' <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).unbalanced('"'))> '"' }

sub quote__S_210Double_Double__PEEK { $_[0]->_AUTOLEXpeek('quote__S_210Double_Double',$retree) }
sub quote__S_210Double_Double {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(" ")];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_210Double_Double", 
do {
if (my ($C) = ($C->_EXACT('"'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->unbalanced('"'))
}))) {
$C->_EXACT('"');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_211Fre_Nch (:$sym is context<rw> = < >)
##      token quote:sym< >   { '' <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('',''))> '' }

sub quote__S_211Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('quote__S_211Fre_Nch',$retree) }
sub quote__S_211Fre_Nch {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_211Fre_Nch", 
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('',''))
}))) {
$C->_EXACT('');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_212LtLt_GtGt (:$sym is context<rw> = << >>)
##      token quote:sym<< >> { '<<' <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> '>>' }

sub quote__S_212LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('quote__S_212LtLt_GtGt',$retree) }
sub quote__S_212LtLt_GtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_212LtLt_GtGt", 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
$C->_EXACT('>>');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_213Lt_Gt (:$sym is context<rw> = < >)
##      token quote:sym< >   { '<'
##                                    [ <?before 'STDIN>' > <.obs('<STDIN>', '$' ~ '*IN.lines')> ]?  # XXX fake out gimme5
##                                    [ <?before '>' > <.obs('<>', 'lines() or ()')> ]?
##                                    <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))> '>' }

sub quote__S_213Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('quote__S_213Lt_Gt',$retree) }
sub quote__S_213Lt_Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_213Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('STDIN>')
}))) {
$C->obs('<STDIN>', '$' . '*IN.lines');
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('>')
}))) {
$C->obs('<>', 'lines() or ()');
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_214SlashSlash (:$sym is context<rw> = <//>)
##      token quote:sym<//>   {
##          '/'\s*'/' <.panic: "Null regex not allowed">
##      }

sub quote__S_214SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_214SlashSlash',$retree) }
sub quote__S_214SlashSlash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(//);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_214SlashSlash", 
do {
if (my ($C) = ($C->_EXACT('/'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
do {
if (my ($C) = ($C->_EXACT('/'))) {
$C->panic("Null regex not allowed");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_215Slash_Slash (:$sym is context<rw> = </ />)
##      token quote:sym</ />   {
##          '/' <nibble( $.cursor_fresh( %*LANG<Regex> ).unbalanced("/") )> [ '/' || <.panic: "Unable to parse regex; couldn't find final '/'"> ]
##          <.old_rx_mods>?
##      }

sub quote__S_215Slash_Slash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_215Slash_Slash',$retree) }
sub quote__S_215Slash_Slash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(/ /)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_215Slash_Slash", 
do {
if (my ($C) = ($C->_EXACT('/'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh( $::LANG{'Regex'} )->unbalanced("/") )
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('/')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find final '/'")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_OPTr(sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# handle composite forms like qww
## token quote__S_216qq (:$sym is context<rw> = 'qq')
##      token quote:qq {
##          :my $qm;
##          'qq'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.Str } <.ws> <quibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq))>
##          ]
##      }

sub quote__S_216qq__PEEK { $_[0]->_AUTOLEXpeek('quote__S_216qq',$retree) }
sub quote__S_216qq {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';
my $qm;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_216qq", 
do {
if (my ($C) = ($C->_EXACT('qq'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_216qq_01') {
$C->deb("Fate passed to quote__S_216qq_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_216qq_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_216qq_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{'quote_mod'}->Str ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
## token quote__S_217q (:$sym is context<rw> = 'q')
##      token quote:q {
##          :my $qm;
##          'q'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.Str } <quibble($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( %*LANG<Q> ).tweak(:q))>
##          ]
##      }

sub quote__S_217q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_217q',$retree) }
sub quote__S_217q {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'q';
my $qm;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_217q", 
do {
if (my ($C) = ($C->_EXACT('q'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_217q_01') {
$C->deb("Fate passed to quote__S_217q_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_217q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_217q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{'quote_mod'}->Str ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token quote__S_218Q (:$sym is context<rw> = 'Q')
##      token quote:Q {
##          :my $qm;
##          'Q'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.Str } <quibble($.cursor_fresh( %*LANG<Q> ).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( %*LANG<Q> ))>
##          ]
##      }

sub quote__S_218Q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_218Q',$retree) }
sub quote__S_218Q {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';
my $qm;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_218Q", 
do {
if (my ($C) = ($C->_EXACT('Q'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_218Q_01') {
$C->deb("Fate passed to quote__S_218Q_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_218Q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_218Q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{'quote_mod'}->Str ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token quote_mod__S_219w (:$sym is context<rw> = 'w')
##      token quote_mod:w  { <sym> }

sub quote_mod__S_219w__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_219w',$retree) }
sub quote_mod__S_219w {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_219w", 
$C->_PATTERN(qr/\Gw/)
);
}
## token quote_mod__S_220ww (:$sym is context<rw> = 'ww')
##      token quote_mod:ww { <sym> }

sub quote_mod__S_220ww__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_220ww',$retree) }
sub quote_mod__S_220ww {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ww';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_220ww", 
$C->_PATTERN(qr/\Gww/)
);
}
## token quote_mod__S_221x (:$sym is context<rw> = 'x')
##      token quote_mod:x  { <sym> }

sub quote_mod__S_221x__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_221x',$retree) }
sub quote_mod__S_221x {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_221x", 
$C->_PATTERN(qr/\Gx/)
);
}
## token quote_mod__S_222to (:$sym is context<rw> = 'to')
##      token quote_mod:to { <sym> }

sub quote_mod__S_222to__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_222to',$retree) }
sub quote_mod__S_222to {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'to';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_222to", 
$C->_PATTERN(qr/\Gto/)
);
}
## token quote_mod__S_223s (:$sym is context<rw> = 's')
##      token quote_mod:s  { <sym> }

sub quote_mod__S_223s__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_223s',$retree) }
sub quote_mod__S_223s {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_223s", 
$C->_PATTERN(qr/\Gs/)
);
}
## token quote_mod__S_224a (:$sym is context<rw> = 'a')
##      token quote_mod:a  { <sym> }

sub quote_mod__S_224a__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_224a',$retree) }
sub quote_mod__S_224a {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_224a", 
$C->_PATTERN(qr/\Ga/)
);
}
## token quote_mod__S_225h (:$sym is context<rw> = 'h')
##      token quote_mod:h  { <sym> }

sub quote_mod__S_225h__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_225h',$retree) }
sub quote_mod__S_225h {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_225h", 
$C->_PATTERN(qr/\Gh/)
);
}
## token quote_mod__S_226f (:$sym is context<rw> = 'f')
##      token quote_mod:f  { <sym> }

sub quote_mod__S_226f__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_226f',$retree) }
sub quote_mod__S_226f {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_226f", 
$C->_PATTERN(qr/\Gf/)
);
}
## token quote_mod__S_227c (:$sym is context<rw> = 'c')
##      token quote_mod:c  { <sym> }

sub quote_mod__S_227c__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_227c',$retree) }
sub quote_mod__S_227c {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_227c", 
$C->_PATTERN(qr/\Gc/)
);
}
## token quote_mod__S_228b (:$sym is context<rw> = 'b')
##      token quote_mod:b  { <sym> }

sub quote_mod__S_228b__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_228b',$retree) }
sub quote_mod__S_228b {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_228b", 
$C->_PATTERN(qr/\Gb/)
);
}

## token quote__S_229rx (:$sym is context<rw> = 'rx')
##      token quote:rx {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( %*LANG<Regex> ) )>
##          <!old_rx_mods>
##      }

sub quote__S_229rx__PEEK { $_[0]->_AUTOLEXpeek('quote__S_229rx',$retree) }
sub quote__S_229rx {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rx';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_229rx", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grx/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_230m (:$sym is context<rw> = 'm')
##      token quote:m  {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( %*LANG<Regex> ) )>
##          <!old_rx_mods>
##      }

sub quote__S_230m__PEEK { $_[0]->_AUTOLEXpeek('quote__S_230m',$retree) }
sub quote__S_230m {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'm';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_230m", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_231mm (:$sym is context<rw> = 'mm')
##      token quote:mm {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( %*LANG<Regex> ).tweak(:s))>
##          <!old_rx_mods>
##      }

sub quote__S_231mm__PEEK { $_[0]->_AUTOLEXpeek('quote__S_231mm',$retree) }
sub quote__S_231mm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mm';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_231mm", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_232s (:$sym is context<rw> = 's')
##      token quote:s {
##          <sym>  <!before '('>
##          <pat=sibble( $.cursor_fresh( %*LANG<Regex> ), $.cursor_fresh( %*LANG<Q> ).tweak(:qq))>
##          <!old_rx_mods>
##      }

sub quote__S_232s__PEEK { $_[0]->_AUTOLEXpeek('quote__S_232s',$retree) }
sub quote__S_232s {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_232s", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} ), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_233ss (:$sym is context<rw> = 'ss')
##      token quote:ss {
##          <sym>  <!before '('>
##          <pat=sibble( $.cursor_fresh( %*LANG<Regex> ).tweak(:s), $.cursor_fresh( %*LANG<Q> ).tweak(:qq))>
##          <!old_rx_mods>
##      }

sub quote__S_233ss__PEEK { $_[0]->_AUTOLEXpeek('quote__S_233ss',$retree) }
sub quote__S_233ss {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ss';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_233ss", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gss/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_234tr (:$sym is context<rw> = 'tr')
##      token quote:tr {
##          <sym>  <!before '('> <pat=tribble( $.cursor_fresh( %*LANG<Q> ).tweak(:q))>
##          <!old_tr_mods>
##      }

sub quote__S_234tr__PEEK { $_[0]->_AUTOLEXpeek('quote__S_234tr',$retree) }
sub quote__S_234tr {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'tr';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_234tr", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtr/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->tribble( $C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_tr_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token old_rx_mods
##      token old_rx_mods {
##          <!after \s>
##          (< i g s m x c e >+) 
##          {{
##              given $0.Str {
##                  $_ ~~ /i/ and $.worryobs('/i',':i');
##                  $_ ~~ /g/ and $.worryobs('/g',':g');
##                  $_ ~~ /s/ and $.worryobs('/s','^^ and $$ anchors');
##                  $_ ~~ /m/ and $.worryobs('/m','. or \N');
##                  $_ ~~ /x/ and $.worryobs('/x','normal default whitespace');
##                  $_ ~~ /c/ and $.worryobs('/c',':c or :p');
##                  $_ ~~ /e/ and $.worryobs('/e','interpolated {...} or s{} = ... form');
##                  $.obs('suffix regex modifiers','prefix adverbs');
##              }
##          }}
##      }

sub old_rx_mods__PEEK { $_[0]->_AUTOLEXpeek('old_rx_mods',$retree) }
sub old_rx_mods {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "old_rx_mods", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=\s)/)
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< i g s m x c e > )
})
})}
}))) {
scalar(do {

given ($C->{'0'}->Str) {
$_ =~ qr/i/ and $C->worryobs('/i',':i');
$_ =~ qr/g/ and $C->worryobs('/g',':g');
$_ =~ qr/s/ and $C->worryobs('/s','^^ and $$ anchors');
$_ =~ qr/m/ and $C->worryobs('/m','. or \N');
$_ =~ qr/x/ and $C->worryobs('/x','normal default whitespace');
$_ =~ qr/c/ and $C->worryobs('/c',':c or :p');
$_ =~ qr/e/ and $C->worryobs('/e','interpolated {...} or s{} = ... form');
$C->obs('suffix regex modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token old_tr_mods
##      token old_tr_mods {
##          (< c d s ] >+) 
##          {{
##              given $0.Str {
##                  $_ ~~ /c/ and $.worryobs('/c',':c');
##                  $_ ~~ /d/ and $.worryobs('/g',':d');
##                  $_ ~~ /s/ and $.worryobs('/s',':s');
##                  $.obs('suffix transliteration modifiers','prefix adverbs');
##              }
##          }}
##      }

sub old_tr_mods__PEEK { $_[0]->_AUTOLEXpeek('old_tr_mods',$retree) }
sub old_tr_mods {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "old_tr_mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< c d s ] > )
})
})}
}))) {
scalar(do {

given ($C->{'0'}->Str) {
$_ =~ qr/c/ and $C->worryobs('/c',':c');
$_ =~ qr/d/ and $C->worryobs('/g',':d');
$_ =~ qr/s/ and $C->worryobs('/s',':s');
$C->obs('suffix transliteration modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
}
);
}


## token quote__S_235quasi (:$sym is context<rw> = 'quasi')
##      token quote:quasi {
##          <sym>  <!before '('> <quasiquibble($.cursor_fresh( %*LANG<Quasi> ))>
##      }

sub quote__S_235quasi__PEEK { $_[0]->_AUTOLEXpeek('quote__S_235quasi',$retree) }
sub quote__S_235quasi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quasi';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_235quasi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gquasi/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
$C->_SUBSUMEr(['quasiquibble'], sub {
my $C = shift;
$C->quasiquibble($C->cursor_fresh( $::LANG{'Quasi'} ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX should eventually be derived from current Unicode tables.
our %open2close = (
"\x{0028}" => "\x{0029}",
"\x{003C}" => "\x{003E}",
"\x{005B}" => "\x{005D}",
"\x{007B}" => "\x{007D}",
"\x{00AB}" => "\x{00BB}",
"\x{0F3A}" => "\x{0F3B}",
"\x{0F3C}" => "\x{0F3D}",
"\x{169B}" => "\x{169C}",
"\x{2018}" => "\x{2019}",
"\x{201A}" => "\x{2019}",
"\x{201B}" => "\x{2019}",
"\x{201C}" => "\x{201D}",
"\x{201E}" => "\x{201D}",
"\x{201F}" => "\x{201D}",
"\x{2039}" => "\x{203A}",
"\x{2045}" => "\x{2046}",
"\x{207D}" => "\x{207E}",
"\x{208D}" => "\x{208E}",
"\x{2208}" => "\x{220B}",
"\x{2209}" => "\x{220C}",
"\x{220A}" => "\x{220D}",
"\x{2215}" => "\x{29F5}",
"\x{223C}" => "\x{223D}",
"\x{2243}" => "\x{22CD}",
"\x{2252}" => "\x{2253}",
"\x{2254}" => "\x{2255}",
"\x{2264}" => "\x{2265}",
"\x{2266}" => "\x{2267}",
"\x{2268}" => "\x{2269}",
"\x{226A}" => "\x{226B}",
"\x{226E}" => "\x{226F}",
"\x{2270}" => "\x{2271}",
"\x{2272}" => "\x{2273}",
"\x{2274}" => "\x{2275}",
"\x{2276}" => "\x{2277}",
"\x{2278}" => "\x{2279}",
"\x{227A}" => "\x{227B}",
"\x{227C}" => "\x{227D}",
"\x{227E}" => "\x{227F}",
"\x{2280}" => "\x{2281}",
"\x{2282}" => "\x{2283}",
"\x{2284}" => "\x{2285}",
"\x{2286}" => "\x{2287}",
"\x{2288}" => "\x{2289}",
"\x{228A}" => "\x{228B}",
"\x{228F}" => "\x{2290}",
"\x{2291}" => "\x{2292}",
"\x{2298}" => "\x{29B8}",
"\x{22A2}" => "\x{22A3}",
"\x{22A6}" => "\x{2ADE}",
"\x{22A8}" => "\x{2AE4}",
"\x{22A9}" => "\x{2AE3}",
"\x{22AB}" => "\x{2AE5}",
"\x{22B0}" => "\x{22B1}",
"\x{22B2}" => "\x{22B3}",
"\x{22B4}" => "\x{22B5}",
"\x{22B6}" => "\x{22B7}",
"\x{22C9}" => "\x{22CA}",
"\x{22CB}" => "\x{22CC}",
"\x{22D0}" => "\x{22D1}",
"\x{22D6}" => "\x{22D7}",
"\x{22D8}" => "\x{22D9}",
"\x{22DA}" => "\x{22DB}",
"\x{22DC}" => "\x{22DD}",
"\x{22DE}" => "\x{22DF}",
"\x{22E0}" => "\x{22E1}",
"\x{22E2}" => "\x{22E3}",
"\x{22E4}" => "\x{22E5}",
"\x{22E6}" => "\x{22E7}",
"\x{22E8}" => "\x{22E9}",
"\x{22EA}" => "\x{22EB}",
"\x{22EC}" => "\x{22ED}",
"\x{22F0}" => "\x{22F1}",
"\x{22F2}" => "\x{22FA}",
"\x{22F3}" => "\x{22FB}",
"\x{22F4}" => "\x{22FC}",
"\x{22F6}" => "\x{22FD}",
"\x{22F7}" => "\x{22FE}",
"\x{2308}" => "\x{2309}",
"\x{230A}" => "\x{230B}",
"\x{2329}" => "\x{232A}",
"\x{23B4}" => "\x{23B5}",
"\x{2768}" => "\x{2769}",
"\x{276A}" => "\x{276B}",
"\x{276C}" => "\x{276D}",
"\x{276E}" => "\x{276F}",
"\x{2770}" => "\x{2771}",
"\x{2772}" => "\x{2773}",
"\x{2774}" => "\x{2775}",
"\x{27C3}" => "\x{27C4}",
"\x{27C5}" => "\x{27C6}",
"\x{27D5}" => "\x{27D6}",
"\x{27DD}" => "\x{27DE}",
"\x{27E2}" => "\x{27E3}",
"\x{27E4}" => "\x{27E5}",
"\x{27E6}" => "\x{27E7}",
"\x{27E8}" => "\x{27E9}",
"\x{27EA}" => "\x{27EB}",
"\x{2983}" => "\x{2984}",
"\x{2985}" => "\x{2986}",
"\x{2987}" => "\x{2988}",
"\x{2989}" => "\x{298A}",
"\x{298B}" => "\x{298C}",
"\x{298D}" => "\x{298E}",
"\x{298F}" => "\x{2990}",
"\x{2991}" => "\x{2992}",
"\x{2993}" => "\x{2994}",
"\x{2995}" => "\x{2996}",
"\x{2997}" => "\x{2998}",
"\x{29C0}" => "\x{29C1}",
"\x{29C4}" => "\x{29C5}",
"\x{29CF}" => "\x{29D0}",
"\x{29D1}" => "\x{29D2}",
"\x{29D4}" => "\x{29D5}",
"\x{29D8}" => "\x{29D9}",
"\x{29DA}" => "\x{29DB}",
"\x{29F8}" => "\x{29F9}",
"\x{29FC}" => "\x{29FD}",
"\x{2A2B}" => "\x{2A2C}",
"\x{2A2D}" => "\x{2A2E}",
"\x{2A34}" => "\x{2A35}",
"\x{2A3C}" => "\x{2A3D}",
"\x{2A64}" => "\x{2A65}",
"\x{2A79}" => "\x{2A7A}",
"\x{2A7D}" => "\x{2A7E}",
"\x{2A7F}" => "\x{2A80}",
"\x{2A81}" => "\x{2A82}",
"\x{2A83}" => "\x{2A84}",
"\x{2A8B}" => "\x{2A8C}",
"\x{2A91}" => "\x{2A92}",
"\x{2A93}" => "\x{2A94}",
"\x{2A95}" => "\x{2A96}",
"\x{2A97}" => "\x{2A98}",
"\x{2A99}" => "\x{2A9A}",
"\x{2A9B}" => "\x{2A9C}",
"\x{2AA1}" => "\x{2AA2}",
"\x{2AA6}" => "\x{2AA7}",
"\x{2AA8}" => "\x{2AA9}",
"\x{2AAA}" => "\x{2AAB}",
"\x{2AAC}" => "\x{2AAD}",
"\x{2AAF}" => "\x{2AB0}",
"\x{2AB3}" => "\x{2AB4}",
"\x{2ABB}" => "\x{2ABC}",
"\x{2ABD}" => "\x{2ABE}",
"\x{2ABF}" => "\x{2AC0}",
"\x{2AC1}" => "\x{2AC2}",
"\x{2AC3}" => "\x{2AC4}",
"\x{2AC5}" => "\x{2AC6}",
"\x{2ACD}" => "\x{2ACE}",
"\x{2ACF}" => "\x{2AD0}",
"\x{2AD1}" => "\x{2AD2}",
"\x{2AD3}" => "\x{2AD4}",
"\x{2AD5}" => "\x{2AD6}",
"\x{2AEC}" => "\x{2AED}",
"\x{2AF7}" => "\x{2AF8}",
"\x{2AF9}" => "\x{2AFA}",
"\x{2E02}" => "\x{2E03}",
"\x{2E04}" => "\x{2E05}",
"\x{2E09}" => "\x{2E0A}",
"\x{2E0C}" => "\x{2E0D}",
"\x{2E1C}" => "\x{2E1D}",
"\x{2E20}" => "\x{2E21}",
"\x{3008}" => "\x{3009}",
"\x{300A}" => "\x{300B}",
"\x{300C}" => "\x{300D}",
"\x{300E}" => "\x{300F}",
"\x{3010}" => "\x{3011}",
"\x{3014}" => "\x{3015}",
"\x{3016}" => "\x{3017}",
"\x{3018}" => "\x{3019}",
"\x{301A}" => "\x{301B}",
"\x{301D}" => "\x{301E}",
"\x{FD3E}" => "\x{FD3F}",
"\x{FE17}" => "\x{FE18}",
"\x{FE35}" => "\x{FE36}",
"\x{FE37}" => "\x{FE38}",
"\x{FE39}" => "\x{FE3A}",
"\x{FE3B}" => "\x{FE3C}",
"\x{FE3D}" => "\x{FE3E}",
"\x{FE3F}" => "\x{FE40}",
"\x{FE41}" => "\x{FE42}",
"\x{FE43}" => "\x{FE44}",
"\x{FE47}" => "\x{FE48}",
"\x{FE59}" => "\x{FE5A}",
"\x{FE5B}" => "\x{FE5C}",
"\x{FE5D}" => "\x{FE5E}",
"\x{FF08}" => "\x{FF09}",
"\x{FF1C}" => "\x{FF1E}",
"\x{FF3B}" => "\x{FF3D}",
"\x{FF5B}" => "\x{FF5D}",
"\x{FF5F}" => "\x{FF60}",
"\x{FF62}" => "\x{FF63}",
);

## token opener
##      token opener {
##        <[
##      \x0028
##      \x003C
##      \x005B
##      \x007B
##      \x00AB
##      \x0F3A
##      \x0F3C
##      \x169B
##      \x2018
##      \x201A
##      \x201B
##      \x201C
##      \x201E
##      \x201F
##      \x2039
##      \x2045
##      \x207D
##      \x208D
##      \x2208
##      \x2209
##      \x220A
##      \x2215
##      \x223C
##      \x2243
##      \x2252
##      \x2254
##      \x2264
##      \x2266
##      \x2268
##      \x226A
##      \x226E
##      \x2270
##      \x2272
##      \x2274
##      \x2276
##      \x2278
##      \x227A
##      \x227C
##      \x227E
##      \x2280
##      \x2282
##      \x2284
##      \x2286
##      \x2288
##      \x228A
##      \x228F
##      \x2291
##      \x2298
##      \x22A2
##      \x22A6
##      \x22A8
##      \x22A9
##      \x22AB
##      \x22B0
##      \x22B2
##      \x22B4
##      \x22B6
##      \x22C9
##      \x22CB
##      \x22D0
##      \x22D6
##      \x22D8
##      \x22DA
##      \x22DC
##      \x22DE
##      \x22E0
##      \x22E2
##      \x22E4
##      \x22E6
##      \x22E8
##      \x22EA
##      \x22EC
##      \x22F0
##      \x22F2
##      \x22F3
##      \x22F4
##      \x22F6
##      \x22F7
##      \x2308
##      \x230A
##      \x2329
##      \x23B4
##      \x2768
##      \x276A
##      \x276C
##      \x276E
##      \x2770
##      \x2772
##      \x2774
##      \x27C3
##      \x27C5
##      \x27D5
##      \x27DD
##      \x27E2
##      \x27E4
##      \x27E6
##      \x27E8
##      \x27EA
##      \x2983
##      \x2985
##      \x2987
##      \x2989
##      \x298B
##      \x298D
##      \x298F
##      \x2991
##      \x2993
##      \x2995
##      \x2997
##      \x29C0
##      \x29C4
##      \x29CF
##      \x29D1
##      \x29D4
##      \x29D8
##      \x29DA
##      \x29F8
##      \x29FC
##      \x2A2B
##      \x2A2D
##      \x2A34
##      \x2A3C
##      \x2A64
##      \x2A79
##      \x2A7D
##      \x2A7F
##      \x2A81
##      \x2A83
##      \x2A8B
##      \x2A91
##      \x2A93
##      \x2A95
##      \x2A97
##      \x2A99
##      \x2A9B
##      \x2AA1
##      \x2AA6
##      \x2AA8
##      \x2AAA
##      \x2AAC
##      \x2AAF
##      \x2AB3
##      \x2ABB
##      \x2ABD
##      \x2ABF
##      \x2AC1
##      \x2AC3
##      \x2AC5
##      \x2ACD
##      \x2ACF
##      \x2AD1
##      \x2AD3
##      \x2AD5
##      \x2AEC
##      \x2AF7
##      \x2AF9
##      \x2E02
##      \x2E04
##      \x2E09
##      \x2E0C
##      \x2E1C
##      \x2E20
##      \x3008
##      \x300A
##      \x300C
##      \x300E
##      \x3010
##      \x3014
##      \x3016
##      \x3018
##      \x301A
##      \x301D
##      \xFD3E
##      \xFE17
##      \xFE35
##      \xFE37
##      \xFE39
##      \xFE3B
##      \xFE3D
##      \xFE3F
##      \xFE41
##      \xFE43
##      \xFE47
##      \xFE59
##      \xFE5B
##      \xFE5D
##      \xFF08
##      \xFF1C
##      \xFF3B
##      \xFF5B
##      \xFF5F
##      \xFF62
##        ]>
##      }

sub opener__PEEK { $_[0]->_AUTOLEXpeek('opener',$retree) }
sub opener {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "opener", 
$C->_PATTERN(qr/\G[\x{0028}\x{003C}\x{005B}\x{007B}\x{00AB}\x{0F3A}\x{0F3C}\x{169B}\x{2018}\x{201A}\x{201B}\x{201C}\x{201E}\x{201F}\x{2039}\x{2045}\x{207D}\x{208D}\x{2208}\x{2209}\x{220A}\x{2215}\x{223C}\x{2243}\x{2252}\x{2254}\x{2264}\x{2266}\x{2268}\x{226A}\x{226E}\x{2270}\x{2272}\x{2274}\x{2276}\x{2278}\x{227A}\x{227C}\x{227E}\x{2280}\x{2282}\x{2284}\x{2286}\x{2288}\x{228A}\x{228F}\x{2291}\x{2298}\x{22A2}\x{22A6}\x{22A8}\x{22A9}\x{22AB}\x{22B0}\x{22B2}\x{22B4}\x{22B6}\x{22C9}\x{22CB}\x{22D0}\x{22D6}\x{22D8}\x{22DA}\x{22DC}\x{22DE}\x{22E0}\x{22E2}\x{22E4}\x{22E6}\x{22E8}\x{22EA}\x{22EC}\x{22F0}\x{22F2}\x{22F3}\x{22F4}\x{22F6}\x{22F7}\x{2308}\x{230A}\x{2329}\x{23B4}\x{2768}\x{276A}\x{276C}\x{276E}\x{2770}\x{2772}\x{2774}\x{27C3}\x{27C5}\x{27D5}\x{27DD}\x{27E2}\x{27E4}\x{27E6}\x{27E8}\x{27EA}\x{2983}\x{2985}\x{2987}\x{2989}\x{298B}\x{298D}\x{298F}\x{2991}\x{2993}\x{2995}\x{2997}\x{29C0}\x{29C4}\x{29CF}\x{29D1}\x{29D4}\x{29D8}\x{29DA}\x{29F8}\x{29FC}\x{2A2B}\x{2A2D}\x{2A34}\x{2A3C}\x{2A64}\x{2A79}\x{2A7D}\x{2A7F}\x{2A81}\x{2A83}\x{2A8B}\x{2A91}\x{2A93}\x{2A95}\x{2A97}\x{2A99}\x{2A9B}\x{2AA1}\x{2AA6}\x{2AA8}\x{2AAA}\x{2AAC}\x{2AAF}\x{2AB3}\x{2ABB}\x{2ABD}\x{2ABF}\x{2AC1}\x{2AC3}\x{2AC5}\x{2ACD}\x{2ACF}\x{2AD1}\x{2AD3}\x{2AD5}\x{2AEC}\x{2AF7}\x{2AF9}\x{2E02}\x{2E04}\x{2E09}\x{2E0C}\x{2E1C}\x{2E20}\x{3008}\x{300A}\x{300C}\x{300E}\x{3010}\x{3014}\x{3016}\x{3018}\x{301A}\x{301D}\x{FD3E}\x{FE17}\x{FE35}\x{FE37}\x{FE39}\x{FE3B}\x{FE3D}\x{FE3F}\x{FE41}\x{FE43}\x{FE47}\x{FE59}\x{FE5B}\x{FE5D}\x{FF08}\x{FF1C}\x{FF3B}\x{FF5B}\x{FF5F}\x{FF62}]/)
);
}

# assumes whitespace is eaten already

## method peek_delimiters
sub peek_delimiters {
my $self = shift;


my $pos = $self->{'_pos'};
my $startpos = $pos;
my $char = substr($::ORIG,$pos++,1);
if ($char =~ qr/^\s$/) {
$self->panic("Whitespace not allowed as delimiter");
}

# XXX not defined yet
#    <?before <+isPe> > {
#        self.panic("Use a closing delimiter for an opener is reserved");
#    }

my $rightbrack = $open2close{$char};
if (not defined $rightbrack) {
return $char, $char;
}
while (substr($::ORIG,$pos,1) eq $char) {
$pos++;
}
my $len = $pos - $startpos;
my $start = $char x $len;
my $stop = $rightbrack x $len;
return $start, $stop;
}

{ package STD::startstop;
sub __instantiate__ { my $self = shift;
my ($start,$stop) = @_;
my $mangle = ::mangle($start,$stop);
my $mixin = "STD::startstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$start' => $start,'$stop' => $stop } }
##     token starter
##          token starter { $start }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "starter", 
$C->_EXACT($start)
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: starter
    i: 0
    min: 0
    r: 1
    s: 0
    var: $start
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::stop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::stop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token starter
##          token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::unitstop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::unitstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token unitstopper
##          token unitstopper { $stop }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
unitstopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role
## token unitstopper
##      } # end role
##      
##      token unitstopper { $ }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_PATTERN(qr/\G\z/)
);
}

## method balanced ($start,$stop)
sub balanced {
my $self = shift;
my $start = shift;
my $stop = shift;

$self->mixin( 'STD::startstop'->__instantiate__($start,$stop) ); }
## method unbalanced ($stop)
sub unbalanced {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::stop'->__instantiate__($stop) ); }
## method unitstop ($stop)
sub unitstop {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::unitstop'->__instantiate__($stop) ); }

## token charname
##      token charname {
##          [
##          | <radint>
##          | <[a..z A..Z]><-[ \] , # ]>*?<[a..z A..Z ) ]> <?before \s*<[ \] , # ]>>
##          ] || <.panic: "Unrecognized character name">
##      }

sub charname__PEEK { $_[0]->_AUTOLEXpeek('charname',$retree) }
sub charname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "charname", 
do { my @gather;
eval { push @gather, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charname_01') {
$C->deb("Fate passed to charname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'charname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("charname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUME(['radint'], sub {
my $C = shift;
$C->radint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G[\],#]/)
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
})
}, $C->_PATTERN(qr/\G[a-zA-Z)]/))
}, $C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[^\],#]/)
}))
}, $C->_PATTERN(qr/\G[a-zA-Z]/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unrecognized character name")} or do { die $@ if $@ };
@gather;
}
);
}

## token charnames
##      token charnames { [<.ws><charname><.ws>] ** ',' }

sub charnames__PEEK { $_[0]->_AUTOLEXpeek('charnames',$retree) }
sub charnames {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'charname'} = [];

$self->_MATCHIFYr($S, "charnames", 
$C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['charname'], sub {
my $C = shift;
$C->charname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
})
);
}

## token charspec
##      token charspec {
##          [
##          | '[' ~ ']' <charnames>
##          | \d+
##          | <[ ?..Z \\.._ ]>
##          | <?> <.panic: "Unrecognized \\c character">
##          ]
##      }

sub charspec__PEEK { $_[0]->_AUTOLEXpeek('charspec',$retree) }
sub charspec {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "charspec", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charspec_01') {
$C->deb("Fate passed to charspec_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'charspec_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("charspec_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'charspec')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['charnames'], sub {
my $C = shift;
$C->charnames
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_PATTERN(qr/\G[?-Z\\-_]/)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Unrecognized \\c character")
}, $C->before( sub { my $C=shift;
$C
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## method truly ($bool,$opt)
sub truly {
my $self = shift;
my $bool = shift;
my $opt = shift;


return $self if $bool;
$self->panic("Can't negate $opt adverb");
}

{ package STD::Q;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
{ package STD::Q::b1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_236Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <sym> <item=backslash> }

sub escape__S_236Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_236Back',$retree) }
sub escape__S_236Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_236Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##         token backslash__S_237qq (:$sym is context<rw> = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $.cursor_fresh(%*LANG<MAIN>).quote(); } }

sub backslash__S_237qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_237qq',$retree) }
sub backslash__S_237qq {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_237qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_238Back (:$sym is context<rw> = <\\>)
##              token backslash:sym<\\> { <text=sym> }

sub backslash__S_238Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_238Back',$retree) }
sub backslash__S_238Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_238Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_239stopper (:$sym is context<rw> = 'stopper')
##              token backslash:stopper { <text=stopper> }

sub backslash__S_239stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_239stopper',$retree) }
sub backslash__S_239stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'stopper';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_239stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}
##         token backslash__S_240a (:$sym is context<rw> = 'a')
##              token backslash:a { <sym> }

sub backslash__S_240a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_240a',$retree) }
sub backslash__S_240a {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_240a", 
$C->_PATTERN(qr/\Ga/)
);
}
##         token backslash__S_241b (:$sym is context<rw> = 'b')
##              token backslash:b { <sym> }

sub backslash__S_241b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_241b',$retree) }
sub backslash__S_241b {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_241b", 
$C->_PATTERN(qr/\Gb/)
);
}
##         token backslash__S_242c (:$sym is context<rw> = 'c')
##              token backslash:c { <sym> <charspec> }

sub backslash__S_242c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_242c',$retree) }
sub backslash__S_242c {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_242c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gc/))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
});
}
else {
();
}
}
);
}
##         token backslash__S_243e (:$sym is context<rw> = 'e')
##              token backslash:e { <sym> }

sub backslash__S_243e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_243e',$retree) }
sub backslash__S_243e {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_243e", 
$C->_PATTERN(qr/\Ge/)
);
}
##         token backslash__S_244f (:$sym is context<rw> = 'f')
##              token backslash:f { <sym> }

sub backslash__S_244f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_244f',$retree) }
sub backslash__S_244f {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_244f", 
$C->_PATTERN(qr/\Gf/)
);
}
##         token backslash__S_245n (:$sym is context<rw> = 'n')
##              token backslash:n { <sym> }

sub backslash__S_245n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_245n',$retree) }
sub backslash__S_245n {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_245n", 
$C->_PATTERN(qr/\Gn/)
);
}
##         token backslash__S_246o (:$sym is context<rw> = 'o')
##              token backslash:o { <sym> [ <octint> | '[' ~ ']' <octints> ] }

sub backslash__S_246o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_246o',$retree) }
sub backslash__S_246o {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_246o", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_246o_01') {
$C->deb("Fate passed to backslash__S_246o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_246o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_246o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'backslash__S_246o')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['octints'], sub {
my $C = shift;
$C->octints
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_PATTERN(qr/\Go/))
);
}
##         token backslash__S_247r (:$sym is context<rw> = 'r')
##              token backslash:r { <sym> }

sub backslash__S_247r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_247r',$retree) }
sub backslash__S_247r {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_247r", 
$C->_PATTERN(qr/\Gr/)
);
}
##         token backslash__S_248t (:$sym is context<rw> = 't')
##              token backslash:t { <sym> }

sub backslash__S_248t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_248t',$retree) }
sub backslash__S_248t {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_248t", 
$C->_PATTERN(qr/\Gt/)
);
}
##         token backslash__S_249x (:$sym is context<rw> = 'x')
##              token backslash:x { <sym> [ <hexint> | '[' ~ ']' <hexints> ] }

sub backslash__S_249x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_249x',$retree) }
sub backslash__S_249x {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_249x", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_249x_01') {
$C->deb("Fate passed to backslash__S_249x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_249x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_249x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'backslash__S_249x')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['hexints'], sub {
my $C = shift;
$C->hexints
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_PATTERN(qr/\Gx/))
);
}
##         token backslash__S_2500 (:$sym is context<rw> = <0>)
##              token backslash:sym<0> { <sym> }

sub backslash__S_2500__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_2500',$retree) }
sub backslash__S_2500 {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(0);


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "backslash__S_2500", 
$C->_PATTERN(qr/\G0/)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_237qq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_237qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_237qq
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: backslash__S_237qq
              i: 0
              min: 1
              r: 1
              s: 0
              text: q
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_237qq
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<quote> = $.cursor_fresh(%*LANG<MAIN>).quote(); "
backslash__S_238Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_238Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_238Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_239stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_239stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_239stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_240a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_240a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
backslash__S_241b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_241b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_242c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_242c
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_242c
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: c
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_242c
        i: 0
        min: 12345
        name: charspec
        r: 1
        rest: ''
        s: 0
backslash__S_243e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_243e
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_244f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_244f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_245n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_245n
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_246o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_246o
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_246o
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: o
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &2 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_246o_01
          dba: backslash__S_246o
          i: 0
          min: 12345
          name: backslash__S_246o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_246o_01 0
              dba: backslash__S_246o
              i: 0
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_246o_01 1
              dba: backslash__S_246o
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_246o
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: backslash__S_246o
                  extra: "local $::GOAL = ']' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: backslash__S_246o
                  i: 0
                  min: 12345
                  name: octints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: backslash__S_246o
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: backslash__S_246o
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'backslash__S_246o')
backslash__S_246o_01: *2
backslash__S_247r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_247r
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_248t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_248t
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_249x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_249x
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_249x
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_249x_01
          dba: backslash__S_249x
          i: 0
          min: 12345
          name: backslash__S_249x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_249x_01 0
              dba: backslash__S_249x
              i: 0
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_249x_01 1
              dba: backslash__S_249x
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_249x
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: backslash__S_249x
                  extra: "local $::GOAL = ']' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: backslash__S_249x
                  i: 0
                  min: 12345
                  name: hexints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: backslash__S_249x
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: backslash__S_249x
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'backslash__S_249x')
backslash__S_249x_01: *1
backslash__S_2500: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_2500
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 0
escape__S_236Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_236Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: escape__S_236Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: escape__S_236Back
          i: 0
          min: 12345
          name: backslash
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: escape__S_236Back
        i: 0
        min: 12345
        r: 1
        s: 0
        var: item
RETREE_END
}
} ## end role

{ package STD::Q::b0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_251Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <!> }

sub escape__S_251Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_251Back',$retree) }
sub escape__S_251Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_251Back", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_251Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_251Back
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_252Cur_Ly (:$sym is context<rw> = <{ }>)
##              token escape:sym<{ }> { <?before '{'> [ :lang(%*LANG<MAIN>) <block> ] }

sub escape__S_252Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_252Cur_Ly',$retree) }
sub escape__S_252Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_252Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_252Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_252Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_252Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_252Cur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: escape__S_252Cur_Ly
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: escape__S_252Cur_Ly
              i: 0
              lang: ($::LANG{'MAIN'})
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: escape__S_252Cur_Ly
              i: 0
              lang: ($::LANG{'MAIN'})
              min: 12345
              name: block
              r: 1
              rest: ''
              s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_253Cur_Ly (:$sym is context<rw> = <{ }>)
##              token escape:sym<{ }> { <!> }

sub escape__S_253Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_253Cur_Ly',$retree) }
sub escape__S_253Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_253Cur_Ly", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_253Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_253Cur_Ly
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::s1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_254Dollar (:$sym is context<rw> = <$>)
##              token escape:sym<$> {
##                  :my $INTERPOLATION is context = '$';
##                  <?before '$'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> ] || <.panic: "Non-variable \$ must be backslashed">
##              }

sub escape__S_254Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_254Dollar',$retree) }
sub escape__S_254Dollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);
local $::INTERPOLATION = '$';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_254Dollar", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
});
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Non-variable \$ must be backslashed")} or do { die $@ if $@ };
@gather;
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_254Dollar: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_254Dollar
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INTERPOLATION is context = '$'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: escape__S_254Dollar
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: escape__S_254Dollar
        i: 0
        min: 0
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_assertion 
            assert: "?"
            min: 0
            re: !!perl/hash:RE_method_re 
              a: 0
              dba: escape__S_254Dollar
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE 
                decl: []

                min: 1
                re: !!perl/hash:RE_string 
                  a: 0
                  dba: escape__S_254Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: $
              s: 0
          - !!perl/hash:RE_bracket 
            decl: []

            min: 0
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: escape__S_254Dollar
              i: 0
              lang: ($::LANG{'MAIN'})
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_254Dollar
                  i: 0
                  lang: ($::LANG{'MAIN'})
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Non-variable \$ must be backslashed")
RETREE_END
}
} ## end role

{ package STD::Q::s0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_255Dollar (:$sym is context<rw> = <$>)
##              token escape:sym<$> { <!> }

sub escape__S_255Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_255Dollar',$retree) }
sub escape__S_255Dollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_255Dollar", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_255Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_255Dollar
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::a1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_256At (:$sym is context<rw> = <@>)
##              token escape:sym<@> {
##                  :my $INTERPOLATION is context<rw> = '@';
##                  <?before '@'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> | <!> ] # trap ABORTBRANCH from variable's ::
##              }

sub escape__S_256At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_256At',$retree) }
sub escape__S_256At {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);
local $::INTERPOLATION = '@';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_256At", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('@')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_256At_02') {
$C->deb("Fate passed to escape__S_256At_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::a1', 'escape__S_256At_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_256At_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_256At: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_256At
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INTERPOLATION is context<rw> = '@'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_256At
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_256At
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_256At
              i: 0
              min: 1
              r: 1
              s: 0
              text: "@"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_256At_02
          dba: escape__S_256At
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 0
          name: escape__S_256At_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_256At_02 0
              dba: escape__S_256At
              i: 0
              lang: ($::LANG{'MAIN'})
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_256At
                  i: 0
                  lang: ($::LANG{'MAIN'})
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
            - !!perl/hash:RE_assertion 
              alt: escape__S_256At_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_256At
                i: 0
                lang: ($::LANG{'MAIN'})
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_256At_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::a0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_257At (:$sym is context<rw> = <@>)
##              token escape:sym<@> { <!> }

sub escape__S_257At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_257At',$retree) }
sub escape__S_257At {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_257At", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_257At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_257At
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::h1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_258Percent (:$sym is context<rw> = <%>)
##              token escape:sym<%> {
##                  :my $INTERPOLATION is context<rw> = '%';
##                  <?before '%'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> | <!> ]
##              }

sub escape__S_258Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_258Percent',$retree) }
sub escape__S_258Percent {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);
local $::INTERPOLATION = '%';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_258Percent", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('%')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_258Percent_02') {
$C->deb("Fate passed to escape__S_258Percent_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::h1', 'escape__S_258Percent_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_258Percent_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_258Percent: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_258Percent
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INTERPOLATION is context<rw> = '%'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_258Percent
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_258Percent
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_258Percent
              i: 0
              min: 1
              r: 1
              s: 0
              text: "%"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_258Percent_02
          dba: escape__S_258Percent
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 0
          name: escape__S_258Percent_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_258Percent_02 0
              dba: escape__S_258Percent
              i: 0
              lang: ($::LANG{'MAIN'})
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_258Percent
                  i: 0
                  lang: ($::LANG{'MAIN'})
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
            - !!perl/hash:RE_assertion 
              alt: escape__S_258Percent_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_258Percent
                i: 0
                lang: ($::LANG{'MAIN'})
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_258Percent_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::h0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_259Percent (:$sym is context<rw> = <%>)
##              token escape:sym<%> { <!> }

sub escape__S_259Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_259Percent',$retree) }
sub escape__S_259Percent {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_259Percent", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_259Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_259Percent
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::f1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_260Amp (:$sym is context<rw> = <&>)
##              token escape:sym<&> {
##                  :my $INTERPOLATION is context<rw> = '&';
##                  <?before '&'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> | <!> ]
##              }

sub escape__S_260Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_260Amp',$retree) }
sub escape__S_260Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);
local $::INTERPOLATION = '&';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_260Amp", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('&')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_260Amp_02') {
$C->deb("Fate passed to escape__S_260Amp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::f1', 'escape__S_260Amp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_260Amp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_260Amp: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_260Amp
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INTERPOLATION is context<rw> = '&'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_260Amp
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_260Amp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_260Amp
              i: 0
              min: 1
              r: 1
              s: 0
              text: "&"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_260Amp_02
          dba: escape__S_260Amp
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 0
          name: escape__S_260Amp_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_260Amp_02 0
              dba: escape__S_260Amp
              i: 0
              lang: ($::LANG{'MAIN'})
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_260Amp
                  i: 0
                  lang: ($::LANG{'MAIN'})
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
            - !!perl/hash:RE_assertion 
              alt: escape__S_260Amp_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_260Amp
                i: 0
                lang: ($::LANG{'MAIN'})
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_260Amp_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::f0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_261Amp (:$sym is context<rw> = <&>)
##              token escape:sym<&> { <!> }

sub escape__S_261Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_261Amp',$retree) }
sub escape__S_261Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_261Amp", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_261Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_261Amp
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::w1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->words }
} ## end role

{ package STD::Q::w0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::ww1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->words }
} ## end role

{ package STD::Q::ww0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::x1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->run }
} ## end role

{ package STD::Q::x0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::q;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token stopper
##              token stopper { \' }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('\'')
);
}

##         token escape__S_262Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <sym> <item=backslash> }

sub escape__S_262Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_262Back',$retree) }
sub escape__S_262Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_262Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}

##         token backslash__S_263qq (:$sym is context<rw> = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $.cursor_fresh(%*LANG<MAIN>).quote(); } }

sub backslash__S_263qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_263qq',$retree) }
sub backslash__S_263qq {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_263qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_264Back (:$sym is context<rw> = <\\>)
##              token backslash:sym<\\> { <text=sym> }

sub backslash__S_264Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_264Back',$retree) }
sub backslash__S_264Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_264Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_265stopper (:$sym is context<rw> = 'stopper')
##              token backslash:stopper { <text=stopper> }

sub backslash__S_265stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_265stopper',$retree) }
sub backslash__S_265stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'stopper';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_265stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}

# in single quotes, keep backslash on random character by default
##         token backslash__S_266misc (:$sym is context<rw> = 'misc')
##              token backslash:misc { {} (.) { $<text> = "\\" ~ $0.Str; } }

sub backslash__S_266misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_266misc',$retree) }
sub backslash__S_266misc {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_266misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G(?s:.)/)
})}
}))) {
scalar(do {
my $M = $C;  $M->{'text'} = "\\" . $C->{'0'}->Str; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_263qq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_263qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_263qq
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: backslash__S_263qq
              i: 0
              min: 1
              r: 1
              s: 0
              text: q
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_263qq
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<quote> = $.cursor_fresh(%*LANG<MAIN>).quote(); "
backslash__S_264Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_264Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_264Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_265stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_265stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_265stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_266misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_266misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_266misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_meta 
            a: 0
            dba: backslash__S_266misc
            i: 0
            min: 1
            r: 1
            s: 0
            text: .
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_266misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<text> = \"\\\\\" ~ $0.Str; "
escape__S_262Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_262Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: escape__S_262Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: escape__S_262Back
          i: 0
          min: 12345
          name: backslash
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: escape__S_262Back
        i: 0
        min: 12345
        r: 1
        s: 0
        var: item
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: "'"
RETREE_END
}
} ## end role

{ package STD::Q::qq;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::Q::b1 STD::Q::c1 STD::Q::s1 STD::Q::a1 STD::Q::h1 STD::Q::f1));
##         token stopper
##              token stopper { \" }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('"')
);
}
# in double quotes, omit backslash on random \W backslash by default
##         token backslash__S_267misc (:$sym is context<rw> = 'misc')
##              token backslash:misc { {} [ (\W) { $<text> = $0.Str; } | $<x>=(\w) <.panic("Unrecognized backslash sequence: '\\" ~ $<x>.Str ~ "'")> ] }

sub backslash__S_267misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_267misc',$retree) }
sub backslash__S_267misc {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_267misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_267misc_01') {
$C->deb("Fate passed to backslash__S_267misc_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::qq', 'backslash__S_267misc_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_267misc_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
}))) {
scalar(do {
my $M = $C;  $M->{'text'} = $C->{'0'}->Str; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['x'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})}
}))) {
do { my $M = $C;
$C->panic("Unrecognized backslash sequence: '\\" . $M->{'x'}->Str . "'")
; };
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_267misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_267misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_267misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_267misc_01
          dba: backslash__S_267misc
          i: 0
          min: 1
          name: backslash__S_267misc_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_267misc_01 0
              dba: backslash__S_267misc
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_meta 
                      a: 0
                      dba: backslash__S_267misc
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \W
                  min: 1
                  var: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: backslash__S_267misc
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<text> = $0.Str; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_267misc_01 1
              dba: backslash__S_267misc
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_meta 
                      a: 0
                      dba: backslash__S_267misc
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \w
                  dba: backslash__S_267misc
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: x
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: "(\"Unrecognized backslash sequence: '\\\\\" ~ $<x>.Str ~ \"'\")"
backslash__S_267misc_01: *1
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: "\""
RETREE_END
}
} ## end role

{ package STD::Q::p5;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'i') {
my $i = $v;  $self }
elsif ($k eq 'm') {
my $m = $v;  $self }
elsif ($k eq 's') {
my $s = $v;  $self }
elsif ($k eq 'x') {
my $x = $v;  $self }
elsif ($k eq 'p') {
my $p = $v;  $self }
elsif ($k eq 'c') {
my $c = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks
} ## end role

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}

elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->truly($q,':q'); $self->mixin( 'STD::Q::q' ); }

elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->truly($qq, ':qq'); $self->mixin( 'STD::Q::qq' ); }

elsif ($k eq 'backslash' or $k eq 'b') {
my $b = $v;  $self->mixin($b ? 'STD::Q::b1' : 'STD::Q::b0') }
elsif ($k eq 'scalar' or $k eq 's') {
my $s = $v;  $self->mixin($s ? 'STD::Q::s1' : 'STD::Q::s0') }
elsif ($k eq 'array' or $k eq 'a') {
my $a = $v;  $self->mixin($a ? 'STD::Q::a1' : 'STD::Q::a0') }
elsif ($k eq 'hash' or $k eq 'h') {
my $h = $v;  $self->mixin($h ? 'STD::Q::h1' : 'STD::Q::h0') }
elsif ($k eq 'function' or $k eq 'f') {
my $f = $v;  $self->mixin($f ? 'STD::Q::f1' : 'STD::Q::f0') }
elsif ($k eq 'closure' or $k eq 'c') {
my $c = $v;  $self->mixin($c ? 'STD::Q::c1' : 'STD::Q::c0') }

elsif ($k eq 'exec' or $k eq 'x') {
my $x = $v;  $self->mixin($x ? 'STD::Q::x1' : 'STD::Q::x0') }
elsif ($k eq 'words' or $k eq 'w') {
my $w = $v;  $self->mixin($w ? 'STD::Q::w1' : 'STD::Q::w0') }
elsif ($k eq 'quotewords' or $k eq 'ww') {
my $ww = $v;  $self->mixin($ww ? 'STD::Q::ww1' : 'STD::Q::ww0') }

elsif ($k eq 'heredoc' or $k eq 'to') {
my $to = $v;  $self->truly($to, ':to'); $self->cursor_herelang; }

elsif ($k eq 'regex') {
my $regex = $v; 
return $::LANG{'Regex'};
}

elsif ($k eq 'trans') {
my $trans = $v; 
return $::LANG{'Trans'};
}

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quote modifier: " . join('',@k));
}
else { die 'NOMATCH' }
} # end tweaks


} ## end grammar

{ package STD::Quasi;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));##     token term__S_268unquote (:$sym is context<rw> = 'unquote')
##          token term:unquote {
##              :my $QUASI_QUASH is context = 0;
##              <starter><starter><starter> <EXPR> <stopper><stopper><stopper>
##          }

sub term__S_268unquote__PEEK { $_[0]->_AUTOLEXpeek('term__S_268unquote',$retree) }
sub term__S_268unquote {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unquote';
local $::QUASI_QUASH = 0;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_268unquote", 
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'ast') {
my $ast = $v;  $self; } # XXX some transformer operating on the normal AST?
elsif ($k eq 'lang') {
my $lang = $v;  $self->cursor_fresh( $lang ); }
elsif ($k eq 'unquote') {
my $unquote = $v;  $self; } # XXX needs to override unquote
elsif ($k eq 'COMPILING') {
my $COMPILING = $v;  $::QUASI_QUASH = 1; $self; } # XXX needs to lazify the lexical lookups somehow

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quasiquote modifier: " . join('',@k));
}
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
term__S_268unquote: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_268unquote
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QUASI_QUASH is context = 0
  kind: token
  min: 86415
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_268unquote
    i: 0
    min: 86415
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_268unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_268unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_268unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_268unquote
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_268unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_268unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_268unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
RETREE_END
}
} ## end grammar
## rule multisig
##      } # end grammar
##      
##      rule multisig {
##          [
##              ':'?'(' ~ ')' <signature>
##          ]
##          ** '|'
##      }

sub multisig__PEEK { $_[0]->_AUTOLEXpeek('multisig',$retree) }
sub multisig {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'signature'} = [];

$self->_MATCHIFY($S, "multisig", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('|')
}, sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')', 'multisig')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
}, $C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))
}, $C->ws)
})
}))
}, $C->ws)
);
}

## rule routine_def ($CURPAD is context<rw> = $*CURPAD)
##      rule routine_def ($CURPAD is context<rw> = $*CURPAD) {
##          :my $IN_DECL is context<rw> = 1;
##          [
##              [ '&'<deflongname>? | <deflongname> ]?
##              <.newpad>
##              [ <multisig> | <trait> ]*
##              <!{
##                  $*IN_DECL = 0;
##              }>
##              <blockoid>:!s
##          ] || <.panic: "Malformed routine">
##      }

sub routine_def__PEEK { $_[0]->_AUTOLEXpeek('routine_def',$retree) }
sub routine_def {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;
local $::IN_DECL = 1;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "routine_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_02') {
$C->deb("Fate passed to routine_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_03') {
$C->deb("Fate passed to routine_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$::IN_DECL = 0;

})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed routine"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## rule method_def ($CURPAD is context<rw> = $*CURPAD)
##      rule method_def ($CURPAD is context<rw> = $*CURPAD) {
##          <.newpad>
##          [
##              [
##              | <[ ! ^ ]>?<longname> [ <multisig> | <trait> ]*
##              | <multisig> <trait>*
##              | <sigil> '.'
##                  :dba('subscript signature')
##                  [
##                  | '(' ~ ')' <signature>
##                  | '[' ~ ']' <signature>
##                  | '{' ~ '}' <signature>
##                  | <?before '<'> <postcircumfix>
##                  ]
##                  <trait>*
##              | <?>
##              ]
##              <blockoid>:!s
##          ] || <.panic: "Malformed method">
##      }

sub method_def__PEEK { $_[0]->_AUTOLEXpeek('method_def',$retree) }
sub method_def {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFY($S, "method_def", 
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['blockoid'], sub {
my $C = shift;
$C->blockoid
})
}, $C->ws)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_02') {
$C->deb("Fate passed to method_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[!^])?+)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_03') {
$C->deb("Fate passed to method_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
}))
}, $C->ws)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_04') {
$C->deb("Fate passed to method_def_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']'))
}, $C->ws)
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}'))
}, $C->ws)
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->ws)
}, $C->before(sub { my $C=shift;
$C->_EXACT('<')
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
}, $C->ws)
}, $C->_EXACT('.'))
}, $C->ws)
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->before( sub { my $C=shift;
$C
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}))
}, $C->ws)
}, $C->newpad)
}, $C->ws)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->panic("Malformed method"))
}, $C->ws)} or do { die $@ if $@ };
@gather;
}
);
}

## rule regex_def ($CURPAD is context<rw> = $*CURPAD)
##      rule regex_def ($CURPAD is context<rw> = $*CURPAD) {
##          :my $IN_DECL is context<rw> = 1;
##          [
##              [ '&'<deflongname>? | <deflongname> ]?
##              <.newpad>
##              [ [ ':'?'(' <signature> ')'] | <trait> ]*
##              { $*IN_DECL = 0; }
##              <.finishpad>
##              <regex_block>:!s
##          ] || <.panic: "Malformed regex">
##      }

sub regex_def__PEEK { $_[0]->_AUTOLEXpeek('regex_def',$retree) }
sub regex_def {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;
local $::IN_DECL = 1;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "regex_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_02') {
$C->deb("Fate passed to regex_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_03') {
$C->deb("Fate passed to regex_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$::IN_DECL = 0; 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->finishpad)) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['regex_block'], sub {
my $C = shift;
$C->regex_block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed regex"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## rule macro_def ($CURPAD is context<rw> = $*CURPAD)
##      rule macro_def ($CURPAD is context<rw> = $*CURPAD) {
##          :my $IN_DECL is context<rw> = 1;
##          [
##              [ '&'<deflongname>? | <deflongname> ]?
##              <.newpad>
##              [ <multisig> | <trait> ]*
##              <!{
##                  $*IN_DECL = 0;
##              }>
##              <blockoid>:!s
##          ] || <.panic: "Malformed macro">
##      }

sub macro_def__PEEK { $_[0]->_AUTOLEXpeek('macro_def',$retree) }
sub macro_def {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;
local $::IN_DECL = 1;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "macro_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_02') {
$C->deb("Fate passed to macro_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'macro_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_03') {
$C->deb("Fate passed to macro_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'macro_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$::IN_DECL = 0;

})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed macro"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## rule trait
##      rule trait {
##          :my $IN_DECL is context<rw> = 0;
##          [
##          | <trait_mod>
##          | <colonpair>
##          ]
##      }

sub trait__PEEK { $_[0]->_AUTOLEXpeek('trait',$retree) }
sub trait {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = 0;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "trait", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'trait_01') {
$C->deb("Fate passed to trait_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['trait_mod'], sub {
my $C = shift;
$C->trait_mod
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token trait_mod__S_269is (:$endsym is context = 'spacey', :$sym is context<rw> = 'is')
##      token trait_mod:is {
##          <sym>:s <longname><postcircumfix>?  # e.g. context<rw> and Array[Int]
##      }

sub trait_mod__S_269is__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_269is',$retree) }
sub trait_mod__S_269is {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'is';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'postcircumfix'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_269is", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gis/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_270hides (:$endsym is context = 'spacey', :$sym is context<rw> = 'hides')
##      token trait_mod:hides {
##          <sym>:s <module_name>
##      }

sub trait_mod__S_270hides__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_270hides',$retree) }
sub trait_mod__S_270hides {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'hides';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_270hides", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghides/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_271does (:$endsym is context = 'spacey', :$sym is context<rw> = 'does')
##      token trait_mod:does {
##          :my $PKGDECL is context = 'role';
##          <sym>:s <module_name>
##      }

sub trait_mod__S_271does__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_271does',$retree) }
sub trait_mod__S_271does {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'does';
local $::PKGDECL = 'role';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_271does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_272will (:$endsym is context = 'spacey', :$sym is context<rw> = 'will')
##      token trait_mod:will {
##          <sym>:s <identifier> <block>
##      }

sub trait_mod__S_272will__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_272will',$retree) }
sub trait_mod__S_272will {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'will';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_272will", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwill/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token trait_mod__S_273of (:$endsym is context = 'spacey', :$sym is context<rw> = 'of')
##      token trait_mod:of      { <sym>:s <typename> }

sub trait_mod__S_273of__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_273of',$retree) }
sub trait_mod__S_273of {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'of';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_273of", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gof/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_274as (:$endsym is context = 'spacey', :$sym is context<rw> = 'as')
##      token trait_mod:as      { <sym>:s <typename> }

sub trait_mod__S_274as__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_274as',$retree) }
sub trait_mod__S_274as {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'as';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_274as", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gas/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_275returns (:$endsym is context = 'spacey', :$sym is context<rw> = 'returns')
##      token trait_mod:returns { <sym>:s <typename> }

sub trait_mod__S_275returns__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_275returns',$retree) }
sub trait_mod__S_275returns {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'returns';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_275returns", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Greturns/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_276handles (:$endsym is context = 'spacey', :$sym is context<rw> = 'handles')
##      token trait_mod:handles { <sym>:s <noun> }

sub trait_mod__S_276handles__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_276handles',$retree) }
sub trait_mod__S_276handles {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'handles';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_276handles", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghandles/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->noun
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token capterm
##      token capterm {
##          '\\'
##          [
##          | '(' <capture>? ')'
##          | <?before \S> <termish>
##          ]
##      }

sub capterm__PEEK { $_[0]->_AUTOLEXpeek('capterm',$retree) }
sub capterm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'capture'} = [];

$self->_MATCHIFYr($S, "capterm", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'capterm_01') {
$C->deb("Fate passed to capterm_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'capterm_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("capterm_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['capture'], sub {
my $C = shift;
$C->capture
})
}))) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## rule capture
##      rule capture {
##          :my $INVOCANT_OK is context<rw> = 1;
##          <EXPR>
##      }

sub capture__PEEK { $_[0]->_AUTOLEXpeek('capture',$retree) }
sub capture {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK = 1;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "capture", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token sigterm
##      token sigterm {
##          ':(' ~ ')' <fakesignature>
##      }

sub sigterm__PEEK { $_[0]->_AUTOLEXpeek('sigterm',$retree) }
sub sigterm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "sigterm", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'sigterm')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT(':('))
);
}

## rule param_sep
##      rule param_sep { [','|':'|';'|';;'] }

sub param_sep__PEEK { $_[0]->_AUTOLEXpeek('param_sep',$retree) }
sub param_sep {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "param_sep", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_sep_01') {
$C->deb("Fate passed to param_sep_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'param_sep_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_sep_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT(':')
},
sub { my $C=shift;
$C->_EXACT(';')
},
sub { my $C=shift;
$C->_EXACT(';;')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token fakesignature($CURPAD is context<rw> = $*CURPAD)
##      token fakesignature($CURPAD is context<rw> = $*CURPAD) {
##          <.newpad>
##          <signature>
##      }

sub fakesignature__PEEK { $_[0]->_AUTOLEXpeek('fakesignature',$retree) }
sub fakesignature {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "fakesignature", 
do {
if (my ($C) = ($C->newpad)) {
$C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
});
}
else {
();
}
}
);
}

## token signature
##      token signature {
##          # XXX incorrectly scopes &infix:<x> parameters to outside following block
##          :my $IN_DECL is context<rw> = 1;
##          :my $zone is context<rw> = 'posreq';
##          :my $startpos = self.pos;
##          <.ws>
##          [
##          | <?before '-->' | ')' | ']' | '{' | ':'\s >
##          | <parameter>
##          ] ** <param_sep>
##          <.ws>
##          { $*IN_DECL = 0; }
##          [ '-->' <.ws> <typename> ]?
##          {{ $*SIGIL = '@'; $*CURPAD.{'$?GOTSIG'} ~= '(' ~ substr($*ORIG, $startpos, $.pos - $startpos) ~ ')'; }}
##      }

sub signature__PEEK { $_[0]->_AUTOLEXpeek('signature',$retree) }
sub signature {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = 1;
local $::zone = 'posreq';
my $startpos = $self->{'_pos'};


my $C = $self;
my $S = $C->{'_pos'};
$C->{'typename'} = [];
$C->{'parameter'} = [];
$C->{'param_sep'} = [];

$self->_MATCHIFYr($S, "signature", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_SUBSUMEr(['param_sep'], sub {
my $C = shift;
$C->param_sep
})
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_01') {
$C->deb("Fate passed to signature_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'signature_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_02') {
$C->deb("Fate passed to signature_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'signature_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('-->')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
},
sub { my $C=shift;
$C->_SUBSUMEr(['parameter'], sub {
my $C = shift;
$C->parameter
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$::IN_DECL = 0; 
}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-->'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {
$::SIGIL = '@'; $CURPAD->{'$?GOTSIG'} .= '(' . substr($::ORIG, $startpos, $C->{'_pos'} - $startpos) . ')'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token type_declarator__S_277subset (:$endsym is context = 'spacey', :$sym is context<rw> = 'subset')
##      token type_declarator:subset {
##          <sym> :s
##          [
##              <longname> { $.add_name($<longname>.Str); }
##              [ of <.ws> <typename> ]?
##              <trait>*
##              [where <EXPR(item %chaining)> ]?    # (EXPR can parse multiple where clauses)
##          ] || <.panic: "Malformed subset">
##      }

sub type_declarator__S_277subset__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_277subset',$retree) }
sub type_declarator__S_277subset {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'subset';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'typename'} = [];
$C->{'trait'} = [];
$C->{'EXPR'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "type_declarator__S_277subset", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubset/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $C->add_name($M->{'longname'}->Str); ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('of'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed subset"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## token type_declarator__S_278enum (:$endsym is context = 'spacey', :$sym is context<rw> = 'enum')
##      token type_declarator:enum {
##          <sym> <.ws>
##          <longname> <.ws> <trait>* <?before <[ < (  ]> > <noun> <.ws>
##              { $.add_name($<longname>.Str); $.add_enum($<longname>.Str, $<noun>.Str); }
##      }

sub type_declarator__S_278enum__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_278enum',$retree) }
sub type_declarator__S_278enum {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'enum';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "type_declarator__S_278enum", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Genum/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[<(]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->noun
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C;  $C->add_name($M->{'longname'}->Str); $C->add_enum($M->{'longname'}->Str, $M->{'noun'}->Str); ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token type_constraint
##      token type_constraint {
##          [
##          | <value>
##          | <typename>
##          | where <.ws> <EXPR(item %chaining)>
##          ]
##          <.ws>
##      }

sub type_constraint__PEEK { $_[0]->_AUTOLEXpeek('type_constraint',$retree) }
sub type_constraint {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "type_constraint", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_constraint_01') {
$C->deb("Fate passed to type_constraint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'type_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
}
);
}

## rule post_constraint
##      rule post_constraint {
##          [
##          | '[' ~ ']' <signature>
##          | '(' ~ ')' <signature>
##          | where <EXPR(item %chaining)>
##          ]
##      }

sub post_constraint__PEEK { $_[0]->_AUTOLEXpeek('post_constraint',$retree) }
sub post_constraint {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "post_constraint", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'post_constraint_01') {
$C->deb("Fate passed to post_constraint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'post_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("post_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']', 'post_constraint')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']'))
}, $C->ws)
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')', 'post_constraint')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))
}, $C->ws)
}, $C->_EXACT('where'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
);
}

## token named_param
##      token named_param {
##          :my $GOAL is context = ')';
##          ':'
##          [
##          | <name=identifier> '(' <.ws>
##              [ <named_param> | <param_var> <.ws> ]
##              [ ')' || <.panic: "Unable to parse named parameter; couldn't find right parenthesis"> ]
##          | <param_var>
##          ]
##      }

sub named_param__PEEK { $_[0]->_AUTOLEXpeek('named_param',$retree) }
sub named_param {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL = ')';


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "named_param", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_01') {
$C->deb("Fate passed to named_param_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'named_param_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_02') {
$C->deb("Fate passed to named_param_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'named_param_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse named parameter; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token param_var
##      token param_var {
##          [
##          | '[' ~ ']' <signature>
##          | '(' ~ ')' <signature>
##          | <sigil> [<?before <.twigil>\w> <twigil>]?
##              [
##                  # Is it a longname declaration?
##              || <?{ $<sigil>.Str eq '&' }> <?ident> {}
##                  <name=sublongname>
##      
##              ||  # Is it a shaped array or hash declaration?
##                  <?{ $<sigil>.Str eq '@' || $<sigil>.Str eq '%' }>
##                  <name=identifier>?
##                  <?before <[ \< \( \[ \{ ]> >
##                  <postcircumfix>
##      
##                  # ordinary parameter name
##              || <name=identifier>
##              || $<name> = [<[/!]>]
##      
##                  # bare sigil?
##              ]?
##              {{
##                  my $vname = $<sigil>.Str;
##                  my $t = $<twigil>;
##                  my $twigil = '';
##                  $twigil = $t.[0].Str if @$t;
##                  $vname ~= $twigil;
##                  my $n = try { $<name>[0].Str } // '';
##                  $vname ~= $n;
##                  if $*REALLYADD {
##                      given $twigil {
##                          when '' {
##                              self.add_my_variable($vname) if $n ne '';
##                          }
##                          when '.' {
##                          }
##                          when '!' {
##                          }
##                          default {
##                              self.worry("Illegal to use $twigil twigil in signature");
##                          }
##                      }
##                  }
##              }}
##          ]
##      }

sub param_var__PEEK { $_[0]->_AUTOLEXpeek('param_var',$retree) }
sub param_var {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'identifier'} = [];
$C->{'name'} = [];
$C->{'twigil'} = [];
$C->{'postcircumfix'} = [];

$self->_MATCHIFY($S, "param_var", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_var_01') {
$C->deb("Fate passed to param_var_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'param_var_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_var_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'param_var')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'param_var')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C; 
my $vname = $M->{'sigil'}->Str;
my $t = $M->{'twigil'};
my $twigil = '';
$twigil = $t->[0]->Str if @$t;
$vname .= $twigil;
my $n = eval { $M->{'name'}[0]->Str } // '';
$vname .= $n;
if ($::REALLYADD) {
given ($twigil) {
when ('') {
$self->add_my_variable($vname) if $n ne '';
}
when ('.') {
}
when ('!') {
}
default {
$self->worry("Illegal to use $twigil twigil in signature");
}
};
}
;
}, $C)
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->sublongname
})
}, scalar(do {

}, $C))
}, $C->before( sub { my $C=shift;
$C->ident
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'sigil'}->Str eq '&' ;
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\<\(\[\{]/)
}))
},     $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['name','identifier'], sub {
my $C = shift;
$C->identifier
})
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'sigil'}->Str eq '@' || $M->{'sigil'}->Str eq '%' ;
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather,     $C->_SUBSUME(['name'], sub {
my $C = shift;
$C->identifier
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather,     $C->_SUBSUME(['name'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
$C->_PATTERN(qr/\G[\/!]/)
})
})} or do { die $@ if $@ };
@gather;
}
})
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G\w/)
}, $C->twigil)
}))
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token parameter
##      token parameter {
##          :my $kind;
##          :my $quant = '';
##          :my $q;
##          :my $REALLYADD is context<rw> = 0;
##      
##          {{ $*REALLYADD = 1 }}
##      
##          [
##          | <type_constraint>+
##              {
##                  my $t = $<type_constraint>;
##                  @$t > 1 and $.panic("Multiple prefix constraints not yet supported")
##              }
##              [
##              | '*' <param_var>   { $quant = '*'; $kind = '*'; }
##              | '|' <param_var>   { $quant = '|'; $kind = '*'; }
##              | '\\' <param_var>  { $quant = '\\'; $kind = '!'; }
##              |   [
##                  | <param_var>   { $quant = ''; $kind = '!'; }
##                  | <named_param> { $quant = ''; $kind = '*'; }
##                  ]
##                  [
##                  | '?'           { $quant = '?'; $kind = '?' }
##                  | '!'           { $quant = '!'; $kind //= '!' }
##                  | <?>
##                  ]
##              | <?> { $quant = ''; $kind = '!' }
##              ]
##      
##          | '*' <param_var>   { $quant = '*'; $kind = '*'; }
##          | '|' <param_var>   { $quant = '|'; $kind = '*'; }
##          | '\\' <param_var>  { $quant = '\\'; $kind = '!'; }
##          |   [
##              | <param_var>   { $quant = ''; $kind = '!'; }
##              | <named_param> { $quant = ''; $kind = '*'; }
##              ]
##              [
##              | '?'           { $quant = '?'; $kind = '?' }
##              | '!'           { $quant = '!'; $kind //= '!' }
##              | <?>
##              ]
##          ]
##      
##          <trait>*
##      
##          <post_constraint>*
##      
##          [
##              <default_value> {{
##                  given $quant {
##                    when '!' { $.panic("Can't put a default on a required parameter") }
##                    when '*' { $.panic("Can't put a default on a slurpy parameter") }
##                    when '|' { $.panic("Can't put a default on an slurpy capture parameter") }
##                    when '\\' { $.panic("Can't put a default on a capture parameter") }
##                  }
##                  $kind = '?' if $kind eq '!';
##              }}
##          ]?
##      
##          {
##              $<quant> = $quant;
##              $<kind> = $kind;
##          }
##      
##          # enforce zone constraints
##          {{
##              given $kind {
##                  when '!' {
##                      given $*zone {
##                          when 'posopt' {
##      $.panic("Can't put required parameter after optional parameters");
##                          }
##                          when 'var' {
##      $.panic("Can't put required parameter after variadic parameters");
##                          }
##                      }
##                  }
##                  when '?' {
##                      given $*zone {
##                          when 'posreq' { $*zone = 'posopt' }
##                          when 'var' {
##      $.panic("Can't put optional positional parameter after variadic parameters");
##                          }
##                      }
##                  }
##                  when '*' {
##                      $*zone = 'var';
##                  }
##              }
##          }}
##      }

sub parameter__PEEK { $_[0]->_AUTOLEXpeek('parameter',$retree) }
sub parameter {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $kind;
my $quant = '';
my $q;
local $::REALLYADD = 0;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'default_value'} = [];
$C->{'post_constraint'} = [];
$C->{'type_constraint'} = [];

$self->_MATCHIFYr($S, "parameter", 
do {
if (my ($C) = (scalar(do {
$::REALLYADD = 1 
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_01') {
$C->deb("Fate passed to parameter_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{'type_constraint'};
@$t > 1 and $C->panic("Multiple prefix constraints not yet supported")
;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_02') {
$C->deb("Fate passed to parameter_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\'; $kind = '!'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_03') {
$C->deb("Fate passed to parameter_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = ''; $kind = '*'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_04') {
$C->deb("Fate passed to parameter_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('?'))) {
scalar(do {
$quant = '?'; $kind = '?' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
scalar(do {
$quant = '!'; $kind //= '!' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C
}))) {
scalar(do {
$quant = ''; $kind = '!' 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\'; $kind = '!'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_05') {
$C->deb("Fate passed to parameter_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = ''; $kind = '*'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_06') {
$C->deb("Fate passed to parameter_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('?'))) {
scalar(do {
$quant = '?'; $kind = '?' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
scalar(do {
$quant = '!'; $kind //= '!' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['default_value'], sub {
my $C = shift;
$C->default_value
}))) {
scalar(do {

given ($quant) {
when ('!') { $C->panic("Can't put a default on a required parameter") }
when ('*') { $C->panic("Can't put a default on a slurpy parameter") }
when ('|') { $C->panic("Can't put a default on an slurpy capture parameter") }
when ('\\') { $C->panic("Can't put a default on a capture parameter") }
};
$kind = '?' if $kind eq '!';

}, $C);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$M->{'quant'} = $quant;
$M->{'kind'} = $kind;
;
}, $C))) {
scalar(do {

given ($kind) {
when ('!') {
given ($::zone) {
when ('posopt') {
$C->panic("Can't put required parameter after optional parameters");
}
when ('var') {
$C->panic("Can't put required parameter after variadic parameters");
}
};
}
when ('?') {
given ($::zone) {
when ('posreq') { $::zone = 'posopt' }
when ('var') {
$C->panic("Can't put optional positional parameter after variadic parameters");
}
};
}
when ('*') {
$::zone = 'var';
}
};

}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule default_value
##      rule default_value {
##          '=' <EXPR(item %item_assignment)>
##      }

sub default_value__PEEK { $_[0]->_AUTOLEXpeek('default_value',$retree) }
sub default_value {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "default_value", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_prefix__S_279try (:$sym is context<rw> = 'try')
##      token statement_prefix:try     { <sym> <blorst> }

sub statement_prefix__S_279try__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_279try',$retree) }
sub statement_prefix__S_279try {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'try';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_279try", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtry/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_280gather (:$sym is context<rw> = 'gather')
##      token statement_prefix:gather  { <sym> <blorst> }

sub statement_prefix__S_280gather__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_280gather',$retree) }
sub statement_prefix__S_280gather {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'gather';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_280gather", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggather/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_281contend (:$sym is context<rw> = 'contend')
##      token statement_prefix:contend { <sym> <blorst> }

sub statement_prefix__S_281contend__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_281contend',$retree) }
sub statement_prefix__S_281contend {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'contend';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_281contend", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gcontend/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_282async (:$sym is context<rw> = 'async')
##      token statement_prefix:async   { <sym> <blorst> }

sub statement_prefix__S_282async__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_282async',$retree) }
sub statement_prefix__S_282async {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'async';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_282async", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gasync/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_283maybe (:$sym is context<rw> = 'maybe')
##      token statement_prefix:maybe   { <sym> <blorst> }

sub statement_prefix__S_283maybe__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_283maybe',$retree) }
sub statement_prefix__S_283maybe {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'maybe';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_283maybe", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmaybe/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_284lazy (:$sym is context<rw> = 'lazy')
##      token statement_prefix:lazy    { <sym> <blorst> }

sub statement_prefix__S_284lazy__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_284lazy',$retree) }
sub statement_prefix__S_284lazy {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lazy';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_284lazy", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glazy/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_285do (:$sym is context<rw> = 'do')
##      token statement_prefix:do      { <sym> <blorst> }

sub statement_prefix__S_285do__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_285do',$retree) }
sub statement_prefix__S_285do {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'do';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_285do", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdo/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}

## token statement_prefix__S_286lift (:$sym is context<rw> = 'lift')
##      token statement_prefix:lift    {
##          :my $QUASI_QUASH is context = 1;
##          <sym> <blorst>
##      }

sub statement_prefix__S_286lift__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_286lift',$retree) }
sub statement_prefix__S_286lift {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lift';
local $::QUASI_QUASH = 1;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_286lift", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glift/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}

## token blorst
##      token blorst {
##          <?before \s> <.ws>
##          [
##          | <block>
##          | <statement>
##          ]
##      }

sub blorst__PEEK { $_[0]->_AUTOLEXpeek('blorst',$retree) }
sub blorst {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "blorst", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blorst_02') {
$C->deb("Fate passed to blorst_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'blorst_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("blorst_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
);
}

## term

# start playing with the setting stubber
## token term__S_287YOU_ARE_HERE (  :$sym is context<rw> = 'YOU_ARE_HERE' --> Term)
##      token term:YOU_ARE_HERE ( --> Term) {
##          <sym> <.you_are_here>
##      }

sub term__S_287YOU_ARE_HERE__PEEK { $_[0]->_AUTOLEXpeek('term__S_287YOU_ARE_HERE',$retree) }
sub term__S_287YOU_ARE_HERE {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'YOU_ARE_HERE';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_287YOU_ARE_HERE",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\GYOU_ARE_HERE/))) {
$C->you_are_here;
}
else {
();
}
}
);
}

## token term__S_288new (  :$sym is context<rw> = 'new' --> Term)
##      token term:new ( --> Term) {
##          'new' \h+ <longname> \h* <!before ':'> <.obs("C++ constructor syntax", "method call syntax")>
##      }

sub term__S_288new__PEEK { $_[0]->_AUTOLEXpeek('term__S_288new',$retree) }
sub term__S_288new {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'new';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_288new",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('new'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(':')
})
}))) {
$C->obs("C++ constructor syntax", "method call syntax");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_289ColonColonQuestionIDENT (  :$sym is context<rw> = <::?IDENT> --> Term)
##      token term:sym<::?IDENT> ( --> Term) {
##          $<sym> = [ '::?' <identifier> ] 
##      }

sub term__S_289ColonColonQuestionIDENT__PEEK { $_[0]->_AUTOLEXpeek('term__S_289ColonColonQuestionIDENT',$retree) }
sub term__S_289ColonColonQuestionIDENT {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::?IDENT);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_289ColonColonQuestionIDENT",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token term__S_290undef (  :$sym is context<rw> = <undef> --> Term)
##      token term:sym<undef> ( --> Term) {
##          <sym> 
##          [ <?before \h*'$/' >
##              <.obs('$/ variable as input record separator',
##                   "the filehandle's .slurp method")>
##          ]?
##          [ <?before \h*<sigil><twigil>?\w >
##              <.obs('undef as a verb', 'undefine function')>
##          ]?
##      }

sub term__S_290undef__PEEK { $_[0]->_AUTOLEXpeek('term__S_290undef',$retree) }
sub term__S_290undef {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(undef);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_290undef",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gundef/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_EXACT('$/');
}
else {
();
}
}
}))) {
$C->obs('$/ variable as input record separator',
"the filehandle's .slurp method");
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
$C->_PATTERN(qr/\G\w/);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->obs('undef as a verb', 'undefine function');
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_291continue (  :$sym is context<rw> = <continue> --> Term)
##      token term:sym<continue> ( --> Term)
##          { <sym>  }

sub term__S_291continue__PEEK { $_[0]->_AUTOLEXpeek('term__S_291continue',$retree) }
sub term__S_291continue {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(continue);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_291continue",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gcontinue\b/)
);
}

## token term__S_292self (  :$sym is context<rw> = <self> --> Term)
##      token term:sym<self> ( --> Term)
##          { <sym>  }

sub term__S_292self__PEEK { $_[0]->_AUTOLEXpeek('term__S_292self',$retree) }
sub term__S_292self {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(self);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_292self",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gself\b/)
);
}

## token term__S_293defer (  :$sym is context<rw> = <defer> --> Term)
##      token term:sym<defer> ( --> Term)
##          { <sym>  }

sub term__S_293defer__PEEK { $_[0]->_AUTOLEXpeek('term__S_293defer',$retree) }
sub term__S_293defer {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(defer);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_293defer",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gdefer\b/)
);
}

## token term__S_294rand (  :$sym is context<rw> = 'rand' --> Term)
##      token term:rand ( --> Term) {
##          <sym> 
##          [ <?before '('? \h* [\d|'$']> <.obs('rand(N)', 'N.rand or (1..N).pick')> ]?
##          [ <?before '()'> <.obs('rand()', 'rand')> ]?
##      }

sub term__S_294rand__PEEK { $_[0]->_AUTOLEXpeek('term__S_294rand',$retree) }
sub term__S_294rand {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rand';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_294rand",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grand/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('(')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_294rand_03') {
$C->deb("Fate passed to term__S_294rand_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_294rand_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_294rand_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub { my $C=shift;
$C->_EXACT('$')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->obs('rand(N)', 'N.rand or (1..N).pick');
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('()')
}))) {
$C->obs('rand()', 'rand');
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_295e (  :$sym is context<rw> = 'e' --> Term)
##      token term:e ( --> Term)
##          { <sym>  }

sub term__S_295e__PEEK { $_[0]->_AUTOLEXpeek('term__S_295e',$retree) }
sub term__S_295e {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_295e",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Ge\b/)
);
}

## token term__S_296i (  :$sym is context<rw> = 'i' --> Term)
##      token term:i ( --> Term)
##          { <sym>  }

sub term__S_296i__PEEK { $_[0]->_AUTOLEXpeek('term__S_296i',$retree) }
sub term__S_296i {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'i';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_296i",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gi\b/)
);
}

## token term__S_297pi (  :$sym is context<rw> = 'pi' --> Term)
##      token term:pi ( --> Term)
##          { <sym>  }

sub term__S_297pi__PEEK { $_[0]->_AUTOLEXpeek('term__S_297pi',$retree) }
sub term__S_297pi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'pi';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_297pi",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gpi\b/)
);
}

## token term__S_298Inf (  :$sym is context<rw> = 'Inf' --> Term)
##      token term:Inf ( --> Term)
##          { <sym>  }

sub term__S_298Inf__PEEK { $_[0]->_AUTOLEXpeek('term__S_298Inf',$retree) }
sub term__S_298Inf {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Inf';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_298Inf",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\GInf\b/)
);
}

## token term__S_299NaN (  :$sym is context<rw> = 'NaN' --> Term)
##      token term:NaN ( --> Term)
##          { <sym>  }

sub term__S_299NaN__PEEK { $_[0]->_AUTOLEXpeek('term__S_299NaN',$retree) }
sub term__S_299NaN {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'NaN';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_299NaN",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\GNaN\b/)
);
}

## token term__S_300Star (  :$sym is context<rw> = <*> --> Term)
##      token term:sym<*> ( --> Term)
##          { <sym> }

sub term__S_300Star__PEEK { $_[0]->_AUTOLEXpeek('term__S_300Star',$retree) }
sub term__S_300Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_300Star",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\G\*/)
);
}

## token term__S_301StarStar (  :$sym is context<rw> = <**> --> Term)
##      token term:sym<**> ( --> Term)
##          { <sym> }

sub term__S_301StarStar__PEEK { $_[0]->_AUTOLEXpeek('term__S_301StarStar',$retree) }
sub term__S_301StarStar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_301StarStar",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\G\*\*/)
);
}

## token infix__S_302lambda (  :$sym is context<rw> = 'lambda' --> Term)
##      token infix:lambda ( --> Term) {
##          <?before '{' | '->' > {{
##              my $line = $.lineof($.pos);
##              for 'if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when' {
##                  my $m = %*MYSTERY{$_};
##                  next unless $m;
##                  if $line - ($m.<line>//-123) < 5 {
##                      $.panic("$_() interpreted as function call at line " ~ $m.<line> ~
##                      "; please use whitespace instead of parens\nUnexpected block in infix position (two terms in a row)");
##                  }
##              }
##              return () if $*IN_REDUCE;
##              $.panic("Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)");
##          }}
##      }

sub infix__S_302lambda__PEEK { $_[0]->_AUTOLEXpeek('infix__S_302lambda',$retree) }
sub infix__S_302lambda {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lambda';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_302lambda",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_302lambda_01') {
$C->deb("Fate passed to infix__S_302lambda_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_302lambda_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_302lambda_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('->')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {

my $line = $C->lineof($C->{'_pos'});
for ('if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when') {
my $m = $::MYSTERY{$_};
next unless $m;
if ($line - ($m->{'line'}//-123) < 5) {
$C->panic("$_() interpreted as function call at line " . $m->{'line'} .
"; please use whitespace instead of parens\nUnexpected block in infix position (two terms in a row)");
}
};
return () if $::IN_REDUCE;
$C->panic("Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)");

}, $C);
}
else {
();
}
}
);
}

## token circumfix__S_303sigil (  :$sym is context<rw> = 'sigil' --> Term)
##      token circumfix:sigil ( --> Term)
##          { :dba('contextualizer') <sigil> '(' ~ ')' <semilist> { $*SIGIL ||= $<sigil>.Str } }

sub circumfix__S_303sigil__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_303sigil',$retree) }
sub circumfix__S_303sigil {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_303sigil",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $::SIGIL ||= $M->{'sigil'}->Str ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'contextualizer')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
);
}

## token circumfix__S_304Paren_Thesis (  :$sym is context<rw> = <( )> --> Term)
##      token circumfix:sym<( )> ( --> Term)
##          { :dba('parenthesized expression') '(' ~ ')' <semilist> }

sub circumfix__S_304Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_304Paren_Thesis',$retree) }
sub circumfix__S_304Paren_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_304Paren_Thesis",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'parenthesized expression')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

## token circumfix__S_305Bra_Ket (  :$sym is context<rw> = <[ ]> --> Term)
##      token circumfix:sym<[ ]> ( --> Term)
##          { :dba('array composer') '[' ~ ']' <semilist> }

sub circumfix__S_305Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_305Bra_Ket',$retree) }
sub circumfix__S_305Bra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_305Bra_Ket",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'array composer')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
);
}

## methodcall

## token postfix__S_306i (  :$sym is context<rw> = <i> --> Methodcall)
##      token postfix:sym<i> ( --> Methodcall)
##          { <sym>  }

sub postfix__S_306i__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_306i',$retree) }
sub postfix__S_306i {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(i);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_306i",  map { STD::Methodcall->coerce($_) } 
$C->_PATTERN(qr/\Gi\b/)
);
}

## token infix__S_307Dot (:$sym is context<rw> = <.>)
##      token infix:sym<.> ()
##          { '.' <[\]\)\},:\s\$"']> <.obs('. to concatenate strings', '~')> }

sub infix__S_307Dot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_307Dot',$retree) }
sub infix__S_307Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_307Dot", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\]\)\},:\s\$"']/))) {
$C->obs('. to concatenate strings', '~');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postfix__S_308MinusGt (:$sym is context<rw> = ['->'])
##      token postfix:sym['->'] ()
##          { '->' <.obs('-> to call a method', '.')> }

sub postfix__S_308MinusGt__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_308MinusGt',$retree) }
sub postfix__S_308MinusGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // ['->'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_308MinusGt", 
do {
if (my ($C) = ($C->_EXACT('->'))) {
$C->obs('-> to call a method', '.');
}
else {
();
}
}
);
}

## autoincrement
## token postfix__S_309PlusPlus (  :$sym is context<rw> = <++> --> Autoincrement)
##      token postfix:sym<++> ( --> Autoincrement)
##          { <sym> }

sub postfix__S_309PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_309PlusPlus',$retree) }
sub postfix__S_309PlusPlus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(++);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_309PlusPlus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\+\+/)
);
}

## token postfix__S_310MinusMinus (  :$sym is context<rw> = <--> --> Autoincrement)
##      token postfix:sym<--> ( --> Autoincrement)
##          { <sym> }

sub postfix__S_310MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_310MinusMinus',$retree) }
sub postfix__S_310MinusMinus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(--);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_310MinusMinus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\-\-/)
);
}

## token prefix__S_311PlusPlus (  :$sym is context<rw> = <++> --> Autoincrement)
##      token prefix:sym<++> ( --> Autoincrement)
##          { <sym> }

sub prefix__S_311PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_311PlusPlus',$retree) }
sub prefix__S_311PlusPlus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(++);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_311PlusPlus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\+\+/)
);
}

## token prefix__S_312MinusMinus (  :$sym is context<rw> = <--> --> Autoincrement)
##      token prefix:sym<--> ( --> Autoincrement)
##          { <sym> }

sub prefix__S_312MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_312MinusMinus',$retree) }
sub prefix__S_312MinusMinus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(--);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_312MinusMinus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\-\-/)
);
}

## exponentiation
## token infix__S_313StarStar (  :$sym is context<rw> = <**> --> Exponentiation)
##      token infix:sym<**> ( --> Exponentiation)
##          { <sym> }

sub infix__S_313StarStar__PEEK { $_[0]->_AUTOLEXpeek('infix__S_313StarStar',$retree) }
sub infix__S_313StarStar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_313StarStar",  map { STD::Exponentiation->coerce($_) } 
$C->_PATTERN(qr/\G\*\*/)
);
}

## symbolic unary
## token prefix__S_314Bang (  :$sym is context<rw> = <!> --> Symbolic_unary)
##      token prefix:sym<!> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_314Bang__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_314Bang',$retree) }
sub prefix__S_314Bang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_314Bang",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\!/)
);
}

## token prefix__S_315Plus (  :$sym is context<rw> = <+> --> Symbolic_unary)
##      token prefix:sym<+> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_315Plus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_315Plus',$retree) }
sub prefix__S_315Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_315Plus",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\+/)
);
}

## token prefix__S_316Minus (  :$sym is context<rw> = <-> --> Symbolic_unary)
##      token prefix:sym<-> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_316Minus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_316Minus',$retree) }
sub prefix__S_316Minus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_316Minus",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\-/)
);
}

## token prefix__S_317Tilde (  :$sym is context<rw> = <~> --> Symbolic_unary)
##      token prefix:sym<~> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_317Tilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_317Tilde',$retree) }
sub prefix__S_317Tilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_317Tilde",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}

## token prefix__S_318Question (  :$sym is context<rw> = <?> --> Symbolic_unary)
##      token prefix:sym<?> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_318Question__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_318Question',$retree) }
sub prefix__S_318Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_318Question",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\?/)
);
}

## token prefix__S_319TildeCaret (  :$sym is context<rw> = <~^> --> Symbolic_unary)
##      token prefix:sym<~^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_319TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_319TildeCaret',$retree) }
sub prefix__S_319TildeCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_319TildeCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\~\^/)
);
}

## token prefix__S_320PlusCaret (  :$sym is context<rw> = <+^> --> Symbolic_unary)
##      token prefix:sym<+^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_320PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_320PlusCaret',$retree) }
sub prefix__S_320PlusCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_320PlusCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\+\^/)
);
}

## token prefix__S_321QuestionCaret (  :$sym is context<rw> = <?^> --> Symbolic_unary)
##      token prefix:sym<?^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_321QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_321QuestionCaret',$retree) }
sub prefix__S_321QuestionCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_321QuestionCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\?\^/)
);
}

## token prefix__S_322Caret (  :$sym is context<rw> = <^> --> Symbolic_unary)
##      token prefix:sym<^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_322Caret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_322Caret',$retree) }
sub prefix__S_322Caret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_322Caret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\^/)
);
}

## token prefix__S_323Vert (  :$sym is context<rw> = <|> --> Symbolic_unary)
##      token prefix:sym<|> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_323Vert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_323Vert',$retree) }
sub prefix__S_323Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_323Vert",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}


## multiplicative
## token infix__S_324Star (  :$sym is context<rw> = <*> --> Multiplicative)
##      token infix:sym<*> ( --> Multiplicative)
##          { <sym> }

sub infix__S_324Star__PEEK { $_[0]->_AUTOLEXpeek('infix__S_324Star',$retree) }
sub infix__S_324Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_324Star",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\*/)
);
}

## token infix__S_325Slash (  :$sym is context<rw> = </> --> Multiplicative)
##      token infix:sym</> ( --> Multiplicative)
##          { <sym> }

sub infix__S_325Slash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_325Slash',$retree) }
sub infix__S_325Slash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(/);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_325Slash",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\//)
);
}

## token infix__S_326div (  :$sym is context<rw> = <div> --> Multiplicative)
##      token infix:sym<div> ( --> Multiplicative)
##          { <sym> }

sub infix__S_326div__PEEK { $_[0]->_AUTOLEXpeek('infix__S_326div',$retree) }
sub infix__S_326div {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(div);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_326div",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\Gdiv/)
);
}

## token infix__S_327Percent (  :$sym is context<rw> = <%> --> Multiplicative)
##      token infix:sym<%> ( --> Multiplicative)
##          { <sym> <?{ $<O><iffy> = 1; }> }

sub infix__S_327Percent__PEEK { $_[0]->_AUTOLEXpeek('infix__S_327Percent',$retree) }
sub infix__S_327Percent {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_327Percent",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\%/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'}{'iffy'} = 1; ;
})
});
}
else {
();
}
}
);
}   # Allow !% operator

## token infix__S_328mod (  :$sym is context<rw> = <mod> --> Multiplicative)
##      token infix:sym<mod> ( --> Multiplicative)
##          { <sym> }

sub infix__S_328mod__PEEK { $_[0]->_AUTOLEXpeek('infix__S_328mod',$retree) }
sub infix__S_328mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(mod);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_328mod",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\Gmod/)
);
}

## token infix__S_329PlusAmp (  :$sym is context<rw> = <+&> --> Multiplicative)
##      token infix:sym<+&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_329PlusAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_329PlusAmp',$retree) }
sub infix__S_329PlusAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_329PlusAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\+\&/)
);
}

## token infix__S_330PlusLt (  :$sym is context<rw> =  +<  --> Multiplicative)
##      token infix:sym +<  ( --> Multiplicative)
##          { <sym> <!before '<'> }

sub infix__S_330PlusLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_330PlusLt',$retree) }
sub infix__S_330PlusLt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['+<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_330PlusLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\</))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('<')
})
});
}
else {
();
}
}
);
}

## token infix__S_331LtLt (  :$sym is context<rw> =  <<  --> Multiplicative)
##      token infix:sym <<  ( --> Multiplicative)
##          { <sym> \s <.obs('<< to do left shift', '+< or ~<')> }

sub infix__S_331LtLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_331LtLt',$retree) }
sub infix__S_331LtLt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_331LtLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\</))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('<< to do left shift', '+< or ~<');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_332GtGt (  :$sym is context<rw> =  >>  --> Multiplicative)
##      token infix:sym >>  ( --> Multiplicative)
##          { <sym> \s <.obs('>> to do right shift', '+> or ~>')> }

sub infix__S_332GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_332GtGt',$retree) }
sub infix__S_332GtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_332GtGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>\>/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('>> to do right shift', '+> or ~>');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_333PlusGt (  :$sym is context<rw> =  +>  --> Multiplicative)
##      token infix:sym +>  ( --> Multiplicative)
##          { <sym> <!before '>'> }

sub infix__S_333PlusGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_333PlusGt',$retree) }
sub infix__S_333PlusGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['+>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_333PlusGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\>/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
});
}
else {
();
}
}
);
}

## token infix__S_334TildeAmp (  :$sym is context<rw> = <~&> --> Multiplicative)
##      token infix:sym<~&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_334TildeAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_334TildeAmp',$retree) }
sub infix__S_334TildeAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_334TildeAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\~\&/)
);
}

## token infix__S_335QuestionAmp (  :$sym is context<rw> = <?&> --> Multiplicative)
##      token infix:sym<?&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_335QuestionAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_335QuestionAmp',$retree) }
sub infix__S_335QuestionAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_335QuestionAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\?\&/)
);
}

## token infix__S_336TildeLt (  :$sym is context<rw> =  ~<  --> Multiplicative)
##      token infix:sym ~<  ( --> Multiplicative)
##          { <sym> <!before '<'> }

sub infix__S_336TildeLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_336TildeLt',$retree) }
sub infix__S_336TildeLt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['~<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_336TildeLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\</))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('<')
})
});
}
else {
();
}
}
);
}

## token infix__S_337TildeGt (  :$sym is context<rw> =  ~>  --> Multiplicative)
##      token infix:sym ~>  ( --> Multiplicative)
##          { <sym> <!before '>'> }

sub infix__S_337TildeGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_337TildeGt',$retree) }
sub infix__S_337TildeGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['~>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_337TildeGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\>/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
});
}
else {
();
}
}
);
}


## additive
## token infix__S_338Plus (  :$sym is context<rw> = <+> --> Additive)
##      token infix:sym<+> ( --> Additive)
##          { <sym> }

sub infix__S_338Plus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_338Plus',$retree) }
sub infix__S_338Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_338Plus",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+/)
);
}

## token infix__S_339Minus (  :$sym is context<rw> = <-> --> Additive)
##      token infix:sym<-> ( --> Additive)
##          { <sym> }

sub infix__S_339Minus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_339Minus',$retree) }
sub infix__S_339Minus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_339Minus",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\-/)
);
}

## token infix__S_340PlusVert (  :$sym is context<rw> = <+|> --> Additive)
##      token infix:sym<+|> ( --> Additive)
##          { <sym> }

sub infix__S_340PlusVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_340PlusVert',$retree) }
sub infix__S_340PlusVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_340PlusVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+\|/)
);
}

## token infix__S_341PlusCaret (  :$sym is context<rw> = <+^> --> Additive)
##      token infix:sym<+^> ( --> Additive)
##          { <sym> }

sub infix__S_341PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_341PlusCaret',$retree) }
sub infix__S_341PlusCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_341PlusCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+\^/)
);
}

## token infix__S_342TildeVert (  :$sym is context<rw> = <~|> --> Additive)
##      token infix:sym<~|> ( --> Additive)
##          { <sym> }

sub infix__S_342TildeVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_342TildeVert',$retree) }
sub infix__S_342TildeVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_342TildeVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~\|/)
);
}

## token infix__S_343TildeCaret (  :$sym is context<rw> = <~^> --> Additive)
##      token infix:sym<~^> ( --> Additive)
##          { <sym> }

sub infix__S_343TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_343TildeCaret',$retree) }
sub infix__S_343TildeCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_343TildeCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~\^/)
);
}

## token infix__S_344QuestionVert (  :$sym is context<rw> = <?|> --> Additive)
##      token infix:sym<?|> ( --> Additive)
##          { <sym> }

sub infix__S_344QuestionVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_344QuestionVert',$retree) }
sub infix__S_344QuestionVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_344QuestionVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\?\|/)
);
}

## token infix__S_345QuestionCaret (  :$sym is context<rw> = <?^> --> Additive)
##      token infix:sym<?^> ( --> Additive)
##          { <sym> }

sub infix__S_345QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_345QuestionCaret',$retree) }
sub infix__S_345QuestionCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_345QuestionCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\?\^/)
);
}

## replication
# Note: no word boundary check after x, relies on longest token for x2 xx2 etc
## token infix__S_346x (  :$sym is context<rw> = <x> --> Replication)
##      token infix:sym<x> ( --> Replication)
##          { <sym> }

sub infix__S_346x__PEEK { $_[0]->_AUTOLEXpeek('infix__S_346x',$retree) }
sub infix__S_346x {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(x);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_346x",  map { STD::Replication->coerce($_) } 
$C->_PATTERN(qr/\Gx/)
);
}

## token infix__S_347xx (  :$sym is context<rw> = <xx> --> Replication)
##      token infix:sym<xx> ( --> Replication)
##          { <sym> }

sub infix__S_347xx__PEEK { $_[0]->_AUTOLEXpeek('infix__S_347xx',$retree) }
sub infix__S_347xx {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(xx);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_347xx",  map { STD::Replication->coerce($_) } 
$C->_PATTERN(qr/\Gxx/)
);
}

## concatenation
## token infix__S_348Tilde (  :$sym is context<rw> = <~> --> Concatenation)
##      token infix:sym<~> ( --> Concatenation)
##          { <sym> }

sub infix__S_348Tilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_348Tilde',$retree) }
sub infix__S_348Tilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_348Tilde",  map { STD::Concatenation->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}


## junctive and (all)
## token infix__S_349Amp (  :$sym is context<rw> = <&> --> Junctive_and)
##      token infix:sym<&> ( --> Junctive_and)
##          { <sym> }

sub infix__S_349Amp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_349Amp',$retree) }
sub infix__S_349Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_349Amp",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\G\&/)
);
}

## token infix__S_350also (  :$sym is context<rw> = <also> --> Junctive_and)
##      token infix:sym<also> ( --> Junctive_and)
##          { <sym> }

sub infix__S_350also__PEEK { $_[0]->_AUTOLEXpeek('infix__S_350also',$retree) }
sub infix__S_350also {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(also);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_350also",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\Galso/)
);
}


## junctive or (any)
## token infix__S_351Vert (  :$sym is context<rw> = <|> --> Junctive_or)
##      token infix:sym<|> ( --> Junctive_or)
##          { <sym> }

sub infix__S_351Vert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_351Vert',$retree) }
sub infix__S_351Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_351Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}

## token infix__S_352Caret (  :$sym is context<rw> = <^> --> Junctive_or)
##      token infix:sym<^> ( --> Junctive_or)
##          { <sym> }

sub infix__S_352Caret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_352Caret',$retree) }
sub infix__S_352Caret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_352Caret",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\^/)
);
}


## named unary examples
# (need \s* to win LTM battle with listops)
## token prefix__S_353sleep (  :$sym is context<rw> = 'sleep' --> Named_unary)
##      token prefix:sleep ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_353sleep__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_353sleep',$retree) }
sub prefix__S_353sleep {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sleep';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_353sleep",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsleep/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_354abs (  :$sym is context<rw> = 'abs' --> Named_unary)
##      token prefix:abs ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_354abs__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_354abs',$retree) }
sub prefix__S_354abs {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'abs';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_354abs",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gabs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_355let (  :$sym is context<rw> = 'let' --> Named_unary)
##      token prefix:let ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_355let__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_355let',$retree) }
sub prefix__S_355let {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'let';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_355let",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glet/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_356temp (  :$sym is context<rw> = 'temp' --> Named_unary)
##      token prefix:temp ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_356temp__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_356temp',$retree) }
sub prefix__S_356temp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'temp';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_356temp",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtemp/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}


## nonchaining binary
## token infix__S_357LtEqualGt (  :$sym is context<rw> =  <=>  --> Nonchaining)
##      token infix:sym <=>  ( --> Nonchaining)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_357LtEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_357LtEqualGt',$retree) }
sub infix__S_357LtEqualGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<=>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_357LtEqualGt",  map { STD::Nonchaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\=\>/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'}{'returns'} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_358cmp (  :$sym is context<rw> = 'cmp' --> Nonchaining)
##      token infix:cmp ( --> Nonchaining)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_358cmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_358cmp',$retree) }
sub infix__S_358cmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'cmp';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_358cmp",  map { STD::Nonchaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gcmp/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'}{'returns'} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_359leg (  :$sym is context<rw> = 'leg' --> Nonchaining)
##      token infix:leg ( --> Nonchaining)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_359leg__PEEK { $_[0]->_AUTOLEXpeek('infix__S_359leg',$retree) }
sub infix__S_359leg {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'leg';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_359leg",  map { STD::Nonchaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gleg/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'}{'returns'} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_360but (  :$sym is context<rw> = 'but' --> Nonchaining)
##      token infix:but ( --> Nonchaining)
##          { <sym> }

sub infix__S_360but__PEEK { $_[0]->_AUTOLEXpeek('infix__S_360but',$retree) }
sub infix__S_360but {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'but';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_360but",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gbut/)
);
}

## token infix__S_361does (  :$sym is context<rw> = 'does' --> Nonchaining)
##      token infix:does ( --> Nonchaining)
##          { <sym> }

sub infix__S_361does__PEEK { $_[0]->_AUTOLEXpeek('infix__S_361does',$retree) }
sub infix__S_361does {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'does';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_361does",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gdoes/)
);
}

## token infix__S_362DotDot (  :$sym is context<rw> = <..> --> Nonchaining)
##      token infix:sym<..> ( --> Nonchaining)
##          { <sym> [<!{ $*IN_META }> <?before ')' | ']'> <.panic: "Please use ..* for indefinite range">]? }

sub infix__S_362DotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_362DotDot',$retree) }
sub infix__S_362DotDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(..);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_362DotDot",  map { STD::Nonchaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\./))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::IN_META 
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_362DotDot_02') {
$C->deb("Fate passed to infix__S_362DotDot_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_362DotDot_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_362DotDot_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->panic("Please use ..* for indefinite range");
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token infix__S_363CaretDotDot (  :$sym is context<rw> = <^..> --> Nonchaining)
##      token infix:sym<^..> ( --> Nonchaining)
##          { <sym> }

sub infix__S_363CaretDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_363CaretDotDot',$retree) }
sub infix__S_363CaretDotDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^..);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_363CaretDotDot",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^\.\./)
);
}

## token infix__S_364DotDotCaret (  :$sym is context<rw> = <..^> --> Nonchaining)
##      token infix:sym<..^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_364DotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_364DotDotCaret',$retree) }
sub infix__S_364DotDotCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(..^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_364DotDotCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\.\.\^/)
);
}

## token infix__S_365CaretDotDotCaret (  :$sym is context<rw> = <^..^> --> Nonchaining)
##      token infix:sym<^..^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_365CaretDotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_365CaretDotDotCaret',$retree) }
sub infix__S_365CaretDotDotCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^..^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_365CaretDotDotCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^\.\.\^/)
);
}


## chaining binary
## token infix__S_366EqualEqual (  :$sym is context<rw> = <==> --> Chaining)
##      token infix:sym<==> ( --> Chaining)
##          { <sym> <!before '=' > }

sub infix__S_366EqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_366EqualEqual',$retree) }
sub infix__S_366EqualEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(==);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_366EqualEqual",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('=')
})
});
}
else {
();
}
}
);
}

## token infix__S_367BangEqual (  :$sym is context<rw> = <!=> --> Chaining)
##      token infix:sym<!=> ( --> Chaining)
##          { <sym> <?before \s> }

sub infix__S_367BangEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_367BangEqual',$retree) }
sub infix__S_367BangEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_367BangEqual",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\=/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
});
}
else {
();
}
}
);
}

## token infix__S_368Lt (  :$sym is context<rw> =  <  --> Chaining)
##      token infix:sym <  ( --> Chaining)
##          { <sym> }

sub infix__S_368Lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_368Lt',$retree) }
sub infix__S_368Lt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_368Lt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\</)
);
}

## token infix__S_369LtEqual (  :$sym is context<rw> =  <=  --> Chaining)
##      token infix:sym <=  ( --> Chaining)
##          { <sym> }

sub infix__S_369LtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_369LtEqual',$retree) }
sub infix__S_369LtEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<='];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_369LtEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\<\=/)
);
}

## token infix__S_370Gt (  :$sym is context<rw> =  >  --> Chaining)
##      token infix:sym >  ( --> Chaining)
##          { <sym> }

sub infix__S_370Gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_370Gt',$retree) }
sub infix__S_370Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_370Gt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\>/)
);
}

## token infix__S_371GtEqual (  :$sym is context<rw> =  >=  --> Chaining)
##      token infix:sym >=  ( --> Chaining)
##          { <sym> }

sub infix__S_371GtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_371GtEqual',$retree) }
sub infix__S_371GtEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>='];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_371GtEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\>\=/)
);
}

## token infix__S_372TildeTilde (  :$sym is context<rw> = <~~> --> Chaining)
##      token infix:sym<~~> ( --> Chaining)
##          { <sym> }

sub infix__S_372TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_372TildeTilde',$retree) }
sub infix__S_372TildeTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_372TildeTilde",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\~\~/)
);
}

# XXX should move to inside meta !
## token infix__S_373BangTilde (  :$sym is context<rw> = <!~> --> Chaining)
##      token infix:sym<!~> ( --> Chaining)
##          { <sym> \s <.obs('!~ to do negated pattern matching', '!~~')> }

sub infix__S_373BangTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_373BangTilde',$retree) }
sub infix__S_373BangTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_373BangTilde",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\~/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('!~ to do negated pattern matching', '!~~');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_374EqualTilde (  :$sym is context<rw> = <=~> --> Chaining)
##      token infix:sym<=~> ( --> Chaining)
##          { <sym> <.obs('=~ to do pattern matching', '~~')> }

sub infix__S_374EqualTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_374EqualTilde',$retree) }
sub infix__S_374EqualTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_374EqualTilde",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\~/))) {
$C->obs('=~ to do pattern matching', '~~');
}
else {
();
}
}
);
}

## token infix__S_375eq (  :$sym is context<rw> = <eq> --> Chaining)
##      token infix:sym<eq> ( --> Chaining)
##          { <sym> }

sub infix__S_375eq__PEEK { $_[0]->_AUTOLEXpeek('infix__S_375eq',$retree) }
sub infix__S_375eq {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(eq);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_375eq",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Geq/)
);
}

## token infix__S_376ne (  :$sym is context<rw> = <ne> --> Chaining)
##      token infix:sym<ne> ( --> Chaining)
##          { <sym> }

sub infix__S_376ne__PEEK { $_[0]->_AUTOLEXpeek('infix__S_376ne',$retree) }
sub infix__S_376ne {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ne);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_376ne",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gne/)
);
}

## token infix__S_377lt (  :$sym is context<rw> = <lt> --> Chaining)
##      token infix:sym<lt> ( --> Chaining)
##          { <sym> }

sub infix__S_377lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_377lt',$retree) }
sub infix__S_377lt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(lt);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_377lt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Glt/)
);
}

## token infix__S_378le (  :$sym is context<rw> = <le> --> Chaining)
##      token infix:sym<le> ( --> Chaining)
##          { <sym> }

sub infix__S_378le__PEEK { $_[0]->_AUTOLEXpeek('infix__S_378le',$retree) }
sub infix__S_378le {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(le);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_378le",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gle/)
);
}

## token infix__S_379gt (  :$sym is context<rw> = <gt> --> Chaining)
##      token infix:sym<gt> ( --> Chaining)
##          { <sym> }

sub infix__S_379gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_379gt',$retree) }
sub infix__S_379gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(gt);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_379gt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Ggt/)
);
}

## token infix__S_380ge (  :$sym is context<rw> = <ge> --> Chaining)
##      token infix:sym<ge> ( --> Chaining)
##          { <sym> }

sub infix__S_380ge__PEEK { $_[0]->_AUTOLEXpeek('infix__S_380ge',$retree) }
sub infix__S_380ge {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ge);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_380ge",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gge/)
);
}

## token infix__S_381EqualColonEqual (  :$sym is context<rw> = <=:=> --> Chaining)
##      token infix:sym<=:=> ( --> Chaining)
##          { <sym> }

sub infix__S_381EqualColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_381EqualColonEqual',$retree) }
sub infix__S_381EqualColonEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=:=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_381EqualColonEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\=\:\=/)
);
}

## token infix__S_382EqualEqualEqual (  :$sym is context<rw> = <===> --> Chaining)
##      token infix:sym<===> ( --> Chaining)
##          { <sym> }

sub infix__S_382EqualEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_382EqualEqualEqual',$retree) }
sub infix__S_382EqualEqualEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(===);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_382EqualEqualEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\=\=\=/)
);
}

## token infix__S_383eqv (  :$sym is context<rw> = <eqv> --> Chaining)
##      token infix:sym<eqv> ( --> Chaining)
##          { <sym> }

sub infix__S_383eqv__PEEK { $_[0]->_AUTOLEXpeek('infix__S_383eqv',$retree) }
sub infix__S_383eqv {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(eqv);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_383eqv",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Geqv/)
);
}

## token infix__S_384before (  :$sym is context<rw> = <before> --> Chaining)
##      token infix:sym<before> ( --> Chaining)
##          { <sym> }

sub infix__S_384before__PEEK { $_[0]->_AUTOLEXpeek('infix__S_384before',$retree) }
sub infix__S_384before {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(before);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_384before",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gbefore/)
);
}

## token infix__S_385after (  :$sym is context<rw> = <after> --> Chaining)
##      token infix:sym<after> ( --> Chaining)
##          { <sym> }

sub infix__S_385after__PEEK { $_[0]->_AUTOLEXpeek('infix__S_385after',$retree) }
sub infix__S_385after {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(after);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_385after",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gafter/)
);
}


## tight and
## token infix__S_386AmpAmp (  :$sym is context<rw> = <&&> --> Tight_and)
##      token infix:sym<&&> ( --> Tight_and)
##          { <sym> }

sub infix__S_386AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_386AmpAmp',$retree) }
sub infix__S_386AmpAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_386AmpAmp",  map { STD::Tight_and->coerce($_) } 
$C->_PATTERN(qr/\G\&\&/)
);
}


## tight or
## token infix__S_387VertVert (  :$sym is context<rw> = <||> --> Tight_or)
##      token infix:sym<||> ( --> Tight_or)
##          { <sym> }

sub infix__S_387VertVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_387VertVert',$retree) }
sub infix__S_387VertVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_387VertVert",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\|\|/)
);
}

## token infix__S_388CaretCaret (  :$sym is context<rw> = <^^> --> Tight_or)
##      token infix:sym<^^> ( --> Tight_or)
##          { <sym> }

sub infix__S_388CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_388CaretCaret',$retree) }
sub infix__S_388CaretCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_388CaretCaret",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\^\^/)
);
}

## token infix__S_389SlashSlash (  :$sym is context<rw> = <//> --> Tight_or)
##      token infix:sym<//> ( --> Tight_or)
##          { <sym> }

sub infix__S_389SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_389SlashSlash',$retree) }
sub infix__S_389SlashSlash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(//);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_389SlashSlash",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\/\//)
);
}

## token infix__S_390min (  :$sym is context<rw> = <min> --> Tight_or)
##      token infix:sym<min> ( --> Tight_or)
##          { <sym> }

sub infix__S_390min__PEEK { $_[0]->_AUTOLEXpeek('infix__S_390min',$retree) }
sub infix__S_390min {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(min);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_390min",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\Gmin/)
);
}

## token infix__S_391max (  :$sym is context<rw> = <max> --> Tight_or)
##      token infix:sym<max> ( --> Tight_or)
##          { <sym> }

sub infix__S_391max__PEEK { $_[0]->_AUTOLEXpeek('infix__S_391max',$retree) }
sub infix__S_391max {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(max);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_391max",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\Gmax/)
);
}


## conditional
## token infix__S_392QuestionQuestion_BangBang (  :$sym is context<rw> = <?? !!> --> Conditional)
##      token infix:sym<?? !!> ( --> Conditional) {
##          :my $GOAL is context = '!!';
##          '??'
##          <.ws>
##          <EXPR(item %item_assignment)>
##          [ '!!' ||
##              [
##              || <?before '='> <.panic: "Assignment not allowed within ??!!">
##              || <?before '::'> <.panic: "Please use !! rather than ::">
##              || <?before <infixish>>    # Note: a tight infix would have parsed right
##                  <.panic: "Precedence too loose within ??!!; use ??()!! instead ">
##              || <.panic: "Found ?? but no !!; possible precedence problem">
##              ]
##          ]
##      }

sub infix__S_392QuestionQuestion_BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_392QuestionQuestion_BangBang',$retree) }
sub infix__S_392QuestionQuestion_BangBang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(?? !!)];
local $::GOAL = '!!';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_392QuestionQuestion_BangBang",  map { STD::Conditional->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('??'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('!!')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
$C->panic("Assignment not allowed within ??!!");
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('::')
}))) {
$C->panic("Please use !! rather than ::");
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}))) {
$C->panic("Precedence too loose within ??!!; use ??()!! instead ");
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Found ?? but no !!; possible precedence problem")} or do { die $@ if $@ };
@gather;
}
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_393Question (  :$sym is context<rw> = <?> --> Conditional)
##      token infix:sym<?> ( --> Conditional)
##          { <sym> <.obs('?: for the conditional operator', '??!!')> }

sub infix__S_393Question__PEEK { $_[0]->_AUTOLEXpeek('infix__S_393Question',$retree) }
sub infix__S_393Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_393Question",  map { STD::Conditional->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->obs('?: for the conditional operator', '??!!');
}
else {
();
}
}
);
}

## token infix__S_394ff (  :$sym is context<rw> = <ff> --> Conditional)
##      token infix:sym<ff> ( --> Conditional)
##          { <sym> }

sub infix__S_394ff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_394ff',$retree) }
sub infix__S_394ff {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ff);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_394ff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gff/)
);
}

## token infix__S_395Caretff (  :$sym is context<rw> = <^ff> --> Conditional)
##      token infix:sym<^ff> ( --> Conditional)
##          { <sym> }

sub infix__S_395Caretff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_395Caretff',$retree) }
sub infix__S_395Caretff {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^ff);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_395Caretff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^ff/)
);
}

## token infix__S_396ffCaret (  :$sym is context<rw> = <ff^> --> Conditional)
##      token infix:sym<ff^> ( --> Conditional)
##          { <sym> }

sub infix__S_396ffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_396ffCaret',$retree) }
sub infix__S_396ffCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ff^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_396ffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gff\^/)
);
}

## token infix__S_397CaretffCaret (  :$sym is context<rw> = <^ff^> --> Conditional)
##      token infix:sym<^ff^> ( --> Conditional)
##          { <sym> }

sub infix__S_397CaretffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_397CaretffCaret',$retree) }
sub infix__S_397CaretffCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^ff^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_397CaretffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^ff\^/)
);
}

## token infix__S_398fff (  :$sym is context<rw> = <fff> --> Conditional)
##      token infix:sym<fff> ( --> Conditional)
##          { <sym> }

sub infix__S_398fff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_398fff',$retree) }
sub infix__S_398fff {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(fff);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_398fff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gfff/)
);
}

## token infix__S_399Caretfff (  :$sym is context<rw> = <^fff> --> Conditional)
##      token infix:sym<^fff> ( --> Conditional)
##          { <sym> }

sub infix__S_399Caretfff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_399Caretfff',$retree) }
sub infix__S_399Caretfff {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^fff);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_399Caretfff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^fff/)
);
}

## token infix__S_400fffCaret (  :$sym is context<rw> = <fff^> --> Conditional)
##      token infix:sym<fff^> ( --> Conditional)
##          { <sym> }

sub infix__S_400fffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_400fffCaret',$retree) }
sub infix__S_400fffCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(fff^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_400fffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gfff\^/)
);
}

## token infix__S_401CaretfffCaret (  :$sym is context<rw> = <^fff^> --> Conditional)
##      token infix:sym<^fff^> ( --> Conditional)
##          { <sym> }

sub infix__S_401CaretfffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_401CaretfffCaret',$retree) }
sub infix__S_401CaretfffCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^fff^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_401CaretfffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^fff\^/)
);
}

## assignment
# There is no "--> type" because assignment may be coerced to either
# item assignment or list assignment at "make" time.

## token infix__S_402Equal (:$sym is context<rw> = <=>)
##      token infix:sym<=> ()
##      {
##          <sym>
##          { $ = $*SIGIL eq '$' 
##              ?? ::Item_assignment.coerce($)
##              !! ::List_assignment.coerce($);
##          }
##      }

sub infix__S_402Equal__PEEK { $_[0]->_AUTOLEXpeek('infix__S_402Equal',$retree) }
sub infix__S_402Equal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_402Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
scalar(do {
$C = $::SIGIL eq '$' 
? 'STD::Item_assignment'->coerce($C)
: 'STD::List_assignment'->coerce($C);

}, $C);
}
else {
();
}
}
);
}

## token infix__S_403ColonEqual (  :$sym is context<rw> = <:=> --> Item_assignment)
##      token infix:sym<:=> ( --> Item_assignment)
##          { <sym> }

sub infix__S_403ColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_403ColonEqual',$retree) }
sub infix__S_403ColonEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_403ColonEqual",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\:\=/)
);
}

## token infix__S_404ColonColonEqual (  :$sym is context<rw> = <::=> --> Item_assignment)
##      token infix:sym<::=> ( --> Item_assignment)
##          { <sym> }

sub infix__S_404ColonColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_404ColonColonEqual',$retree) }
sub infix__S_404ColonColonEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_404ColonColonEqual",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\:\:\=/)
);
}

## token infix__S_405DotEqual (  :$sym is context<rw> = <.=> --> Item_assignment)
##      token infix:sym<.=> ( --> Item_assignment) {
##          <sym> <.ws>
##          [ <?before \w+';' | 'new'|'sort'|'subst'|'trans'|'reverse'|'uniq'|'map'|'samecase'|'substr'|'flip'|'fmt' > || <worryobs('.= as append operator', '~=')> ]
##          { $<O><nextterm> = 'dottyopish' }
##      }

sub infix__S_405DotEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_405DotEqual',$retree) }
sub infix__S_405DotEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_405DotEqual",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\=/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_405DotEqual_02') {
$C->deb("Fate passed to infix__S_405DotEqual_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_405DotEqual_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_405DotEqual_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
$C->_EXACT(';');
}
else {
();
}
}
},
sub { my $C=shift;
$C->_EXACT('new')
},
sub { my $C=shift;
$C->_EXACT('sort')
},
sub { my $C=shift;
$C->_EXACT('subst')
},
sub { my $C=shift;
$C->_EXACT('trans')
},
sub { my $C=shift;
$C->_EXACT('reverse')
},
sub { my $C=shift;
$C->_EXACT('uniq')
},
sub { my $C=shift;
$C->_EXACT('map')
},
sub { my $C=shift;
$C->_EXACT('samecase')
},
sub { my $C=shift;
$C->_EXACT('substr')
},
sub { my $C=shift;
$C->_EXACT('flip')
},
sub { my $C=shift;
$C->_EXACT('fmt')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUMEr(['worryobs'], sub {
my $C = shift;
$C->worryobs('.= as append operator', '~=')
})} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'O'}{'nextterm'} = 'dottyopish' ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_406EqualGt (  :$sym is context<rw> =  =>  --> Item_assignment)
##      token infix:sym =>  ( --> Item_assignment)
##          { <sym> { $<O><fiddly> = 0; } }

sub infix__S_406EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_406EqualGt',$retree) }
sub infix__S_406EqualGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['=>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_406EqualGt",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\>/))) {
scalar(do {
my $M = $C;  $M->{'O'}{'fiddly'} = 0; ;
}, $C);
}
else {
();
}
}
);
}

# Note, other assignment ops generated by infix_postfix_meta_operator rule

## loose unary
## token prefix__S_407true (  :$sym is context<rw> = <true> --> Loose_unary)
##      token prefix:sym<true> ( --> Loose_unary)
##          { <sym>  }

sub prefix__S_407true__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_407true',$retree) }
sub prefix__S_407true {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(true);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_407true",  map { STD::Loose_unary->coerce($_) } 
$C->_PATTERN(qr/\Gtrue\b/)
);
}

## token prefix__S_408not (  :$sym is context<rw> = <not> --> Loose_unary)
##      token prefix:sym<not> ( --> Loose_unary)
##          { <sym>  }

sub prefix__S_408not__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_408not',$retree) }
sub prefix__S_408not {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(not);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_408not",  map { STD::Loose_unary->coerce($_) } 
$C->_PATTERN(qr/\Gnot\b/)
);
}

## list item separator
## token infix__S_409Comma (  :$sym is context<rw> = <,> --> Comma)
##      token infix:sym<,> ( --> Comma)
##          { <sym> { $<O><fiddly> = 0; } }

sub infix__S_409Comma__PEEK { $_[0]->_AUTOLEXpeek('infix__S_409Comma',$retree) }
sub infix__S_409Comma {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[,];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_409Comma",  map { STD::Comma->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\,/))) {
scalar(do {
my $M = $C;  $M->{'O'}{'fiddly'} = 0; ;
}, $C);
}
else {
();
}
}
);
}

## token infix__S_410Colon (  :$sym is context<rw> = <:> --> Comma)
##      token infix:sym<:> ( --> Comma)
##          { <sym> <?before \s | <terminator> >
##              { $.panic("Illegal use of colon as invocant marker") unless $*INVOCANT_OK--; }
##          }

sub infix__S_410Colon__PEEK { $_[0]->_AUTOLEXpeek('infix__S_410Colon',$retree) }
sub infix__S_410Colon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_410Colon",  map { STD::Comma->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_410Colon_01') {
$C->deb("Fate passed to infix__S_410Colon_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_410Colon_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_410Colon_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$C->panic("Illegal use of colon as invocant marker") unless $::INVOCANT_OK--; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_411p5EqualGt (  :$sym is context<rw> =  p5=>  --> Comma)
##      token infix:sym p5=>  ( --> Comma)
##          { <sym> }

sub infix__S_411p5EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_411p5EqualGt',$retree) }
sub infix__S_411p5EqualGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['p5=>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_411p5EqualGt",  map { STD::Comma->coerce($_) } 
$C->_PATTERN(qr/\Gp5\=\>/)
);
}

## token infix__S_412Z (  :$sym is context<rw> = <Z> --> List_infix)
##      token infix:sym<Z> ( --> List_infix)
##          { <sym> }

sub infix__S_412Z__PEEK { $_[0]->_AUTOLEXpeek('infix__S_412Z',$retree) }
sub infix__S_412Z {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(Z);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_412Z",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\GZ/)
);
}

## token infix__S_413minmax (  :$sym is context<rw> = <minmax> --> List_infix)
##      token infix:sym<minmax> ( --> List_infix)
##          { <sym> }

sub infix__S_413minmax__PEEK { $_[0]->_AUTOLEXpeek('infix__S_413minmax',$retree) }
sub infix__S_413minmax {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(minmax);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_413minmax",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\Gminmax/)
);
}

## token infix__S_414DotDotDot (  :$sym is context<rw> = <...> --> List_infix)
##      token infix:sym<...> ( --> List_infix)
##          { <sym> }

sub infix__S_414DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_414DotDotDot',$retree) }
sub infix__S_414DotDotDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_414DotDotDot",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\G\.\.\./)
);
}

## token term__S_415DotDotDot (  :$sym is context<rw> = <...> --> List_prefix)
##      token term:sym<...> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_415DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('term__S_415DotDotDot',$retree) }
sub term__S_415DotDotDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_415DotDotDot",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\.\./))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_416QuestionQuestionQuestion (  :$sym is context<rw> = <???> --> List_prefix)
##      token term:sym<???> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_416QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('term__S_416QuestionQuestionQuestion',$retree) }
sub term__S_416QuestionQuestionQuestion {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(???);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_416QuestionQuestionQuestion",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\?\?/))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_417BangBangBang (  :$sym is context<rw> = <!!!> --> List_prefix)
##      token term:sym<!!!> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_417BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('term__S_417BangBangBang',$retree) }
sub term__S_417BangBangBang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_417BangBangBang",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\!\!/))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

# force identifier(), identifier.(), etc. to be a function call always
## token term__S_418identifier (  :$sym is context<rw> = 'identifier' --> Term )
##      token term:identifier ( --> Term )
##      {
##          :my $name;
##          :my $pos;
##          <identifier> <?before [<unsp>|'(']? >
##          { $name = $<identifier>.Str; $pos = $.pos; }
##          <args( $.is_name($name) )>
##          { self.add_mystery($name,$pos) unless $<args><invocant>; }
##          {{
##              if $*BORG and $*BORG.<block> {
##                  if not $*BORG.<name> {
##                      $*BORG.<culprit> = $<identifier>.cursor($pos);
##                      $*BORG.<name> = $name;
##                  }
##              }
##          }}
##      }

sub term__S_418identifier__PEEK { $_[0]->_AUTOLEXpeek('term__S_418identifier',$retree) }
sub term__S_418identifier {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'identifier';
my $name;
my $pos;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_418identifier",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_418identifier_02') {
$C->deb("Fate passed to term__S_418identifier_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_418identifier_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_418identifier_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $name = $M->{'identifier'}->Str; $pos = $C->{'_pos'}; ;
}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args( $C->is_name($name) )
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $self->add_mystery($name,$pos) unless $M->{'args'}{'invocant'}; ;
}, $C))) {
scalar(do {
my $M = $C; 
if ($::BORG and $BORG->{'block'}) {
if (not $BORG->{'name'}) {
$BORG->{'culprit'} = $M->{'identifier'}->cursor($pos);
$BORG->{'name'} = $name;
}
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_419opfunc (  :$sym is context<rw> = 'opfunc' --> Term )
##      token term:opfunc ( --> Term )
##      {
##          <category> <colonpair>+ <args>
##      }

sub term__S_419opfunc__PEEK { $_[0]->_AUTOLEXpeek('term__S_419opfunc',$retree) }
sub term__S_419opfunc {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'opfunc';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_419opfunc",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token args ($istype = 0)
##      token args ($istype = 0) {
##          :my $listopish = 0;
##          :my $GOAL is context = '';
##          :my $INVOCANT_OK is context<rw> = 1;
##          :my $INVOCANT_IS is context<rw>;
##          [
##      #    | :dba('argument list') '.(' ~ ')' <semiarglist> {*}             #= func args
##          | :dba('argument list') '(' ~ ')' <semiarglist> {*}              #= func args
##          | :dba('argument list') <.unsp> '(' ~ ')' <semiarglist> {*} #= func args
##          |  { $listopish = 1 } [<?before \s> <!{ $istype }> <.ws> <!infixstopper> <arglist>]?
##          ]
##          { $<invocant> = $*INVOCANT_IS; }
##      
##          :dba('extra arglist after (...):')
##          [
##          || <?{ $listopish }>
##          || ':' <?before \s> <moreargs=arglist>    # either switch to listopiness
##          || {{ $<O> = {}; }}   # or allow adverbs (XXX needs hoisting?)
##          ]
##      }

sub args__PEEK { $_[0]->_AUTOLEXpeek('args',$retree) }
sub args {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $istype = shift() // 0;
my $listopish = 0;
local $::GOAL = '';
local $::INVOCANT_OK = 1;
local $::INVOCANT_IS;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];

$self->_MATCHIFY($S, "args", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$listopish 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['moreargs'], sub {
my $C = shift;
$C->arglist
})
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
}, $C->_EXACT(':'))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
my $M = $C;  $M->{'O'} = {}; ;
}, $C)} or do { die $@ if $@ };
@gather;
}
})
}, scalar(do {
my $M = $C;  $M->{'invocant'} = $::INVOCANT_IS; ;
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'args_01') {
$C->deb("Fate passed to args_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'args_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("args_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args', 'func args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args', 'func args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
}, $C->unsp)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['arglist'], sub {
my $C = shift;
$C->arglist
})
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))
}, $C->ws)
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$istype 
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
})
})
}, scalar(do {
$listopish = 1 
}, $C))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

# names containing :: may or may not be function calls
# bare identifier without parens also handled here if no other rule parses it
## token term__S_420name (  :$sym is context<rw> = 'name' --> Term)
##      token term:name ( --> Term)
##      {
##          :my $name;
##          :my $pos;
##          <longname>
##          {
##              $name = $<longname>.Str;
##              $pos = $.pos;
##          }
##          [
##          ||  <?{
##                  $.is_name($<longname>.Str) or substr($<longname>.Str,0,2) eq '::'
##              }>
##              # parametric type?
##              <.unsp>? [ <?before '['> <postcircumfix> ]?
##              :dba('type parameter')
##              [
##                  '::'
##                  <?before [ '' | '<' | '{' | '<<' ] > <postcircumfix>
##                  {*}                                                 #= packagevar 
##              ]?
##              {*}                                                     #= typename
##      
##          # unrecognized names are assumed to be post-declared listops.
##          || <args> { self.add_mystery($name,$pos) unless $<args><invocant>; }
##              {{
##                  if $*BORG and $*BORG.<block> {
##                      if not $*BORG.<name> {
##                          $*BORG.<culprit> = $<longname>.cursor($pos);
##                          $*BORG.<name> //= $name;
##                      }
##                  }
##              }}
##          ]
##      }

sub term__S_420name__PEEK { $_[0]->_AUTOLEXpeek('term__S_420name',$retree) }
sub term__S_420name {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'name';
my $name;
my $pos;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'postcircumfix'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_420name",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$name = $M->{'longname'}->Str;
$pos = $C->{'_pos'};
;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
$C->is_name($M->{'longname'}->Str) or substr($M->{'longname'}->Str,0,2) eq '::'
;
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_420name_06') {
$C->deb("Fate passed to term__S_420name_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_420name_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_420name_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->_REDUCE($S, 'term__S_420name', 'packagevar ');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_REDUCE($S, 'term__S_420name', 'typename');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $self->add_mystery($name,$pos) unless $M->{'args'}{'invocant'}; ;
}, $C))) {
scalar(do {
my $M = $C; 
if ($::BORG and $BORG->{'block'}) {
if (not $BORG->{'name'}) {
$BORG->{'culprit'} = $M->{'longname'}->cursor($pos);
$BORG->{'name'} //= $name;
}
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## loose and
## token infix__S_421and (  :$sym is context<rw> = <and> --> Loose_and)
##      token infix:sym<and> ( --> Loose_and)
##          { <sym> }

sub infix__S_421and__PEEK { $_[0]->_AUTOLEXpeek('infix__S_421and',$retree) }
sub infix__S_421and {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(and);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_421and",  map { STD::Loose_and->coerce($_) } 
$C->_PATTERN(qr/\Gand/)
);
}

## token infix__S_422andthen (  :$sym is context<rw> = <andthen> --> Loose_and)
##      token infix:sym<andthen> ( --> Loose_and)
##          { <sym> }

sub infix__S_422andthen__PEEK { $_[0]->_AUTOLEXpeek('infix__S_422andthen',$retree) }
sub infix__S_422andthen {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(andthen);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_422andthen",  map { STD::Loose_and->coerce($_) } 
$C->_PATTERN(qr/\Gandthen/)
);
}

## loose or
## token infix__S_423or (  :$sym is context<rw> = <or> --> Loose_or)
##      token infix:sym<or> ( --> Loose_or)
##          { <sym> }

sub infix__S_423or__PEEK { $_[0]->_AUTOLEXpeek('infix__S_423or',$retree) }
sub infix__S_423or {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(or);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_423or",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gor/)
);
}

## token infix__S_424orelse (  :$sym is context<rw> = <orelse> --> Loose_or)
##      token infix:sym<orelse> ( --> Loose_or)
##          { <sym> }

sub infix__S_424orelse__PEEK { $_[0]->_AUTOLEXpeek('infix__S_424orelse',$retree) }
sub infix__S_424orelse {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(orelse);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_424orelse",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gorelse/)
);
}

## token infix__S_425xor (  :$sym is context<rw> = <xor> --> Loose_or)
##      token infix:sym<xor> ( --> Loose_or)
##          { <sym> }

sub infix__S_425xor__PEEK { $_[0]->_AUTOLEXpeek('infix__S_425xor',$retree) }
sub infix__S_425xor {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(xor);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_425xor",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gxor/)
);
}

## sequencer
## token infix__S_426LtEqualEqual (  :$sym is context<rw> =  <==  --> Sequencer)
##      token infix:sym <==  ( --> Sequencer)
##          { <sym> }

sub infix__S_426LtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_426LtEqualEqual',$retree) }
sub infix__S_426LtEqualEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<=='];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_426LtEqualEqual",  map { STD::Sequencer->coerce($_) } 
$C->_PATTERN(qr/\G\<\=\=/)
);
}

## token infix__S_427EqualEqualGt (  :$sym is context<rw> =  ==>  --> Sequencer)
##      token infix:sym ==>  ( --> Sequencer)
##          { <sym> {*} }

sub infix__S_427EqualEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_427EqualEqualGt',$retree) }
sub infix__S_427EqualEqualGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['==>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_427EqualEqualGt",  map { STD::Sequencer->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>/))) {
$C->_REDUCE($S, 'infix__S_427EqualEqualGt');
}
else {
();
}
}
);
}              #'

## token infix__S_428LtLtEqualEqual (  :$sym is context<rw> =  <<==  --> Sequencer)
##      token infix:sym <<==  ( --> Sequencer)
##          { <sym> }

sub infix__S_428LtLtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_428LtLtEqualEqual',$retree) }
sub infix__S_428LtLtEqualEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<=='];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_428LtLtEqualEqual",  map { STD::Sequencer->coerce($_) } 
$C->_PATTERN(qr/\G\<\<\=\=/)
);
}

## token infix__S_429EqualEqualGtGt (  :$sym is context<rw> =  ==>>  --> Sequencer)
##      token infix:sym ==>>  ( --> Sequencer)
##          { <sym> {*} }

sub infix__S_429EqualEqualGtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_429EqualEqualGtGt',$retree) }
sub infix__S_429EqualEqualGtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['==>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_429EqualEqualGtGt",  map { STD::Sequencer->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>\>/))) {
$C->_REDUCE($S, 'infix__S_429EqualEqualGtGt');
}
else {
();
}
}
);
}              #'

## expression terminator
# Note: must always be called as <?terminator> or <?before ...<terminator>...>

## token terminator__S_430Semi (  :$sym is context<rw> = <;> --> Terminator)
##      token terminator:sym<;> ( --> Terminator)
##          { ';' }

sub terminator__S_430Semi__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_430Semi',$retree) }
sub terminator__S_430Semi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(;);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_430Semi",  map { STD::Terminator->coerce($_) } 
$C->_EXACT(';')
);
}

## token terminator__S_431if (  :$sym is context<rw> = <if> --> Terminator)
##      token terminator:sym<if> ( --> Terminator)
##          { 'if'  <.nofun> }

sub terminator__S_431if__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_431if',$retree) }
sub terminator__S_431if {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(if);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_431if",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('if'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_432unless (  :$sym is context<rw> = <unless> --> Terminator)
##      token terminator:sym<unless> ( --> Terminator)
##          { 'unless'  <.nofun> }

sub terminator__S_432unless__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_432unless',$retree) }
sub terminator__S_432unless {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(unless);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_432unless",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('unless'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_433while (  :$sym is context<rw> = <while> --> Terminator)
##      token terminator:sym<while> ( --> Terminator)
##          { 'while'  <.nofun> }

sub terminator__S_433while__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_433while',$retree) }
sub terminator__S_433while {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(while);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_433while",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('while'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_434until (  :$sym is context<rw> = <until> --> Terminator)
##      token terminator:sym<until> ( --> Terminator)
##          { 'until'  <.nofun> }

sub terminator__S_434until__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_434until',$retree) }
sub terminator__S_434until {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(until);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_434until",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('until'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_435for (  :$sym is context<rw> = <for> --> Terminator)
##      token terminator:sym<for> ( --> Terminator)
##          { 'for'  <.nofun> }

sub terminator__S_435for__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_435for',$retree) }
sub terminator__S_435for {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(for);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_435for",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('for'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_436given (  :$sym is context<rw> = <given> --> Terminator)
##      token terminator:sym<given> ( --> Terminator)
##          { 'given'  <.nofun> }

sub terminator__S_436given__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_436given',$retree) }
sub terminator__S_436given {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(given);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_436given",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('given'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_437when (  :$sym is context<rw> = <when> --> Terminator)
##      token terminator:sym<when> ( --> Terminator)
##          { 'when'  <.nofun> }

sub terminator__S_437when__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_437when',$retree) }
sub terminator__S_437when {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(when);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_437when",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('when'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_438MinusMinusGt (  :$sym is context<rw> =  -->  --> Terminator)
##      token terminator:sym -->  ( --> Terminator)
##          { '-->' {*} }

sub terminator__S_438MinusMinusGt__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_438MinusMinusGt',$retree) }
sub terminator__S_438MinusMinusGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['-->'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_438MinusMinusGt",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('-->'))) {
$C->_REDUCE($S, 'terminator__S_438MinusMinusGt');
}
else {
();
}
}
);
}              #'

## token terminator__S_439Thesis (  :$sym is context<rw> = <)> --> Terminator)
##      token terminator:sym<)> ( --> Terminator)
##          { <sym> }

sub terminator__S_439Thesis__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_439Thesis',$retree) }
sub terminator__S_439Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_439Thesis",  map { STD::Terminator->coerce($_) } 
$C->_PATTERN(qr/\G\)/)
);
}

## token terminator__S_440Ket (  :$sym is context<rw> = <]> --> Terminator)
##      token terminator:sym<]> ( --> Terminator)
##          { ']' }

sub terminator__S_440Ket__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_440Ket',$retree) }
sub terminator__S_440Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(]);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_440Ket",  map { STD::Terminator->coerce($_) } 
$C->_EXACT(']')
);
}

## token terminator__S_441Ly (  :$sym is context<rw> = <}> --> Terminator)
##      token terminator:sym<}> ( --> Terminator)
##          { '}' }

sub terminator__S_441Ly__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_441Ly',$retree) }
sub terminator__S_441Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(});


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_441Ly",  map { STD::Terminator->coerce($_) } 
$C->_EXACT('}')
);
}

## token terminator__S_442BangBang (  :$sym is context<rw> = <!!> --> Terminator)
##      token terminator:sym<!!> ( --> Terminator)
##          { '!!' <?{ $*GOAL eq '!!' }> }

sub terminator__S_442BangBang__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_442BangBang',$retree) }
sub terminator__S_442BangBang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_442BangBang",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('!!'))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
});
}
else {
();
}
}
);
}

# disallow &[] and such as infix
# token infix:sigil ( --> Term )
#     { <sigil><-[&]> <.worry: "Sigiled form not allowed where infix expected"> <!> }

## regex infixstopper
##      regex infixstopper {
##          :dba('infix stopper')
##          [
##          | <?before <stopper> >
##          | <?before '!!' > <?{ $*GOAL eq '!!' }>
##          | <?before '{' | <lambda> > <?{ ($*GOAL eq '{' or $*GOAL eq 'endargs') and @*MEMOS[$.pos]<ws> }>
##          | <?{ $*GOAL eq 'endargs' and @*MEMOS[$.pos]<endargs> }>
##          ]
##      }

sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper',$retree) }
sub infixstopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "infixstopper", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_01') {
$C->deb("Fate passed to infixstopper_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
})
}, $C->before(sub { my $C=shift;
$C->_EXACT('!!')
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
($::GOAL eq '{' or $::GOAL eq 'endargs') and $::MEMOS[$C->{'_pos'}]{'ws'} 
})
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_04') {
$C->deb("Fate passed to infixstopper_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixstopper_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_SUBSUME(['lambda'], sub {
my $C = shift;
$C->lambda
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq 'endargs' and $::MEMOS[$C->{'_pos'}]{'endargs'} 
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# overridden in subgrammars
## token stopper
##      token stopper { <!> }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

# hopefully we can include these tokens in any outer LTM matcher
## regex stdstopper
##      regex stdstopper {
##          :my @stub = return self if @*MEMOS[self.pos]<endstmt> :exists;
##          :dba('standard stopper')
##          [
##          | <?terminator>
##          | <?unitstopper>
##          | $                                 # unlikely, check last (normal LTM behavior)
##          ]
##          { @*MEMOS[$.pos]<endstmt> ||= 1; }
##      }

sub stdstopper__PEEK { $_[0]->_AUTOLEXpeek('stdstopper',$retree) }
sub stdstopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $::MEMOS[$self->{'_pos'}]{'endstmt'};


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "stdstopper", 
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} ||= 1; 
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'stdstopper_01') {
$C->deb("Fate passed to stdstopper_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'stdstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("stdstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->terminator
})
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->unitstopper
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

# A fairly complete operator precedence parser

## method EXPR ($preclvl)
sub EXPR {
my $self = shift;
my $preclvl = shift;


local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
if ($self->peek) {
return $self->_AUTOLEXpeek('EXPR');
}
my $preclim = $preclvl ? $preclvl->{'prec'} // $LOOSEST : $LOOSEST;
local $::SIGIL = '';
my @termstack;
my @opstack;
my $termish = 'termish';

push @opstack, { 'O' => \%terminator, 'sym' => '' };         # (just a sentinel value)

my $here = $self;
my $S = $here->{'_pos'};
$self->deb("In EXPR, at $S") if $::DEBUG & DEBUG::EXPR;

my $reduce = sub {
$self->deb("entering reduce, termstack == ", 0+@termstack, " opstack == ", 0+@opstack) if $::DEBUG & DEBUG::EXPR;
my $op = pop @opstack;
my $sym = $op->{'sym'};
given ($op->{'O'}{'assoc'} // 'unary') {
when ('chain') {
$self->deb("reducing chain") if $::DEBUG & DEBUG::EXPR;
my @chain;
push @chain, pop(@termstack);
push @chain, $op;
while (@opstack) {
last if $op->{'O'}{'prec'} ne $opstack[-1]{'O'}{'prec'};
push @chain, pop(@termstack);
push @chain, pop(@opstack);
}
push @chain, pop(@termstack);
my $endpos = $chain[0]{'_pos'};
@chain = reverse @chain if @chain > 1;
my $startpos = $chain[0]{'_from'};
my $nop = $op->cursor_fresh();
$nop->{'chain'} = [@chain];
$nop->{'_arity'} = 'CHAIN';
$nop->{'_from'} = $startpos;
$nop->{'_pos'} = $endpos;
$nop->{'~CAPS'} = \@chain;
push @termstack, $nop->_REDUCE($startpos, 'CHAIN');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
when ('list') {
$self->deb("reducing list") if $::DEBUG & DEBUG::EXPR;
my @list;
my @delims = $op;
push @list, pop(@termstack);
while (@opstack) {
$self->deb($sym . " vs " . $opstack[-1]{'sym'}) if $::DEBUG & DEBUG::EXPR;
last if $sym ne $opstack[-1]{'sym'};
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
else {
$self->worry("Missing term in " . $sym . " list");
}
push @delims, pop(@opstack);
}
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
else {
$self->worry("Missing final term in '" . $sym . "' list");
}
my $endpos = $list[0]{'_pos'};
@list = reverse @list if @list > 1;
my $startpos = $list[0]{'_from'};
@delims = reverse @delims if @delims > 1;
my $nop = $op->cursor_fresh();
$nop->{'sym'} = $sym;
$nop->{'O'} = $op->{'O'};
$nop->{'list'} = [@list];
$nop->{'delims'} = [@delims];
$nop->{'_arity'} = 'LIST';
$nop->{'_from'} = $startpos;
$nop->{'_pos'} = $endpos;
if (@list) {
my @caps;
push @caps, $list[0]->caps if $list[0];
for (0..@delims-1) {
my $d = $delims[$_];
my $l = $list[$_+1];
push @caps, $d;
push @caps, $l;  # nullterm?
}
$nop->{'~CAPS'} = \@caps;
}
push @termstack, $nop->_REDUCE($startpos, 'LIST');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
when ('unary') {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
my $nop = $op->cursor_fresh();
my $arg = pop @termstack;
$op->{'arg'} = $arg;
my $a = $op->{'~CAPS'};
$op->{'_arity'} = 'UNARY';
if ($arg->{'_from'} < $op->{'_from'}) { # postfix
$op->{'_from'} = $arg->{'_from'};   # extend from to include arg
#                    warn "OOPS ", $arg.Str, "\n" if @acaps > 1;
unshift @$a, $arg;
push @termstack, $op->_REDUCE($op->{'_from'}, 'POSTFIX');
}
elsif ($arg->{'_pos'} > $op->{'_pos'}) {   # prefix
$op->{'_pos'} = $arg->{'_pos'};     # extend pos to include arg
#                    warn "OOPS ", $arg.Str, "\n" if @acaps > 1;
push @$a, $arg;
push @termstack, $op->_REDUCE($op->{'_from'}, 'PREFIX');
}
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
default {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

my $right = pop @termstack;
my $left = pop @termstack;
$op->{'right'} = $right;
$op->{'left'} = $left;
$op->{'_from'} = $left->{'_from'};
$op->{'_pos'} = $right->{'_pos'};
$op->{'_arity'} = 'BINARY';

my $a = $op->{'~CAPS'};
unshift @$a, $left;
push @$a, $right;

$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
push @termstack, $op->_REDUCE($op->{'_from'}, 'INFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
}
};

TERM:
for (;;) {
$self->deb("In loop, at ", $here->{'_pos'}) if $::DEBUG & DEBUG::EXPR;
my $oldpos = $here->{'_pos'};
$here = $here->cursor_fresh();
$::SIGIL = $opstack[-1]{'O'}{'prec'} gt $item_assignment_prec ? '@' : '';
my @t = $here->$termish;

if (not @t or not $here = $t[0] or ($here->{'_pos'} == $oldpos and $termish eq 'termish')) {
return ();
# $here.panic("Failed to parse a required term");
}
$termish = 'termish';
my $PRE = delete $here->{'PRE'} // [];
my $POST = delete $here->{'POST'} // [];
my @PRE = @$PRE;
my @POST = reverse @$POST;

# interleave prefix and postfix, pretend they're infixish
my $M = $here;

# note that we push loose stuff onto opstack before tight stuff
while (@PRE and @POST) {
my $postO = $POST[0]{'O'};
my $preO = $PRE[0]{'O'};
if ($postO->{'prec'} lt $preO->{'prec'}) {
push @opstack, shift @POST;
}
elsif ($postO->{'prec'} gt $preO->{'prec'}) {
push @opstack, shift @PRE;
}
elsif ($postO->{'uassoc'} eq 'left') {
push @opstack, shift @POST;
}
elsif ($postO->{'uassoc'} eq 'right') {
push @opstack, shift @PRE;
}
else {
$here->panic('"' . $PRE[0]{'sym'} . '" and "' . $POST[0]{'sym'} . '" are not associative');
}
}
push @opstack, @PRE,@POST;

push @termstack, $here->{'noun'};
delete $termstack[-1]->{'POST'};
$self->deb("after push: " . (0+@termstack)) if $::DEBUG & DEBUG::EXPR;

last TERM if $preclim eq $methodcall_prec; # in interpolation, probably

for (;;) {     # while we see adverbs
$oldpos = $here->{'_pos'};
last TERM if ($::MEMOS[$oldpos]{'endstmt'} // 0) == 2;
$here = $here->cursor_fresh->ws;
my @infix = $here->cursor_fresh->infixish();
last TERM unless @infix;
my $infix = $infix[0];
last TERM unless $infix->{'_pos'} > $oldpos;

if (not $infix->{'sym'}) {
die $infix->dump if $::DEBUG & DEBUG::EXPR;
}

my $inO = $infix->{'O'};
my $inprec = $inO->{'prec'};
if (not defined $inprec) {
$self->deb("No prec given in infix!") if $::DEBUG & DEBUG::EXPR;
die $infix->dump if $::DEBUG & DEBUG::EXPR;
$inprec = $terminator{'prec'};
}

if ($inprec le $preclim) {
if ($preclim ne $LOOSEST) {
my $dba = $preclvl->{'dba'};
my $h = $::HIGHEXPECT;
my $k = 'infix or meta-infix';
delete $h->{$k};
$h->{"infix or meta-infix (with precedence tighter than $dba)"} = 1;
}
last TERM;
}

$here = $infix->cursor_fresh->ws();

# substitute precedence for listops
$inO->{'prec'} = $inO->{'sub'} if $inO->{'sub'};

# Does new infix (or terminator) force any reductions?
while ($opstack[-1]{'O'}{'prec'} gt $inprec) {
$reduce->();
}

# Not much point in reducing the sentinels...
last if $inprec lt $LOOSEST;

if ($infix->{'fake'}) {
push @opstack, $infix;
$reduce->();
next;  # not really an infix, so keep trying
}

# Equal precedence, so use associativity to decide.
if ($opstack[-1]{'O'}{'prec'} eq $inprec) {
given ($inO->{'assoc'}) {
when ('non')   { $here->panic('"' . $infix->Str . '" is not associative') }
when ('left')  { $reduce->() }   # reduce immediately
when ('right') { }            # just shift
when ('chain') { }            # just shift
when ('unary') { }            # just shift
when ('list')  {              # if op differs reduce else shift
# &reduce() if $infix<sym> !eqv @opstack[*-1]<sym>;
}
default { $here->panic('Unknown associativity "' . $_ . '" for "' . $infix->{'sym'} . '"') }
}
}

$termish = $inO->{'nextterm'} if $inO->{'nextterm'};
push @opstack, $infix;              # The Shift
last;
}
}
$reduce->() while 0+@opstack > 1;
if (@termstack) {
0+@termstack == 1 or $here->panic("Internal operator parser error, termstack == " . (0+@termstack));
$termstack[0]{'_from'} = $self->{'_pos'};
$termstack[0]{'_pos'} = $here->{'_pos'};
}
$self->_MATCHIFYr($S, "EXPR", @termstack);
}

#################################################
## Regex
#################################################

{ package STD::Regex;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'Perl5' or $k eq 'P5') {
my $P5 = $v;  $self->cursor_fresh( $::LANG{'Q'} )->mixin( 'STD::Q::q' )->mixin( 'STD::Q::p5' ) }
elsif ($k eq 'overlap' or $k eq 'ov') {
my $ov = $v;  $self }
elsif ($k eq 'exhaustive' or $k eq 'ex') {
my $ex = $v;  $self }
elsif ($k eq 'continue' or $k eq 'c') {
my $c = $v;  $self }
elsif ($k eq 'pos' or $k eq 'p') {
my $p = $v;  $self }
elsif ($k eq 'sigspace' or $k eq 's') {
my $s = $v;  $self }
elsif ($k eq 'ratchet' or $k eq 'r') {
my $r = $v;  $self }
elsif ($k eq 'global' or $k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'ignorecase' or $k eq 'i') {
my $i = $v;  $self }
elsif ($k eq 'ignoreaccent' or $k eq 'a') {
my $a = $v;  $self }
elsif ($k eq 'samecase' or $k eq 'ii') {
my $ii = $v;  $self }
elsif ($k eq 'sameaccent' or $k eq 'aa') {
my $aa = $v;  $self }
elsif ($k eq 'nth') {
my $nth = $v;  $self }
elsif ($k eq 'st' or $k eq 'nd') {
my $nd = $v;  $self }
elsif ($k eq 'rd' or $k eq 'th') {
my $th = $v;  $self }
elsif ($k eq 'x') {
my $x = $v;  $self }
elsif ($k eq 'bytes') {
my $bytes = $v;  $self }
elsif ($k eq 'codes') {
my $codes = $v;  $self }
elsif ($k eq 'graphs') {
my $graphs = $v;  $self }
elsif ($k eq 'chars') {
my $chars = $v;  $self }
elsif ($k eq 'rw') {
my $rw = $v;  $self }
elsif ($k eq 'keepall') {
my $keepall = $v;  $self }
elsif ($k eq 'panic') {
my $panic = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks

##     token category__S_443metachar (:$sym is context<rw> = 'metachar')
##          token category:metachar { <sym> }

sub category__S_443metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_443metachar',$retree) }
sub category__S_443metachar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'metachar';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_443metachar", 
$C->_PATTERN(qr/\Gmetachar/)
);
}
#proto token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "metachar", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_444backslash (:$sym is context<rw> = 'backslash')
##          token category:backslash { <sym> }

sub category__S_444backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_444backslash',$retree) }
sub category__S_444backslash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'backslash';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_444backslash", 
$C->_PATTERN(qr/\Gbackslash/)
);
}
#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_445assertion (:$sym is context<rw> = 'assertion')
##          token category:assertion { <sym> }

sub category__S_445assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_445assertion',$retree) }
sub category__S_445assertion {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'assertion';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_445assertion", 
$C->_PATTERN(qr/\Gassertion/)
);
}
#proto token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "assertion", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_446quantifier (:$sym is context<rw> = 'quantifier')
##          token category:quantifier { <sym> }

sub category__S_446quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_446quantifier',$retree) }
sub category__S_446quantifier {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quantifier';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_446quantifier", 
$C->_PATTERN(qr/\Gquantifier/)
);
}
#proto token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quantifier", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_447mod_internal (:$sym is context<rw> = 'mod_internal')
##          token category:mod_internal { <sym> }

sub category__S_447mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_447mod_internal',$retree) }
sub category__S_447mod_internal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod_internal';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_447mod_internal", 
$C->_PATTERN(qr/\Gmod_internal/)
);
}
#proto token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "mod_internal", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


#proto token rxinfix { <...> }
sub rxinfix__PEEK { $_[0]->_AUTOLEXpeek('rxinfix:*',$retree); }
sub rxinfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'rxinfix') {
$C->deb("Fate passed to rxinfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'rxinfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("rxinfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "rxinfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token ws
##          token ws {
##              <?{ $*sigspace }>
##              || [ <?before \s | '#'> <.nextsame> ]?   # still get all the pod goodness, hopefully
##          }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
my @origargs = @_;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "ws", 
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$::sigspace 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_03') {
$C->deb("Fate passed to ws_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'ws_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$self->SUPER::ws(@origargs);
}
else {
();
}
}
})
})} or do { die $@ if $@ };
@gather;
}
);
}

##     token normspace
##          token normspace {
##              <?before \s | '#'> [ :lang($.cursor_fresh(%*LANG<MAIN>)) <.ws> ]
##          }

sub normspace__PEEK { $_[0]->_AUTOLEXpeek('normspace',$retree) }
sub normspace {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "normspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'normspace_01') {
$C->deb("Fate passed to normspace_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'normspace_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("normspace_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->ws
});
}
else {
();
}
}
);
}

# suppress fancy end-of-line checking
##     token codeblock
##          token codeblock {
##              :my $GOAL is context = '}';
##              '{' :: [ :lang($.cursor_fresh(%*LANG<MAIN>)) <statementlist> ]
##              [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
##          }

sub codeblock__PEEK { $_[0]->_AUTOLEXpeek('codeblock',$retree) }
sub codeblock {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL = '}';


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "codeblock", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse statement list; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
);
}

##     rule nibbler
##          rule nibbler {
##              :my $sigspace    is context<rw> = $*sigspace    // 0;
##              :my $ratchet     is context<rw> = $*ratchet     // 0;
##              :my $ignorecase is context<rw> = $*ignorecase // 0;
##              :my $ignoreaccent    is context<rw> = $*ignoreaccent    // 0;
##              [ \s* < || | && & > ]?
##              <EXPR>
##          }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::sigspace = $::sigspace    // 0;
local $::ratchet = $::ratchet     // 0;
local $::ignorecase = $::ignorecase // 0;
local $::ignoreaccent = $::ignoreaccent    // 0;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_ARRAY( qw< || | && & > ))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token termish
##          token termish {
##              <.ws>
##              <noun=quantified_atom>+
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quantified_atom'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->ws)) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['noun','quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
});
}
else {
();
}
}
);
}
##     token infixish
##          token infixish {
##              <!infixstopper>
##              <!stdstopper>
##              <rxinfix>
##              {
##                  $<O> = $<rxinfix><O>;
##                  $<sym> = $<rxinfix><sym>;
##              }
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rxinfix'], sub {
my $C = shift;
$C->rxinfix
}))) {
scalar(do {
my $M = $C; 
$M->{'O'} = $M->{'rxinfix'}{'O'};
$M->{'sym'} = $M->{'rxinfix'}{'sym'};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token rxinfix__S_448VertVert (  :$sym is context<rw> = <||> --> Tight_or )
##          token rxinfix:sym<||> ( --> Tight_or ) { <sym> }

sub rxinfix__S_448VertVert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_448VertVert',$retree) }
sub rxinfix__S_448VertVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_448VertVert",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\|\|/)
);
}
##     token rxinfix__S_449AmpAmp (  :$sym is context<rw> = <&&> --> Tight_and )
##          token rxinfix:sym<&&> ( --> Tight_and ) { <sym> }

sub rxinfix__S_449AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_449AmpAmp',$retree) }
sub rxinfix__S_449AmpAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_449AmpAmp",  map { STD::Tight_and->coerce($_) } 
$C->_PATTERN(qr/\G\&\&/)
);
}
##     token rxinfix__S_450Vert (  :$sym is context<rw> = <|> --> Junctive_or )
##          token rxinfix:sym<|> ( --> Junctive_or ) { <sym> }

sub rxinfix__S_450Vert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_450Vert',$retree) }
sub rxinfix__S_450Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_450Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}
##     token rxinfix__S_451Amp (  :$sym is context<rw> = <&> --> Junctive_and )
##          token rxinfix:sym<&> ( --> Junctive_and ) { <sym> }

sub rxinfix__S_451Amp__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_451Amp',$retree) }
sub rxinfix__S_451Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_451Amp",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\G\&/)
);
}
##     token rxinfix__S_452Tilde (  :$sym is context<rw> = <~> --> Additive )
##          token rxinfix:sym<~> ( --> Additive ) { <sym> }

sub rxinfix__S_452Tilde__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_452Tilde',$retree) }
sub rxinfix__S_452Tilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_452Tilde",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}

##     token quantified_atom
##          token quantified_atom {
##              <!stopper>
##              <!rxinfix>
##              <atom>
##              <.ws>
##              [ <quantifier> <.ws> ]?
##      #            <?{ $<atom>.max_width }>
##      #                || <.panic: "Can't quantify zero-width atom">
##          }

sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom',$retree) }
sub quantified_atom {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quantifier'} = [];

$self->_MATCHIFYr($S, "quantified_atom", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->rxinfix
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->ws;
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token atom
##          token atom {
##              :dba('regex atom')
##              [
##              | \w
##              | <metachar> ::
##              | <.panic: "Unrecognized regex metacharacter">
##              ]
##          }

sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom',$retree) }
sub atom {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "atom", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'atom_01') {
$C->deb("Fate passed to atom_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'atom_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("atom_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_COMMITBRANCH()
}, $C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
}))
},
sub { my $C=shift;
$C->panic("Unrecognized regex metacharacter")
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# sequence stoppers
##     token metachar__S_453Gt (:$sym is context<rw> =  > )
##          token metachar:sym >  { '>'  :: <fail> }

sub metachar__S_453Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_453Gt',$retree) }
sub metachar__S_453Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_453Gt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('>'))
);
}
##     token metachar__S_454AmpAmp (:$sym is context<rw> = <&&>)
##          token metachar:sym<&&>  { '&&' :: <fail> }

sub metachar__S_454AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_454AmpAmp',$retree) }
sub metachar__S_454AmpAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_454AmpAmp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('&&'))
);
}
##     token metachar__S_455Amp (:$sym is context<rw> = <&>)
##          token metachar:sym<&>   { '&'  :: <fail> }

sub metachar__S_455Amp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_455Amp',$retree) }
sub metachar__S_455Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_455Amp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('&'))
);
}
##     token metachar__S_456VertVert (:$sym is context<rw> = <||>)
##          token metachar:sym<||>  { '||' :: <fail> }

sub metachar__S_456VertVert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_456VertVert',$retree) }
sub metachar__S_456VertVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_456VertVert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('||'))
);
}
##     token metachar__S_457Vert (:$sym is context<rw> = <|>)
##          token metachar:sym<|>   { '|'  :: <fail> }

sub metachar__S_457Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_457Vert',$retree) }
sub metachar__S_457Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_457Vert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('|'))
);
}
##     token metachar__S_458Ket (:$sym is context<rw> = <]>)
##          token metachar:sym<]>   { ']'  :: <fail> }

sub metachar__S_458Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_458Ket',$retree) }
sub metachar__S_458Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(]);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_458Ket", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(']'))
);
}
##     token metachar__S_459Thesis (:$sym is context<rw> = <)>)
##          token metachar:sym<)>   { ')'  :: <fail> }

sub metachar__S_459Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_459Thesis',$retree) }
sub metachar__S_459Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_459Thesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(')'))
);
}

##     token metachar__S_460quant (:$sym is context<rw> = 'quant')
##          token metachar:quant { <quantifier> <.panic: "quantifier quantifies nothing"> }

sub metachar__S_460quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_460quant',$retree) }
sub metachar__S_460quant {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quant';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_460quant", 
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->panic("quantifier quantifies nothing");
}
else {
();
}
}
);
}

# "normal" metachars

##     token metachar__S_461sigwhite (:$sym is context<rw> = 'sigwhite')
##          token metachar:sigwhite {
##              <normspace>
##          }

sub metachar__S_461sigwhite__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_461sigwhite',$retree) }
sub metachar__S_461sigwhite {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigwhite';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_461sigwhite", 
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
);
}

##     token metachar__S_462Cur_Ly (:$sym is context<rw> = <{ }>)
##          token metachar:sym<{ }> {
##              <?before '{'>
##              <codeblock>
##              {{ $/<sym> := <{ }> }}
##          }

sub metachar__S_462Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_462Cur_Ly',$retree) }
sub metachar__S_462Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_462Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw({ })] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_463mod (:$sym is context<rw> = 'mod')
##          token metachar:mod {
##              <mod_internal>
##              { $/<sym> := $<mod_internal><sym> }
##          }

sub metachar__S_463mod__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_463mod',$retree) }
sub metachar__S_463mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_463mod", 
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_internal'], sub {
my $C = shift;
$C->mod_internal
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = $M->{'mod_internal'}{'sym'} ;
}, $C);
}
else {
();
}
}
);
}

##     token metachar__S_464Colon (:$sym is context<rw> = <:>)
##          token metachar:sym<:> {
##              <sym>
##          }

sub metachar__S_464Colon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_464Colon',$retree) }
sub metachar__S_464Colon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_464Colon", 
$C->_PATTERN(qr/\G\:/)
);
}

##     token metachar__S_465ColonColon (:$sym is context<rw> = <::>)
##          token metachar:sym<::> {
##              <sym>
##          }

sub metachar__S_465ColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_465ColonColon',$retree) }
sub metachar__S_465ColonColon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_465ColonColon", 
$C->_PATTERN(qr/\G\:\:/)
);
}

##     token metachar__S_466ColonColonColon (:$sym is context<rw> = <:::>)
##          token metachar:sym<:::> {
##              <sym>
##          }

sub metachar__S_466ColonColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_466ColonColonColon',$retree) }
sub metachar__S_466ColonColonColon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:::);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_466ColonColonColon", 
$C->_PATTERN(qr/\G\:\:\:/)
);
}

##     token metachar__S_467Bra_Ket (:$sym is context<rw> = <[ ]>)
##          token metachar:sym<[ ]> {
##              '[' {} [:lang(self.unbalanced(']')) <nibbler>]
##              [ ']' || <.panic: "Unable to parse regex; couldn't find right bracket"> ]
##              { $/<sym> := <[ ]> }
##          }

sub metachar__S_467Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_467Bra_Ket',$retree) }
sub metachar__S_467Bra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_467Bra_Ket", 
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(']'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right bracket")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw([ ])] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_468Paren_Thesis (:$sym is context<rw> = <( )>)
##          token metachar:sym<( )> {
##              '(' {} [:lang(self.unbalanced(')')) <nibbler>]
##              [ ')' || <.panic: "Unable to parse regex; couldn't find right parenthesis"> ]
##              { $/<sym> := <( )> }
##          }

sub metachar__S_468Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_468Paren_Thesis',$retree) }
sub metachar__S_468Paren_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_468Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw[( )]] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_469LtParen (:$sym is context<rw> =  <( )
##          token metachar:sym <(  { '<(' }

sub metachar__S_469LtParen__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_469LtParen',$retree) }
sub metachar__S_469LtParen {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<('];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_469LtParen", 
$C->_EXACT('<(')
);
}
##     token metachar__S_470ThesisGt (:$sym is context<rw> =  )> )
##          token metachar:sym )>  { ')>' }

sub metachar__S_470ThesisGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_470ThesisGt',$retree) }
sub metachar__S_470ThesisGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //[')>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_470ThesisGt", 
$C->_EXACT(')>')
);
}

##     token metachar__S_471LtLt (:$sym is context<rw> =  << )
##          token metachar:sym <<  { '<<' }

sub metachar__S_471LtLt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_471LtLt',$retree) }
sub metachar__S_471LtLt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_471LtLt", 
$C->_EXACT('<<')
);
}
##     token metachar__S_472GtGt (:$sym is context<rw> =  >> )
##          token metachar:sym >>  { '>>' }

sub metachar__S_472GtGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_472GtGt',$retree) }
sub metachar__S_472GtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_472GtGt", 
$C->_EXACT('>>')
);
}
##     token metachar__S_473Fre (:$sym is context<rw> = <  >)
##          token metachar:sym<  > { '' }

sub metachar__S_473Fre__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_473Fre',$retree) }
sub metachar__S_473Fre {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_473Fre", 
$C->_EXACT('')
);
}
##     token metachar__S_474Nch (:$sym is context<rw> = <  >)
##          token metachar:sym<  > { '' }

sub metachar__S_474Nch__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_474Nch',$retree) }
sub metachar__S_474Nch {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_474Nch", 
$C->_EXACT('')
);
}

##     token metachar__S_475qw (:$sym is context<rw> = 'qw')
##          token metachar:qw {
##              <?before '<' \s >  # (note required whitespace)
##              <quote>
##          }

sub metachar__S_475qw__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_475qw',$retree) }
sub metachar__S_475qw {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qw';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_475qw", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('<'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
});
}
else {
();
}
}
);
}

##     token metachar__S_476Lt_Gt (:$sym is context<rw> = < >)
##          token metachar:sym< > {
##              '<' <unsp>? {} <assertion>
##              [ '>' || <.panic: "regex assertion not terminated by angle bracket"> ]
##          }

sub metachar__S_476Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_476Lt_Gt',$retree) }
sub metachar__S_476Lt_Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'unsp'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_476Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("regex assertion not terminated by angle bracket")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_477Back (:$sym is context<rw> = <\\>)
##          token metachar:sym<\\> { <sym> <backslash> }

sub metachar__S_477Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_477Back',$retree) }
sub metachar__S_477Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_477Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##     token metachar__S_478Dot (:$sym is context<rw> = <.>)
##          token metachar:sym<.>  { <sym> }

sub metachar__S_478Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_478Dot',$retree) }
sub metachar__S_478Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_478Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token metachar__S_479CaretCaret (:$sym is context<rw> = <^^>)
##          token metachar:sym<^^> { <sym> }

sub metachar__S_479CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_479CaretCaret',$retree) }
sub metachar__S_479CaretCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_479CaretCaret", 
$C->_PATTERN(qr/\G\^\^/)
);
}
##     token metachar__S_480Caret (:$sym is context<rw> = <^>)
##          token metachar:sym<^>  { <sym> }

sub metachar__S_480Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_480Caret',$retree) }
sub metachar__S_480Caret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_480Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
##     token metachar__S_481DollarDollar (:$sym is context<rw> = <$$>)
##          token metachar:sym<$$> {
##              <sym>
##              [ (\w+) <.obs("\$\$" ~ $0.Str ~ " to deref var inside a regex", "\$(\$" ~ $0.Str ~ ")")> ]?
##          }

sub metachar__S_481DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_481DollarDollar',$retree) }
sub metachar__S_481DollarDollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($$);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'0'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_481DollarDollar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\$/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))) {
$C->obs("\$\$" . $C->{'0'}->Str . " to deref var inside a regex", "\$(\$" . $C->{'0'}->Str . ")");
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}
##     token metachar__S_482Dollar (:$sym is context<rw> = <$>)
##          token metachar:sym<$>  {
##              '$'
##              <?before
##              | \s
##              | '|'
##              | '&'
##              | ')'
##              | ']'
##              | '>'
##              | $
##              | <.stopper>
##              >
##          }

sub metachar__S_482Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_482Dollar',$retree) }
sub metachar__S_482Dollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_482Dollar", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'metachar__S_482Dollar_01') {
$C->deb("Fate passed to metachar__S_482Dollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar__S_482Dollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar__S_482Dollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('|')
},
sub { my $C=shift;
$C->_EXACT('&')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('>')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
sub { my $C=shift;
$C->stopper
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token metachar__S_483Single_Single (:$sym is context<rw> = <' '>)
##          token metachar:sym<' '> { <?before "'"> [:lang($.cursor_fresh(%*LANG<MAIN>)) <quote>] }

sub metachar__S_483Single_Single__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_483Single_Single',$retree) }
sub metachar__S_483Single_Single {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(' ')];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_483Single_Single", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G'/)
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}
##     token metachar__S_484Double_Double (:$sym is context<rw> = <" ">)
##          token metachar:sym<" "> { <?before '"'> [:lang($.cursor_fresh(%*LANG<MAIN>)) <quote>] }

sub metachar__S_484Double_Double__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_484Double_Double',$retree) }
sub metachar__S_484Double_Double {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(" ")];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_484Double_Double", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('"')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}

##     token metachar__S_485var (:$sym is context<rw> = 'var')
##          token metachar:var {
##              <!before '$$'>
##              <?before <sigil>>
##              [:lang($.cursor_fresh(%*LANG<MAIN>)) <variable> <.ws> <.check_variable($<variable>)> ]
##              $<binding> = ( <.ws> '=' <.ws> <quantified_atom> )?
##              { $<sym> = $<variable>.Str; }
##          }

sub metachar__S_485var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_485var',$retree) }
sub metachar__S_485var {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'var';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_485var", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('$$')
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
do {
if (my ($C) = ($C->ws)) {
do { my $M = $C;
$C->check_variable($M->{'variable'})
; };
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['binding'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = $M->{'variable'}->Str; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token backslash__S_486unspace (:$sym is context<rw> = 'unspace')
##          token backslash:unspace { <?before \s> <.SUPER::ws> }

sub backslash__S_486unspace__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_486unspace',$retree) }
sub backslash__S_486unspace {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unspace';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_486unspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
$C->SUPER::ws;
}
else {
();
}
}
);
}

##     token backslash__S_4870 (:$sym is context<rw> = <0>)
##          token backslash:sym<0> { '0' <!before <[0..7]> > }

sub backslash__S_4870__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_4870',$retree) }
sub backslash__S_4870 {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(0);


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "backslash__S_4870", 
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[0-7]/)
})
});
}
else {
();
}
}
);
}

##     token backslash__S_488A (:$sym is context<rw> = 'A')
##          token backslash:A { <sym> <.obs('\\A as beginning-of-string matcher', '^')> }

sub backslash__S_488A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_488A',$retree) }
sub backslash__S_488A {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'A';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_488A", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GA/))) {
$C->obs('\\A as beginning-of-string matcher', '^');
}
else {
();
}
}
);
}
##     token backslash__S_489a (:$sym is context<rw> = 'a')
##          token backslash:a { <sym> <.panic: "\\a is allowed only in strings, not regexes"> }

sub backslash__S_489a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_489a',$retree) }
sub backslash__S_489a {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_489a", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ga/))) {
$C->panic("\\a is allowed only in strings, not regexes");
}
else {
();
}
}
);
}
##     token backslash__S_490b (:$sym is context<rw> = 'b')
##          token backslash:b { :i <sym> }

sub backslash__S_490b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_490b',$retree) }
sub backslash__S_490b {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_490b", 
$C->_PATTERN(qr/\G(?i:b)/)
);
}
##     token backslash__S_491c (:$sym is context<rw> = 'c')
##          token backslash:c { :i <sym> <charspec> }

sub backslash__S_491c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_491c',$retree) }
sub backslash__S_491c {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_491c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:c)/))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
});
}
else {
();
}
}
);
}
##     token backslash__S_492d (:$sym is context<rw> = 'd')
##          token backslash:d { :i <sym> }

sub backslash__S_492d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_492d',$retree) }
sub backslash__S_492d {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'd';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_492d", 
$C->_PATTERN(qr/\G(?i:d)/)
);
}
##     token backslash__S_493e (:$sym is context<rw> = 'e')
##          token backslash:e { :i <sym> }

sub backslash__S_493e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_493e',$retree) }
sub backslash__S_493e {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_493e", 
$C->_PATTERN(qr/\G(?i:e)/)
);
}
##     token backslash__S_494f (:$sym is context<rw> = 'f')
##          token backslash:f { :i <sym> }

sub backslash__S_494f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_494f',$retree) }
sub backslash__S_494f {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_494f", 
$C->_PATTERN(qr/\G(?i:f)/)
);
}
##     token backslash__S_495h (:$sym is context<rw> = 'h')
##          token backslash:h { :i <sym> }

sub backslash__S_495h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_495h',$retree) }
sub backslash__S_495h {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_495h", 
$C->_PATTERN(qr/\G(?i:h)/)
);
}
##     token backslash__S_496n (:$sym is context<rw> = 'n')
##          token backslash:n { :i <sym> }

sub backslash__S_496n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_496n',$retree) }
sub backslash__S_496n {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_496n", 
$C->_PATTERN(qr/\G(?i:n)/)
);
}
##     token backslash__S_497o (:$sym is context<rw> = 'o')
##          token backslash:o { :i <sym> [ <octint> | '[' ~ ']' <octints> ] }

sub backslash__S_497o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_497o',$retree) }
sub backslash__S_497o {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_497o", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_497o_01') {
$C->deb("Fate passed to backslash__S_497o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_497o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_497o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:\])/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'backslash__S_497o')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['octints'], sub {
my $C = shift;
$C->octints
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_PATTERN(qr/\G(?i:\[)/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_PATTERN(qr/\G(?i:o)/))
);
}
##     token backslash__S_498Q (:$sym is context<rw> = 'Q')
##          token backslash:Q { <sym> <.obs('\\Q as quotemeta', 'quotes or literal variable match')> }

sub backslash__S_498Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_498Q',$retree) }
sub backslash__S_498Q {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_498Q", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GQ/))) {
$C->obs('\\Q as quotemeta', 'quotes or literal variable match');
}
else {
();
}
}
);
}
##     token backslash__S_499r (:$sym is context<rw> = 'r')
##          token backslash:r { :i <sym> }

sub backslash__S_499r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_499r',$retree) }
sub backslash__S_499r {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_499r", 
$C->_PATTERN(qr/\G(?i:r)/)
);
}
##     token backslash__S_500s (:$sym is context<rw> = 's')
##          token backslash:s { :i <sym> }

sub backslash__S_500s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_500s',$retree) }
sub backslash__S_500s {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_500s", 
$C->_PATTERN(qr/\G(?i:s)/)
);
}
##     token backslash__S_501t (:$sym is context<rw> = 't')
##          token backslash:t { :i <sym> }

sub backslash__S_501t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_501t',$retree) }
sub backslash__S_501t {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_501t", 
$C->_PATTERN(qr/\G(?i:t)/)
);
}
##     token backslash__S_502v (:$sym is context<rw> = 'v')
##          token backslash:v { :i <sym> }

sub backslash__S_502v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_502v',$retree) }
sub backslash__S_502v {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'v';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_502v", 
$C->_PATTERN(qr/\G(?i:v)/)
);
}
##     token backslash__S_503w (:$sym is context<rw> = 'w')
##          token backslash:w { :i <sym> }

sub backslash__S_503w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_503w',$retree) }
sub backslash__S_503w {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_503w", 
$C->_PATTERN(qr/\G(?i:w)/)
);
}
##     token backslash__S_504x (:$sym is context<rw> = 'x')
##          token backslash:x { :i <sym> [ <hexint> | '[' ~ ']' <hexints> ] }

sub backslash__S_504x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_504x',$retree) }
sub backslash__S_504x {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_504x", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_504x_01') {
$C->deb("Fate passed to backslash__S_504x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_504x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_504x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:\])/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'backslash__S_504x')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['hexints'], sub {
my $C = shift;
$C->hexints
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_PATTERN(qr/\G(?i:\[)/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_PATTERN(qr/\G(?i:x)/))
);
}
##     token backslash__S_505z (:$sym is context<rw> = 'z')
##          token backslash:z { <sym> <.obs('\\z as end-of-string matcher', '$')> }

sub backslash__S_505z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_505z',$retree) }
sub backslash__S_505z {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'z';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_505z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gz/))) {
$C->obs('\\z as end-of-string matcher', '$');
}
else {
();
}
}
);
}
##     token backslash__S_506Z (:$sym is context<rw> = 'Z')
##          token backslash:Z { <sym> <.obs('\\Z as end-of-string matcher', '\\n?$')> }

sub backslash__S_506Z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_506Z',$retree) }
sub backslash__S_506Z {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Z';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_506Z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GZ/))) {
$C->obs('\\Z as end-of-string matcher', '\\n?$');
}
else {
();
}
}
);
}
##     token backslash__S_507misc (:$sym is context<rw> = 'misc')
##          token backslash:misc { $<litchar>=(\W) }

sub backslash__S_507misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_507misc',$retree) }
sub backslash__S_507misc {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_507misc", 
$C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
})
);
}
##     token backslash__S_508oops (:$sym is context<rw> = 'oops')
##          token backslash:oops { <.panic: "Unrecognized regex backslash sequence"> }

sub backslash__S_508oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_508oops',$retree) }
sub backslash__S_508oops {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_508oops", 
$C->panic("Unrecognized regex backslash sequence")
);
}

##     token assertion__S_509DotDotDot (:$sym is context<rw> = <...>)
##          token assertion:sym<...> { <sym> }

sub assertion__S_509DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_509DotDotDot',$retree) }
sub assertion__S_509DotDotDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_509DotDotDot", 
$C->_PATTERN(qr/\G\.\.\./)
);
}
##     token assertion__S_510QuestionQuestionQuestion (:$sym is context<rw> = <???>)
##          token assertion:sym<???> { <sym> }

sub assertion__S_510QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_510QuestionQuestionQuestion',$retree) }
sub assertion__S_510QuestionQuestionQuestion {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(???);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_510QuestionQuestionQuestion", 
$C->_PATTERN(qr/\G\?\?\?/)
);
}
##     token assertion__S_511BangBangBang (:$sym is context<rw> = <!!!>)
##          token assertion:sym<!!!> { <sym> }

sub assertion__S_511BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_511BangBangBang',$retree) }
sub assertion__S_511BangBangBang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_511BangBangBang", 
$C->_PATTERN(qr/\G\!\!\!/)
);
}

##     token assertion__S_512Question (:$sym is context<rw> = <?>)
##          token assertion:sym<?> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_512Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_512Question',$retree) }
sub assertion__S_512Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_512Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_512Question_01') {
$C->deb("Fate passed to assertion__S_512Question_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_512Question_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_512Question_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_513Bang (:$sym is context<rw> = <!>)
##          token assertion:sym<!> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_513Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_513Bang',$retree) }
sub assertion__S_513Bang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_513Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_513Bang_01') {
$C->deb("Fate passed to assertion__S_513Bang_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_513Bang_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_513Bang_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_514Star (:$sym is context<rw> = <*>)
##          token assertion:sym<*> { <sym> [ <?before '>'> | <.ws> <nibbler> ] }

sub assertion__S_514Star__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_514Star',$retree) }
sub assertion__S_514Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_514Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_514Star_01') {
$C->deb("Fate passed to assertion__S_514Star_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_514Star_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_514Star_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_515Cur_Ly (:$sym is context<rw> = <{ }>)
##          token assertion:sym<{ }> { <codeblock> }

sub assertion__S_515Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_515Cur_Ly',$retree) }
sub assertion__S_515Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_515Cur_Ly", 
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
);
}

##     token assertion__S_516variable (:$sym is context<rw> = 'variable')
##          token assertion:variable {
##              <?before <sigil>>  # note: semantics must be determined per-sigil
##              [:lang($.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <variable=EXPR(item %LOOSEST)>]
##          }

sub assertion__S_516variable__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_516variable',$retree) }
sub assertion__S_516variable {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'variable';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_516variable", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;    $C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->EXPR(\%LOOSEST)
})
});
}
else {
();
}
}
);
}

##     token assertion__S_517method (:$sym is context<rw> = 'method')
##          token assertion:method {
##              '.' [
##                  | <?before <alpha> > <assertion>
##                  | [ :lang($.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <dottyop> ]
##                  ]
##          }

sub assertion__S_517method__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_517method',$retree) }
sub assertion__S_517method {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'method';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_517method", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_517method_01') {
$C->deb("Fate passed to assertion__S_517method_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_517method_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_517method_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_518name (:$sym is context<rw> = 'name')
##          token assertion:name { [ :lang($.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <longname> ]
##                                          [
##                                          | <?before '>' >
##                                          | <.ws> <nibbler>
##                                          | '=' <assertion>
##                                          | ':' <.ws>
##                                              [ :lang($.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <arglist> ]
##                                          | '(' {}
##                                              [ :lang($.cursor_fresh(%*LANG<MAIN>)) <arglist> ]
##                                              [ ')' || <.panic: "Assertion call missing right parenthesis"> ]
##                                          ]?
##          }

sub assertion__S_518name__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_518name',$retree) }
sub assertion__S_518name {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'name';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'nibbler'} = [];
$C->{'assertion'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_518name", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_518name_02') {
$C->deb("Fate passed to assertion__S_518name_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_518name_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_518name_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Assertion call missing right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}

##     token assertion__S_519Bra (:$sym is context<rw> = <[>)
##          token assertion:sym<[> { <?before '['> <cclass_elem>+ }

sub assertion__S_519Bra__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_519Bra',$retree) }
sub assertion__S_519Bra {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q([);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_519Bra", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_520Plus (:$sym is context<rw> = <+>)
##          token assertion:sym<+> { <?before '+'> <cclass_elem>+ }

sub assertion__S_520Plus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_520Plus',$retree) }
sub assertion__S_520Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_520Plus", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('+')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_521Minus (:$sym is context<rw> = <->)
##          token assertion:sym<-> { <?before '-'> <cclass_elem>+ }

sub assertion__S_521Minus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_521Minus',$retree) }
sub assertion__S_521Minus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_521Minus", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('-')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_522Dot (:$sym is context<rw> = <.>)
##          token assertion:sym<.> { <sym> }

sub assertion__S_522Dot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_522Dot',$retree) }
sub assertion__S_522Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_522Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token assertion__S_523Comma (:$sym is context<rw> = <,>)
##          token assertion:sym<,> { <sym> }

sub assertion__S_523Comma__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_523Comma',$retree) }
sub assertion__S_523Comma {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[,];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_523Comma", 
$C->_PATTERN(qr/\G\,/)
);
}
##     token assertion__S_524TildeTilde (:$sym is context<rw> = <~~>)
##          token assertion:sym<~~> { <sym> [ <?before '>'> | \d+ | <desigilname> ] }

sub assertion__S_524TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_524TildeTilde',$retree) }
sub assertion__S_524TildeTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_524TildeTilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\~/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_524TildeTilde_01') {
$C->deb("Fate passed to assertion__S_524TildeTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_524TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_524TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_525bogus (:$sym is context<rw> = 'bogus')
##          token assertion:bogus { <.panic: "Unrecognized regex assertion"> }

sub assertion__S_525bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_525bogus',$retree) }
sub assertion__S_525bogus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'bogus';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_525bogus", 
$C->panic("Unrecognized regex assertion")
);
}

##     token sign
##          token sign { '+' | '-' | <?> }

sub sign__PEEK { $_[0]->_AUTOLEXpeek('sign',$retree) }
sub sign {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "sign", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'sign_00') {
$C->deb("Fate passed to sign_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'sign_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sign_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('+')
},
sub { my $C=shift;
$C->_EXACT('-')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}
##     token cclass_elem
##          token cclass_elem {
##              :dba('character class element')
##              <sign>
##              <.normspace>?
##              [
##              | <name>
##              | <before '['> <quibble($.cursor_fresh( %*LANG<Q> ).tweak(:q))> # XXX parse as q[] for now
##              ]
##              <.normspace>?
##          }

sub cclass_elem__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem',$retree) }
sub cclass_elem {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "cclass_elem", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sign'], sub {
my $C = shift;
$C->sign
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->normspace
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'cclass_elem_01') {
$C->deb("Fate passed to cclass_elem_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'cclass_elem_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("cclass_elem_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_OPTr(sub { my $C=shift;
$C->normspace
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_arg
##          token mod_arg { :dba('modifier argument') '(' ~ ')' <semilist> }

sub mod_arg__PEEK { $_[0]->_AUTOLEXpeek('mod_arg',$retree) }
sub mod_arg {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "mod_arg", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'modifier argument')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

##     token mod_internal__S_526Colonmy (:$sym is context<rw> = <:my>)
##          token mod_internal:sym<:my>    { ':' <?before ['my'|'state'|'our'|'constant'] \s > [:lang($.cursor_fresh(%*LANG<MAIN>)) <statement> <eat_terminator> ] }

sub mod_internal__S_526Colonmy__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_526Colonmy',$retree) }
sub mod_internal__S_526Colonmy {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:my);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_526Colonmy", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_526Colonmy_02') {
$C->deb("Fate passed to mod_internal__S_526Colonmy_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_526Colonmy_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_526Colonmy_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('my')
},
sub { my $C=shift;
$C->_EXACT('state')
},
sub { my $C=shift;
$C->_EXACT('our')
},
sub { my $C=shift;
$C->_EXACT('constant')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
});
}
else {
();
}
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_527Colontemp (:$sym is context<rw> = <:temp>)
##          token mod_internal:sym<:temp>    { ':' <?before ['temp'|'let'] \s > [:lang($.cursor_fresh(%*LANG<MAIN>)) <statement> <eat_terminator> ] }

sub mod_internal__S_527Colontemp__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_527Colontemp',$retree) }
sub mod_internal__S_527Colontemp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:temp);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_527Colontemp", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_527Colontemp_02') {
$C->deb("Fate passed to mod_internal__S_527Colontemp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_527Colontemp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_527Colontemp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('temp')
},
sub { my $C=shift;
$C->_EXACT('let')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
});
}
else {
();
}
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX needs some generalization

##     token mod_internal__S_528Coloni (:$sym is context<rw> = <:i>)
##          token mod_internal:sym<:i>    { $<sym>=[':i'|':ignorecase']  { $*ignorecase = 1 } }

sub mod_internal__S_528Coloni__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_528Coloni',$retree) }
sub mod_internal__S_528Coloni {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:i);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_528Coloni", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_528Coloni_01') {
$C->deb("Fate passed to mod_internal__S_528Coloni_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_528Coloni_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_528Coloni_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignorecase = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_529ColonBangi (:$sym is context<rw> = <:!i>)
##          token mod_internal:sym<:!i>   { $<sym>=[':!i'|':!ignorecase']  { $*ignorecase = 0 } }

sub mod_internal__S_529ColonBangi__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_529ColonBangi',$retree) }
sub mod_internal__S_529ColonBangi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!i);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_529ColonBangi", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_529ColonBangi_01') {
$C->deb("Fate passed to mod_internal__S_529ColonBangi_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_529ColonBangi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_529ColonBangi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!i')
},
sub { my $C=shift;
$C->_EXACT(':!ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignorecase = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_530ColoniParen_Thesis (:$sym is context<rw> = <:i( )>)
##          token mod_internal:sym<:i( )> { $<sym>=[':i'|':ignorecase'] <mod_arg> { $*ignorecase = eval $<mod_arg>.Str } }

sub mod_internal__S_530ColoniParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_530ColoniParen_Thesis',$retree) }
sub mod_internal__S_530ColoniParen_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:i( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_530ColoniParen_Thesis", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_530ColoniParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_530ColoniParen_Thesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_530ColoniParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_530ColoniParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ignorecase = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_531Colon0i (:$sym is context<rw> = <:0i>)
##          token mod_internal:sym<:0i>   { ':' (\d+) ['i'|'ignorecase'] { $*ignorecase = $0 } }

sub mod_internal__S_531Colon0i__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_531Colon0i',$retree) }
sub mod_internal__S_531Colon0i {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0i);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_531Colon0i", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_531Colon0i_02') {
$C->deb("Fate passed to mod_internal__S_531Colon0i_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_531Colon0i_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_531Colon0i_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('i')
},
sub { my $C=shift;
$C->_EXACT('ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::ignorecase = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_532Colona (:$sym is context<rw> = <:a>)
##          token mod_internal:sym<:a>    { $<sym>=[':a'|':ignoreaccent']  { $*ignoreaccent = 1 } }

sub mod_internal__S_532Colona__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_532Colona',$retree) }
sub mod_internal__S_532Colona {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:a);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_532Colona", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_532Colona_01') {
$C->deb("Fate passed to mod_internal__S_532Colona_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_532Colona_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_532Colona_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignoreaccent = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_533ColonBanga (:$sym is context<rw> = <:!a>)
##          token mod_internal:sym<:!a>   { $<sym>=[':!a'|':!ignoreaccent']  { $*ignoreaccent = 0 } }

sub mod_internal__S_533ColonBanga__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_533ColonBanga',$retree) }
sub mod_internal__S_533ColonBanga {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!a);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_533ColonBanga", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_533ColonBanga_01') {
$C->deb("Fate passed to mod_internal__S_533ColonBanga_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_533ColonBanga_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_533ColonBanga_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!a')
},
sub { my $C=shift;
$C->_EXACT(':!ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignoreaccent = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_534ColonaParen_Thesis (:$sym is context<rw> = <:a( )>)
##          token mod_internal:sym<:a( )> { $<sym>=[':a'|':ignoreaccent'] <mod_arg> { $*ignoreaccent = eval $<mod_arg>.Str } }

sub mod_internal__S_534ColonaParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_534ColonaParen_Thesis',$retree) }
sub mod_internal__S_534ColonaParen_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:a( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_534ColonaParen_Thesis", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_534ColonaParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_534ColonaParen_Thesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_534ColonaParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_534ColonaParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ignoreaccent = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_535Colon0a (:$sym is context<rw> = <:0a>)
##          token mod_internal:sym<:0a>   { ':' (\d+) ['a'|'ignoreaccent'] { $*ignoreaccent = $0 } }

sub mod_internal__S_535Colon0a__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_535Colon0a',$retree) }
sub mod_internal__S_535Colon0a {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0a);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_535Colon0a", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_535Colon0a_02') {
$C->deb("Fate passed to mod_internal__S_535Colon0a_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_535Colon0a_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_535Colon0a_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('a')
},
sub { my $C=shift;
$C->_EXACT('ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::ignoreaccent = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_536Colons (:$sym is context<rw> = <:s>)
##          token mod_internal:sym<:s>    { ':s' 'igspace'?  { $*sigspace = 1 } }

sub mod_internal__S_536Colons__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_536Colons',$retree) }
sub mod_internal__S_536Colons {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:s);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_536Colons", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_537ColonBangs (:$sym is context<rw> = <:!s>)
##          token mod_internal:sym<:!s>   { ':!s' 'igspace'?  { $*sigspace = 0 } }

sub mod_internal__S_537ColonBangs__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_537ColonBangs',$retree) }
sub mod_internal__S_537ColonBangs {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!s);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_537ColonBangs", 
do {
if (my ($C) = ($C->_EXACT(':!s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_538ColonsParen_Thesis (:$sym is context<rw> = <:s( )>)
##          token mod_internal:sym<:s( )> { ':s' 'igspace'? <mod_arg> { $*sigspace = eval $<mod_arg>.Str } }

sub mod_internal__S_538ColonsParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_538ColonsParen_Thesis',$retree) }
sub mod_internal__S_538ColonsParen_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:s( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_538ColonsParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::sigspace = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_539Colon0s (:$sym is context<rw> = <:0s>)
##          token mod_internal:sym<:0s>   { ':' (\d+) 's' 'igspace'?  { $*sigspace = $0 } }

sub mod_internal__S_539Colon0s__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_539Colon0s',$retree) }
sub mod_internal__S_539Colon0s {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0s);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_539Colon0s", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_540Colonr (:$sym is context<rw> = <:r>)
##          token mod_internal:sym<:r>    { ':r' 'atchet'?  { $*ratchet = 1 } }

sub mod_internal__S_540Colonr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_540Colonr',$retree) }
sub mod_internal__S_540Colonr {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:r);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_540Colonr", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_541ColonBangr (:$sym is context<rw> = <:!r>)
##          token mod_internal:sym<:!r>   { ':!r' 'atchet'?  { $*ratchet = 0 } }

sub mod_internal__S_541ColonBangr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_541ColonBangr',$retree) }
sub mod_internal__S_541ColonBangr {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!r);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_541ColonBangr", 
do {
if (my ($C) = ($C->_EXACT(':!r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_542ColonrParen_Thesis (:$sym is context<rw> = <:r( )>)
##          token mod_internal:sym<:r( )> { ':r' 'atchet'?  <mod_arg> { $*ratchet = eval $<mod_arg>.Str } }

sub mod_internal__S_542ColonrParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_542ColonrParen_Thesis',$retree) }
sub mod_internal__S_542ColonrParen_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:r( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_542ColonrParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ratchet = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_543Colon0r (:$sym is context<rw> = <:0r>)
##          token mod_internal:sym<:0r>   { ':' (\d+) 'r' 'atchet'?  { $*ratchet = $0 } }

sub mod_internal__S_543Colon0r__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_543Colon0r',$retree) }
sub mod_internal__S_543Colon0r {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0r);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_543Colon0r", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_544ColonPerl5 (:$sym is context<rw> = <:Perl5>)
##          token mod_internal:sym<:Perl5>    { [':Perl5' | ':P5'] [ :lang( $.cursor_fresh( %*LANG<P5Regex> ).unbalanced($*GOAL) ) <nibbler> ] }

sub mod_internal__S_544ColonPerl5__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_544ColonPerl5',$retree) }
sub mod_internal__S_544ColonPerl5 {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:Perl5);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_544ColonPerl5", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_544ColonPerl5_01') {
$C->deb("Fate passed to mod_internal__S_544ColonPerl5_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_544ColonPerl5_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_544ColonPerl5_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':Perl5')
},
sub { my $C=shift;
$C->_EXACT(':P5')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) );  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
});
}
else {
();
}
}
);
}

##     token mod_internal__S_545adv (:$sym is context<rw> = 'adv')
##          token mod_internal:adv {
##              <?before ':' <.identifier> > [ :lang($.cursor_fresh(%*LANG<MAIN>)) <quotepair> ] { $/<sym> := : $<quotepair><key> }
##          }

sub mod_internal__S_545adv__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_545adv',$retree) }
sub mod_internal__S_545adv {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'adv';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_545adv", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->identifier;
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
})
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} =[':','$<quotepair><key>'] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_546oops (:$sym is context<rw> = 'oops')
##          token mod_internal:oops { ':'\w+ <.panic: "Unrecognized regex modifier"> }

sub mod_internal__S_546oops__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_546oops',$retree) }
sub mod_internal__S_546oops {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_546oops", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
$C->panic("Unrecognized regex modifier");
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantifier__S_547Star (:$sym is context<rw> = <*>)
##          token quantifier:sym<*>  { <sym> <quantmod> }

sub quantifier__S_547Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_547Star',$retree) }
sub quantifier__S_547Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_547Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_548Plus (:$sym is context<rw> = <+>)
##          token quantifier:sym<+>  { <sym> <quantmod> }

sub quantifier__S_548Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_548Plus',$retree) }
sub quantifier__S_548Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_548Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_549Question (:$sym is context<rw> = <?>)
##          token quantifier:sym<?>  { <sym> <quantmod> }

sub quantifier__S_549Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_549Question',$retree) }
sub quantifier__S_549Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_549Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_550StarStar (:$sym is context<rw> = <**>)
##          token quantifier:sym<**> { <sym> :: <normspace>? <quantmod> <normspace>?
##              [
##              | \d+ [ '..' [ \d+ | '*' ] ]?
##              | <codeblock>
##              | <quantified_atom>
##              ]
##          }

sub quantifier__S_550StarStar__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_550StarStar',$retree) }
sub quantifier__S_550StarStar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'normspace'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "quantifier__S_550StarStar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_550StarStar_01') {
$C->deb("Fate passed to quantifier__S_550StarStar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_550StarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_550StarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_550StarStar_03') {
$C->deb("Fate passed to quantifier__S_550StarStar_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_550StarStar_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_550StarStar_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('..'))
})
})
}, $C->_PATTERN(qr/\G((?:\d)++)/))
},
sub { my $C=shift;
$C->_SUBSUME(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
},
sub { my $C=shift;
$C->_SUBSUME(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
}, $C->_SUBSUME(['quantmod'], sub {
my $C = shift;
$C->quantmod
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\*\*/))
);
}

##     token quantifier__S_551TildeTilde (:$sym is context<rw> = <~~>)
##          token quantifier:sym<~~> {
##              [
##              | '!' <sym>
##              | <sym>
##              ]
##              <normspace> <quantified_atom> }

sub quantifier__S_551TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_551TildeTilde',$retree) }
sub quantifier__S_551TildeTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_551TildeTilde", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_551TildeTilde_01') {
$C->deb("Fate passed to quantifier__S_551TildeTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_551TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_551TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
$C->_PATTERN(qr/\G\~\~/);
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\~\~/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantmod
##          token quantmod { ':'? [ '?' | '!' | '+' ]? }

sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod',$retree) }
sub quantmod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quantmod", 
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantmod_01') {
$C->deb("Fate passed to quantmod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantmod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantmod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('?')
},
sub { my $C=shift;
$C->_EXACT('!')
},
sub { my $C=shift;
$C->_EXACT('+')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
assertion__S_509DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_509DotDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ...
assertion__S_510QuestionQuestionQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_510QuestionQuestionQuestion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ???
assertion__S_511BangBangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_511BangBangBang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!!!"
assertion__S_512Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_512Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_512Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &14 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_512Question_01
          dba: assertion__S_512Question
          i: 0
          min: 0
          name: assertion__S_512Question_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_512Question_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_512Question
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_512Question
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_512Question_01 1
              dba: assertion__S_512Question
              i: 0
              min: 12345
              name: assertion
              r: 1
              rest: ''
              s: 0
assertion__S_512Question_01: *14
assertion__S_513Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_513Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_513Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &2 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_513Bang_01
          dba: assertion__S_513Bang
          i: 0
          min: 0
          name: assertion__S_513Bang_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_513Bang_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_513Bang
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_513Bang
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_513Bang_01 1
              dba: assertion__S_513Bang
              i: 0
              min: 12345
              name: assertion
              r: 1
              rest: ''
              s: 0
assertion__S_513Bang_01: *2
assertion__S_514Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_514Star
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_514Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &12 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_514Star_01
          dba: assertion__S_514Star
          i: 0
          min: 0
          name: assertion__S_514Star_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_514Star_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_514Star
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_514Star
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_514Star_01 1
              dba: assertion__S_514Star
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_514Star
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_514Star
                  i: 0
                  min: 12345
                  name: nibbler
                  r: 1
                  rest: ''
                  s: 0
assertion__S_514Star_01: *12
assertion__S_515Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_515Cur_Ly
    i: 0
    min: 12345
    name: codeblock
    r: 1
    rest: ''
    s: 0
assertion__S_516variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_516variable
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_516variable
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: assertion__S_516variable
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: assertion__S_516variable
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: assertion__S_516variable
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_method 
                min: 0
                name: EXPR
                nobind: 1
                rest: (item %LOOSEST)
              dba: assertion__S_516variable
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
              min: 0
              r: 1
              s: 0
              var: variable
assertion__S_517method: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_517method
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: assertion__S_517method
        i: 0
        min: 1
        r: 1
        s: 0
        text: .
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &17 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_517method_01
          dba: assertion__S_517method
          i: 0
          min: 12345
          name: assertion__S_517method_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_517method_01 0
              dba: assertion__S_517method
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: assertion__S_517method
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 12345
                      re: !!perl/hash:RE_method 
                        a: 0
                        dba: assertion__S_517method
                        i: 0
                        min: 12345
                        name: alpha
                        r: 1
                        rest: ''
                        s: 0
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_517method
                  i: 0
                  min: 12345
                  name: assertion
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_bracket 
              alt: assertion__S_517method_01 1
              decl: []

              min: 12345
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: assertion__S_517method
                i: 0
                lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_decl 
                    a: 0
                    dba: assertion__S_517method
                    i: 0
                    lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                    max: 0
                    min: 0
                    noquant: 1
                    r: 1
                    s: 0
                    text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_517method
                    i: 0
                    lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                    min: 12345
                    name: dottyop
                    r: 1
                    rest: ''
                    s: 0
assertion__S_517method_01: *17
assertion__S_518name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_518name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: assertion__S_518name
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: assertion__S_518name
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: assertion__S_518name
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
              min: 12345
              name: longname
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &1 !!perl/hash:RE_any 
            a: 0
            altname: assertion__S_518name_02
            dba: assertion__S_518name
            i: 0
            min: 0
            name: assertion__S_518name_02
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                alt: assertion__S_518name_02 0
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: assertion__S_518name
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: assertion__S_518name
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ">"
                  s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_518name_02 1
                dba: assertion__S_518name
                i: 0
                min: 24690
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_518name
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_518name
                    i: 0
                    min: 12345
                    name: nibbler
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_518name_02 2
                dba: assertion__S_518name
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_518name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_518name
                    i: 0
                    min: 12345
                    name: assertion
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_518name_02 3
                dba: assertion__S_518name
                i: 0
                min: 24691
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_518name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_518name
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_518name
                      i: 0
                      lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_518name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_518name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_518name_02 4
                dba: assertion__S_518name
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_518name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: (
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: assertion__S_518name
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: ''
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_518name
                      i: 0
                      lang: ($C->cursor_fresh($::LANG{'MAIN'}))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_518name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_518name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 0
                    re: !!perl/hash:RE_first 
                      a: 0
                      dba: assertion__S_518name
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: assertion__S_518name
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Assertion call missing right parenthesis")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
assertion__S_518name_02: *1
assertion__S_519Bra: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_519Bra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_519Bra
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_519Bra
              i: 0
              min: 1
              r: 1
              s: 0
              text: "["
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_519Bra
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_520Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_520Plus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_520Plus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_520Plus
              i: 0
              min: 1
              r: 1
              s: 0
              text: +
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_520Plus
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_521Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_521Minus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_521Minus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_521Minus
              i: 0
              min: 1
              r: 1
              s: 0
              text: "-"
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_521Minus
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_522Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_522Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
assertion__S_523Comma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_523Comma
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ","
assertion__S_524TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_524TildeTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_524TildeTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~~
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &26 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_524TildeTilde_01
          dba: assertion__S_524TildeTilde
          i: 0
          min: 0
          name: assertion__S_524TildeTilde_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_524TildeTilde_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_524TildeTilde
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_524TildeTilde
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_quantified_atom 
              alt: assertion__S_524TildeTilde_01 1
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: assertion__S_524TildeTilde
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_524TildeTilde_01 2
              dba: assertion__S_524TildeTilde
              i: 0
              min: 12345
              name: desigilname
              r: 1
              rest: ''
              s: 0
assertion__S_524TildeTilde_01: *26
assertion__S_525bogus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex assertion")
atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &19 !!perl/hash:RE_any 
      a: 0
      altname: atom_01
      dba: regex atom
      i: 0
      min: 0
      name: atom_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_meta 
          a: 0
          alt: atom_01 0
          dba: regex atom
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        - !!perl/hash:RE_sequence 
          a: 0
          alt: atom_01 1
          dba: regex atom
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: regex atom
              i: 0
              min: 12345
              name: metachar
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_meta 
              a: 0
              dba: regex atom
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
        - !!perl/hash:RE_method 
          alt: atom_01 2
          min: 0
          name: panic
          nobind: 1
          rest: ("Unrecognized regex metacharacter")
atom_01: *19
backslash__S_486unspace: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_486unspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_486unspace
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: backslash__S_486unspace
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_486unspace
        i: 0
        min: 12345
        name: SUPER::ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
backslash__S_4870: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_4870
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_4870
        i: 0
        min: 1
        r: 1
        s: 0
        text: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_4870
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: backslash__S_4870
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[0..7]"
          s: 0
backslash__S_488A: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_488A
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_488A
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: A
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\A as beginning-of-string matcher', '^')
backslash__S_489a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_489a
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_489a
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: a
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("\\a is allowed only in strings, not regexes")
backslash__S_490b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_490b
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_491c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_491c
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_491c
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: c
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_491c
        i: 1
        min: 12345
        name: charspec
        r: 1
        rest: ''
        s: 0
backslash__S_492d: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_492d
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: d
backslash__S_493e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_493e
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_494f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_494f
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_495h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_495h
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
backslash__S_496n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_496n
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_497o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_497o
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_497o
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: o
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &4 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_497o_01
          dba: backslash__S_497o
          i: 1
          min: 12345
          name: backslash__S_497o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_497o_01 0
              dba: backslash__S_497o
              i: 1
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_497o_01 1
              dba: backslash__S_497o
              i: 1
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_497o
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: backslash__S_497o
                  extra: "local $::GOAL = ']' "
                  i: 1
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: backslash__S_497o
                  i: 1
                  min: 12345
                  name: octints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: backslash__S_497o
                    i: 1
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: backslash__S_497o
                        i: 1
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'backslash__S_497o')
backslash__S_497o_01: *4
backslash__S_498Q: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_498Q
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_498Q
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Q
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\Q as quotemeta', 'quotes or literal variable match')
backslash__S_499r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_499r
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_500s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_500s
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
backslash__S_501t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_501t
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_502v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_502v
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: v
backslash__S_503w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_503w
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
backslash__S_504x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_504x
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_504x
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &28 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_504x_01
          dba: backslash__S_504x
          i: 1
          min: 12345
          name: backslash__S_504x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_504x_01 0
              dba: backslash__S_504x
              i: 1
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_504x_01 1
              dba: backslash__S_504x
              i: 1
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_504x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: backslash__S_504x
                  extra: "local $::GOAL = ']' "
                  i: 1
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: backslash__S_504x
                  i: 1
                  min: 12345
                  name: hexints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: backslash__S_504x
                    i: 1
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: backslash__S_504x
                        i: 1
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'backslash__S_504x')
backslash__S_504x_01: *28
backslash__S_505z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_505z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_505z
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: z
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\z as end-of-string matcher', '$')
backslash__S_506Z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_506Z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_506Z
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Z
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\Z as end-of-string matcher', '\\n?$')
backslash__S_507misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_paren 
      decl: []

      min: 1
      nobind: 1
      re: !!perl/hash:RE_meta 
        a: 0
        dba: backslash__S_507misc
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
    dba: backslash__S_507misc
    i: 0
    min: 1
    r: 1
    s: 0
    var: litchar
backslash__S_508oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex backslash sequence")
category__S_443metachar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_443metachar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: metachar
category__S_444backslash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_444backslash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: backslash
category__S_445assertion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_445assertion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: assertion
category__S_446quantifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_446quantifier
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quantifier
category__S_447mod_internal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_447mod_internal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod_internal
cclass_elem: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: character class element
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: character class element
        i: 0
        min: 12345
        name: sign
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: character class element
          i: 0
          min: 12345
          name: normspace
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &25 !!perl/hash:RE_any 
          a: 0
          altname: cclass_elem_01
          dba: character class element
          i: 0
          min: 0
          name: cclass_elem_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: cclass_elem_01 0
              dba: character class element
              i: 0
              min: 12345
              name: name
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: cclass_elem_01 1
              dba: character class element
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method_re 
                  a: 0
                  dba: character class element
                  i: 0
                  min: 0
                  name: before
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: character class element
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q))
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: character class element
          i: 0
          min: 12345
          name: normspace
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
cclass_elem_01: *25
codeblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: codeblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codeblock
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codeblock
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: codeblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: codeblock
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: statementlist
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: codeblock
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: codeblock
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse statement list; couldn't find right brace")
infixish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infixish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: rxinfix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infixish
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n            $<O> = $<rxinfix><O>;\n            $<sym> = $<rxinfix><sym>;\n        "
metachar__S_453Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_453Gt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_453Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: ">"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_453Gt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_453Gt
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_454AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_454AmpAmp
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_454AmpAmp
        i: 0
        min: 2
        r: 1
        s: 0
        text: "&&"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_454AmpAmp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_454AmpAmp
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_455Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_455Amp
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_455Amp
        i: 0
        min: 1
        r: 1
        s: 0
        text: "&"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_455Amp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_455Amp
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_456VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_456VertVert
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_456VertVert
        i: 0
        min: 2
        r: 1
        s: 0
        text: "||"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_456VertVert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_456VertVert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_457Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_457Vert
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_457Vert
        i: 0
        min: 1
        r: 1
        s: 0
        text: "|"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_457Vert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_457Vert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_458Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_458Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_458Ket
        i: 0
        min: 1
        r: 1
        s: 0
        text: "]"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_458Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_458Ket
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_459Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_459Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_459Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: )
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_459Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_459Thesis
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_460quant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_460quant
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_460quant
        i: 0
        min: 12345
        name: quantifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("quantifier quantifies nothing")
metachar__S_461sigwhite: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_461sigwhite
    i: 0
    min: 12345
    name: normspace
    r: 1
    rest: ''
    s: 0
metachar__S_462Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_462Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_462Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_462Cur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_462Cur_Ly
        i: 0
        min: 12345
        name: codeblock
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_462Cur_Ly
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <{ }> "
metachar__S_463mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_463mod
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_463mod
        i: 0
        min: 12345
        name: mod_internal
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_463mod
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := $<mod_internal><sym> "
metachar__S_464Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_464Colon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ":"
metachar__S_465ColonColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_465ColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "::"
metachar__S_466ColonColonColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_466ColonColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ":::"
metachar__S_467Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_467Bra_Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_467Bra_Ket
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_467Bra_Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_467Bra_Ket
          i: 0
          lang: ($self->unbalanced(']'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_467Bra_Ket
              i: 0
              lang: ($self->unbalanced(']'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(']'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_467Bra_Ket
              i: 0
              lang: ($self->unbalanced(']'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_467Bra_Ket
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_467Bra_Ket
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right bracket")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_467Bra_Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <[ ]> "
metachar__S_468Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_468Paren_Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_468Paren_Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_468Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_468Paren_Thesis
          i: 0
          lang: ($self->unbalanced(')'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_468Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_468Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_468Paren_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_468Paren_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right parenthesis")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_468Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <( )> "
metachar__S_469LtParen: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_469LtParen
    i: 0
    min: 2
    r: 1
    s: 0
    text: <(
metachar__S_470ThesisGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_470ThesisGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: )>
metachar__S_471LtLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_471LtLt
    i: 0
    min: 2
    r: 1
    s: 0
    text: <<
metachar__S_472GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_472GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: ">>"
metachar__S_473Fre: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_473Fre
    i: 0
    min: 1
    r: 1
    s: 0
    text: 
metachar__S_474Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_474Nch
    i: 0
    min: 1
    r: 1
    s: 0
    text: 
metachar__S_475qw: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_475qw
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_475qw
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_475qw
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: metachar__S_475qw
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: <
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: metachar__S_475qw
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_475qw
        i: 0
        min: 12345
        name: quote
        r: 1
        rest: ''
        s: 0
metachar__S_476Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_476Lt_Gt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_476Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: metachar__S_476Lt_Gt
          i: 0
          min: 12345
          name: unsp
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_476Lt_Gt
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_476Lt_Gt
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_476Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_476Lt_Gt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("regex assertion not terminated by angle bracket")
metachar__S_477Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_477Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_477Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_477Back
        i: 0
        min: 12345
        name: backslash
        r: 1
        rest: ''
        s: 0
metachar__S_478Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_478Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
metachar__S_479CaretCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_479CaretCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^^"
metachar__S_480Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_480Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
metachar__S_481DollarDollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_481DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_481DollarDollar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $$
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: metachar__S_481DollarDollar
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_meta 
                      a: 0
                      dba: metachar__S_481DollarDollar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \w
                    min: 1
                    quant: 
                      - +
                      - ":"
                      - ''
                      - 1
                min: 1
                var: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ("\$\$" ~ $0.Str ~ " to deref var inside a regex", "\$(\$" ~ $0.Str ~ ")")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
metachar__S_482Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_482Dollar
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_482Dollar
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_482Dollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: &22 !!perl/hash:RE_any 
              a: 0
              altname: metachar__S_482Dollar_01
              dba: metachar__S_482Dollar
              i: 0
              min: 0
              name: metachar__S_482Dollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_482Dollar_01 0
                  dba: metachar__S_482Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_482Dollar_01 1
                  dba: metachar__S_482Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "|"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_482Dollar_01 2
                  dba: metachar__S_482Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "&"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_482Dollar_01 3
                  dba: metachar__S_482Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: )
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_482Dollar_01 4
                  dba: metachar__S_482Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_482Dollar_01 5
                  dba: metachar__S_482Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_482Dollar_01 6
                  dba: metachar__S_482Dollar
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $
                - !!perl/hash:RE_method 
                  a: 0
                  alt: metachar__S_482Dollar_01 7
                  dba: metachar__S_482Dollar
                  i: 0
                  min: 12345
                  name: stopper
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
          s: 0
metachar__S_482Dollar_01: *22
metachar__S_483Single_Single: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_483Single_Single
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_483Single_Single
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_double 
              a: 0
              dba: metachar__S_483Single_Single
              i: 0
              min: 1
              r: 1
              s: 0
              text: "'"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_483Single_Single
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_483Single_Single
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_483Single_Single
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: quote
              r: 1
              rest: ''
              s: 0
metachar__S_484Double_Double: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_484Double_Double
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_484Double_Double
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_484Double_Double
              i: 0
              min: 1
              r: 1
              s: 0
              text: "\""
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_484Double_Double
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_484Double_Double
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_484Double_Double
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: quote
              r: 1
              rest: ''
              s: 0
metachar__S_485var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_485var
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_485var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_485var
              i: 0
              min: 2
              r: 1
              s: 0
              text: $$
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_485var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_485var
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_485var
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_485var
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_485var
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: variable
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_485var
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: check_variable
              nobind: 1
              rest: ($<variable>)
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_paren 
            decl: []

            min: 37036
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_485var
              i: 0
              min: 37036
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_485var
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: metachar__S_485var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_485var
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_485var
                  i: 0
                  min: 12345
                  name: quantified_atom
                  r: 1
                  rest: ''
                  s: 0
          min: 0
          nobind: 1
          quant: 
            - "?"
            - ":"
            - ''
            - 0
        dba: metachar__S_485var
        i: 0
        min: 0
        r: 1
        s: 0
        var: binding
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_485var
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $<variable>.Str; "
mod_arg: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: modifier argument
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: modifier argument
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: modifier argument
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: modifier argument
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: modifier argument
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: modifier argument
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'modifier argument')
mod_internal__S_526Colonmy: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_526Colonmy
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_526Colonmy
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_526Colonmy
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 3
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_526Colonmy
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 2
                  re: &9 !!perl/hash:RE_any 
                    a: 0
                    altname: mod_internal__S_526Colonmy_02
                    dba: mod_internal__S_526Colonmy
                    i: 0
                    min: 2
                    name: mod_internal__S_526Colonmy_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_526Colonmy_02 0
                        dba: mod_internal__S_526Colonmy
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        text: my
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_526Colonmy_02 1
                        dba: mod_internal__S_526Colonmy
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: state
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_526Colonmy_02 2
                        dba: mod_internal__S_526Colonmy
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: our
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_526Colonmy_02 3
                        dba: mod_internal__S_526Colonmy
                        i: 0
                        min: 8
                        r: 1
                        s: 0
                        text: constant
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: mod_internal__S_526Colonmy
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_526Colonmy
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_526Colonmy
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_526Colonmy
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: statement
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_526Colonmy
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: eat_terminator
              r: 1
              rest: ''
              s: 0
mod_internal__S_526Colonmy_02: *9
mod_internal__S_527Colontemp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_527Colontemp
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_527Colontemp
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_527Colontemp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 4
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_527Colontemp
              i: 0
              min: 4
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 3
                  re: &16 !!perl/hash:RE_any 
                    a: 0
                    altname: mod_internal__S_527Colontemp_02
                    dba: mod_internal__S_527Colontemp
                    i: 0
                    min: 3
                    name: mod_internal__S_527Colontemp_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_527Colontemp_02 0
                        dba: mod_internal__S_527Colontemp
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: temp
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_527Colontemp_02 1
                        dba: mod_internal__S_527Colontemp
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: let
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: mod_internal__S_527Colontemp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_527Colontemp
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_527Colontemp
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_527Colontemp
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: statement
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_527Colontemp
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: eat_terminator
              r: 1
              rest: ''
              s: 0
mod_internal__S_527Colontemp_02: *16
mod_internal__S_528Coloni: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_528Coloni
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &15 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_528Coloni_01
            dba: mod_internal__S_528Coloni
            i: 0
            min: 2
            name: mod_internal__S_528Coloni_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_528Coloni_01 0
                dba: mod_internal__S_528Coloni
                i: 0
                min: 2
                r: 1
                s: 0
                text: :i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_528Coloni_01 1
                dba: mod_internal__S_528Coloni
                i: 0
                min: 11
                r: 1
                s: 0
                text: :ignorecase
        dba: mod_internal__S_528Coloni
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_528Coloni
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_528Coloni
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = 1 "
mod_internal__S_528Coloni_01: *15
mod_internal__S_529ColonBangi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_529ColonBangi
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 3
          nobind: 1
          re: &20 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_529ColonBangi_01
            dba: mod_internal__S_529ColonBangi
            i: 0
            min: 3
            name: mod_internal__S_529ColonBangi_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_529ColonBangi_01 0
                dba: mod_internal__S_529ColonBangi
                i: 0
                min: 3
                r: 1
                s: 0
                text: :!i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_529ColonBangi_01 1
                dba: mod_internal__S_529ColonBangi
                i: 0
                min: 12
                r: 1
                s: 0
                text: :!ignorecase
        dba: mod_internal__S_529ColonBangi
        i: 0
        min: 3
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_529ColonBangi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_529ColonBangi
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = 0 "
mod_internal__S_529ColonBangi_01: *20
mod_internal__S_530ColoniParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_530ColoniParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &6 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_530ColoniParen_Thesis_01
            dba: mod_internal__S_530ColoniParen_Thesis
            i: 0
            min: 2
            name: mod_internal__S_530ColoniParen_Thesis_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_530ColoniParen_Thesis_01 0
                dba: mod_internal__S_530ColoniParen_Thesis
                i: 0
                min: 2
                r: 1
                s: 0
                text: :i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_530ColoniParen_Thesis_01 1
                dba: mod_internal__S_530ColoniParen_Thesis
                i: 0
                min: 11
                r: 1
                s: 0
                text: :ignorecase
        dba: mod_internal__S_530ColoniParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_530ColoniParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_530ColoniParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = eval $<mod_arg>.Str "
mod_internal__S_530ColoniParen_Thesis_01: *6
mod_internal__S_531Colon0i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_531Colon0i
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_531Colon0i
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_531Colon0i
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &27 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_531Colon0i_02
          dba: mod_internal__S_531Colon0i
          i: 0
          min: 1
          name: mod_internal__S_531Colon0i_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_531Colon0i_02 0
              dba: mod_internal__S_531Colon0i
              i: 0
              min: 1
              r: 1
              s: 0
              text: i
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_531Colon0i_02 1
              dba: mod_internal__S_531Colon0i
              i: 0
              min: 10
              r: 1
              s: 0
              text: ignorecase
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_531Colon0i
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = $0 "
mod_internal__S_531Colon0i_02: *27
mod_internal__S_532Colona: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_532Colona
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &29 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_532Colona_01
            dba: mod_internal__S_532Colona
            i: 0
            min: 2
            name: mod_internal__S_532Colona_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_532Colona_01 0
                dba: mod_internal__S_532Colona
                i: 0
                min: 2
                r: 1
                s: 0
                text: :a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_532Colona_01 1
                dba: mod_internal__S_532Colona
                i: 0
                min: 13
                r: 1
                s: 0
                text: :ignoreaccent
        dba: mod_internal__S_532Colona
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_532Colona
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_532Colona
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = 1 "
mod_internal__S_532Colona_01: *29
mod_internal__S_533ColonBanga: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_533ColonBanga
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 3
          nobind: 1
          re: &21 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_533ColonBanga_01
            dba: mod_internal__S_533ColonBanga
            i: 0
            min: 3
            name: mod_internal__S_533ColonBanga_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_533ColonBanga_01 0
                dba: mod_internal__S_533ColonBanga
                i: 0
                min: 3
                r: 1
                s: 0
                text: :!a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_533ColonBanga_01 1
                dba: mod_internal__S_533ColonBanga
                i: 0
                min: 14
                r: 1
                s: 0
                text: :!ignoreaccent
        dba: mod_internal__S_533ColonBanga
        i: 0
        min: 3
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_533ColonBanga
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_533ColonBanga
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = 0 "
mod_internal__S_533ColonBanga_01: *21
mod_internal__S_534ColonaParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_534ColonaParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &3 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_534ColonaParen_Thesis_01
            dba: mod_internal__S_534ColonaParen_Thesis
            i: 0
            min: 2
            name: mod_internal__S_534ColonaParen_Thesis_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_534ColonaParen_Thesis_01 0
                dba: mod_internal__S_534ColonaParen_Thesis
                i: 0
                min: 2
                r: 1
                s: 0
                text: :a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_534ColonaParen_Thesis_01 1
                dba: mod_internal__S_534ColonaParen_Thesis
                i: 0
                min: 13
                r: 1
                s: 0
                text: :ignoreaccent
        dba: mod_internal__S_534ColonaParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_534ColonaParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_534ColonaParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = eval $<mod_arg>.Str "
mod_internal__S_534ColonaParen_Thesis_01: *3
mod_internal__S_535Colon0a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_535Colon0a
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_535Colon0a
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_535Colon0a
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &13 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_535Colon0a_02
          dba: mod_internal__S_535Colon0a
          i: 0
          min: 1
          name: mod_internal__S_535Colon0a_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_535Colon0a_02 0
              dba: mod_internal__S_535Colon0a
              i: 0
              min: 1
              r: 1
              s: 0
              text: a
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_535Colon0a_02 1
              dba: mod_internal__S_535Colon0a
              i: 0
              min: 12
              r: 1
              s: 0
              text: ignoreaccent
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_535Colon0a
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = $0 "
mod_internal__S_535Colon0a_02: *13
mod_internal__S_536Colons: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_536Colons
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_536Colons
        i: 0
        min: 2
        r: 1
        s: 0
        text: :s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_536Colons
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_536Colons
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_536Colons
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = 1 "
mod_internal__S_537ColonBangs: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_537ColonBangs
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_537ColonBangs
        i: 0
        min: 3
        r: 1
        s: 0
        text: :!s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_537ColonBangs
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_537ColonBangs
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_537ColonBangs
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = 0 "
mod_internal__S_538ColonsParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_538ColonsParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_538ColonsParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: :s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_538ColonsParen_Thesis
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_538ColonsParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_538ColonsParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = eval $<mod_arg>.Str "
mod_internal__S_539Colon0s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_539Colon0s
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_539Colon0s
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_539Colon0s
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_539Colon0s
        i: 0
        min: 1
        r: 1
        s: 0
        text: s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_539Colon0s
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_539Colon0s
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_539Colon0s
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = $0 "
mod_internal__S_540Colonr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_540Colonr
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_540Colonr
        i: 0
        min: 2
        r: 1
        s: 0
        text: :r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_540Colonr
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_540Colonr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_540Colonr
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = 1 "
mod_internal__S_541ColonBangr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_541ColonBangr
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_541ColonBangr
        i: 0
        min: 3
        r: 1
        s: 0
        text: :!r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_541ColonBangr
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_541ColonBangr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_541ColonBangr
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = 0 "
mod_internal__S_542ColonrParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_542ColonrParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_542ColonrParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: :r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_542ColonrParen_Thesis
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_542ColonrParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_542ColonrParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_542ColonrParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = eval $<mod_arg>.Str "
mod_internal__S_543Colon0r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_543Colon0r
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_543Colon0r
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_543Colon0r
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_543Colon0r
        i: 0
        min: 1
        r: 1
        s: 0
        text: r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_543Colon0r
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_543Colon0r
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_543Colon0r
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = $0 "
mod_internal__S_544ColonPerl5: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_544ColonPerl5
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 3
        re: &7 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_544ColonPerl5_01
          dba: mod_internal__S_544ColonPerl5
          i: 0
          min: 3
          name: mod_internal__S_544ColonPerl5_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_544ColonPerl5_01 0
              dba: mod_internal__S_544ColonPerl5
              i: 0
              min: 6
              r: 1
              s: 0
              text: :Perl5
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_544ColonPerl5_01 1
              dba: mod_internal__S_544ColonPerl5
              i: 0
              min: 3
              r: 1
              s: 0
              text: :P5
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_544ColonPerl5
          i: 0
          lang: ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) )
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_544ColonPerl5
              i: 0
              lang: ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) )
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) );  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_544ColonPerl5
              i: 0
              lang: ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) )
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
mod_internal__S_544ColonPerl5_01: *7
mod_internal__S_545adv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_545adv
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_545adv
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12346
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_545adv
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: mod_internal__S_545adv
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: mod_internal__S_545adv
                  i: 0
                  min: 12345
                  name: identifier
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_545adv
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_545adv
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_545adv
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: quotepair
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_545adv
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := : $<quotepair><key> "
mod_internal__S_546oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_546oops
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_546oops
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: mod_internal__S_546oops
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized regex modifier")
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $sigspace    is context<rw> = $*sigspace    // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ratchet     is context<rw> = $*ratchet     // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignorecase is context<rw> = $*ignorecase // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignoreaccent    is context<rw> = $*ignoreaccent    // 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: nibbler
            i: 0
            min: 1
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: \s
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_qw 
                a: 0
                dba: nibbler
                i: 0
                min: 1
                r: 1
                s: 1
                text: < || | && & >
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: nibbler
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
normspace: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: normspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: normspace
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &24 !!perl/hash:RE_any 
              a: 0
              altname: normspace_01
              dba: normspace
              i: 0
              min: 1
              name: normspace_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: normspace_01 0
                  dba: normspace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: normspace_01 1
                  dba: normspace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "#"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: normspace
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: normspace
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: normspace
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
normspace_01: *24
quantified_atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantified_atom
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: stopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: rxinfix
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: atom
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantified_atom
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: quantifier
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantifier__S_547Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_547Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_547Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_547Star
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_548Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_548Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_548Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_548Plus
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_549Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_549Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_549Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_549Question
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_550StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_550StarStar
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_550StarStar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "**"
      - !!perl/hash:RE_meta 
        a: 0
        dba: quantifier__S_550StarStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quantifier__S_550StarStar
          i: 0
          min: 12345
          name: normspace
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_550StarStar
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quantifier__S_550StarStar
          i: 0
          min: 12345
          name: normspace
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &5 !!perl/hash:RE_any 
          a: 0
          altname: quantifier__S_550StarStar_01
          dba: quantifier__S_550StarStar
          i: 0
          min: 1
          name: quantifier__S_550StarStar_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quantifier__S_550StarStar_01 0
              dba: quantifier__S_550StarStar
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: quantifier__S_550StarStar
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \d
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 3
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: quantifier__S_550StarStar
                      i: 0
                      min: 3
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: quantifier__S_550StarStar
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: ..
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: &8 !!perl/hash:RE_any 
                            a: 0
                            altname: quantifier__S_550StarStar_03
                            dba: quantifier__S_550StarStar
                            i: 0
                            min: 1
                            name: quantifier__S_550StarStar_03
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_quantified_atom 
                                alt: quantifier__S_550StarStar_03 0
                                atom: !!perl/hash:RE_meta 
                                  a: 0
                                  dba: quantifier__S_550StarStar
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \d
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: quantifier__S_550StarStar_03 1
                                dba: quantifier__S_550StarStar
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "*"
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_550StarStar_01 1
              dba: quantifier__S_550StarStar
              i: 0
              min: 12345
              name: codeblock
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_550StarStar_01 2
              dba: quantifier__S_550StarStar
              i: 0
              min: 12345
              name: quantified_atom
              r: 1
              rest: ''
              s: 0
quantifier__S_550StarStar_01: *5
quantifier__S_550StarStar_03: *8
quantifier__S_551TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_551TildeTilde
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &18 !!perl/hash:RE_any 
          a: 0
          altname: quantifier__S_551TildeTilde_01
          dba: quantifier__S_551TildeTilde
          i: 0
          min: 12345
          name: quantifier__S_551TildeTilde_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quantifier__S_551TildeTilde_01 0
              dba: quantifier__S_551TildeTilde
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: quantifier__S_551TildeTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quantifier__S_551TildeTilde
                  i: 0
                  min: 12345
                  name: sym
                  r: 1
                  rest: ''
                  s: 0
                  sym: ~~
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_551TildeTilde_01 1
              dba: quantifier__S_551TildeTilde
              i: 0
              min: 12345
              name: sym
              r: 1
              rest: ''
              s: 0
              sym: ~~
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_551TildeTilde
        i: 0
        min: 12345
        name: normspace
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_551TildeTilde
        i: 0
        min: 12345
        name: quantified_atom
        r: 1
        rest: ''
        s: 0
quantifier__S_551TildeTilde_01: *18
quantmod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantmod
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: quantmod
          i: 0
          min: 1
          r: 1
          s: 0
          text: ":"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &11 !!perl/hash:RE_any 
            a: 0
            altname: quantmod_01
            dba: quantmod
            i: 0
            min: 1
            name: quantmod_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 0
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: "?"
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 1
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: "!"
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 2
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: +
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantmod_01: *11
rxinfix__S_448VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_448VertVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "||"
rxinfix__S_449AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_449AmpAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&&"
rxinfix__S_450Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_450Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
rxinfix__S_451Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_451Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
rxinfix__S_452Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_452Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
sign: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: &10 !!perl/hash:RE_any 
    a: 0
    altname: sign_00
    dba: sign
    i: 0
    min: 0
    name: sign_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        alt: sign_00 0
        dba: sign
        i: 0
        min: 1
        r: 1
        s: 0
        text: +
      - !!perl/hash:RE_string 
        a: 0
        alt: sign_00 1
        dba: sign
        i: 0
        min: 1
        r: 1
        s: 0
        text: "-"
      - !!perl/hash:RE_assertion 
        alt: sign_00 2
        assert: "?"
        min: 0
        re: !!perl/hash:RE_noop 
          a: 0
          dba: sign
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
sign_00: *10
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: termish
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: termish
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_method 
            a: 0
            dba: termish
            i: 0
            min: 12345
            name: quantified_atom
            r: 1
            rest: ''
            s: 0
          min: 12345
          nobind: 1
          quant: 
            - +
            - ":"
            - ''
            - 1
        dba: termish
        i: 0
        min: 12345
        r: 1
        s: 0
        var: noun
ws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: ws
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: ws
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*sigspace "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: ws
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: ws
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &23 !!perl/hash:RE_any 
                      a: 0
                      altname: ws_03
                      dba: ws
                      i: 0
                      min: 1
                      name: ws_03
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          alt: ws_03 0
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: ws_03 1
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "#"
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: ws
                i: 0
                min: 12345
                name: nextsame
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws_03: *23
RETREE_END
}
} ## end grammar

{ package STD::P5Regex;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'global' or $k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'ignorecase' or $k eq 'i') {
my $i = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks

##     token category__S_552metachar (:$sym is context<rw> = 'metachar')
##          token category:metachar { <sym> }

sub category__S_552metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_552metachar',$retree) }
sub category__S_552metachar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'metachar';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_552metachar", 
$C->_PATTERN(qr/\Gmetachar/)
);
}
#proto token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'metachar:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "metachar", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_553backslash (:$sym is context<rw> = 'backslash')
##          token category:backslash { <sym> }

sub category__S_553backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_553backslash',$retree) }
sub category__S_553backslash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'backslash';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_553backslash", 
$C->_PATTERN(qr/\Gbackslash/)
);
}
#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_554assertion (:$sym is context<rw> = 'assertion')
##          token category:assertion { <sym> }

sub category__S_554assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_554assertion',$retree) }
sub category__S_554assertion {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'assertion';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_554assertion", 
$C->_PATTERN(qr/\Gassertion/)
);
}
#proto token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "assertion", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_555quantifier (:$sym is context<rw> = 'quantifier')
##          token category:quantifier { <sym> }

sub category__S_555quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_555quantifier',$retree) }
sub category__S_555quantifier {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quantifier';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_555quantifier", 
$C->_PATTERN(qr/\Gquantifier/)
);
}
#proto token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'quantifier:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quantifier", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_556mod_internal (:$sym is context<rw> = 'mod_internal')
##          token category:mod_internal { <sym> }

sub category__S_556mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_556mod_internal',$retree) }
sub category__S_556mod_internal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod_internal';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_556mod_internal", 
$C->_PATTERN(qr/\Gmod_internal/)
);
}
#proto token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'mod_internal:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "mod_internal", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


#proto token rxinfix { <...> }
sub rxinfix__PEEK { $_[0]->_AUTOLEXpeek('rxinfix:*',$retree); }
sub rxinfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'rxinfix') {
$C->deb("Fate passed to rxinfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'rxinfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("rxinfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "rxinfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


# suppress fancy end-of-line checking
##     token codeblock
##          token codeblock {
##              :my $GOAL is context = '}';
##              '{' :: [ :lang($.cursor_fresh(%*LANG<MAIN>)) <statementlist> ]
##              [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
##          }

sub codeblock__PEEK { $_[0]->_AUTOLEXpeek('codeblock',$retree) }
sub codeblock {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL = '}';


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "codeblock", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse statement list; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
);
}

##     token ws
##          token ws {
##              <?{ $*sigspace }>
##              || [ <?before \s | '#'> <.nextsame> ]?   # still get all the pod goodness, hopefully
##          }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
my @origargs = @_;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "ws", 
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$::sigspace 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_03') {
$C->deb("Fate passed to ws_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'ws_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$self->SUPER::ws(@origargs);
}
else {
();
}
}
})
})} or do { die $@ if $@ };
@gather;
}
);
}

##     rule nibbler
##          rule nibbler {
##              :my $ignorecase is context<rw> = $*ignorecase // 0;
##              <EXPR>
##          }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::ignorecase = $::ignorecase // 0;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token termish
##          token termish {
##              <.ws>  # XXX assuming old /x here?
##              <noun=quantified_atom>+
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quantified_atom'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->ws)) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['noun','quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
});
}
else {
();
}
}
);
}
##     token infixish
##          token infixish {
##              <!infixstopper>
##              <!stdstopper>
##              <rxinfix>
##              {
##                  $<O> = $<rxinfix><O>;
##                  $<sym> = $<rxinfix><sym>;
##              }
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rxinfix'], sub {
my $C = shift;
$C->rxinfix
}))) {
scalar(do {
my $M = $C; 
$M->{'O'} = $M->{'rxinfix'}{'O'};
$M->{'sym'} = $M->{'rxinfix'}{'sym'};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token rxinfix__S_557Vert (  :$sym is context<rw> = <|> --> Junctive_or )
##          token rxinfix:sym<|> ( --> Junctive_or ) { <sym> }

sub rxinfix__S_557Vert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_557Vert',$retree) }
sub rxinfix__S_557Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_557Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}

##     token quantified_atom
##          token quantified_atom {
##              <!stopper>
##              <!rxinfix>
##              <atom>
##              [ <.ws> <quantifier>
##      #            <?{ $<atom>.max_width }>
##      #                || <.panic: "Can't quantify zero-width atom">
##              ]?
##              <.ws>
##          }

sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom',$retree) }
sub quantified_atom {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quantifier'} = [];

$self->_MATCHIFYr($S, "quantified_atom", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->rxinfix
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
});
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token atom
##          token atom {
##              [
##              | \w
##              | <metachar>
##              | '\\' :: .
##              ]
##          }

sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom',$retree) }
sub atom {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "atom", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'atom_01') {
$C->deb("Fate passed to atom_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'atom_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("atom_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?s:.)/)
}, $C->_COMMITBRANCH())
}, $C->_EXACT('\\'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# sequence stoppers
##     token metachar__S_558Vert (:$sym is context<rw> = <|>)
##          token metachar:sym<|>   { '|'  :: <fail> }

sub metachar__S_558Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_558Vert',$retree) }
sub metachar__S_558Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_558Vert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('|'))
);
}
##     token metachar__S_559Thesis (:$sym is context<rw> = <)>)
##          token metachar:sym<)>   { ')'  :: <fail> }

sub metachar__S_559Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_559Thesis',$retree) }
sub metachar__S_559Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_559Thesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(')'))
);
}

##     token metachar__S_560quant (:$sym is context<rw> = 'quant')
##          token metachar:quant { <quantifier> <.panic: "quantifier quantifies nothing"> }

sub metachar__S_560quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_560quant',$retree) }
sub metachar__S_560quant {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quant';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_560quant", 
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->panic("quantifier quantifies nothing");
}
else {
();
}
}
);
}

# "normal" metachars

##     token metachar__S_561Bra_Ket (:$sym is context<rw> = <[ ]>)
##          token metachar:sym<[ ]> {
##              <before '['> <quibble($.cursor_fresh( %*LANG<Q> ).tweak(:q))> # XXX parse as q[] for now
##          }

sub metachar__S_561Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_561Bra_Ket',$retree) }
sub metachar__S_561Bra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_561Bra_Ket", 
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
});
}
else {
();
}
}
);
}

##     token metachar__S_562ParenQuestion_Thesis (:$sym is context<rw> = (? ))
##          token metachar:sym(? ) {
##              '(?' {} <assertion>
##              [ ')' || <.panic: "Perl 5 regex assertion not terminated by parenthesis"> ]
##          }

sub metachar__S_562ParenQuestion_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_562ParenQuestion_Thesis',$retree) }
sub metachar__S_562ParenQuestion_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['(?',')'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_562ParenQuestion_Thesis", 
do {
if (my ($C) = ($C->_EXACT('(?'))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Perl 5 regex assertion not terminated by parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_563Paren_Thesis (:$sym is context<rw> = <( )>)
##          token metachar:sym<( )> {
##              '(' {} [:lang(self.unbalanced(')')) <nibbler>]?
##              [ ')' || <.panic: "Unable to parse Perl 5 regex; couldn't find right parenthesis"> ]
##              { $/<sym> := <( )> }
##          }

sub metachar__S_563Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_563Paren_Thesis',$retree) }
sub metachar__S_563Paren_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'nibbler'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_563Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse Perl 5 regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw[( )]] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_564Back (:$sym is context<rw> = <\\>)
##          token metachar:sym<\\> { <sym> <backslash> }

sub metachar__S_564Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_564Back',$retree) }
sub metachar__S_564Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_564Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##     token metachar__S_565Dot (:$sym is context<rw> = <.>)
##          token metachar:sym<.>  { <sym> }

sub metachar__S_565Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_565Dot',$retree) }
sub metachar__S_565Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_565Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token metachar__S_566Caret (:$sym is context<rw> = <^>)
##          token metachar:sym<^>  { <sym> }

sub metachar__S_566Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_566Caret',$retree) }
sub metachar__S_566Caret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_566Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
##     token metachar__S_567Dollar (:$sym is context<rw> = <$>)
##          token metachar:sym<$>  {
##              '$' <?before \W | $>
##          }

sub metachar__S_567Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_567Dollar',$retree) }
sub metachar__S_567Dollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_567Dollar", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'metachar__S_567Dollar_01') {
$C->deb("Fate passed to metachar__S_567Dollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'metachar__S_567Dollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar__S_567Dollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token metachar__S_568var (:$sym is context<rw> = 'var')
##          token metachar:var {
##              <?before <sigil>\w>
##              <.panic: "Can't interpolate variable in Perl 5 regex">
##          }

sub metachar__S_568var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_568var',$retree) }
sub metachar__S_568var {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'var';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_568var", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
$C->_PATTERN(qr/\G\w/);
}
else {
();
}
}
}))) {
$C->panic("Can't interpolate variable in Perl 5 regex");
}
else {
();
}
}
);
}

##     token backslash__S_569A (:$sym is context<rw> = 'A')
##          token backslash:A { <sym> }

sub backslash__S_569A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_569A',$retree) }
sub backslash__S_569A {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'A';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_569A", 
$C->_PATTERN(qr/\GA/)
);
}
##     token backslash__S_570a (:$sym is context<rw> = 'a')
##          token backslash:a { <sym> }

sub backslash__S_570a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_570a',$retree) }
sub backslash__S_570a {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_570a", 
$C->_PATTERN(qr/\Ga/)
);
}
##     token backslash__S_571b (:$sym is context<rw> = 'b')
##          token backslash:b { :i <sym> }

sub backslash__S_571b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_571b',$retree) }
sub backslash__S_571b {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_571b", 
$C->_PATTERN(qr/\G(?i:b)/)
);
}
##     token backslash__S_572c (:$sym is context<rw> = 'c')
##          token backslash:c { :i <sym>
##              <[ ?.._ ]> || <.panic: "Unrecognized \\c character">
##          }

sub backslash__S_572c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_572c',$retree) }
sub backslash__S_572c {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_572c", 
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:c)(?i:[?-_])/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unrecognized \\c character")} or do { die $@ if $@ };
@gather;
}
);
}
##     token backslash__S_573d (:$sym is context<rw> = 'd')
##          token backslash:d { :i <sym> }

sub backslash__S_573d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_573d',$retree) }
sub backslash__S_573d {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'd';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_573d", 
$C->_PATTERN(qr/\G(?i:d)/)
);
}
##     token backslash__S_574e (:$sym is context<rw> = 'e')
##          token backslash:e { :i <sym> }

sub backslash__S_574e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_574e',$retree) }
sub backslash__S_574e {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_574e", 
$C->_PATTERN(qr/\G(?i:e)/)
);
}
##     token backslash__S_575f (:$sym is context<rw> = 'f')
##          token backslash:f { :i <sym> }

sub backslash__S_575f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_575f',$retree) }
sub backslash__S_575f {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_575f", 
$C->_PATTERN(qr/\G(?i:f)/)
);
}
##     token backslash__S_576h (:$sym is context<rw> = 'h')
##          token backslash:h { :i <sym> }

sub backslash__S_576h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_576h',$retree) }
sub backslash__S_576h {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_576h", 
$C->_PATTERN(qr/\G(?i:h)/)
);
}
##     token backslash__S_577l (:$sym is context<rw> = 'l')
##          token backslash:l { :i <sym> }

sub backslash__S_577l__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_577l',$retree) }
sub backslash__S_577l {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'l';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_577l", 
$C->_PATTERN(qr/\G(?i:l)/)
);
}
##     token backslash__S_578n (:$sym is context<rw> = 'n')
##          token backslash:n { :i <sym> }

sub backslash__S_578n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_578n',$retree) }
sub backslash__S_578n {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_578n", 
$C->_PATTERN(qr/\G(?i:n)/)
);
}
##     token backslash__S_579o (:$sym is context<rw> = 'o')
##          token backslash:o { '0' [ <octint> | '{' ~ '}' <octints> ] }

sub backslash__S_579o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_579o',$retree) }
sub backslash__S_579o {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_579o", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_579o_01') {
$C->deb("Fate passed to backslash__S_579o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_579o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_579o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}' , 'backslash__S_579o')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['octints'], sub {
my $C = shift;
$C->octints
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('0'))
);
}
##     token backslash__S_580p (:$sym is context<rw> = 'p')
##          token backslash:p { :i <sym> '{' <[\w:]>+ '}' }

sub backslash__S_580p__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_580p',$retree) }
sub backslash__S_580p {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'p';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_580p", 
$C->_PATTERN(qr/\G(?i:p)(?i:\{)((?:(?i:[\w:]))++)(?i:\})/)
);
}
##     token backslash__S_581Q (:$sym is context<rw> = 'Q')
##          token backslash:Q { <sym> }

sub backslash__S_581Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_581Q',$retree) }
sub backslash__S_581Q {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_581Q", 
$C->_PATTERN(qr/\GQ/)
);
}
##     token backslash__S_582r (:$sym is context<rw> = 'r')
##          token backslash:r { :i <sym> }

sub backslash__S_582r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_582r',$retree) }
sub backslash__S_582r {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_582r", 
$C->_PATTERN(qr/\G(?i:r)/)
);
}
##     token backslash__S_583s (:$sym is context<rw> = 's')
##          token backslash:s { :i <sym> }

sub backslash__S_583s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_583s',$retree) }
sub backslash__S_583s {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_583s", 
$C->_PATTERN(qr/\G(?i:s)/)
);
}
##     token backslash__S_584t (:$sym is context<rw> = 't')
##          token backslash:t { :i <sym> }

sub backslash__S_584t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_584t',$retree) }
sub backslash__S_584t {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_584t", 
$C->_PATTERN(qr/\G(?i:t)/)
);
}
##     token backslash__S_585u (:$sym is context<rw> = 'u')
##          token backslash:u { :i <sym> }

sub backslash__S_585u__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_585u',$retree) }
sub backslash__S_585u {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'u';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_585u", 
$C->_PATTERN(qr/\G(?i:u)/)
);
}
##     token backslash__S_586v (:$sym is context<rw> = 'v')
##          token backslash:v { :i <sym> }

sub backslash__S_586v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_586v',$retree) }
sub backslash__S_586v {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'v';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_586v", 
$C->_PATTERN(qr/\G(?i:v)/)
);
}
##     token backslash__S_587w (:$sym is context<rw> = 'w')
##          token backslash:w { :i <sym> }

sub backslash__S_587w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_587w',$retree) }
sub backslash__S_587w {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_587w", 
$C->_PATTERN(qr/\G(?i:w)/)
);
}
##     token backslash__S_588x (:$sym is context<rw> = 'x')
##          token backslash:x { :i <sym> [ <hexint> | '{' ~ '}' <hexints> ] }

sub backslash__S_588x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_588x',$retree) }
sub backslash__S_588x {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_588x", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_588x_01') {
$C->deb("Fate passed to backslash__S_588x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_588x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_588x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:\})/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}' , 'backslash__S_588x')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['hexints'], sub {
my $C = shift;
$C->hexints
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_PATTERN(qr/\G(?i:\{)/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_PATTERN(qr/\G(?i:x)/))
);
}
##     token backslash__S_589z (:$sym is context<rw> = 'z')
##          token backslash:z { :i <sym> }

sub backslash__S_589z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_589z',$retree) }
sub backslash__S_589z {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'z';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_589z", 
$C->_PATTERN(qr/\G(?i:z)/)
);
}
##     token backslash__S_590misc (:$sym is context<rw> = 'misc')
##          token backslash:misc { $<litchar>=(\W) | $<number>=(\d+) }

sub backslash__S_590misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_590misc',$retree) }
sub backslash__S_590misc {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_590misc", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_590misc_00') {
$C->deb("Fate passed to backslash__S_590misc_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_590misc_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_590misc_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}
##     token backslash__S_591oops (:$sym is context<rw> = 'oops')
##          token backslash:oops { <.panic: "Unrecognized Perl 5 regex backslash sequence"> }

sub backslash__S_591oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_591oops',$retree) }
sub backslash__S_591oops {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_591oops", 
$C->panic("Unrecognized Perl 5 regex backslash sequence")
);
}

##     token assertion__S_592Question (:$sym is context<rw> = <?>)
##          token assertion:sym<?> { <sym> <codeblock> }

sub assertion__S_592Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_592Question',$retree) }
sub assertion__S_592Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_592Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
});
}
else {
();
}
}
);
}
##     token assertion__S_593Cur_Ly (:$sym is context<rw> = <{ }>)
##          token assertion:sym<{ }> { <codeblock> }

sub assertion__S_593Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_593Cur_Ly',$retree) }
sub assertion__S_593Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_593Cur_Ly", 
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
);
}

##     token assertion__S_594Lt (:$sym is context<rw> = <)
##          token assertion:sym< { <sym> <?before '=' | '!'> <assertion> }

sub assertion__S_594Lt__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_594Lt',$retree) }
sub assertion__S_594Lt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_594Lt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\</))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_594Lt_01') {
$C->deb("Fate passed to assertion__S_594Lt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_594Lt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_594Lt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_EXACT('!')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token assertion__S_595Equal (:$sym is context<rw> = <=>)
##          token assertion:sym<=> { <sym> [ <?before ')'> | <rx> ] }

sub assertion__S_595Equal__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_595Equal',$retree) }
sub assertion__S_595Equal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_595Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_595Equal_01') {
$C->deb("Fate passed to assertion__S_595Equal_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_595Equal_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_595Equal_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_596Bang (:$sym is context<rw> = <!>)
##          token assertion:sym<!> { <sym> [ <?before ')'> | <rx> ] }

sub assertion__S_596Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_596Bang',$retree) }
sub assertion__S_596Bang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_596Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_596Bang_01') {
$C->deb("Fate passed to assertion__S_596Bang_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_596Bang_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_596Bang_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_597Gt (:$sym is context<rw> = >)
##          token assertion:sym> { <sym> <rx> }

sub assertion__S_597Gt__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_597Gt',$retree) }
sub assertion__S_597Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_597Gt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>/))) {
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
});
}
else {
();
}
}
);
}

##     token rx
##          token rx {
##              #[:lang(self.unbalanced(')')) <nibbler>]
##              <nibbler>
##              [ <?before ')'> || <.panic: "Unable to parse Perl 5 regex; couldn't find right parenthesis"> ]
##          }

sub rx__PEEK { $_[0]->_AUTOLEXpeek('rx',$retree) }
sub rx {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "rx", 
do {
if (my ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
$C->_EXACT(')')
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse Perl 5 regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}

#token assertion:identifier { <longname> [               # is qq right here?
#                                | <?before ')' >
#                                | <.ws> <nibbler>
#                               ]
#                               [ ':' <rx> ]?
#}
##     token p5mod
##          token p5mod { <[imox]>* }

sub p5mod__PEEK { $_[0]->_AUTOLEXpeek('p5mod',$retree) }
sub p5mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "p5mod", 
$C->_PATTERN(qr/\G((?:[imox])*+)/)
);
}
##     token p5mods
##          token p5mods { <on=p5mod> [ '-' <off=p5mod> ]? }

sub p5mods__PEEK { $_[0]->_AUTOLEXpeek('p5mods',$retree) }
sub p5mods {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'off'} = [];

$self->_MATCHIFYr($S, "p5mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['on'], sub {
my $C = shift;
$C->p5mod
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-'))) {
$C->_SUBSUMEr(['off'], sub {
my $C = shift;
$C->p5mod
});
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}
##     token assertion__S_598mod (:$sym is context<rw> = 'mod')
##          token assertion:mod { <p5mods> [               # is qq right here?
##                                         | ':' <rx>?
##                                         | <?before ')' >
##                                         ]
##          }

sub assertion__S_598mod__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_598mod',$retree) }
sub assertion__S_598mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'rx'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_598mod", 
do {
if (my ($C) = ($C->_SUBSUMEr(['p5mods'], sub {
my $C = shift;
$C->p5mods
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_598mod_01') {
$C->deb("Fate passed to assertion__S_598mod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_598mod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_598mod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_599bogus (:$sym is context<rw> = 'bogus')
##          token assertion:bogus { <.panic: "Unrecognized Perl 5 regex assertion"> }

sub assertion__S_599bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_599bogus',$retree) }
sub assertion__S_599bogus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'bogus';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_599bogus", 
$C->panic("Unrecognized Perl 5 regex assertion")
);
}

##     token quantifier__S_600Star (:$sym is context<rw> = <*>)
##          token quantifier:sym<*>  { <sym> <quantmod> }

sub quantifier__S_600Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_600Star',$retree) }
sub quantifier__S_600Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_600Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_601Plus (:$sym is context<rw> = <+>)
##          token quantifier:sym<+>  { <sym> <quantmod> }

sub quantifier__S_601Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_601Plus',$retree) }
sub quantifier__S_601Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_601Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_602Question (:$sym is context<rw> = <?>)
##          token quantifier:sym<?>  { <sym> <quantmod> }

sub quantifier__S_602Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_602Question',$retree) }
sub quantifier__S_602Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_602Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_603Cur_Ly (:$sym is context<rw> = <{ }>)
##          token quantifier:sym<{ }> { '{' \d+ [','\d*]? '}' <quantmod> }

sub quantifier__S_603Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_603Cur_Ly',$retree) }
sub quantifier__S_603Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_603Cur_Ly", 
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(','))) {
$C->_PATTERN(qr/\G((?:\d)*+)/);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('}'))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantmod
##          token quantmod { [ '?' | '+' ]? }

sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod',$retree) }
sub quantmod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quantmod", 
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantmod_01') {
$C->deb("Fate passed to quantmod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'quantmod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantmod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('?')
},
sub { my $C=shift;
$C->_EXACT('+')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
assertion__S_592Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_592Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_592Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_592Question
        i: 0
        min: 12345
        name: codeblock
        r: 1
        rest: ''
        s: 0
assertion__S_593Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_593Cur_Ly
    i: 0
    min: 12345
    name: codeblock
    r: 1
    rest: ''
    s: 0
assertion__S_594Lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_594Lt
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_594Lt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_594Lt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &6 !!perl/hash:RE_any 
              a: 0
              altname: assertion__S_594Lt_01
              dba: assertion__S_594Lt
              i: 0
              min: 1
              name: assertion__S_594Lt_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: assertion__S_594Lt_01 0
                  dba: assertion__S_594Lt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_string 
                  a: 0
                  alt: assertion__S_594Lt_01 1
                  dba: assertion__S_594Lt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_594Lt
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
assertion__S_594Lt_01: *6
assertion__S_595Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_595Equal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_595Equal
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &3 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_595Equal_01
          dba: assertion__S_595Equal
          i: 0
          min: 0
          name: assertion__S_595Equal_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_595Equal_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_595Equal
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_595Equal
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_595Equal_01 1
              dba: assertion__S_595Equal
              i: 0
              min: 12345
              name: rx
              r: 1
              rest: ''
              s: 0
assertion__S_595Equal_01: *3
assertion__S_596Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_596Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_596Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_596Bang_01
          dba: assertion__S_596Bang
          i: 0
          min: 0
          name: assertion__S_596Bang_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_596Bang_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_596Bang
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_596Bang
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_596Bang_01 1
              dba: assertion__S_596Bang
              i: 0
              min: 12345
              name: rx
              r: 1
              rest: ''
              s: 0
assertion__S_596Bang_01: *1
assertion__S_597Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_597Gt
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_597Gt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ">"
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_597Gt
        i: 0
        min: 12345
        name: rx
        r: 1
        rest: ''
        s: 0
assertion__S_598mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_598mod
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_598mod
        i: 0
        min: 12345
        name: p5mods
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &9 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_598mod_01
          dba: assertion__S_598mod
          i: 0
          min: 0
          name: assertion__S_598mod_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_598mod_01 0
              dba: assertion__S_598mod
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: assertion__S_598mod
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_598mod
                    i: 0
                    min: 12345
                    name: rx
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_assertion 
              alt: assertion__S_598mod_01 1
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_598mod
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_598mod
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
assertion__S_598mod_01: *9
assertion__S_599bogus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized Perl 5 regex assertion")
atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &5 !!perl/hash:RE_any 
      a: 0
      altname: atom_01
      dba: atom
      i: 0
      min: 1
      name: atom_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_meta 
          a: 0
          alt: atom_01 0
          dba: atom
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        - !!perl/hash:RE_method 
          a: 0
          alt: atom_01 1
          dba: atom
          i: 0
          min: 12345
          name: metachar
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: atom_01 2
          dba: atom
          i: 0
          min: 2
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: atom
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            - !!perl/hash:RE_meta 
              a: 0
              dba: atom
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_meta 
              a: 0
              dba: atom
              i: 0
              min: 1
              r: 1
              s: 0
              text: .
atom_01: *5
backslash__S_569A: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_569A
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: A
backslash__S_570a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_570a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
backslash__S_571b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_571b
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_572c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: backslash__S_572c
    i: 1
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: backslash__S_572c
        i: 1
        min: 12346
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: backslash__S_572c
            i: 1
            min: 12345
            name: sym
            r: 1
            rest: ''
            s: 0
            sym: c
          - !!perl/hash:RE_cclass 
            a: 0
            dba: backslash__S_572c
            i: 1
            min: 1
            r: 1
            s: 0
            text: "[ ?.._ ]"
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized \\c character")
backslash__S_573d: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_573d
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: d
backslash__S_574e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_574e
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_575f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_575f
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_576h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_576h
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
backslash__S_577l: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_577l
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: l
backslash__S_578n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_578n
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_579o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_579o
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_579o
        i: 0
        min: 1
        r: 1
        s: 0
        text: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &10 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_579o_01
          dba: backslash__S_579o
          i: 0
          min: 12345
          name: backslash__S_579o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_579o_01 0
              dba: backslash__S_579o
              i: 0
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_579o_01 1
              dba: backslash__S_579o
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_579o
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: backslash__S_579o
                  extra: "local $::GOAL = '}' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: backslash__S_579o
                  i: 0
                  min: 12345
                  name: octints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: backslash__S_579o
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: backslash__S_579o
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "}"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: ('}' , 'backslash__S_579o')
backslash__S_579o_01: *10
backslash__S_580p: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_580p
    i: 1
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_580p
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: p
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_580p
        i: 1
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: backslash__S_580p
          i: 1
          min: 1
          r: 1
          s: 0
          text: "[\\w:]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_580p
        i: 1
        min: 1
        r: 1
        s: 0
        text: "}"
backslash__S_581Q: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_581Q
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: Q
backslash__S_582r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_582r
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_583s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_583s
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
backslash__S_584t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_584t
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_585u: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_585u
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: u
backslash__S_586v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_586v
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: v
backslash__S_587w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_587w
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
backslash__S_588x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_588x
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_588x
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &7 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_588x_01
          dba: backslash__S_588x
          i: 1
          min: 12345
          name: backslash__S_588x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_588x_01 0
              dba: backslash__S_588x
              i: 1
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_588x_01 1
              dba: backslash__S_588x
              i: 1
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_588x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: backslash__S_588x
                  extra: "local $::GOAL = '}' "
                  i: 1
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: backslash__S_588x
                  i: 1
                  min: 12345
                  name: hexints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: backslash__S_588x
                    i: 1
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: backslash__S_588x
                        i: 1
                        min: 1
                        r: 1
                        s: 0
                        text: "}"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: ('}' , 'backslash__S_588x')
backslash__S_588x_01: *7
backslash__S_589z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_589z
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: z
backslash__S_590misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: &4 !!perl/hash:RE_any 
    a: 0
    altname: backslash__S_590misc_00
    dba: backslash__S_590misc
    i: 0
    min: 1
    name: backslash__S_590misc_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        alt: backslash__S_590misc_00 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_meta 
            a: 0
            dba: backslash__S_590misc
            i: 0
            min: 1
            r: 1
            s: 0
            text: \W
        dba: backslash__S_590misc
        i: 0
        min: 1
        r: 1
        s: 0
        var: litchar
      - !!perl/hash:RE_bindnamed 
        a: 0
        alt: backslash__S_590misc_00 1
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: backslash__S_590misc
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        dba: backslash__S_590misc
        i: 0
        min: 1
        r: 1
        s: 0
        var: number
backslash__S_590misc_00: *4
backslash__S_591oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized Perl 5 regex backslash sequence")
category__S_552metachar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_552metachar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: metachar
category__S_553backslash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_553backslash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: backslash
category__S_554assertion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_554assertion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: assertion
category__S_555quantifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_555quantifier
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quantifier
category__S_556mod_internal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_556mod_internal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod_internal
codeblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: codeblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codeblock
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codeblock
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: codeblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: codeblock
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: statementlist
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: codeblock
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: codeblock
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse statement list; couldn't find right brace")
infixish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infixish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: rxinfix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infixish
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n            $<O> = $<rxinfix><O>;\n            $<sym> = $<rxinfix><sym>;\n        "
metachar__S_558Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_558Vert
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_558Vert
        i: 0
        min: 1
        r: 1
        s: 0
        text: "|"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_558Vert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_558Vert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_559Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_559Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_559Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: )
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_559Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_559Thesis
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_560quant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_560quant
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_560quant
        i: 0
        min: 12345
        name: quantifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("quantifier quantifies nothing")
metachar__S_561Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_561Bra_Ket
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method_re 
        a: 0
        dba: metachar__S_561Bra_Ket
        i: 0
        min: 0
        name: before
        r: 1
        re: !!perl/hash:RE 
          decl: []

          min: 1
          re: !!perl/hash:RE_string 
            a: 0
            dba: metachar__S_561Bra_Ket
            i: 0
            min: 1
            r: 1
            s: 0
            text: "["
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q))
metachar__S_562ParenQuestion_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_562ParenQuestion_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_562ParenQuestion_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: (?
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_562ParenQuestion_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_562ParenQuestion_Thesis
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_562ParenQuestion_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_562ParenQuestion_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Perl 5 regex assertion not terminated by parenthesis")
metachar__S_563Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_563Paren_Thesis
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_563Paren_Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_563Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: metachar__S_563Paren_Thesis
            i: 0
            lang: ($self->unbalanced(')'))
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_decl 
                a: 0
                dba: metachar__S_563Paren_Thesis
                i: 0
                lang: ($self->unbalanced(')'))
                max: 0
                min: 0
                noquant: 1
                r: 1
                s: 0
                text: "my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); "
              - !!perl/hash:RE_method 
                a: 0
                dba: metachar__S_563Paren_Thesis
                i: 0
                lang: ($self->unbalanced(')'))
                min: 12345
                name: nibbler
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_563Paren_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_563Paren_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse Perl 5 regex; couldn't find right parenthesis")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_563Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <( )> "
metachar__S_564Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_564Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_564Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_564Back
        i: 0
        min: 12345
        name: backslash
        r: 1
        rest: ''
        s: 0
metachar__S_565Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_565Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
metachar__S_566Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_566Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
metachar__S_567Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_567Dollar
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_567Dollar
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_567Dollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: &11 !!perl/hash:RE_any 
              a: 0
              altname: metachar__S_567Dollar_01
              dba: metachar__S_567Dollar
              i: 0
              min: 0
              name: metachar__S_567Dollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_567Dollar_01 0
                  dba: metachar__S_567Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \W
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_567Dollar_01 1
                  dba: metachar__S_567Dollar
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $
          s: 0
metachar__S_567Dollar_01: *11
metachar__S_568var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_568var
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_568var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12346
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_568var
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_568var
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: metachar__S_568var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \w
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Can't interpolate variable in Perl 5 regex")
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignorecase is context<rw> = $*ignorecase // 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: nibbler
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
p5mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_cclass 
      a: 0
      dba: p5mod
      i: 0
      min: 1
      r: 1
      s: 0
      text: "[imox]"
    min: 0
    quant: 
      - "*"
      - ":"
      - ''
      - 0
p5mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: p5mods
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: p5mods
          i: 0
          min: 12345
          name: p5mod
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: p5mods
        i: 0
        min: 12345
        r: 1
        s: 0
        var: 'on'
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12346
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: p5mods
            i: 0
            min: 12346
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: p5mods
                i: 0
                min: 1
                r: 1
                s: 0
                text: "-"
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: p5mods
                  i: 0
                  min: 12345
                  name: p5mod
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                dba: p5mods
                i: 0
                min: 12345
                r: 1
                s: 0
                var: 'off'
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantified_atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantified_atom
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: stopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: rxinfix
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: atom
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantified_atom
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: quantifier
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
quantifier__S_600Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_600Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_600Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_600Star
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_601Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_601Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_601Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_601Plus
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_602Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_602Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_602Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_602Question
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_603Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_603Cur_Ly
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quantifier__S_603Cur_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: quantifier__S_603Cur_Ly
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantifier__S_603Cur_Ly
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: quantifier__S_603Cur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: ","
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: quantifier__S_603Cur_Ly
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: quantifier__S_603Cur_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        text: "}"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_603Cur_Ly
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantmod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 1
      re: &2 !!perl/hash:RE_any 
        a: 0
        altname: quantmod_01
        dba: quantmod
        i: 0
        min: 1
        name: quantmod_01
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_string 
            a: 0
            alt: quantmod_01 0
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: "?"
          - !!perl/hash:RE_string 
            a: 0
            alt: quantmod_01 1
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: +
    min: 0
    quant: 
      - "?"
      - ":"
      - ''
      - 0
quantmod_01: *2
rx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: rx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: rx
        i: 0
        min: 12345
        name: nibbler
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: rx
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: rx
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: rx
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse Perl 5 regex; couldn't find right parenthesis")
rxinfix__S_557Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_557Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: termish
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: termish
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_method 
            a: 0
            dba: termish
            i: 0
            min: 12345
            name: quantified_atom
            r: 1
            rest: ''
            s: 0
          min: 12345
          nobind: 1
          quant: 
            - +
            - ":"
            - ''
            - 1
        dba: termish
        i: 0
        min: 12345
        r: 1
        s: 0
        var: noun
ws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: ws
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: ws
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*sigspace "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: ws
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: ws
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &8 !!perl/hash:RE_any 
                      a: 0
                      altname: ws_03
                      dba: ws
                      i: 0
                      min: 1
                      name: ws_03
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          alt: ws_03 0
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: ws_03 1
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "#"
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: ws
                i: 0
                min: 12345
                name: nextsame
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws_03: *8
RETREE_END
}
} ## end grammar

# token panic (Str $s) { <commit> <fail($s)> }

## method panic (Str $s)
sub panic {
my $self = shift;
my $s = shift;


my $m;
my $here = $self;

# Have we backed off recently?
my $highvalid = $self->{'_pos'} <= $::HIGHWATER;

$here = $self->cursor($::HIGHWATER) if $highvalid;

my $first = $here->lineof($COMPILING::LAST_NIBBLE->{'_from'});
my $last = $here->lineof($COMPILING::LAST_NIBBLE->{'_pos'});
if ($first != $last) {
if ($here->lineof($here->{'_pos'}) == $last) {
$m .= "\n(Possible runaway string from line $first)";
}
else {
$first = $here->lineof($COMPILING::LAST_NIBBLE_MULTILINE->{'_from'});
$last = $here->lineof($COMPILING::LAST_NIBBLE_MULTILINE->{'_pos'});
# the bigger the string (in lines), the further back we suspect it
if ($here->lineof($here->{'_pos'}) - $last < $last - $first)  {
$m .= "\n(Possible runaway string from line $first to line $last)";
}
}
}

$m .= "\n" . $s;

if ($highvalid) {
$m .= $::HIGHMESS if $::HIGHMESS;
$::HIGHMESS = $m;
}
else {
# not in backoff, so at "bleeding edge", as it were... therefore probably
# the exception will be caught and re-panicked later, so remember message
$::HIGHMESS .= "\n" . $s;
}

$m .= $here->locmess;

if ($highvalid and %$::HIGHEXPECT) {
my @keys = sort keys %$::HIGHEXPECT;
if (@keys > 1) {
$m .= "\n    expecting any of:\n\t" . join("\n\t", sort keys %$::HIGHEXPECT);
}
else {
$m .= "\n    expecting @keys" unless $keys[0] eq 'whitespace';
}
}
$m =~ s|Syntax error|Syntax error (two terms in a row?)| if $m =~ qr/infix|nofun/;

if (@COMPILING::WORRIES) {
$m .= "\nOther potential difficulties:\n  " . join( "\n  ", @COMPILING::WORRIES);
}
$m .= "\n";
$m .= $self->explain_mystery();

die "##### PARSE FAILED #####" . $m;
}

## method worry (Str $s)
sub worry {
my $self = shift;
my $s = shift;


push @COMPILING::WORRIES, $s . $self->locmess;
$self;
}

## method locmess ()
sub locmess {
my $self = shift;


my $pre = substr($::ORIG, 0, $self->{'_pos'});
my $line = $self->lineof($self->{'_pos'});
$pre = substr($pre, -40, 40);
1 while $pre =~ s!.*\n!!;
my $post = substr($::ORIG, $self->{'_pos'}, 40);
1 while $post =~ s!(\n.*)!!;
" at " . $COMPILING::FILE . " line $line:\n------> " . $Cursor::GREEN . $pre . $Cursor::RED . 
"$post$Cursor::CLEAR";
}

## method line
sub line {
my $self = shift;


$self->lineof($self->{'_pos'});
}

## method lineof ($p)
sub lineof {
my $self = shift;
my $p = shift;


return 1 unless defined $p;
my $line = $::MEMOS[$p]{'L'};
return $line if $line;
$line = 0;
my $pos = 0;
my @text = split(qr/^/,$::ORIG);   # XXX p5ism, should be ^^
for (@text) {
$line++;
$::MEMOS[$pos++]{'L'} = $line
for 1 .. length($_);
}
$::MEMOS[$pos++]{'L'} = $line;
return $::MEMOS[$p]{'L'} // 0;
}

## method SETGOAL
sub SETGOAL {
my $self = shift;

}
## method FAILGOAL (Str $stop, Str $name)
sub FAILGOAL {
my $self = shift;
my $stop = shift;
my $name = shift;


$self->panic("Unable to parse $name; couldn't find final '$stop'");
}

# "when" arg assumes more things will become obsolete after Perl 6 comes out...
## method obs (Str $old, Str $new, Str $when = ' in Perl 6')
sub obs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


%$::HIGHEXPECT = ();
$self->panic("Obsolete use of $old;$when please use $new instead");
}

## method worryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub worryobs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


$self->worry("Possible obsolete use of $old;$when please use $new instead");
$self;
}

## vim: expandtab sw=4 ft=perl6
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
POST: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: POST
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: POST
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " @*MEMOS[$.pos]<ws> "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &16 !!perl/hash:RE_any 
            a: 0
            altname: POST_01
            dba: POST
            i: 0
            min: 1
            name: POST_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                alt: POST_01 0
                dba: POST
                i: 0
                min: 12345
                name: unsp
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_string 
                a: 0
                alt: POST_01 1
                dba: POST
                i: 0
                min: 1
                r: 1
                s: 0
                text: \
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: POST
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: POST
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: POST
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_method 
                          a: 0
                          dba: POST
                          i: 0
                          min: 12345
                          name: unsp
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                a: 0
                dba: POST
                i: 0
                min: 12345
                name: postfix_prefix_meta_operator
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: POST
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &58 !!perl/hash:RE_any 
          a: 0
          altname: POST_04
          dba: postfix
          i: 0
          min: 12345
          name: POST_04
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 0
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: dotty
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<dotty><O>;  $<sym> = $<dotty><sym>;  $<~CAPS> = $<dotty><~CAPS>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 1
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: privop
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<privop><O>; $<sym> = $<privop><sym>; $<~CAPS> = $<privop><~CAPS>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 2
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: postop
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<postop><O>; $<sym> = $<postop><sym>; $<~CAPS> = $<postop><~CAPS>; "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: postfix
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SIGIL = '@'; "
POST_01: *16
POST_04: *58
PRE: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix or meta-prefix
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &72 !!perl/hash:RE_any 
          a: 0
          altname: PRE_01
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          name: PRE_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: PRE_01 0
              dba: prefix or meta-prefix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or meta-prefix
                  i: 0
                  min: 12345
                  name: prefix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: prefix or meta-prefix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<prefix><O>; $<sym> = $<prefix><sym> "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'PRE', 'prefix'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: PRE_01 1
              dba: prefix or meta-prefix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or meta-prefix
                  i: 0
                  min: 12345
                  name: prefix_circumfix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: prefix or meta-prefix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.Str "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'PRE', 'precircum'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          name: prefix_postfix_meta_operator
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method_internal 
        args: $S, 'PRE', 'prepost'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix or meta-prefix
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
PRE_01: *72
apostrophe: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass 
    a: 0
    dba: apostrophe
    i: 0
    min: 1
    r: 1
    s: 0
    text: "[ ' \\- ]"
arglist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $inv_ok = $*INVOCANT_OK
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my StrPos $endargs is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = 'endargs'
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INTERPOLATION is context<rw> = 0
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: argument list
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: arglist
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &32 !!perl/hash:RE_any 
          a: 0
          altname: arglist_01
          dba: argument list
          i: 0
          min: 0
          name: arglist_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: arglist_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: argument list
                i: 0
                min: 12345
                name: stdstopper
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: arglist_01 1
              dba: argument list
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %list_infix)
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: argument list
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            my $delims = $<EXPR><delims>;\n            for @$delims {\n                if ($_.<sym> // '') eq ':' {\n                    if $inv_ok {\n                        $*INVOCANT_IS = $<EXPR><list>[0];\n                    }\n                }\n            }\n        "
arglist_01: *32
args: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $listopish = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INVOCANT_OK is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INVOCANT_IS is context<rw>
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: "extra arglist after (...):"
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &113 !!perl/hash:RE_any 
          a: 0
          altname: args_01
          dba: argument list
          i: 0
          min: 0
          name: args_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 0
              dba: argument list
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semiarglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args', 'func args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 1
              dba: argument list
              i: 0
              min: 24692
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semiarglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args', 'func args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 2
              dba: argument list
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: argument list
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $listopish = 1 "
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: argument list
                      i: 0
                      min: 24690
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: argument list
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_meta 
                                a: 0
                                dba: argument list
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \s
                            s: 0
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: argument list
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $istype "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: argument list
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_method 
                            a: 0
                            dba: argument list
                            i: 0
                            min: 12345
                            name: infixstopper
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: argument list
                          i: 0
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: args
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<invocant> = $*INVOCANT_IS; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: "extra arglist after (...):"
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: "extra arglist after (...):"
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " $listopish "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: "extra arglist after (...):"
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: "extra arglist after (...):"
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: "extra arglist after (...):"
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: "extra arglist after (...):"
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \s
                    s: 0
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: "extra arglist after (...):"
                    i: 0
                    min: 12345
                    name: arglist
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: "extra arglist after (...):"
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: moreargs
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: "extra arglist after (...):"
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $<O> = {}; "
args_01: *113
babble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $lang = $l
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $start
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $stop
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: babble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: babble
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: babble
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: babble
                i: 0
                min: 12345
                name: quotepair
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: babble
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: babble
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            my $kv = $<quotepair>[*-1];\n            $lang = $lang.tweak($kv.<k>, $kv.<v>)\n                or self.panic(\"Unrecognized adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: babble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        ($start,$stop) = $.peek_delimiters();\n        $lang = $start ne $stop ?? $lang.balanced($start,$stop)\n                                !! $lang.unbalanced($stop);\n        $<B> = [$lang,$start,$stop];\n    "
block: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scoped block
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: scoped block
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: scoped block
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scoped block
        i: 0
        min: 12345
        name: newpad
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scoped block
        i: 0
        min: 12345
        name: blockoid
        r: 1
        rest: ''
        s: 0
blockoid: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: blockoid
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: temp %*LANG
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: blockoid
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: blockoid
        i: 0
        min: 12345
        name: finishpad
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &138 !!perl/hash:RE_any 
          a: 0
          altname: blockoid_01
          dba: blockoid
          i: 0
          min: 0
          name: blockoid_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_01 0
              dba: blockoid
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: blockoid
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: blockoid
                  extra: "local $::GOAL = '}' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: blockoid
                  i: 0
                  min: 12345
                  name: statementlist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: blockoid
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "}"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: ('}' , 'blockoid')
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_01 1
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 12345
                    name: terminator
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ('Missing block')
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_01 2
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_noop 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Malformed block")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &67 !!perl/hash:RE_any 
          a: 0
          altname: blockoid_02
          dba: blockoid
          i: 0
          min: 0
          name: blockoid_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 0
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 0
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: blockoid
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: blockoid
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: blockoid
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid', 'endstmt simple '
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 1
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: blockoid
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[\\\\,:]"
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid', 'normal '
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 2
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid', 'endstmt complex'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 3
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endargs> = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid', 'endargs'
                  max: 0
                  min: 0
                  name: _REDUCE
blockoid_01: *138
blockoid_02: *67
blorst: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: blorst
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: blorst
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: blorst
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: blorst
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &33 !!perl/hash:RE_any 
          a: 0
          altname: blorst_02
          dba: blorst
          i: 0
          min: 12345
          name: blorst_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: blorst_02 0
              dba: blorst
              i: 0
              min: 12345
              name: block
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: blorst_02 1
              dba: blorst
              i: 0
              min: 12345
              name: statement
              r: 1
              rest: ''
              s: 0
blorst_02: *33
capterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: capterm
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: capterm
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &130 !!perl/hash:RE_any 
          a: 0
          altname: capterm_01
          dba: capterm
          i: 0
          min: 2
          name: capterm_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: capterm_01 0
              dba: capterm
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: capterm
                    i: 0
                    min: 12345
                    name: capture
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: )
            - !!perl/hash:RE_sequence 
              a: 0
              alt: capterm_01 1
              dba: capterm
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: capterm
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: capterm
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \S
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 12345
                  name: termish
                  r: 1
                  rest: ''
                  s: 0
capterm_01: *130
capture: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: capture
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 1
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: capture
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: capture
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
category__S_000category: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_000category
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: category
category__S_001sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_001sigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: sigil
category__S_002twigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_002twigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: twigil
category__S_003special_variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_003special_variable
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: special_variable
category__S_004version: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_004version
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: version
category__S_005module_name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_005module_name
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: module_name
category__S_006noun: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_006noun
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: noun
category__S_007value: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_007value
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: value
category__S_008term: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_008term
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: term
category__S_009number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_009number
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: number
category__S_010quote: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_010quote
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote
category__S_011prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_011prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix
category__S_012infix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_012infix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix
category__S_013postfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_013postfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix
category__S_014dotty: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_014dotty
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: dotty
category__S_015circumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_015circumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: circumfix
category__S_016postcircumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_016postcircumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postcircumfix
category__S_017quote_mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_017quote_mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote_mod
category__S_018trait_mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_018trait_mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: trait_mod
category__S_019type_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_019type_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: type_declarator
category__S_020scope_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_020scope_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: scope_declarator
category__S_021package_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_021package_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: package_declarator
category__S_022multi_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_022multi_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: multi_declarator
category__S_023routine_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_023routine_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: routine_declarator
category__S_024regex_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_024regex_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: regex_declarator
category__S_025statement_prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_025statement_prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_prefix
category__S_026statement_control: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_026statement_control
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_control
category__S_027statement_mod_cond: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_027statement_mod_cond
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_cond
category__S_028statement_mod_loop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_028statement_mod_loop
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_loop
category__S_029infix_prefix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_029infix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_prefix_meta_operator
category__S_030infix_postfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_030infix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_postfix_meta_operator
category__S_031infix_circumfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_031infix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_circumfix_meta_operator
category__S_032postfix_prefix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_032postfix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix_prefix_meta_operator
category__S_033prefix_postfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_033prefix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_postfix_meta_operator
category__S_034prefix_circumfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_034prefix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_circumfix_meta_operator
category__S_035terminator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_035terminator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: terminator
charname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: charname
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &46 !!perl/hash:RE_any 
          a: 0
          altname: charname_01
          dba: charname
          i: 0
          min: 2
          name: charname_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: charname_01 0
              dba: charname
              i: 0
              min: 12345
              name: radint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: charname_01 1
              dba: charname
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_cclass 
                  a: 0
                  dba: charname
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[a..z A..Z]"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_cclass 
                    a: 0
                    dba: charname
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "-[ \\] , # ]"
                  min: 0
                  quant: 
                    - "*"
                    - "?"
                    - ''
                    - 0
                - !!perl/hash:RE_cclass 
                  a: 0
                  dba: charname
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[a..z A..Z ) ]"
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: charname
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: charname
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: charname
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \s
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: charname
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "[ \\] , # ]"
                    s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized character name")
charname_01: *46
charnames: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 37035
      re: !!perl/hash:RE_sequence 
        a: 0
        dba: charnames
        i: 0
        min: 37035
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: charnames
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: charnames
            i: 0
            min: 12345
            name: charname
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: charnames
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
    min: 37035
    quant: 
      - "**"
      - ":"
      - !!perl/hash:RE_string 
        a: 0
        dba: charnames
        i: 0
        min: 1
        r: 1
        s: 0
        text: ","
      - 1
charspec: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &141 !!perl/hash:RE_any 
      a: 0
      altname: charspec_01
      dba: charspec
      i: 0
      min: 0
      name: charspec_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: charspec_01 0
          dba: charspec
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: charspec
              i: 0
              min: 1
              r: 1
              s: 0
              text: "["
            - !!perl/hash:RE_meta 
              a: 0
              dba: charspec
              extra: "local $::GOAL = ']' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: charspec
              i: 0
              min: 12345
              name: charnames
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: charspec
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: charspec
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (']' , 'charspec')
        - !!perl/hash:RE_quantified_atom 
          alt: charspec_01 1
          atom: !!perl/hash:RE_meta 
            a: 0
            dba: charspec
            i: 0
            min: 1
            r: 1
            s: 0
            text: \d
          min: 1
          quant: 
            - +
            - ":"
            - ''
            - 1
        - !!perl/hash:RE_cclass 
          a: 0
          alt: charspec_01 2
          dba: charspec
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ ?..Z \\\\.._ ]"
        - !!perl/hash:RE_sequence 
          a: 0
          alt: charspec_01 3
          dba: charspec
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: charspec
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unrecognized \\c character")
charspec_01: *141
circumfix__S_115Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: circumfix__S_115Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: circumfix__S_115Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &118 !!perl/hash:RE_any 
              a: 0
              altname: circumfix__S_115Cur_Ly_01
              dba: circumfix__S_115Cur_Ly
              i: 0
              min: 1
              name: circumfix__S_115Cur_Ly_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: circumfix__S_115Cur_Ly_01 0
                  dba: circumfix__S_115Cur_Ly
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_method 
                  a: 0
                  alt: circumfix__S_115Cur_Ly_01 1
                  dba: circumfix__S_115Cur_Ly
                  i: 0
                  min: 12345
                  name: lambda
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: circumfix__S_115Cur_Ly
        i: 0
        min: 12345
        name: pblock
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: circumfix__S_115Cur_Ly
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        if $*BORG {\n            $*BORG.<block> = $<pblock>;\n        }\n    "
circumfix__S_115Cur_Ly_01: *118
circumfix__S_303sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: contextualizer
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: contextualizer
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: contextualizer
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: contextualizer
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: contextualizer
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: contextualizer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: contextualizer
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'contextualizer')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: contextualizer
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SIGIL ||= $<sigil>.Str "
circumfix__S_304Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parenthesized expression
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: parenthesized expression
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: parenthesized expression
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: parenthesized expression
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: parenthesized expression
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: parenthesized expression
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'parenthesized expression')
circumfix__S_305Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: array composer
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: array composer
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_meta 
        a: 0
        dba: array composer
        extra: "local $::GOAL = ']' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: array composer
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: array composer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: array composer
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'array composer')
colonpair: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: colonpair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $key
    - !!perl/hash:RE_decl 
      a: 0
      dba: colonpair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $value
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: colon pair
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: colonpair
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &40 !!perl/hash:RE_any 
          a: 0
          altname: colonpair_01
          dba: signature
          i: 0
          min: 12345
          name: colonpair_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 0
              dba: colon pair
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; $value = 0; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair', 'false'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 1
              dba: colon pair
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: colon pair
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: num
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 2
              dba: colon pair
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: colon pair
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: colon pair
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: colon pair
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: colon pair
                            i: 0
                            min: 12345
                            name: postcircumfix
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: colon pair
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $value = $<postcircumfix>; "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: colon pair
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $value = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair', 'value'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 3
              dba: signature
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: signature
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: signature
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: fakesignature
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: signature
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: signature
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'signature')
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 4
              dba: signature
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: signature
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = \"\"; $value = $<postcircumfix>; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair', 'structural'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 5
              dba: signature
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 24690
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: signature
                      i: 0
                      min: 24690
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: signature
                          i: 0
                          min: 12345
                          name: sigil
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: signature
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: signature
                            i: 0
                            min: 12345
                            name: twigil
                            r: 1
                            rest: ''
                            s: 0
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: signature
                          i: 0
                          min: 12345
                          name: desigilname
                          r: 1
                          rest: ''
                          s: 0
                  dba: signature
                  i: 0
                  min: 24690
                  r: 1
                  s: 0
                  var: var
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: signature
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<var><desigilname>.Str; $value = $<var>; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair', 'varname'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: colon pair
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<k> = $key; $<v> = $value; "
colonpair_01: *40
comp_unit: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $begin_compunit is context = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $endargs        is context<rw> = -1
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my %LANG is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PKGDECL is context = ""
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PKGNAME is context = "GLOBAL"
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my @PKGS is context<rw> = ()
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INTERPOLATION is context<rw> = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_META is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $QUASI_QUASH is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $SCOPE is context = ""
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $SIGIL is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my %MYSTERY is context<rw> = ()
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my @MEMOS is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $VOID is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_IS is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $CURPAD is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $REALLYADD is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $MULTINESS is context = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $CORE is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $CORESETTING is context = "CORE"
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $GLOBAL is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $CURPKG is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $UNIT is context
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: comp_unit
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        text: "\n\n        %*LANG<MAIN>    = ::STD ;\n        %*LANG<Q>       = ::STD::Q ;\n        %*LANG<Quasi>   = ::STD::Quasi ;\n        %*LANG<Regex>   = ::STD::Regex ;\n        %*LANG<Trans>   = ::STD::Trans ;\n        %*LANG<P5Regex> = ::STD::P5Regex ;\n\n        @COMPILING::WORRIES = ();\n        self.load_setting($*CORESETTING);\n        $*UNIT = self.newpad;\n        self.finishpad(1);\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: comp_unit
        i: 0
        min: 12345
        name: statementlist
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: comp_unit
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: comp_unit
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method 
                    a: 0
                    dba: comp_unit
                    i: 0
                    min: 12345
                    name: unitstopper
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: comp_unit
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Can't understand next input--giving up")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        text: "\n        if @COMPILING::WORRIES {\n            warn \"Potential difficulties:\\n  \" ~ join( \"\\n  \", @COMPILING::WORRIES) ~ \"\\n\";\n        }\n        my $m = $.explain_mystery();\n        warn $m if $m;\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
constant_declarator: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: constant_declarator
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: constant_declarator
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: constant_declarator
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: constant_declarator
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*SCOPE eq 'constant' "
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: constant_declarator
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $.is_name($<identifier>.Str) "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: constant_declarator
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*IN_DECL = 0; self.add_name($<identifier>.Str) "
      - !!perl/hash:RE_method 
        a: 0
        dba: constant_declarator
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: constant_declarator
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
dec_number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: decimal number
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &122 !!perl/hash:RE_any 
          a: 0
          altname: dec_number_01
          dba: decimal number
          i: 0
          min: 2
          name: dec_number_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: dec_number_01 0
              dba: decimal number
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 2
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: decimal number
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  var: coeff
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 12345
                    name: escale
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: dec_number_01 1
              dba: decimal number
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 3
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 3
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: decimal number
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  var: coeff
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 12345
                    name: escale
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: dec_number_01 2
              dba: decimal number
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: decimal number
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: coeff
                - !!perl/hash:RE_method 
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 12345
                  name: escale
                  r: 1
                  rest: ''
                  s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method_re 
            a: 0
            dba: decimal number
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE 
              decl: []

              min: 0
              re: !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: decimal number
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_meta 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Number contains two decimal points (missing 'v' for version number?)")
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
            s: 0
dec_number_01: *122
declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &14 !!perl/hash:RE_any 
      a: 0
      altname: declarator_01
      dba: declarator
      i: 0
      min: 12345
      name: declarator_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 0
          dba: declarator
          i: 0
          min: 12345
          name: constant_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 1
          dba: declarator
          i: 0
          min: 12345
          name: variable_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: declarator_01 2
          dba: declarator
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: declarator
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_meta 
              a: 0
              dba: declarator
              extra: "local $::GOAL = ')' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: declarator
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: declarator
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: declarator
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (')' , 'declarator')
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: declarator
                i: 0
                min: 12345
                name: trait
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 3
          dba: declarator
          i: 0
          min: 12345
          name: routine_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 4
          dba: declarator
          i: 0
          min: 12345
          name: regex_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 5
          dba: declarator
          i: 0
          min: 12345
          name: type_declarator
          r: 1
          rest: ''
          s: 0
declarator_01: *14
def_module_name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: def_module_name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: def_module_name
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 37037
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: generic role
            i: 0
            min: 37037
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: generic role
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " ($*PKGDECL//'') eq 'role' "
              - !!perl/hash:RE_method 
                a: 0
                dba: generic role
                i: 0
                min: 12345
                name: newpad
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: generic role
                i: 0
                min: 1
                r: 1
                s: 0
                text: "["
              - !!perl/hash:RE_meta 
                a: 0
                dba: generic role
                extra: "local $::GOAL = ']' "
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: generic role
                i: 0
                min: 12345
                name: signature
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: generic role
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: generic role
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "]"
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (']' , 'generic role')
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: generic role
                i: 0
                min: 0
                r: 1
                s: 0
                text: " $*IN_DECL = 0; "
              - !!perl/hash:RE_method 
                a: 0
                dba: generic role
                i: 0
                min: 12345
                name: finishpad
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
default_value: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: default_value
    i: 0
    min: 1
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_string 
        a: 0
        dba: default_value
        i: 0
        min: 1
        r: 1
        s: 1
        text: =
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: EXPR
        rest: (item %item_assignment)
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
deflongname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: new name to be defined
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: new name to be defined
        i: 0
        min: 12345
        name: name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &8 !!perl/hash:RE_any 
          a: 0
          altname: deflongname_01
          dba: new name to be defined
          i: 0
          min: 0
          name: deflongname_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: deflongname_01 0
              dba: new name to be defined
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: new name to be defined
                    i: 0
                    min: 12345
                    name: colonpair
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: new name to be defined
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $.add_macro($<name>) if $*IN_DECL; "
            - !!perl/hash:RE_block 
              a: 0
              alt: deflongname_01 1
              context: void
              dba: new name to be defined
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $.add_routine($<name>.Str) if $*IN_DECL; "
deflongname_01: *8
desigilname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &106 !!perl/hash:RE_any 
      a: 0
      altname: desigilname_01
      dba: desigilname
      i: 0
      min: 12345
      name: desigilname_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: desigilname_01 0
          dba: desigilname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: desigilname
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: desigilname
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: $
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: desigilname
              i: 0
              min: 12345
              name: variable
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: desigilname
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $*VAR = $<variable> "
        - !!perl/hash:RE_method 
          a: 0
          alt: desigilname_01 1
          dba: desigilname
          i: 0
          min: 12345
          name: longname
          r: 1
          rest: ''
          s: 0
desigilname_01: *106
dotty__S_098DotStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: dotty__S_098DotStar
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: dotty__S_098DotStar
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: dotty__S_098DotStar
                i: 0
                min: 1
                r: 1
                s: 0
                text: .
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: &24 !!perl/hash:RE_any 
                  a: 0
                  altname: dotty__S_098DotStar_02
                  dba: dotty__S_098DotStar
                  i: 0
                  min: 1
                  name: dotty__S_098DotStar_02
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_cclass 
                      a: 0
                      alt: dotty__S_098DotStar_02 0
                      dba: dotty__S_098DotStar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "[+*?=]"
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: dotty__S_098DotStar_02 1
                      dba: dotty__S_098DotStar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: dotty__S_098DotStar
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "^"
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: dotty__S_098DotStar
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "!"
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
        min: 2
        var: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: dotty__S_098DotStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_098DotStar
        i: 0
        min: 12345
        name: unspacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_098DotStar
        i: 0
        min: 12345
        name: dottyop
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: dotty__S_098DotStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $0.Str; "
dotty__S_098DotStar_02: *24
dotty__S_099Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: dotty__S_099Dot
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_099Dot
        endsym: unspacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: .
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_099Dot
        i: 0
        min: 12345
        name: unspacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_099Dot
        i: 0
        min: 12345
        name: dottyop
        r: 1
        rest: ''
        s: 0
dottyop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &108 !!perl/hash:RE_any 
      a: 0
      altname: dottyop_01
      dba: dotty method or postfix
      i: 0
      min: 12345
      name: dottyop_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: dottyop_01 0
          dba: dotty method or postfix
          i: 0
          min: 12345
          name: methodop
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: dottyop_01 1
          dba: dotty method or postfix
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: dottyop_01 2
          dba: dotty method or postfix
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: dotty method or postfix
                i: 0
                min: 12345
                name: alpha
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: dotty method or postfix
              i: 0
              min: 12345
              name: postop
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: dotty method or postfix
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $<O> = $<postop><O>; $<sym> = $<postop><sym>; "
dottyop_01: *108
dottyopish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: dottyopish
      i: 0
      min: 12345
      name: dottyop
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: dottyopish
    i: 0
    min: 12345
    r: 1
    s: 0
    var: noun
eat_terminator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: !!perl/hash:RE_first 
      a: 0
      dba: eat_terminator
      i: 0
      min: 0
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_string 
          a: 0
          dba: eat_terminator
          i: 0
          min: 1
          r: 1
          s: 0
          text: ;
        - !!perl/hash:RE_sequence 
          a: 0
          dba: eat_terminator
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: eat_terminator
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " @*MEMOS[$.pos]<endstmt> "
            - !!perl/hash:RE_method 
              a: 0
              dba: eat_terminator
              i: 0
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
        - !!perl/hash:RE_assertion 
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method 
            a: 0
            dba: eat_terminator
            i: 0
            min: 12345
            name: terminator
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_meta 
          a: 0
          dba: eat_terminator
          i: 0
          min: 0
          r: 1
          s: 0
          text: $
        - !!perl/hash:RE_sequence 
          a: 0
          dba: eat_terminator
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: eat_terminator
              i: 0
              min: 0
              r: 1
              s: 0
              text: " if @*MEMOS[$.pos]<ws> { $.pos = @*MEMOS[$.pos]<ws>; } "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Syntax error")
endid: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: endid
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: !!perl/hash:RE_cclass 
          a: 0
          dba: endid
          i: 0
          min: 1
          r: 1
          s: 0
          text: -[ \- \' \w ]
      s: 0
escale: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escale
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_cclass 
        a: 0
        dba: escale
        i: 0
        min: 1
        r: 1
        s: 0
        text: "[Ee]"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: escale
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[+\\-]"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: escale
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: escale
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: escale
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: escale
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
escape__S_208none: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_208none
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
fakesignature: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: fakesignature
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: fakesignature
        i: 0
        min: 12345
        name: newpad
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: fakesignature
        i: 0
        min: 12345
        name: signature
        r: 1
        rest: ''
        s: 0
fatarrow: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: fatarrow
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: fatarrow
          i: 0
          min: 12345
          name: identifier
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: fatarrow
        i: 0
        min: 12345
        r: 1
        s: 0
        var: key
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: fatarrow
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: fatarrow
        i: 0
        min: 2
        r: 1
        s: 0
        text: =>
      - !!perl/hash:RE_method 
        a: 0
        dba: fatarrow
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: EXPR
          nobind: 1
          rest: (item %item_assignment)
        dba: fatarrow
        i: 0
        min: 0
        r: 1
        s: 0
        var: val
foo: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: foo
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: foo
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_bracket 
              decl: []

              min: 12345
              re: &10 !!perl/hash:RE_any 
                a: 0
                altname: foo_02
                dba: foo
                i: 0
                min: 12345
                name: foo_02
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: foo_02 0
                    dba: foo
                    i: 0
                    min: 12345
                    name: ident
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: foo_02 1
                    dba: foo
                    i: 0
                    min: 12345
                    name: number
                    r: 1
                    rest: ''
                    s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &136 !!perl/hash:RE_any 
          a: 0
          altname: foo_03
          dba: foo
          i: 0
          min: 12345
          name: foo_03
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: foo_03 0
              dba: foo
              i: 0
              min: 12345
              name: ident
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: foo_03 1
              dba: foo
              i: 0
              min: 12345
              name: number
              r: 1
              rest: ''
              s: 0
foo_02: *10
foo_03: *136
hexint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: hexint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: hexint
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ 0..9 a..f A..F ]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: hexint
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: hexint
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_cclass 
                  a: 0
                  dba: hexint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[ 0..9 a..f A..F ]"
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
hexints: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 37035
      re: !!perl/hash:RE_sequence 
        a: 0
        dba: hexints
        i: 0
        min: 37035
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: hexints
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: hexints
            i: 0
            min: 12345
            name: hexint
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: hexints
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
    min: 37035
    quant: 
      - "**"
      - ":"
      - !!perl/hash:RE_string 
        a: 0
        dba: hexints
        i: 0
        min: 1
        r: 1
        s: 0
        text: ","
      - 1
ident: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: ident
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: ident
        i: 0
        min: 12345
        name: alpha
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: ident
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
identifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: identifier
        i: 0
        min: 12345
        name: ident
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: identifier
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: identifier
                i: 0
                min: 12345
                name: apostrophe
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: identifier
                i: 0
                min: 12345
                name: ident
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
infix__S_302lambda: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_302lambda
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_302lambda
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &104 !!perl/hash:RE_any 
              a: 0
              altname: infix__S_302lambda_01
              dba: infix__S_302lambda
              i: 0
              min: 1
              name: infix__S_302lambda_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: infix__S_302lambda_01 0
                  dba: infix__S_302lambda
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: infix__S_302lambda_01 1
                  dba: infix__S_302lambda
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: ->
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_302lambda
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        my $line = $.lineof($.pos);\n        for 'if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when' {\n            my $m = %*MYSTERY{$_};\n            next unless $m;\n            if $line - ($m.<line>//-123) < 5 {\n                $.panic(\"$_() interpreted as function call at line \" ~ $m.<line> ~\n                \"; please use whitespace instead of parens\\nUnexpected block in infix position (two terms in a row)\");\n            }\n        }\n        return () if $*IN_REDUCE;\n        $.panic(\"Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)\");\n    "
infix__S_302lambda_01: *104
infix__S_307Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_307Dot
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix__S_307Dot
        i: 0
        min: 1
        r: 1
        s: 0
        text: .
      - !!perl/hash:RE_cclass 
        a: 0
        dba: infix__S_307Dot
        i: 0
        min: 1
        r: 1
        s: 0
        text: "[\\]\\)\\},:\\s\\$\"']"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('. to concatenate strings', '~')
infix__S_313StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Exponentiation
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_313StarStar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "**"
infix__S_324Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_324Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
infix__S_325Slash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_325Slash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: /
infix__S_326div: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_326div
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: div
infix__S_327Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_327Percent
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_327Percent
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_327Percent
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><iffy> = 1; "
infix__S_328mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_328mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod
infix__S_329PlusAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_329PlusAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +&
infix__S_330PlusLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_330PlusLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_330PlusLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +<
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_330PlusLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_330PlusLt
              i: 0
              min: 1
              r: 1
              s: 0
              text: <
          s: 0
infix__S_331LtLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_331LtLt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_331LtLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <<
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_331LtLt
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('<< to do left shift', '+< or ~<')
infix__S_332GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_332GtGt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_332GtGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ">>"
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_332GtGt
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('>> to do right shift', '+> or ~>')
infix__S_333PlusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_333PlusGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_333PlusGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +>
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_333PlusGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_333PlusGt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
          s: 0
infix__S_334TildeAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_334TildeAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~&
infix__S_335QuestionAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_335QuestionAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?&
infix__S_336TildeLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_336TildeLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_336TildeLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~<
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_336TildeLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_336TildeLt
              i: 0
              min: 1
              r: 1
              s: 0
              text: <
          s: 0
infix__S_337TildeGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_337TildeGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_337TildeGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~>
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_337TildeGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_337TildeGt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
          s: 0
infix__S_338Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_338Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
infix__S_339Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_339Minus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "-"
infix__S_340PlusVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_340PlusVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +|
infix__S_341PlusCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_341PlusCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +^
infix__S_342TildeVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_342TildeVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~|
infix__S_343TildeCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_343TildeCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~^
infix__S_344QuestionVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_344QuestionVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?|
infix__S_345QuestionCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_345QuestionCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?^
infix__S_346x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Replication
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_346x
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: x
infix__S_347xx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Replication
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_347xx
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: xx
infix__S_348Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Concatenation
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_348Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
infix__S_349Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_349Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
infix__S_350also: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_350also
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: also
infix__S_351Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_351Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
infix__S_352Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_352Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
infix__S_357LtEqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_357LtEqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_357LtEqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <=>
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_357LtEqualGt
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_358cmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_358cmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_358cmp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: cmp
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_358cmp
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_359leg: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_359leg
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_359leg
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: leg
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_359leg
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_360but: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_360but
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: but
infix__S_361does: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_361does
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: does
infix__S_362DotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_362DotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_362DotDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ..
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: infix__S_362DotDot
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix__S_362DotDot
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $*IN_META "
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: infix__S_362DotDot
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &139 !!perl/hash:RE_any 
                      a: 0
                      altname: infix__S_362DotDot_02
                      dba: infix__S_362DotDot
                      i: 0
                      min: 1
                      name: infix__S_362DotDot_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: infix__S_362DotDot_02 0
                          dba: infix__S_362DotDot
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: infix__S_362DotDot_02 1
                          dba: infix__S_362DotDot
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Please use ..* for indefinite range")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
infix__S_362DotDot_02: *139
infix__S_363CaretDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_363CaretDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^.."
infix__S_364DotDotCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_364DotDotCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ..^
infix__S_365CaretDotDotCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_365CaretDotDotCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^..^"
infix__S_366EqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_366EqualEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_366EqualEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_366EqualEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_366EqualEqual
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
          s: 0
infix__S_367BangEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_367BangEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_367BangEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!="
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_367BangEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: infix__S_367BangEqual
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
infix__S_368Lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_368Lt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <
infix__S_369LtEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_369LtEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <=
infix__S_370Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_370Gt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ">"
infix__S_371GtEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_371GtEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ">="
infix__S_372TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_372TildeTilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~~
infix__S_373BangTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_373BangTilde
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_373BangTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!~"
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_373BangTilde
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('!~ to do negated pattern matching', '!~~')
infix__S_374EqualTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_374EqualTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_374EqualTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =~
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('=~ to do pattern matching', '~~')
infix__S_375eq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_375eq
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: eq
infix__S_376ne: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_376ne
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ne
infix__S_377lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_377lt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: lt
infix__S_378le: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_378le
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: le
infix__S_379gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_379gt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: gt
infix__S_380ge: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_380ge
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ge
infix__S_381EqualColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_381EqualColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =:=
infix__S_382EqualEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_382EqualEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ===
infix__S_383eqv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_383eqv
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: eqv
infix__S_384before: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_384before
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: before
infix__S_385after: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_385after
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: after
infix__S_386AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_386AmpAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&&"
infix__S_387VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_387VertVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "||"
infix__S_388CaretCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_388CaretCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^^"
infix__S_389SlashSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_389SlashSlash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: //
infix__S_390min: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_390min
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: min
infix__S_391max: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_391max
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: max
infix__S_392QuestionQuestion_BangBang: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: infix__S_392QuestionQuestion_BangBang
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '!!'
  kind: token
  min: 12347
  pkg: STD::Conditional
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_392QuestionQuestion_BangBang
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix__S_392QuestionQuestion_BangBang
        i: 0
        min: 2
        r: 1
        s: 0
        text: ??
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_392QuestionQuestion_BangBang
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: EXPR
        rest: (item %item_assignment)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix__S_392QuestionQuestion_BangBang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: infix__S_392QuestionQuestion_BangBang
              i: 0
              min: 2
              r: 1
              s: 0
              text: "!!"
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: !!perl/hash:RE_first 
                a: 0
                dba: infix__S_392QuestionQuestion_BangBang
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_392QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_392QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_string 
                              a: 0
                              dba: infix__S_392QuestionQuestion_BangBang
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: =
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Assignment not allowed within ??!!")
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_392QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_392QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_string 
                              a: 0
                              dba: infix__S_392QuestionQuestion_BangBang
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              text: "::"
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Please use !! rather than ::")
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_392QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_392QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 12345
                            re: !!perl/hash:RE_method 
                              a: 0
                              dba: infix__S_392QuestionQuestion_BangBang
                              i: 0
                              min: 12345
                              name: infixish
                              r: 1
                              rest: ''
                              s: 0
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Precedence too loose within ??!!; use ??()!! instead ")
                  - !!perl/hash:RE_method 
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Found ?? but no !!; possible precedence problem")
infix__S_393Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_393Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_393Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: "('?: for the conditional operator', '??!!')"
infix__S_394ff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_394ff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ff
infix__S_395Caretff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_395Caretff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^ff"
infix__S_396ffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_396ffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ff^
infix__S_397CaretffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_397CaretffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^ff^"
infix__S_398fff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_398fff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: fff
infix__S_399Caretfff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_399Caretfff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^fff"
infix__S_400fffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_400fffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: fff^
infix__S_401CaretfffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_401CaretfffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^fff^"
infix__S_402Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_402Equal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_402Equal
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_402Equal
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $ = $*SIGIL eq '$' \n        ?? ::Item_assignment.coerce($)\n        !! ::List_assignment.coerce($);\n    "
infix__S_403ColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_403ColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: :=
infix__S_404ColonColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_404ColonColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ::=
infix__S_405DotEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_405DotEqual
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_405DotEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: .=
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_405DotEqual
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix__S_405DotEqual
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix__S_405DotEqual
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 2
                  re: &89 !!perl/hash:RE_any 
                    a: 0
                    altname: infix__S_405DotEqual_02
                    dba: infix__S_405DotEqual
                    i: 0
                    min: 2
                    name: infix__S_405DotEqual_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: infix__S_405DotEqual_02 0
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: infix__S_405DotEqual
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \w
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: infix__S_405DotEqual
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: ;
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_405DotEqual_02 1
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: new
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_405DotEqual_02 2
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: sort
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_405DotEqual_02 3
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: subst
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_405DotEqual_02 4
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: trans
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_405DotEqual_02 5
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 7
                        r: 1
                        s: 0
                        text: reverse
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_405DotEqual_02 6
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: uniq
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_405DotEqual_02 7
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: map
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_405DotEqual_02 8
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 8
                        r: 1
                        s: 0
                        text: samecase
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_405DotEqual_02 9
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 6
                        r: 1
                        s: 0
                        text: substr
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_405DotEqual_02 10
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: flip
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_405DotEqual_02 11
                        dba: infix__S_405DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: fmt
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: worryobs
              rest: ('.= as append operator', '~=')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_405DotEqual
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><nextterm> = 'dottyopish' "
infix__S_405DotEqual_02: *89
infix__S_406EqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_406EqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_406EqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =>
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_406EqualGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><fiddly> = 0; "
infix__S_409Comma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_409Comma
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_409Comma
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ","
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_409Comma
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><fiddly> = 0; "
infix__S_410Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_410Colon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_410Colon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_410Colon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &78 !!perl/hash:RE_any 
              a: 0
              altname: infix__S_410Colon_01
              dba: infix__S_410Colon
              i: 0
              min: 1
              name: infix__S_410Colon_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: infix__S_410Colon_01 0
                  dba: infix__S_410Colon
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_method 
                  a: 0
                  alt: infix__S_410Colon_01 1
                  dba: infix__S_410Colon
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_410Colon
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.panic(\"Illegal use of colon as invocant marker\") unless $*INVOCANT_OK--; "
infix__S_410Colon_01: *78
infix__S_411p5EqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_411p5EqualGt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: p5=>
infix__S_412Z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_412Z
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: Z
infix__S_413minmax: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_413minmax
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: minmax
infix__S_414DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_414DotDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ...
infix__S_421and: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_421and
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: and
infix__S_422andthen: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_422andthen
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: andthen
infix__S_423or: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_423or
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: or
infix__S_424orelse: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_424orelse
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: orelse
infix__S_425xor: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_425xor
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: xor
infix__S_426LtEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_426LtEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <==
infix__S_427EqualEqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_427EqualEqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_427EqualEqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==>
      - !!perl/hash:RE_method_internal 
        args: $S, 'infix__S_427EqualEqualGt'
        max: 0
        min: 0
        name: _REDUCE
infix__S_428LtLtEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_428LtLtEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <<==
infix__S_429EqualEqualGtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_429EqualEqualGtGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_429EqualEqualGtGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==>>
      - !!perl/hash:RE_method_internal 
        args: $S, 'infix__S_429EqualEqualGtGt'
        max: 0
        min: 0
        name: _REDUCE
infix_circumfix_meta_operator__S_106Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_circumfix_meta_operator__S_106Fre_Nch
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &47 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_106Fre_Nch_01
          dba: infix_circumfix_meta_operator__S_106Fre_Nch
          i: 0
          min: 1
          name: infix_circumfix_meta_operator__S_106Fre_Nch_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_106Fre_Nch_01 0
              dba: infix_circumfix_meta_operator__S_106Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_106Fre_Nch_01 1
              dba: infix_circumfix_meta_operator__S_106Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_circumfix_meta_operator__S_106Fre_Nch
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &49 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_106Fre_Nch_02
          dba: infix_circumfix_meta_operator__S_106Fre_Nch
          i: 0
          min: 1
          name: infix_circumfix_meta_operator__S_106Fre_Nch_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_106Fre_Nch_02 0
              dba: infix_circumfix_meta_operator__S_106Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_106Fre_Nch_02 1
              dba: infix_circumfix_meta_operator__S_106Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<infixish>, "hyper")
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_circumfix_meta_operator__S_106Fre_Nch
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> := $<infixish><O>; "
infix_circumfix_meta_operator__S_106Fre_Nch_01: *47
infix_circumfix_meta_operator__S_106Fre_Nch_02: *49
infix_circumfix_meta_operator__S_107LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &53 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_107LtLt_GtGt_01
          dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
          i: 0
          min: 2
          name: infix_circumfix_meta_operator__S_107LtLt_GtGt_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_107LtLt_GtGt_01 0
              dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: <<
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_107LtLt_GtGt_01 1
              dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &34 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_107LtLt_GtGt_02
          dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
          i: 0
          min: 2
          name: infix_circumfix_meta_operator__S_107LtLt_GtGt_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_107LtLt_GtGt_02 0
              dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: <<
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_107LtLt_GtGt_02 1
              dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<infixish>, "hyper")
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> := $<infixish><O>; "
infix_circumfix_meta_operator__S_107LtLt_GtGt_01: *53
infix_circumfix_meta_operator__S_107LtLt_GtGt_02: *34
infix_postfix_meta_operator__S_108Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_postfix_meta_operator__S_108Equal
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix_postfix_meta_operator__S_108Equal
        i: 0
        min: 1
        r: 1
        s: 0
        text: =
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($op, "make assignment out of")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix_postfix_meta_operator__S_108Equal
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix_postfix_meta_operator__S_108Equal
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " $op<O><diffy> "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't make assignment out of a " ~ $op<O><dba> ~ " operator because it's diffy")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_postfix_meta_operator__S_108Equal
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O> = $op<O>; $<O><prec>:delete; $<O><fiddly> = 1; "
infix_prefix_meta_operator__S_103Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_103Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_103Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix_prefix_meta_operator__S_103Bang
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix_prefix_meta_operator__S_103Bang
              i: 0
              min: 1
              r: 1
              s: 0
              text: "!"
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_prefix_meta_operator__S_103Bang
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix_prefix_meta_operator__S_103Bang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: infix_prefix_meta_operator__S_103Bang
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix_prefix_meta_operator__S_103Bang
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $<infixish>.Str eq '=' "
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix_prefix_meta_operator__S_103Bang
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $ = ::Chaining.coerce($); "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: infix_prefix_meta_operator__S_103Bang
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: can_meta
                  nobind: 1
                  rest: ($<infixish>, "negate")
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix_prefix_meta_operator__S_103Bang
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $<infixish><O><iffy> "
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix_prefix_meta_operator__S_103Bang
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $<O> = $<infixish><O>; "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't negate a " ~ $<infixish><O><dba> ~ " operator because it's not iffy enough")
infix_prefix_meta_operator__S_104R: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_104R
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_104R
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: R
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_prefix_meta_operator__S_104R
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<infixish>, "reverse")
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_prefix_meta_operator__S_104R
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> = $<infixish><O>; "
infix_prefix_meta_operator__S_105X: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_105X
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_105X
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: X
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_prefix_meta_operator__S_105X
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: infix_prefix_meta_operator__S_105X
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: infixish
                rest: (1)
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix_prefix_meta_operator__S_105X
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: infix_prefix_meta_operator__S_105X
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: X
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Old form of XopX found")
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                min: 0
                name: can_meta
                nobind: 1
                rest: ($<infixish>[0], "cross")
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix_prefix_meta_operator__S_105X
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $<O> = $<infixish>[0]<O>; $<O><prec>:delete; $<sym> ~= $<infixish>[0].Str "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
infixish: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: infixish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $infix
    - !!perl/hash:RE_decl 
      a: 0
      dba: infixish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_META is context<rw> = $in_meta
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix or meta-infix
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &127 !!perl/hash:RE_any 
          a: 0
          altname: infixish_01
          dba: infix or meta-infix
          i: 0
          min: 2
          name: infixish_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 0
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            $<fake> = 1;\n            $<sym> = ':';\n            %<O><prec> = %item_assignment<prec>;  # actual test is non-inclusive!\n            %<O><assoc> = 'unary';\n            %<O><kind> = 'ADVERB';\n        "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 1
              dba: infix or meta-infix
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: infix or meta-infix
                  extra: "local $::GOAL = ']' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  min: 0
                  name: infixish
                  rest: (1)
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: infix or meta-infix
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: infix or meta-infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'infix or meta-infix')
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infixish><O>; $<sym> = $<infixish><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 2
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix_circumfix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_circumfix_meta_operator><O>;\n          $<sym> = $<infix_circumfix_meta_operator><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 3
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix_prefix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_prefix_meta_operator><O>;\n          $<sym> = $<infix_prefix_meta_operator><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 4
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: infix or meta-infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix>.<O>; $<sym> = $<infix>.<sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 5
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: infix or meta-infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                    s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $infix = $<infix>; "
                - !!perl/hash:RE_method 
                  min: 0
                  name: infix_postfix_meta_operator
                  rest: ($infix)
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_postfix_meta_operator>.<O>; $<sym> = $<infix_postfix_meta_operator>.<sym>; "
infixish_01: *127
infixstopper: !!perl/hash:RE 
  decl: []

  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &66 !!perl/hash:RE_any 
      a: 0
      altname: infixstopper_01
      dba: infix stopper
      i: 0
      min: 0
      name: infixstopper_01
      r: 0
      s: 0
      zyg: 
        - !!perl/hash:RE_assertion 
          alt: infixstopper_01 0
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method_re 
            a: 0
            dba: infix stopper
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 0
            re: !!perl/hash:RE 
              decl: []

              min: 12345
              re: !!perl/hash:RE_method 
                a: 0
                dba: infix stopper
                i: 0
                min: 12345
                name: stopper
                r: 0
                rest: ''
                s: 0
            s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: infixstopper_01 1
          dba: infix stopper
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix stopper
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 2
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: infix stopper
                    i: 0
                    min: 2
                    r: 0
                    s: 0
                    text: "!!"
                s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix stopper
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $*GOAL eq '!!' "
        - !!perl/hash:RE_sequence 
          a: 0
          alt: infixstopper_01 2
          dba: infix stopper
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix stopper
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: &98 !!perl/hash:RE_any 
                    a: 0
                    altname: infixstopper_04
                    dba: infix stopper
                    i: 0
                    min: 1
                    name: infixstopper_04
                    r: 0
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infixstopper_04 0
                        dba: infix stopper
                        i: 0
                        min: 1
                        r: 0
                        s: 0
                        text: "{"
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: infixstopper_04 1
                        dba: infix stopper
                        i: 0
                        min: 12345
                        name: lambda
                        r: 0
                        rest: ''
                        s: 0
                s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix stopper
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " ($*GOAL eq '{' or $*GOAL eq 'endargs') and @*MEMOS[$.pos]<ws> "
        - !!perl/hash:RE_assertion 
          alt: infixstopper_01 3
          assert: "?"
          min: 0
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: infix stopper
            i: 0
            min: 0
            nobind: 1
            r: 0
            s: 0
            text: " $*GOAL eq 'endargs' and @*MEMOS[$.pos]<endargs> "
infixstopper_01: *66
infixstopper_04: *98
integer: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: integer
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &125 !!perl/hash:RE_any 
          a: 0
          altname: integer_01
          dba: integer
          i: 0
          min: 1
          name: integer_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: integer_01 0
              dba: integer
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: integer
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: &50 !!perl/hash:RE_any 
                    a: 0
                    altname: integer_02
                    dba: integer
                    i: 0
                    min: 1
                    name: integer_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 0
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: b
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[01]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[01]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 1
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: o
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[0..7]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[0..7]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 2
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: x
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[0..9a..fA..F]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[0..9a..fA..F]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 3
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: d
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_meta 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: \d
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 4
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_meta 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: \d
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_assertion 
                            assert: "!"
                            min: 0
                            re: !!perl/hash:RE_assertion 
                              assert: "!"
                              min: 0
                              nobind: 1
                              re: !!perl/hash:RE_block 
                                a: 0
                                context: bool
                                dba: integer
                                i: 0
                                min: 0
                                nobind: 1
                                r: 1
                                s: 0
                                text: " $.worry(\"Leading 0 does not indicate octal in Perl 6\") "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: integer_01 1
              dba: integer
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: integer
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \d
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: integer
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: _
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method_re 
            a: 0
            dba: integer
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE 
              decl: []

              min: 0
              re: !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: integer
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: integer
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: &126 !!perl/hash:RE_any 
                              a: 0
                              altname: integer_11
                              dba: integer
                              i: 0
                              min: 1
                              name: integer_11
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_meta 
                                  a: 0
                                  alt: integer_11 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \s
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: integer_11 1
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: ","
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: integer_11 2
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: =
                                - !!perl/hash:RE_method 
                                  a: 0
                                  alt: integer_11 3
                                  dba: integer
                                  i: 0
                                  min: 12345
                                  name: terminator
                                  r: 1
                                  rest: ''
                                  s: 0
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Decimal point must be followed by digit")
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
            s: 0
integer_01: *125
integer_02: *50
integer_11: *126
label: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: label
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $label
  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: label
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: label
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: label
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: label
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: label
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: label
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: label
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: label
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $.is_name($label = $<identifier>.Str) "
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Illegal redeclaration of '$label'")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: label
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.add_my_name($label); "
lambda: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &111 !!perl/hash:RE_any 
    a: 0
    altname: lambda_00
    dba: lambda
    i: 0
    min: 2
    name: lambda_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        alt: lambda_00 0
        dba: lambda
        i: 0
        min: 2
        r: 1
        s: 0
        text: ->
      - !!perl/hash:RE_string 
        a: 0
        alt: lambda_00 1
        dba: lambda
        i: 0
        min: 3
        r: 1
        s: 0
        text: <->
lambda_00: *111
longname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: longname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: longname
        i: 0
        min: 12345
        name: name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: longname
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
macro_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: macro_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: macro_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: macro_def
        i: 0
        min: 24690
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 24690
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: macro_def
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    re: &116 !!perl/hash:RE_any 
                      a: 0
                      altname: macro_def_02
                      dba: macro_def
                      i: 0
                      min: 1
                      name: macro_def_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_02 0
                          dba: macro_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "&"
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_method 
                                a: 0
                                dba: macro_def
                                i: 0
                                min: 12345
                                name: deflongname
                                r: 1
                                rest: ''
                                s: 1
                              min: 0
                              quant: 
                                - "?"
                                - ":"
                                - ''
                                - 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_02 1
                          dba: macro_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 12345
                              name: deflongname
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: macro_def
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &11 !!perl/hash:RE_any 
                      a: 0
                      altname: macro_def_03
                      dba: macro_def
                      i: 0
                      min: 12345
                      name: macro_def_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_03 0
                          dba: macro_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 12345
                              name: multisig
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_03 1
                          dba: macro_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: macro_def
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 1
                    text: "\n            $*IN_DECL = 0;\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: macro_def
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: macro_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed macro")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
macro_def_02: *116
macro_def_03: *11
method_def: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: method_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: method_def
        i: 0
        min: 24690
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            a: 0
            dba: method_def
            i: 0
            min: 12345
            name: newpad
            nobind: 1
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: method_def
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: &69 !!perl/hash:RE_any 
                    a: 0
                    altname: method_def_02
                    dba: subscript signature
                    i: 0
                    min: 0
                    name: method_def_02
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 0
                        dba: method_def
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: method_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "[ ! ^ ]"
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 12345
                            name: longname
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 12345
                              re: &1 !!perl/hash:RE_any 
                                a: 0
                                altname: method_def_03
                                dba: method_def
                                i: 0
                                min: 12345
                                name: method_def_03
                                r: 1
                                s: 1
                                zyg: 
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: method_def_03 0
                                    dba: method_def
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 1
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: method_def
                                        i: 0
                                        min: 12345
                                        name: multisig
                                        r: 1
                                        rest: ''
                                        s: 1
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: method_def_03 1
                                    dba: method_def
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 1
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: method_def
                                        i: 0
                                        min: 12345
                                        name: trait
                                        r: 1
                                        rest: ''
                                        s: 1
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 1
                        dba: method_def
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 12345
                            name: multisig
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: method_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 2
                        dba: subscript signature
                        i: 0
                        min: 24691
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 12345
                            name: sigil
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: .
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 12345
                            re: &110 !!perl/hash:RE_any 
                              a: 0
                              altname: method_def_04
                              dba: subscript signature
                              i: 0
                              min: 12345
                              name: method_def_04
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 0
                                  dba: subscript signature
                                  i: 0
                                  min: 12347
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: (
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_meta 
                                      a: 0
                                      dba: subscript signature
                                      extra: local $::GOAL = ')'
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 1
                                      text: "::"
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: signature
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_bracket 
                                      decl: []

                                      min: 1
                                      re: !!perl/hash:RE_first 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 1
                                        zyg: 
                                          - !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: )
                                          - !!perl/hash:RE_method 
                                            min: 0
                                            name: FAILGOAL
                                            nobind: 1
                                            rest: (')', 'subscript signature')
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 1
                                  dba: subscript signature
                                  i: 0
                                  min: 12347
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: "["
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_meta 
                                      a: 0
                                      dba: subscript signature
                                      extra: local $::GOAL = ']'
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 1
                                      text: "::"
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: signature
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_bracket 
                                      decl: []

                                      min: 1
                                      re: !!perl/hash:RE_first 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 1
                                        zyg: 
                                          - !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: "]"
                                          - !!perl/hash:RE_method 
                                            min: 0
                                            name: FAILGOAL
                                            nobind: 1
                                            rest: (']', 'subscript signature')
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 2
                                  dba: subscript signature
                                  i: 0
                                  min: 12347
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: "{"
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_meta 
                                      a: 0
                                      dba: subscript signature
                                      extra: local $::GOAL = '}'
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 1
                                      text: "::"
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: signature
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_bracket 
                                      decl: []

                                      min: 1
                                      re: !!perl/hash:RE_first 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 1
                                        zyg: 
                                          - !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: "}"
                                          - !!perl/hash:RE_method 
                                            min: 0
                                            name: FAILGOAL
                                            nobind: 1
                                            rest: ('}', 'subscript signature')
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 3
                                  dba: subscript signature
                                  i: 0
                                  min: 12345
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_assertion 
                                      assert: "?"
                                      min: 0
                                      re: !!perl/hash:RE_method_re 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 0
                                        name: before
                                        nobind: 1
                                        r: 1
                                        re: !!perl/hash:RE 
                                          decl: []

                                          min: 1
                                          re: !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: <
                                        s: 1
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: postcircumfix
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 3
                        dba: subscript signature
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_noop 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: method_def
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: method_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed method")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
method_def_02: *69
method_def_03: *1
method_def_04: *110
methodop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: method arguments
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &82 !!perl/hash:RE_any 
          a: 0
          altname: methodop_01
          dba: methodop
          i: 0
          min: 12345
          name: methodop_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: methodop_01 0
              dba: methodop
              i: 0
              min: 12345
              name: longname
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: methodop_01 1
              dba: methodop
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: &120 !!perl/hash:RE_any 
                        a: 0
                        altname: methodop_02
                        dba: methodop
                        i: 0
                        min: 1
                        name: methodop_02
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 0
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: $
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 1
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "@"
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 2
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "&"
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: methodop
                  i: 0
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: methodop
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $*VAR = $<variable> "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: methodop_01 2
              dba: methodop
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: methodop
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[ ' \" ]"
                    s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "!"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: methodop
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: $*INTERPOLATION
                      - !!perl/hash:RE_assertion 
                        assert: "!"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: methodop
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: methodop
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: methodop
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "\""
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_cclass 
                                    a: 0
                                    dba: methodop
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: -["]
                                  min: 0
                                  quant: 
                                    - "*"
                                    - "?"
                                    - ''
                                    - 0
                                - !!perl/hash:RE_meta 
                                  a: 0
                                  dba: methodop
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \s
                          s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: methodop
                  i: 0
                  min: 12345
                  name: quote
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: methodop
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<quote> ~~ /\\W/ or $.panic(\"Useless use of quotes\") "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: methodop
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &97 !!perl/hash:RE_any 
            a: 0
            altname: methodop_07
            dba: method arguments
            i: 0
            min: 12345
            name: methodop_07
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: methodop_07 0
                dba: method arguments
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_method_re 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE 
                        decl: []

                        min: 1
                        re: !!perl/hash:RE_meta 
                          a: 0
                          dba: method arguments
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                      s: 0
                  - !!perl/hash:RE_assertion 
                    assert: "!"
                    min: 0
                    re: !!perl/hash:RE_block 
                      a: 0
                      context: bool
                      dba: method arguments
                      i: 0
                      min: 0
                      nobind: 1
                      r: 1
                      s: 0
                      text: " $*INTERPOLATION "
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 12345
                    name: arglist
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: methodop_07 1
                dba: method arguments
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_cclass 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 1
                      nobind: 1
                      r: 1
                      s: 0
                      text: "[\\\\(]"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 12345
                    name: args
                    r: 1
                    rest: ''
                    s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
methodop_01: *82
methodop_02: *120
methodop_07: *97
modifier_expr: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: modifier_expr
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: modifier_expr
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
module_name__S_079normal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: module_name__S_079normal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: module_name__S_079normal
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: generic role
            i: 0
            min: 12347
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: module_name__S_079normal
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: module_name__S_079normal
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: generic role
                i: 0
                min: 1
                r: 1
                s: 0
                text: "["
              - !!perl/hash:RE_meta 
                a: 0
                dba: generic role
                extra: "local $::GOAL = ']' "
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: generic role
                i: 0
                min: 12345
                name: arglist
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: generic role
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: generic role
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "]"
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (']' , 'generic role')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
module_name__S_080deprecated: !!perl/hash:RE 
  decl: []

  kind: token
  min: 8
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: module_name__S_080deprecated
    i: 0
    min: 8
    r: 1
    s: 0
    text: v6-alpha
morename: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: morename
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INTERPOLATION is context<rw> = 0
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: morename
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: morename
        i: 0
        min: 2
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: morename
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: morename
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &128 !!perl/hash:RE_any 
                      a: 0
                      altname: morename_02
                      dba: morename
                      i: 0
                      min: 1
                      name: morename_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: morename_02 0
                          dba: morename
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: (
                        - !!perl/hash:RE_method 
                          a: 0
                          alt: morename_02 1
                          dba: morename
                          i: 0
                          min: 12345
                          name: alpha
                          r: 1
                          rest: ''
                          s: 0
                  s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: &129 !!perl/hash:RE_any 
                  a: 0
                  altname: morename_03
                  dba: indirect name
                  i: 0
                  min: 12345
                  name: morename_03
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: morename_03 0
                      dba: morename
                      i: 0
                      min: 12345
                      name: identifier
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: morename_03 1
                      dba: indirect name
                      i: 0
                      min: 12347
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: indirect name
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: (
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: indirect name
                          extra: "local $::GOAL = ')' "
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "::"
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: indirect name
                          i: 0
                          min: 12345
                          name: EXPR
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: !!perl/hash:RE_first 
                            a: 0
                            dba: indirect name
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: indirect name
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: )
                              - !!perl/hash:RE_method 
                                min: 0
                                name: FAILGOAL
                                nobind: 1
                                rest: (')' , 'indirect name')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
morename_02: *128
morename_03: *129
multi_declarator__S_133multi: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: multi_declarator__S_133multi
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $MULTINESS is context = 'multi'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_133multi
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_133multi
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: multi
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_133multi
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_133multi
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_133multi
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_133multi
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_133multi
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ('Malformed multi')
multi_declarator__S_134proto: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: multi_declarator__S_134proto
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $MULTINESS is context = 'proto'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_134proto
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_134proto
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: proto
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_134proto
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_134proto
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_134proto
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_134proto
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_134proto
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ('Malformed proto')
multi_declarator__S_135only: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: multi_declarator__S_135only
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $MULTINESS is context = 'only'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_135only
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_135only
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: only
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_135only
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_135only
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_135only
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_135only
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_135only
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ('Malformed only')
multi_declarator__S_136null: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: multi_declarator__S_136null
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $MULTINESS is context = ''
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: multi_declarator__S_136null
    i: 0
    min: 12345
    name: declarator
    r: 1
    rest: ''
    s: 0
multisig: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multisig
    i: 0
    min: 12347
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: multisig
            i: 0
            min: 12347
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_string 
                  a: 0
                  dba: multisig
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ":"
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_string 
                a: 0
                dba: multisig
                i: 0
                min: 1
                r: 1
                s: 1
                text: (
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_meta 
                a: 0
                dba: multisig
                extra: local $::GOAL = ')'
                i: 0
                min: 0
                r: 1
                s: 1
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: multisig
                i: 0
                min: 12345
                name: signature
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: multisig
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: multisig
                      i: 0
                      min: 1
                      r: 1
                      s: 1
                      text: )
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (')', 'multisig')
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 12347
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: multisig
            i: 0
            min: 1
            r: 1
            s: 1
            text: "|"
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &84 !!perl/hash:RE_any 
      a: 0
      altname: name_01
      dba: name
      i: 0
      min: 12345
      name: name_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: name_01 0
          dba: name
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: name
              i: 0
              min: 12345
              name: identifier
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: name
                i: 0
                min: 12345
                name: morename
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_quantified_atom 
          alt: name_01 1
          atom: !!perl/hash:RE_method 
            a: 0
            dba: name
            i: 0
            min: 12345
            name: morename
            r: 1
            rest: ''
            s: 0
          min: 12345
          quant: 
            - +
            - ":"
            - ''
            - 1
name_01: *84
named_param: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: named_param
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = ')'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: named_param
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: named_param
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &31 !!perl/hash:RE_any 
          a: 0
          altname: named_param_01
          dba: named_param
          i: 0
          min: 12345
          name: named_param_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: named_param_01 0
              dba: named_param
              i: 0
              min: 37036
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: named_param
                    i: 0
                    min: 12345
                    name: identifier
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: name
                - !!perl/hash:RE_string 
                  a: 0
                  dba: named_param
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_method 
                  a: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &102 !!perl/hash:RE_any 
                    a: 0
                    altname: named_param_02
                    dba: named_param
                    i: 0
                    min: 12345
                    name: named_param_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: named_param_02 0
                        dba: named_param
                        i: 0
                        min: 12345
                        name: named_param
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: named_param_02 1
                        dba: named_param
                        i: 0
                        min: 24690
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: named_param
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: named_param
                            i: 0
                            min: 12345
                            name: ws
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: named_param
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: named_param
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unable to parse named parameter; couldn't find right parenthesis")
            - !!perl/hash:RE_method 
              a: 0
              alt: named_param_01 1
              dba: named_param
              i: 0
              min: 12345
              name: param_var
              r: 1
              rest: ''
              s: 0
named_param_01: *31
named_param_02: *102
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $text = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $from = self.pos
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $to = $from
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my @nibbles = ()
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $multiline = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $nibble
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: nibbler
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<_from> = self.pos; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: nibbler
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_method 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 12345
                      name: stopper
                      r: 1
                      rest: ''
                      s: 0
                  s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: starter
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: nibbler
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: stopper
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );\n\n                            my $n = $<nibbler>[*-1]<nibbles>;\n                            my @n = @$n;\n\n                            push @nibbles, $<starter>;\n                            push @nibbles, @n;\n                            push @nibbles, $<stopper>;\n\n                            $text = '';\n                            $to = $from = $.pos;\n                        "
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: escape
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to ), $<escape>[*-1];\n                            $text = '';\n                            $to = $from = $.pos;\n                        "
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            my $ch = substr($*ORIG, $.pos-1, 1);\n                            $text ~= $ch;\n                            $to = $.pos;\n                            if $ch ~~ \"\\n\" {\n                                $multiline++;\n                            }\n                        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: nibbler
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );\n        $<nibbles> = \\@nibbles;\n        $<_pos> = $.pos;\n        $<nibbler> :delete;\n        $<escape> :delete;\n        $<starter> :delete;\n        $<stopper> :delete;\n        $COMPILING::LAST_NIBBLE = $;\n        $COMPILING::LAST_NIBBLE_MULTILINE = $ if $multiline;\n    "
nofun: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: nofun
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: &57 !!perl/hash:RE_any 
          a: 0
          altname: nofun_01
          dba: nofun
          i: 0
          min: 1
          name: nofun_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 0
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 1
              dba: nofun
              i: 0
              min: 2
              r: 1
              s: 0
              text: .(
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 2
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
      s: 0
nofun_01: *57
noun__S_082fatarrow: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_082fatarrow
    i: 0
    min: 12345
    name: fatarrow
    r: 1
    rest: ''
    s: 0
noun__S_083variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: noun__S_083variable
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: noun__S_083variable
        i: 0
        min: 12345
        name: variable
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: noun__S_083variable
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*VAR = $<variable> "
noun__S_084package_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_084package_declarator
    i: 0
    min: 12345
    name: package_declarator
    r: 1
    rest: ''
    s: 0
noun__S_085scope_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_085scope_declarator
    i: 0
    min: 12345
    name: scope_declarator
    r: 1
    rest: ''
    s: 0
noun__S_086multi_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: noun__S_086multi_declarator
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: noun__S_086multi_declarator
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 4
            re: &77 !!perl/hash:RE_any 
              a: 0
              altname: noun__S_086multi_declarator_01
              dba: noun__S_086multi_declarator
              i: 0
              min: 4
              name: noun__S_086multi_declarator_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: noun__S_086multi_declarator_01 0
                  dba: noun__S_086multi_declarator
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: multi
                - !!perl/hash:RE_string 
                  a: 0
                  alt: noun__S_086multi_declarator_01 1
                  dba: noun__S_086multi_declarator
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: proto
                - !!perl/hash:RE_string 
                  a: 0
                  alt: noun__S_086multi_declarator_01 2
                  dba: noun__S_086multi_declarator
                  i: 0
                  min: 4
                  r: 1
                  s: 0
                  text: only
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: noun__S_086multi_declarator
        i: 0
        min: 12345
        name: multi_declarator
        r: 1
        rest: ''
        s: 0
noun__S_086multi_declarator_01: *77
noun__S_087routine_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_087routine_declarator
    i: 0
    min: 12345
    name: routine_declarator
    r: 1
    rest: ''
    s: 0
noun__S_088regex_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_088regex_declarator
    i: 0
    min: 12345
    name: regex_declarator
    r: 1
    rest: ''
    s: 0
noun__S_089type_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_089type_declarator
    i: 0
    min: 12345
    name: type_declarator
    r: 1
    rest: ''
    s: 0
noun__S_090circumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_090circumfix
    i: 0
    min: 12345
    name: circumfix
    r: 1
    rest: ''
    s: 0
noun__S_091dotty: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_091dotty
    i: 0
    min: 12345
    name: dotty
    r: 1
    rest: ''
    s: 0
noun__S_092value: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_092value
    i: 0
    min: 12345
    name: value
    r: 1
    rest: ''
    s: 0
noun__S_093capterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_093capterm
    i: 0
    min: 12345
    name: capterm
    r: 1
    rest: ''
    s: 0
noun__S_094sigterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_094sigterm
    i: 0
    min: 12345
    name: sigterm
    r: 1
    rest: ''
    s: 0
noun__S_095term: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_095term
    i: 0
    min: 12345
    name: term
    r: 1
    rest: ''
    s: 0
noun__S_096statement_prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_096statement_prefix
    i: 0
    min: 12345
    name: statement_prefix
    r: 1
    rest: ''
    s: 0
noun__S_097colonpair: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 24690
      re: !!perl/hash:RE_sequence 
        a: 0
        dba: noun__S_097colonpair
        i: 0
        min: 24690
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: noun__S_097colonpair
            i: 0
            min: 12345
            name: colonpair
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: noun__S_097colonpair
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
    min: 24690
    quant: 
      - +
      - ":"
      - ''
      - 1
nullterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: nullterm
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
nulltermish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &100 !!perl/hash:RE_any 
      a: 0
      altname: nulltermish_01
      dba: null term
      i: 0
      min: 0
      name: nulltermish_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_assertion 
          alt: nulltermish_01 0
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method 
            a: 0
            dba: null term
            i: 0
            min: 12345
            name: stdstopper
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: nulltermish_01 1
          dba: null term
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_method 
                a: 0
                dba: null term
                i: 0
                min: 12345
                name: termish
                nobind: 1
                r: 1
                rest: ''
                s: 0
              dba: null term
              i: 0
              min: 12345
              r: 1
              s: 0
              var: noun
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: null term
              i: 0
              min: 0
              r: 1
              s: 0
              text: "\n            $.<PRE>  = $<noun><PRE>:delete;\n            $.<POST> = $<noun><POST>:delete;\n            $.<~CAPS> = $<noun><~CAPS>;\n        "
        - !!perl/hash:RE_assertion 
          alt: nulltermish_01 2
          assert: "?"
          min: 0
          re: !!perl/hash:RE_noop 
            a: 0
            dba: null term
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
nulltermish_01: *100
number__S_205rational: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: number__S_205rational
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: number__S_205rational
          i: 0
          min: 12345
          name: integer
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: number__S_205rational
        i: 0
        min: 12345
        r: 1
        s: 0
        var: nu
      - !!perl/hash:RE_string 
        a: 0
        dba: number__S_205rational
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: number__S_205rational
          i: 0
          min: 12345
          name: integer
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: number__S_205rational
        i: 0
        min: 12345
        r: 1
        s: 0
        var: de
number__S_206complex: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: &37 !!perl/hash:RE_any 
    a: 0
    altname: number__S_206complex_00
    dba: number__S_206complex
    i: 0
    min: 12346
    name: number__S_206complex_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        alt: number__S_206complex_00 0
        dba: number__S_206complex
        i: 0
        min: 24692
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_method 
              a: 0
              dba: number__S_206complex
              i: 0
              min: 12345
              name: numish
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: number__S_206complex
            i: 0
            min: 12345
            r: 1
            s: 0
            var: re
          - !!perl/hash:RE_string 
            a: 0
            dba: number__S_206complex
            i: 0
            min: 1
            r: 1
            s: 0
            text: +
          - !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_method 
              a: 0
              dba: number__S_206complex
              i: 0
              min: 12345
              name: numish
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: number__S_206complex
            i: 0
            min: 12345
            r: 1
            s: 0
            var: im
          - !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_string 
              a: 0
              dba: number__S_206complex
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            min: 0
            quant: 
              - "?"
              - ":"
              - ''
              - 0
          - !!perl/hash:RE_string 
            a: 0
            dba: number__S_206complex
            i: 0
            min: 1
            r: 1
            s: 0
            text: i
      - !!perl/hash:RE_sequence 
        a: 0
        alt: number__S_206complex_00 1
        dba: number__S_206complex
        i: 0
        min: 12346
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_method 
              a: 0
              dba: number__S_206complex
              i: 0
              min: 12345
              name: numish
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: number__S_206complex
            i: 0
            min: 12345
            r: 1
            s: 0
            var: im
          - !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_string 
              a: 0
              dba: number__S_206complex
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            min: 0
            quant: 
              - "?"
              - ":"
              - ''
              - 0
          - !!perl/hash:RE_string 
            a: 0
            dba: number__S_206complex
            i: 0
            min: 1
            r: 1
            s: 0
            text: i
number__S_206complex_00: *37
number__S_207numish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: number__S_207numish
    i: 0
    min: 12345
    name: numish
    r: 1
    rest: ''
    s: 0
numish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 3
    re: &140 !!perl/hash:RE_any 
      a: 0
      altname: numish_01
      dba: numish
      i: 0
      min: 3
      name: numish_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: numish_01 0
          dba: numish
          i: 0
          min: 12345
          name: integer
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: numish_01 1
          dba: numish
          i: 0
          min: 12345
          name: dec_number
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: numish_01 2
          dba: numish
          i: 0
          min: 12345
          name: rad_number
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 3
          dba: numish
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 3
              r: 1
              s: 0
              text: NaN
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 4
          dba: numish
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 3
              r: 1
              s: 0
              text: Inf
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 5
          dba: numish
          i: 0
          min: 4
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 4
              r: 1
              s: 0
              text: +Inf
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 6
          dba: numish
          i: 0
          min: 4
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 4
              r: 1
              s: 0
              text: -Inf
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: 
numish_01: *140
octint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: octint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: octint
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ 0..7 ]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: octint
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: octint
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_cclass 
                  a: 0
                  dba: octint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[ 0..7 ]"
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
octints: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 37035
      re: !!perl/hash:RE_sequence 
        a: 0
        dba: octints
        i: 0
        min: 37035
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: octints
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: octints
            i: 0
            min: 12345
            name: octint
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: octints
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
    min: 37035
    quant: 
      - "**"
      - ":"
      - !!perl/hash:RE_string 
        a: 0
        dba: octints
        i: 0
        min: 1
        r: 1
        s: 0
        text: ","
      - 1
old_rx_mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: old_rx_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: old_rx_mods
          i: 0
          min: 0
          name: after
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: old_rx_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_qw 
              a: 0
              dba: old_rx_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: < i g s m x c e >
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: old_rx_mods
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $0.Str {\n            $_ ~~ /i/ and $.worryobs('/i',':i');\n            $_ ~~ /g/ and $.worryobs('/g',':g');\n            $_ ~~ /s/ and $.worryobs('/s','^^ and $$ anchors');\n            $_ ~~ /m/ and $.worryobs('/m','. or \\N');\n            $_ ~~ /x/ and $.worryobs('/x','normal default whitespace');\n            $_ ~~ /c/ and $.worryobs('/c',':c or :p');\n            $_ ~~ /e/ and $.worryobs('/e','interpolated {...} or s{} = ... form');\n            $.obs('suffix regex modifiers','prefix adverbs');\n        }\n    "
old_tr_mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: old_tr_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_qw 
              a: 0
              dba: old_tr_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: < c d s ] >
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: old_tr_mods
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $0.Str {\n            $_ ~~ /c/ and $.worryobs('/c',':c');\n            $_ ~~ /d/ and $.worryobs('/g',':d');\n            $_ ~~ /s/ and $.worryobs('/s',':s');\n            $.obs('suffix transliteration modifiers','prefix adverbs');\n        }\n    "
opener: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass 
    a: 0
    dba: opener
    i: 0
    min: 1
    r: 1
    s: 0
    text: "[\n\\x{0028}\n\\x{003C}\n\\x{005B}\n\\x{007B}\n\\x{00AB}\n\\x{0F3A}\n\\x{0F3C}\n\\x{169B}\n\\x{2018}\n\\x{201A}\n\\x{201B}\n\\x{201C}\n\\x{201E}\n\\x{201F}\n\\x{2039}\n\\x{2045}\n\\x{207D}\n\\x{208D}\n\\x{2208}\n\\x{2209}\n\\x{220A}\n\\x{2215}\n\\x{223C}\n\\x{2243}\n\\x{2252}\n\\x{2254}\n\\x{2264}\n\\x{2266}\n\\x{2268}\n\\x{226A}\n\\x{226E}\n\\x{2270}\n\\x{2272}\n\\x{2274}\n\\x{2276}\n\\x{2278}\n\\x{227A}\n\\x{227C}\n\\x{227E}\n\\x{2280}\n\\x{2282}\n\\x{2284}\n\\x{2286}\n\\x{2288}\n\\x{228A}\n\\x{228F}\n\\x{2291}\n\\x{2298}\n\\x{22A2}\n\\x{22A6}\n\\x{22A8}\n\\x{22A9}\n\\x{22AB}\n\\x{22B0}\n\\x{22B2}\n\\x{22B4}\n\\x{22B6}\n\\x{22C9}\n\\x{22CB}\n\\x{22D0}\n\\x{22D6}\n\\x{22D8}\n\\x{22DA}\n\\x{22DC}\n\\x{22DE}\n\\x{22E0}\n\\x{22E2}\n\\x{22E4}\n\\x{22E6}\n\\x{22E8}\n\\x{22EA}\n\\x{22EC}\n\\x{22F0}\n\\x{22F2}\n\\x{22F3}\n\\x{22F4}\n\\x{22F6}\n\\x{22F7}\n\\x{2308}\n\\x{230A}\n\\x{2329}\n\\x{23B4}\n\\x{2768}\n\\x{276A}\n\\x{276C}\n\\x{276E}\n\\x{2770}\n\\x{2772}\n\\x{2774}\n\\x{27C3}\n\\x{27C5}\n\\x{27D5}\n\\x{27DD}\n\\x{27E2}\n\\x{27E4}\n\\x{27E6}\n\\x{27E8}\n\\x{27EA}\n\\x{2983}\n\\x{2985}\n\\x{2987}\n\\x{2989}\n\\x{298B}\n\\x{298D}\n\\x{298F}\n\\x{2991}\n\\x{2993}\n\\x{2995}\n\\x{2997}\n\\x{29C0}\n\\x{29C4}\n\\x{29CF}\n\\x{29D1}\n\\x{29D4}\n\\x{29D8}\n\\x{29DA}\n\\x{29F8}\n\\x{29FC}\n\\x{2A2B}\n\\x{2A2D}\n\\x{2A34}\n\\x{2A3C}\n\\x{2A64}\n\\x{2A79}\n\\x{2A7D}\n\\x{2A7F}\n\\x{2A81}\n\\x{2A83}\n\\x{2A8B}\n\\x{2A91}\n\\x{2A93}\n\\x{2A95}\n\\x{2A97}\n\\x{2A99}\n\\x{2A9B}\n\\x{2AA1}\n\\x{2AA6}\n\\x{2AA8}\n\\x{2AAA}\n\\x{2AAC}\n\\x{2AAF}\n\\x{2AB3}\n\\x{2ABB}\n\\x{2ABD}\n\\x{2ABF}\n\\x{2AC1}\n\\x{2AC3}\n\\x{2AC5}\n\\x{2ACD}\n\\x{2ACF}\n\\x{2AD1}\n\\x{2AD3}\n\\x{2AD5}\n\\x{2AEC}\n\\x{2AF7}\n\\x{2AF9}\n\\x{2E02}\n\\x{2E04}\n\\x{2E09}\n\\x{2E0C}\n\\x{2E1C}\n\\x{2E20}\n\\x{3008}\n\\x{300A}\n\\x{300C}\n\\x{300E}\n\\x{3010}\n\\x{3014}\n\\x{3016}\n\\x{3018}\n\\x{301A}\n\\x{301D}\n\\x{FD3E}\n\\x{FE17}\n\\x{FE35}\n\\x{FE37}\n\\x{FE39}\n\\x{FE3B}\n\\x{FE3D}\n\\x{FE3F}\n\\x{FE41}\n\\x{FE43}\n\\x{FE47}\n\\x{FE59}\n\\x{FE5B}\n\\x{FE5D}\n\\x{FF08}\n\\x{FF1C}\n\\x{FF3B}\n\\x{FF5B}\n\\x{FF5F}\n\\x{FF62}\n  ]"
package_declarator__S_123class: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_123class
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'class'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_123class
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_123class
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: class
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_123class
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_123class
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_124grammar: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_124grammar
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'grammar'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_124grammar
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_124grammar
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: grammar
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_124grammar
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_124grammar
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_125module: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_125module
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'module'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_125module
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_125module
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: module
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_125module
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_125module
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_126package: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_126package
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'package'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_126package
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_126package
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: package
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_126package
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_126package
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_127role: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_127role
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'role'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_127role
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_127role
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: role
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_127role
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_127role
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_128knowhow: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_128knowhow
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'knowhow'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_128knowhow
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_128knowhow
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: knowhow
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_128knowhow
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_128knowhow
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_129slang: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_129slang
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'slang'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_129slang
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_129slang
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: slang
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_129slang
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_129slang
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_130require: !!perl/hash:RE 
  decl: []

  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_130require
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_130require
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: require
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_130require
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_130require
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: package_declarator__S_130require
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: package_declarator__S_130require
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: package_declarator__S_130require
                  i: 0
                  min: 12345
                  name: module_name
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: package_declarator__S_130require
                    i: 0
                    min: 12345
                    name: EXPR
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_method 
              a: 0
              dba: package_declarator__S_130require
              i: 0
              min: 12345
              name: EXPR
              r: 1
              rest: ''
              s: 0
package_declarator__S_131trusts: !!perl/hash:RE 
  decl: []

  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_131trusts
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_131trusts
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: trusts
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_131trusts
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_131trusts
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_131trusts
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 0
package_declarator__S_132does: !!perl/hash:RE 
  decl: []

  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_132does
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_132does
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: does
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_132does
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_132does
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_132does
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 0
package_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $longname
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: package_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: package_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 0
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: package_def
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: package_def
                      i: 0
                      min: 12345
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: package_def
                          i: 0
                          min: 12345
                          name: def_module_name
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: package_def
                          i: 0
                          min: 0
                          r: 1
                          s: 1
                          text: "\n                $longname = $<def_module_name>[0]<longname>;\n                $.add_name($longname.Str);\n            "
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: package_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: package_def
                    i: 0
                    min: 0
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: package_def
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: package_def
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: "{"
                              s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: package_def
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "\n                # figure out the actual full package name (nested in outer package)\n                my $pkg = $*PKGNAME || \"GLOBAL\";\n                my $shortname;\n                if $longname {\n                     $shortname = $longname.<name>.Str;\n                }\n                else {\n                    $shortname = '_anon_';\n                }\n                $*PKGNAME = $pkg ~ '::' ~ $shortname;\n                my $newpkg = $*CURPKG.{$shortname}<stash> //= {};\n                $newpkg.<PARENT> = $*CURPKG;\n                $*CURPKG = $newpkg;\n                push @PKGS, $pkg;\n                # say \"adding $newpkg \" ~ $*PKGNAME;\n            "
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: package_def
                            i: 0
                            min: 12345
                            name: block
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: package_def
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "\n                $*PKGNAME = pop(@PKGS);\n                $*CURPKG = $*CURPKG.<PARENT>;\n            "
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'package_def', 'block'
                            max: 0
                            min: 0
                            name: _REDUCE
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: package_def
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: package_def
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: ;
                              s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 0
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: package_def
                              i: 0
                              min: 0
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  dba: package_def
                                  i: 0
                                  min: 0
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_assertion 
                                      assert: "?"
                                      min: 0
                                      re: !!perl/hash:RE_block 
                                        a: 0
                                        context: bool
                                        dba: package_def
                                        i: 0
                                        min: 0
                                        nobind: 1
                                        r: 1
                                        s: 1
                                        text: " $*begin_compunit "
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: package_def
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 1
                                      text: "\n                    $longname orelse $.panic(\"Compilation unit cannot be anonymous\");\n                    my $shortname = $longname.<name>.Str;\n                    $*PKGNAME = $shortname;\n                    my $newpkg = $*CURPKG.{$shortname}<stash> //= {};\n                    $newpkg.<PARENT> = $*CURPKG;\n                    $*CURPKG = $newpkg;\n                    $*begin_compunit = 0;\n                "
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_method_internal 
                                      args: $S, 'package_def', 'semi'
                                      max: 0
                                      min: 0
                                      name: _REDUCE
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  dba: package_def
                                  i: 0
                                  min: 0
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: panic
                                      nobind: 1
                                      rest: ("Too late for semicolon form of " ~ $*PKGDECL ~ " definition")
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_method 
                            min: 0
                            name: panic
                            nobind: 1
                            rest: ("Unable to parse " ~ $*PKGDECL ~ " definition")
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: package_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed $*PKGDECL")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
param_sep: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: param_sep
    i: 0
    min: 1
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &62 !!perl/hash:RE_any 
          a: 0
          altname: param_sep_01
          dba: param_sep
          i: 0
          min: 1
          name: param_sep_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 0
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ","
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 1
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ":"
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 2
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ;
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 3
              dba: param_sep
              i: 0
              min: 2
              r: 1
              s: 1
              text: ;;
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
param_sep_01: *62
param_var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &119 !!perl/hash:RE_any 
      a: 0
      altname: param_var_01
      dba: param_var
      i: 0
      min: 12345
      name: param_var_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 0
          dba: param_var
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: param_var
              i: 0
              min: 1
              r: 1
              s: 0
              text: "["
            - !!perl/hash:RE_meta 
              a: 0
              dba: param_var
              extra: "local $::GOAL = ']' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: param_var
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: param_var
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (']' , 'param_var')
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 1
          dba: param_var
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: param_var
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_meta 
              a: 0
              dba: param_var
              extra: "local $::GOAL = ')' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: param_var
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: param_var
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (')' , 'param_var')
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 2
          dba: param_var
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: param_var
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_assertion 
                      assert: "?"
                      min: 0
                      re: !!perl/hash:RE_method_re 
                        a: 0
                        dba: param_var
                        i: 0
                        min: 0
                        name: before
                        nobind: 1
                        r: 1
                        re: !!perl/hash:RE 
                          decl: []

                          min: 12346
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12346
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_method 
                                a: 0
                                dba: param_var
                                i: 0
                                min: 12345
                                name: twigil
                                nobind: 1
                                r: 1
                                rest: ''
                                s: 0
                              - !!perl/hash:RE_meta 
                                a: 0
                                dba: param_var
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \w
                        s: 0
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      name: twigil
                      r: 1
                      rest: ''
                      s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: param_var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: param_var
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $<sigil>.Str eq '&' "
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12345
                            name: ident
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: param_var
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: ''
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12345
                            name: sublongname
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: param_var
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: name
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: param_var
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $<sigil>.Str eq '@' || $<sigil>.Str eq '%' "
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: param_var
                              i: 0
                              min: 12345
                              name: identifier
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            nobind: 1
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          dba: param_var
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          var: name
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_cclass 
                                a: 0
                                dba: param_var
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "[ \\< \\( \\[ \\{ ]"
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: param_var
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                    - !!perl/hash:RE_bindnamed 
                      a: 0
                      atom: !!perl/hash:RE_method 
                        a: 0
                        dba: param_var
                        i: 0
                        min: 12345
                        name: identifier
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      var: name
                    - !!perl/hash:RE_bindnamed 
                      a: 0
                      atom: !!perl/hash:RE_bracket 
                        decl: []

                        min: 1
                        nobind: 1
                        re: !!perl/hash:RE_cclass 
                          a: 0
                          dba: param_var
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "[/!]"
                      dba: param_var
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      var: name
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: param_var
              i: 0
              min: 0
              r: 1
              s: 0
              text: "\n            my $vname = $<sigil>.Str;\n            my $t = $<twigil>;\n            my $twigil = '';\n            $twigil = $t.[0].Str if @$t;\n            $vname ~= $twigil;\n            my $n = try { $<name>[0].Str } // '';\n            $vname ~= $n;\n            if $*REALLYADD {\n                given $twigil {\n                    when '' {\n                        self.add_my_variable($vname) if $n ne '';\n                    }\n                    when '.' {\n                    }\n                    when '!' {\n                    }\n                    default {\n                        self.worry(\"Illegal to use $twigil twigil in signature\");\n                    }\n                }\n            }\n        "
param_var_01: *119
parameter: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $kind
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $quant = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $q
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $REALLYADD is context<rw> = 0
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parameter
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*REALLYADD = 1 "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &52 !!perl/hash:RE_any 
          a: 0
          altname: parameter_01
          dba: parameter
          i: 0
          min: 12345
          name: parameter_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 0
              dba: parameter
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: parameter
                    i: 0
                    min: 12345
                    name: type_constraint
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            my $t = $<type_constraint>;\n            @$t > 1 and $.panic(\"Multiple prefix constraints not yet supported\")\n        "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: &65 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_02
                    dba: parameter
                    i: 0
                    min: 0
                    name: parameter_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 0
                        dba: parameter
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "*"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '*'; $kind = '*'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 1
                        dba: parameter
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "|"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '|'; $kind = '*'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 2
                        dba: parameter
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '\\\\'; $kind = '!'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 3
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 12345
                            re: &101 !!perl/hash:RE_any 
                              a: 0
                              altname: parameter_03
                              dba: parameter
                              i: 0
                              min: 12345
                              name: parameter_03
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_03 0
                                  dba: parameter
                                  i: 0
                                  min: 12345
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 12345
                                      name: param_var
                                      r: 1
                                      rest: ''
                                      s: 0
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = ''; $kind = '!'; "
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_03 1
                                  dba: parameter
                                  i: 0
                                  min: 12345
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 12345
                                      name: named_param
                                      r: 1
                                      rest: ''
                                      s: 0
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = ''; $kind = '*'; "
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 0
                            re: &114 !!perl/hash:RE_any 
                              a: 0
                              altname: parameter_04
                              dba: parameter
                              i: 0
                              min: 0
                              name: parameter_04
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_04 0
                                  dba: parameter
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "?"
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = '?'; $kind = '?' "
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_04 1
                                  dba: parameter
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "!"
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = '!'; $kind //= '!' "
                                - !!perl/hash:RE_assertion 
                                  alt: parameter_04 2
                                  assert: "?"
                                  min: 0
                                  re: !!perl/hash:RE_noop 
                                    a: 0
                                    dba: parameter
                                    i: 0
                                    min: 0
                                    nobind: 1
                                    r: 1
                                    s: 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 4
                        dba: parameter
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_noop 
                              a: 0
                              dba: parameter
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '!' "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 1
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "*"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '*'; $kind = '*'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 2
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "|"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '|'; $kind = '*'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 3
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '\\\\'; $kind = '!'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 4
              dba: parameter
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &6 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_05
                    dba: parameter
                    i: 0
                    min: 12345
                    name: parameter_05
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_05 0
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '!'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_05 1
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: named_param
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '*'; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: &7 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_06
                    dba: parameter
                    i: 0
                    min: 0
                    name: parameter_06
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_06 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "?"
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '?'; $kind = '?' "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_06 1
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "!"
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '!'; $kind //= '!' "
                      - !!perl/hash:RE_assertion 
                        alt: parameter_06 2
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_noop 
                          a: 0
                          dba: parameter
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: post_constraint
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: parameter
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: parameter
                i: 0
                min: 12345
                name: default_value
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: parameter
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            given $quant {\n              when '!' { $.panic(\"Can't put a default on a required parameter\") }\n              when '*' { $.panic(\"Can't put a default on a slurpy parameter\") }\n              when '|' { $.panic(\"Can't put a default on an slurpy capture parameter\") }\n              when '\\\\' { $.panic(\"Can't put a default on a capture parameter\") }\n            }\n            $kind = '?' if $kind eq '!';\n        "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        $<quant> = $quant;\n        $<kind> = $kind;\n    "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $kind {\n            when '!' {\n                given $*zone {\n                    when 'posopt' {\n$.panic(\"Can't put required parameter after optional parameters\");\n                    }\n                    when 'var' {\n$.panic(\"Can't put required parameter after variadic parameters\");\n                    }\n                }\n            }\n            when '?' {\n                given $*zone {\n                    when 'posreq' { $*zone = 'posopt' }\n                    when 'var' {\n$.panic(\"Can't put optional positional parameter after variadic parameters\");\n                    }\n                }\n            }\n            when '*' {\n                $*zone = 'var';\n            }\n        }\n    "
parameter_01: *52
parameter_02: *65
parameter_03: *101
parameter_04: *114
parameter_05: *6
parameter_06: *7
pblock: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parameterized block
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: parameterized block
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: parameterized block
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: &74 !!perl/hash:RE_any 
                    a: 0
                    altname: pblock_02
                    dba: parameterized block
                    i: 0
                    min: 1
                    name: pblock_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: pblock_02 0
                        dba: parameterized block
                        i: 0
                        min: 12345
                        name: lambda
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: pblock_02 1
                        dba: parameterized block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "{"
                s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: parameterized block
              i: 0
              min: 0
              r: 1
              s: 0
              text: "\n            if $*BORG and $*BORG.<block> {\n                if $*BORG.<name> {\n                    my $m = \"Function '\" ~ $BORG.<name> ~ \"' needs parens to avoid gobbling block\" ~ $*BORG.<culprit>.locmess;\n                    $*BORG.<block>.panic($m ~ \"\\nMissing block (apparently gobbled by '\" ~ $BORG.<name> ~ \"')\");\n                }\n                else {\n                    my $m = \"Expression needs parens to avoid gobbling block\" ~ $*BORG.<culprit>.locmess;\n                    $*BORG.<block>.panic($m ~ \"\\nMissing block (apparently gobbled by expression)\");\n                }\n            }\n            elsif %*MYSTERY {\n                $.panic(\"Missing block (apparently gobbled by undeclared routine?)\");\n            }\n            else {\n                $.panic(\"Missing block\");\n            }\n        "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: &75 !!perl/hash:RE_any 
          a: 0
          altname: pblock_04
          dba: parameterized block
          i: 0
          min: 24690
          name: pblock_04
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pblock_04 0
              dba: parameterized block
              i: 0
              min: 49380
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: lambda
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pblock_04 1
              dba: parameterized block
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: parameterized block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: parameterized block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "{"
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 0
pblock_02: *74
pblock_04: *75
pod_comment: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: pod_comment
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: pod_comment
        i: 0
        min: 0
        r: 1
        s: 0
        text: "^^"
      - !!perl/hash:RE_string 
        a: 0
        dba: pod_comment
        i: 0
        min: 1
        r: 1
        s: 0
        text: =
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: pod_comment
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &25 !!perl/hash:RE_any 
          a: 0
          altname: pod_comment_01
          dba: pod_comment
          i: 0
          min: 0
          name: pod_comment_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 0
              dba: pod_comment
              i: 0
              min: 12351
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: begin
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_method 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 7
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_double 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: \n=
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 3
                            r: 1
                            s: 0
                            text: end
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_var 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            var: $<identifier>
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \N
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'pod_comment', 'tagged'
                            max: 0
                            min: 0
                            name: _REDUCE
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_block 
                              a: 0
                              context: bool
                              dba: pod_comment
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 0
                              text: " $<identifier>.Str eq 'END'"
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'pod_comment', 'end'
                            max: 0
                            min: 0
                            name: _REDUCE
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: pod_comment
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " my $id = $<identifier>.Str; self.panic(\"=begin $id without matching =end $id\"); "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 1
              dba: pod_comment
              i: 0
              min: 5
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: begin
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $$
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "#"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unrecognized token after =begin")
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 6
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_double 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: \n=
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 3
                            r: 1
                            s: 0
                            text: end
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \N
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: pod_comment
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " self.panic(\"=begin without matching =end\"); "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'pod_comment', 'anon'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 2
              dba: pod_comment
              i: 0
              min: 4
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: for
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 12345
                        name: identifier
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $$
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "#"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unrecognized token after =for")
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: "^^"
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .*
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 3
              dba: pod_comment
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 0
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: pod_comment
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 5
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: pod_comment
                                i: 0
                                min: 5
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: .*?
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 0
                                    r: 1
                                    s: 0
                                    text: "^^"
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 4
                                    r: 1
                                    s: 0
                                    text: =cut
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 0
                                    r: 1
                                    s: 0
                                    text: 
                            s: 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Obsolete pod format, please use =begin/=end instead")
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \N
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'pod_comment', 'misc'
                  max: 0
                  min: 0
                  name: _REDUCE
pod_comment_01: *25
post_constraint: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: post_constraint
    i: 0
    min: 5
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 5
        re: &93 !!perl/hash:RE_any 
          a: 0
          altname: post_constraint_01
          dba: post_constraint
          i: 0
          min: 5
          name: post_constraint_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 0
              dba: post_constraint
              i: 0
              min: 12347
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: "["
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: post_constraint
                  extra: local $::GOAL = ']'
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: post_constraint
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: post_constraint
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']', 'post_constraint')
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 1
              dba: post_constraint
              i: 0
              min: 12347
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: (
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: post_constraint
                  extra: local $::GOAL = ')'
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: post_constraint
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: post_constraint
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')', 'post_constraint')
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 2
              dba: post_constraint
              i: 0
              min: 5
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: where
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %chaining)
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
post_constraint_01: *93
postcircumfix__S_109Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: argument list
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: argument list
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: argument list
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: argument list
        i: 0
        min: 12345
        name: semiarglist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: argument list
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: argument list
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'argument list')
postcircumfix__S_110Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: subscript
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_meta 
        a: 0
        dba: subscript
        extra: "local $::GOAL = ']' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: subscript
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: subscript
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'subscript')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: subscript
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<semilist>.Str ~~ /^\\s*\\-[1]\\s*$/ and $.obs(\"[-1] subscript to access final element\",\"[*-1]\") "
postcircumfix__S_111Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: subscript
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: subscript
        extra: "local $::GOAL = '}' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: subscript
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: subscript
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: ('}' , 'subscript')
postcircumfix__S_112Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_112Lt_Gt
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_112Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_112Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_112Lt_Gt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right angle quote")
postcircumfix__S_113LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_113LtLt_GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_113LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_113LtLt_GtGt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_113LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right double-angle quote")
postcircumfix__S_114Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_114Fre_Nch
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_114Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('',''))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_114Fre_Nch
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_114Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right double-angle quote")
postfix__S_306i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix__S_306i
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: postfix__S_306i
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: i
      - !!perl/hash:RE_meta 
        a: 0
        dba: postfix__S_306i
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
postfix__S_308MinusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix__S_308MinusGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postfix__S_308MinusGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: ->
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('-> to call a method', '.')
postfix__S_309PlusPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: postfix__S_309PlusPlus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ++
postfix__S_310MinusMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: postfix__S_310MinusMinus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: --
postfix_prefix_meta_operator__S_102Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix_prefix_meta_operator__S_102Nch
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &18 !!perl/hash:RE_any 
          a: 0
          altname: postfix_prefix_meta_operator__S_102Nch_01
          dba: postfix_prefix_meta_operator__S_102Nch
          i: 0
          min: 2
          name: postfix_prefix_meta_operator__S_102Nch_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: postfix_prefix_meta_operator__S_102Nch_01 0
              dba: postfix_prefix_meta_operator__S_102Nch
              i: 0
              min: 12345
              name: sym
              r: 1
              rest: ''
              s: 0
              sym: 
            - !!perl/hash:RE_string 
              a: 0
              alt: postfix_prefix_meta_operator__S_102Nch_01 1
              dba: postfix_prefix_meta_operator__S_102Nch
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postfix_prefix_meta_operator__S_102Nch
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: postfix_prefix_meta_operator__S_102Nch
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " $*INTERPOLATION "
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: postfix_prefix_meta_operator__S_102Nch
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: postfix_prefix_meta_operator__S_102Nch
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: (
                s: 0
postfix_prefix_meta_operator__S_102Nch_01: *18
postop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: &9 !!perl/hash:RE_any 
    a: 0
    altname: postop_00
    dba: postop
    i: 0
    min: 12345
    name: postop_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        alt: postop_00 0
        dba: postop
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: postop
            i: 0
            min: 12345
            name: postfix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: postop
            i: 0
            min: 0
            r: 1
            s: 0
            text: " $<O> := $<postfix><O>; $<sym> := $<postfix><sym>; "
      - !!perl/hash:RE_sequence 
        a: 0
        alt: postop_00 1
        dba: postop
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: postop
            i: 0
            min: 12345
            name: postcircumfix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: postop
            i: 0
            min: 0
            r: 1
            s: 0
            text: " $<O> := $<postcircumfix><O>; $<sym> := $<postcircumfix><sym>; "
postop_00: *9
prefix__S_311PlusPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_311PlusPlus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ++
prefix__S_312MinusMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_312MinusMinus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: --
prefix__S_314Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_314Bang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!"
prefix__S_315Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_315Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
prefix__S_316Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_316Minus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "-"
prefix__S_317Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_317Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
prefix__S_318Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_318Question
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "?"
prefix__S_319TildeCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_319TildeCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~^
prefix__S_320PlusCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_320PlusCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +^
prefix__S_321QuestionCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_321QuestionCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?^
prefix__S_322Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_322Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
prefix__S_323Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_323Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
prefix__S_353sleep: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_353sleep
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_353sleep
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: sleep
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_353sleep
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_353sleep
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_353sleep
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_354abs: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_354abs
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_354abs
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: abs
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_354abs
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_354abs
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_354abs
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_355let: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_355let
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_355let
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: let
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_355let
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_355let
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_355let
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_356temp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_356temp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_356temp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: temp
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_356temp
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_356temp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_356temp
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_407true: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_407true
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_407true
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 'true'
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_407true
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
prefix__S_408not: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_408not
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_408not
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: not
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_408not
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
prefix_circumfix_meta_operator__S_100reduce: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: prefix_circumfix_meta_operator__S_100reduce
      i: 0
      max: 0
      min: 0
      r: 0
      s: 0
      text: my $IN_REDUCE is context<rw> = 1
  kind: regex
  min: 1
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix_circumfix_meta_operator__S_100reduce
    i: 0
    min: 1
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix_circumfix_meta_operator__S_100reduce
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 0
          re: !!perl/hash:RE 
            decl: []

            min: 3
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: prefix_circumfix_meta_operator__S_100reduce
              i: 0
              min: 3
              r: 0
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_100reduce
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: prefix_circumfix_meta_operator__S_100reduce
                    i: 0
                    min: 1
                    r: 0
                    s: 0
                    text: \S
                  min: 1
                  quant: 
                    - +
                    - "!"
                    - ''
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_100reduce
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: "]"
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: prefix_circumfix_meta_operator__S_100reduce
            i: 0
            min: 1
            r: 0
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: prefix_circumfix_meta_operator__S_100reduce
                i: 0
                min: 1
                r: 0
                s: 0
                text: "["
              - !!perl/hash:RE_bracket 
                decl: []

                min: 0
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_100reduce
                  i: 0
                  min: 0
                  r: 0
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: prefix_circumfix_meta_operator__S_100reduce
                      i: 0
                      min: 1
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            min: 0
                            name: infixish
                            nobind: 1
                            rest: (1)
                          dba: prefix_circumfix_meta_operator__S_100reduce
                          i: 0
                          min: 0
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_100reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &79 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_100reduce_04
                            dba: prefix_circumfix_meta_operator__S_100reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_100reduce_04
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_100reduce_04 0
                                dba: prefix_circumfix_meta_operator__S_100reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_100reduce_04 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_100reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: prefix_circumfix_meta_operator__S_100reduce
                      i: 0
                      min: 2
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_100reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: \
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            min: 0
                            name: infixish
                            nobind: 1
                            rest: (1)
                          dba: prefix_circumfix_meta_operator__S_100reduce
                          i: 0
                          min: 0
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_100reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &80 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_100reduce_06
                            dba: prefix_circumfix_meta_operator__S_100reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_100reduce_06
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_100reduce_06 0
                                dba: prefix_circumfix_meta_operator__S_100reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_100reduce_06 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_100reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
                    - !!perl/hash:RE_assertion 
                      assert: "!"
                      min: 0
                      re: !!perl/hash:RE_noop 
                        a: 0
                        dba: prefix_circumfix_meta_operator__S_100reduce
                        i: 0
                        min: 0
                        nobind: 1
                        r: 0
                        s: 0
        dba: prefix_circumfix_meta_operator__S_100reduce
        i: 0
        min: 1
        r: 0
        s: 0
        var: s
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix_circumfix_meta_operator__S_100reduce
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 0
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: prefix_circumfix_meta_operator__S_100reduce
              i: 0
              min: 1
              r: 0
              s: 0
              text: "[ \\s ( ]"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<s><op>, "reduce")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: prefix_circumfix_meta_operator__S_100reduce
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: prefix_circumfix_meta_operator__S_100reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $<s><op><O><diffy> "
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: prefix_circumfix_meta_operator__S_100reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $<s><op><O><assoc> eq 'chain' "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't reduce a " ~ $<s><op><O><dba> ~ " operator because it's diffy and not chaining")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: prefix_circumfix_meta_operator__S_100reduce
        i: 0
        min: 0
        r: 0
        s: 0
        text: " $<O> = $<s><op><O>; $<O><prec>:delete; $<O><assoc> = 'unary'; $<O><uassoc> = 'left'; "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: prefix_circumfix_meta_operator__S_100reduce
        i: 0
        min: 0
        r: 0
        s: 0
        text: " $<sym> = $<s>.Str; "
prefix_circumfix_meta_operator__S_100reduce_04: *79
prefix_circumfix_meta_operator__S_100reduce_06: *80
prefix_postfix_meta_operator__S_101Fre: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &3 !!perl/hash:RE_any 
    a: 0
    altname: prefix_postfix_meta_operator__S_101Fre_00
    dba: prefix_postfix_meta_operator__S_101Fre
    i: 0
    min: 2
    name: prefix_postfix_meta_operator__S_101Fre_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        alt: prefix_postfix_meta_operator__S_101Fre_00 0
        dba: prefix_postfix_meta_operator__S_101Fre
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 
      - !!perl/hash:RE_string 
        a: 0
        alt: prefix_postfix_meta_operator__S_101Fre_00 1
        dba: prefix_postfix_meta_operator__S_101Fre
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
prefix_postfix_meta_operator__S_101Fre_00: *3
privop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: privop
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: privop
        i: 0
        min: 1
        r: 1
        s: 0
        text: "!"
      - !!perl/hash:RE_method 
        a: 0
        dba: privop
        i: 0
        min: 12345
        name: methodop
        r: 1
        rest: ''
        s: 0
quasiquibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quasiquibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
    - !!perl/hash:RE_decl 
      a: 0
      dba: quasiquibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QUASI_QUASH is context = 0
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quasiquibble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quasiquibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: quasiquibble
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: quasiquibble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: quasiquibble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start eq '{' "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: quasiquibble
                    i: 0
                    lang: ($lang)
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_decl 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        max: 0
                        min: 0
                        noquant: 1
                        r: 1
                        s: 0
                        text: "my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); "
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        min: 12345
                        name: block
                        r: 1
                        rest: ''
                        s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: quasiquibble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_var 
                  a: 0
                  dba: quasiquibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $start
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: quasiquibble
                    i: 0
                    lang: ($lang)
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_decl 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        max: 0
                        min: 0
                        noquant: 1
                        r: 1
                        s: 0
                        text: "my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); "
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        min: 12345
                        name: statementlist
                        r: 1
                        rest: ''
                        s: 0
                - !!perl/hash:RE_var 
                  a: 0
                  dba: quasiquibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
quibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($lang)
      - !!perl/hash:RE_var 
        a: 0
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        if $lang<_herelang> {\n            push @herestub_queue,\n                ::Herestub.new(\n                    delim => $<nibble><nibbles>[0]<TEXT>,\n                    orignode => $,\n                    lang => $lang<_herelang>,\n                );\n        }\n    "
quote__S_209Single_Single: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_209Single_Single
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_double 
        a: 0
        dba: quote__S_209Single_Single
        i: 0
        min: 1
        r: 1
        s: 0
        text: "'"
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q).unbalanced("'"))
      - !!perl/hash:RE_double 
        a: 0
        dba: quote__S_209Single_Single
        i: 0
        min: 1
        r: 1
        s: 0
        text: "'"
quote__S_210Double_Double: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_210Double_Double
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_210Double_Double
        i: 0
        min: 1
        r: 1
        s: 0
        text: "\""
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).unbalanced('"'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_210Double_Double
        i: 0
        min: 1
        r: 1
        s: 0
        text: "\""
quote__S_211Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_211Fre_Nch
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_211Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('',''))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_211Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
quote__S_212LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_212LtLt_GtGt
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_212LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_212LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: ">>"
quote__S_213Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_213Lt_Gt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_213Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quote__S_213Lt_Gt
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: quote__S_213Lt_Gt
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 6
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: quote__S_213Lt_Gt
                      i: 0
                      min: 6
                      r: 1
                      s: 0
                      text: STDIN>
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('<STDIN>', '$' ~ '*IN.lines')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quote__S_213Lt_Gt
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: quote__S_213Lt_Gt
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: quote__S_213Lt_Gt
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ">"
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('<>', 'lines() or ()')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_213Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: ">"
quote__S_214SlashSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_214SlashSlash
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_214SlashSlash
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: quote__S_214SlashSlash
          i: 0
          min: 1
          r: 1
          s: 0
          text: \s
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_214SlashSlash
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Null regex not allowed")
quote__S_215Slash_Slash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_215Slash_Slash
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_215Slash_Slash
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ( $.cursor_fresh( %*LANG<Regex> ).unbalanced("/") )
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: quote__S_215Slash_Slash
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: quote__S_215Slash_Slash
              i: 0
              min: 1
              r: 1
              s: 0
              text: /
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find final '/'")
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_215Slash_Slash
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quote__S_216qq: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_216qq
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_216qq
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_216qq
        i: 0
        min: 2
        r: 1
        s: 0
        text: qq
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &26 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_216qq_01
          dba: quote__S_216qq
          i: 0
          min: 12345
          name: quote__S_216qq_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_216qq_01 0
              dba: quote__S_216qq
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_216qq
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_216qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_216qq
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_216qq
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_216qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.Str "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_216qq
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_216qq_01 1
              dba: quote__S_216qq
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_216qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_216qq
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_216qq
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_216qq
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq))
quote__S_216qq_01: *26
quote__S_217q: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_217q
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_217q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_217q
        i: 0
        min: 1
        r: 1
        s: 0
        text: q
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &103 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_217q_01
          dba: quote__S_217q
          i: 0
          min: 12345
          name: quote__S_217q_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_217q_01 0
              dba: quote__S_217q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_217q
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_217q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_217q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_217q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_217q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.Str "
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_217q_01 1
              dba: quote__S_217q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_217q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_217q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_217q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_217q
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q))
quote__S_217q_01: *103
quote__S_218Q: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_218Q
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_218Q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_218Q
        i: 0
        min: 1
        r: 1
        s: 0
        text: Q
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &51 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_218Q_01
          dba: quote__S_218Q
          i: 0
          min: 12345
          name: quote__S_218Q_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_218Q_01 0
              dba: quote__S_218Q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_218Q
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_218Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_218Q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_218Q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_218Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.Str "
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( %*LANG<Q> ).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_218Q_01 1
              dba: quote__S_218Q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_218Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_218Q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_218Q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_218Q
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( %*LANG<Q> ))
quote__S_218Q_01: *51
quote__S_229rx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_229rx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_229rx
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rx
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_229rx
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_229rx
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_229rx
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( %*LANG<Regex> ) )
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_229rx
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_230m: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_230m
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_230m
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: m
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_230m
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_230m
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_230m
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( %*LANG<Regex> ) )
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_230m
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_231mm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_231mm
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_231mm
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: mm
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_231mm
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_231mm
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_231mm
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( %*LANG<Regex> ).tweak(:s))
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_231mm
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_232s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_232s
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_232s
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: s
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_232s
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_232s
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_232s
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: sibble
          nobind: 1
          rest: ( $.cursor_fresh( %*LANG<Regex> ), $.cursor_fresh( %*LANG<Q> ).tweak(:qq))
        dba: quote__S_232s
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_232s
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_233ss: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_233ss
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_233ss
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ss
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_233ss
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_233ss
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_233ss
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: sibble
          nobind: 1
          rest: ( $.cursor_fresh( %*LANG<Regex> ).tweak(:s), $.cursor_fresh( %*LANG<Q> ).tweak(:qq))
        dba: quote__S_233ss
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_233ss
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_234tr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_234tr
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_234tr
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: tr
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_234tr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_234tr
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_234tr
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: tribble
          nobind: 1
          rest: ( $.cursor_fresh( %*LANG<Q> ).tweak(:q))
        dba: quote__S_234tr
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_234tr
          i: 0
          min: 12345
          name: old_tr_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_235quasi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_235quasi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_235quasi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: quasi
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_235quasi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_235quasi
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_235quasi
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quasiquibble
        rest: ($.cursor_fresh( %*LANG<Quasi> ))
quote_mod__S_219w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_219w
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
quote_mod__S_220ww: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_220ww
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ww
quote_mod__S_221x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_221x
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: x
quote_mod__S_222to: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_222to
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: to
quote_mod__S_223s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_223s
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
quote_mod__S_224a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_224a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
quote_mod__S_225h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_225h
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
quote_mod__S_226f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_226f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
quote_mod__S_227c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_227c
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: c
quote_mod__S_228b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_228b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
quotepair: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quotepair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $key
    - !!perl/hash:RE_decl 
      a: 0
      dba: quotepair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $value
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: colon pair (restricted)
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quotepair
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &42 !!perl/hash:RE_any 
          a: 0
          altname: quotepair_01
          dba: colon pair (restricted)
          i: 0
          min: 2
          name: quotepair_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 0
              dba: colon pair (restricted)
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; $value = 0; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair', 'false'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 1
              dba: colon pair (restricted)
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: colon pair (restricted)
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: colon pair (restricted)
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                              s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: colon pair (restricted)
                            i: 0
                            min: 12345
                            name: postcircumfix
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: colon pair (restricted)
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $value = $<postcircumfix>; "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: colon pair (restricted)
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $value = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair', 'value'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 2
              dba: colon pair (restricted)
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: 'n'
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_cclass 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[a..z]"
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: id
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<id>.Str; $value = $<n>.Str; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair', 'nth'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: colon pair (restricted)
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<k> = $key; $<v> = $value; "
quotepair_01: *42
rad_number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: number in radix notation
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: rad_number
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: rad_number
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        dba: rad_number
        i: 0
        min: 1
        r: 1
        s: 0
        var: radix
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: rad_number
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: rad_number
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 3
        re: !!perl/hash:RE_first 
          a: 0
          dba: number in radix notation
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: <
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_cclass 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "[ 0..9 a..z A..Z ]"
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: number in radix notation
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: number in radix notation
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_cclass 
                                    a: 0
                                    dba: number in radix notation
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "[ 0..9 a..z A..Z ]"
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: intpart
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_bracket 
                      decl: []

                      min: 2
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: number in radix notation
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[ 0..9 a..z A..Z ]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: number in radix notation
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: number in radix notation
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: number in radix notation
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[ 0..9 a..z A..Z ]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: number in radix notation
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: fracpart
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24693
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 24693
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: number in radix notation
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "*"
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 12345
                            name: radint
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: number in radix notation
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: base
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: number in radix notation
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: "**"
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 12345
                            name: radint
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: number in radix notation
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: exp
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "["
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
radint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &107 !!perl/hash:RE_any 
      a: 0
      altname: radint_01
      dba: radint
      i: 0
      min: 12345
      name: radint_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: radint_01 0
          dba: radint
          i: 0
          min: 12345
          name: integer
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: radint_01 1
          dba: radint
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: radint
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: radint
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: radint
              i: 0
              min: 12345
              name: rad_number
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: radint
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: "\n                        defined $<rad_number><intpart>\n                        and\n                        not defined $<rad_number><fracpart>\n                    "
radint_01: *107
regex_block: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: temp %*LANG
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $lang = %*LANG<Regex>
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_block
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: regex_block
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: regex_block
                i: 0
                min: 12345
                name: quotepair
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: regex_block
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: regex_block
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            my $kv = $<quotepair>[*-1];\n            $lang = $lang.tweak($kv.<k>, $kv.<v>)\n                or self.panic(\"Unrecognized adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: regex_block
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ( $.cursor_fresh($lang).unbalanced('}') )
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: regex_block
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: regex_block
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right brace")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &19 !!perl/hash:RE_any 
          a: 0
          altname: regex_block_04
          dba: regex_block
          i: 0
          min: 0
          name: regex_block_04
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 0
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 0
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: regex_block
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: regex_block
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: regex_block
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block', 'endstmt simple '
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 1
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: regex_block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[\\\\,:]"
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block', 'normal '
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 2
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block', 'endstmt complex'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 3
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endargs> = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block', 'endargs'
                  max: 0
                  min: 0
                  name: _REDUCE
regex_block_04: *19
regex_declarator__S_141regex: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_141regex
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_141regex
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: regex
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_141regex
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_141regex
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_declarator__S_142token: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_142token
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_142token
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: token
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_142token
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_142token
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_declarator__S_143rule: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_143rule
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_143rule
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rule
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_143rule
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_143rule
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: regex_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: regex_def
        i: 0
        min: 37035
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 37035
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: regex_def
              i: 0
              min: 37035
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    re: &94 !!perl/hash:RE_any 
                      a: 0
                      altname: regex_def_02
                      dba: regex_def
                      i: 0
                      min: 1
                      name: regex_def_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_02 0
                          dba: regex_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: regex_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "&"
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_method 
                                a: 0
                                dba: regex_def
                                i: 0
                                min: 12345
                                name: deflongname
                                r: 1
                                rest: ''
                                s: 1
                              min: 0
                              quant: 
                                - "?"
                                - ":"
                                - ''
                                - 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_02 1
                          dba: regex_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: regex_def
                              i: 0
                              min: 12345
                              name: deflongname
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: regex_def
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &15 !!perl/hash:RE_any 
                      a: 0
                      altname: regex_def_03
                      dba: regex_def
                      i: 0
                      min: 12345
                      name: regex_def_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_03 0
                          dba: regex_def
                          i: 0
                          min: 12347
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 12347
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: regex_def
                                i: 0
                                min: 12347
                                r: 1
                                s: 1
                                zyg: 
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_string 
                                      a: 0
                                      dba: regex_def
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: ":"
                                    min: 0
                                    quant: 
                                      - "?"
                                      - ":"
                                      - ''
                                      - 0
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: regex_def
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 1
                                    text: (
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: ws
                                    nobind: 1
                                    noquant: 1
                                    rest: ''
                                  - !!perl/hash:RE_method 
                                    a: 0
                                    dba: regex_def
                                    i: 0
                                    min: 12345
                                    name: signature
                                    r: 1
                                    rest: ''
                                    s: 1
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: ws
                                    nobind: 1
                                    noquant: 1
                                    rest: ''
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: regex_def
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 1
                                    text: )
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_03 1
                          dba: regex_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: regex_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: " $*IN_DECL = 0; "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: regex_def
                  i: 0
                  min: 12345
                  name: finishpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: regex_def
                  i: 0
                  min: 12345
                  name: regex_block
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: regex_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed regex")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
regex_def_02: *94
regex_def_03: *15
routine_declarator__S_137sub: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_137sub
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_137sub
        endsym: endid
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: sub
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_137sub
        i: 0
        min: 12345
        name: endid
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_137sub
        i: 0
        min: 12345
        name: routine_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_138method: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_138method
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_138method
        endsym: endid
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: method
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_138method
        i: 0
        min: 12345
        name: endid
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_138method
        i: 0
        min: 12345
        name: method_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_139submethod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_139submethod
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_139submethod
        endsym: endid
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: submethod
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_139submethod
        i: 0
        min: 12345
        name: endid
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_139submethod
        i: 0
        min: 12345
        name: method_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_140macro: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_140macro
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_140macro
        endsym: endid
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: macro
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_140macro
        i: 0
        min: 12345
        name: endid
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_140macro
        i: 0
        min: 12345
        name: macro_def
        r: 1
        rest: ''
        s: 0
routine_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: routine_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: routine_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: routine_def
        i: 0
        min: 24690
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 24690
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: routine_def
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    re: &117 !!perl/hash:RE_any 
                      a: 0
                      altname: routine_def_02
                      dba: routine_def
                      i: 0
                      min: 1
                      name: routine_def_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_02 0
                          dba: routine_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "&"
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_method 
                                a: 0
                                dba: routine_def
                                i: 0
                                min: 12345
                                name: deflongname
                                r: 1
                                rest: ''
                                s: 1
                              min: 0
                              quant: 
                                - "?"
                                - ":"
                                - ''
                                - 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_02 1
                          dba: routine_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 12345
                              name: deflongname
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: routine_def
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &99 !!perl/hash:RE_any 
                      a: 0
                      altname: routine_def_03
                      dba: routine_def
                      i: 0
                      min: 12345
                      name: routine_def_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_03 0
                          dba: routine_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 12345
                              name: multisig
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_03 1
                          dba: routine_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: routine_def
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 1
                    text: "\n            $*IN_DECL = 0;\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: routine_def
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: routine_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed routine")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
routine_def_02: *117
routine_def_03: *99
scope_declarator__S_116my: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_116my
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_116my
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: my
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_116my
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_116my
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_116my
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_117our: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_117our
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_117our
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: our
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_117our
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_117our
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_117our
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_118state: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_118state
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_118state
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: state
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_118state
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_118state
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_118state
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_119constant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_119constant
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_119constant
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: constant
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_119constant
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_119constant
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_119constant
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_120has: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_120has
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_120has
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: has
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_120has
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_120has
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_120has
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_121augment: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_121augment
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_121augment
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: augment
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_121augment
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_121augment
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_121augment
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_122supersede: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_122supersede
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_122supersede
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: supersede
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_122supersede
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_122supersede
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_122supersede
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scoped: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: scoped declarator
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: scoped declarator
        i: 0
        min: 12345
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 12345
            re: &63 !!perl/hash:RE_any 
              a: 0
              altname: scoped_01
              dba: scoped declarator
              i: 0
              min: 12345
              name: scoped_01
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 1
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: regex_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 2
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: package_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 3
                  dba: scoped declarator
                  i: 0
                  min: 24690
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_method 
                        a: 0
                        dba: scoped declarator
                        i: 0
                        min: 12345
                        name: typename
                        r: 1
                        rest: ''
                        s: 1
                      min: 12345
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                    - !!perl/hash:RE_block 
                      a: 0
                      context: void
                      dba: scoped declarator
                      i: 0
                      min: 0
                      r: 1
                      s: 1
                      text: "\n            my $t = $<typename>;\n            @$t > 1 and $.panic(\"Multiple prefix constraints not yet supported\")\n        "
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: multi_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 4
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: multi_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: scoped declarator
        i: 0
        min: 12345
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion 
            assert: "?"
            min: 0
            re: !!perl/hash:RE_method_re 
              a: 0
              dba: scoped declarator
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE 
                decl: []

                min: 1
                re: !!perl/hash:RE_cclass 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: "[A..Z]"
              s: 1
          - !!perl/hash:RE_method 
            a: 0
            dba: scoped declarator
            i: 0
            min: 12345
            name: longname
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: scoped declarator
            i: 0
            min: 0
            r: 1
            s: 1
            text: "\n            my $t = $<longname>.Str;\n            if not $.is_known($t) {\n                $.panic(\"In \\\"$*SCOPE\\\" declaration, typename $t must be predeclared (or marked as declarative with :: prefix)\");\n            }\n        "
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion 
            assert: "!"
            min: 0
            re: !!perl/hash:RE_noop 
              a: 0
              dba: scoped declarator
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: scoped declarator
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed $*SCOPE")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
scoped_01: *63
semiarglist: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: semiarglist
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: semiarglist
          i: 0
          min: 12345
          name: arglist
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: semiarglist
            i: 0
            min: 1
            r: 1
            s: 0
            text: ;
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: semiarglist
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
semilist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: semilist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 0
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: semicolon list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &54 !!perl/hash:RE_any 
          a: 0
          altname: semilist_01
          dba: semicolon list
          i: 0
          min: 0
          name: semilist_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: semilist_01 0
              dba: semicolon list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: semicolon list
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: semicolon list
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: semicolon list
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "[\\)\\]\\}]"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: semilist_01 1
              dba: semicolon list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: semicolon list
                      i: 0
                      min: 24690
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: semicolon list
                          i: 0
                          min: 12345
                          name: statement
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: semicolon list
                          i: 0
                          min: 12345
                          name: eat_terminator
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
semilist_01: *54
sibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: sibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: nibble
          nobind: 1
          rest: ($lang)
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: left
      - !!perl/hash:RE_var 
        a: 0
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: sibble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: sibble
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: sibble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start ne $stop "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: sibble
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: sibble
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Missing '='")
                - !!perl/hash:RE_method 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: EXPR
                    nobind: 1
                    rest: (item %item_assignment)
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
            - !!perl/hash:RE_sequence 
              a: 0
              dba: sibble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $lang = $lang2.unbalanced($stop); "
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: nibble
                    nobind: 1
                    rest: ($lang)
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
                - !!perl/hash:RE_var 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
sigil__S_188Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_188Dollar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $
sigil__S_189AtAt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_189AtAt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "@@"
sigil__S_190At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_190At
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "@"
sigil__S_191Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_191Percent
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "%"
sigil__S_192Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_192Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
signature: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $zone is context<rw> = 'posreq'
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $startpos = self.pos
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: signature
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &70 !!perl/hash:RE_any 
            a: 0
            altname: signature_01
            dba: signature
            i: 0
            min: 0
            name: signature_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                alt: signature_01 0
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: signature
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &5 !!perl/hash:RE_any 
                      a: 0
                      altname: signature_02
                      dba: signature
                      i: 0
                      min: 1
                      name: signature_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 0
                          dba: signature
                          i: 0
                          min: 3
                          r: 1
                          s: 0
                          text: -->
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 1
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 2
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 3
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "{"
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: signature_02 4
                          dba: signature
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: signature
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: ":"
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: signature
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \s
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                alt: signature_01 1
                dba: signature
                i: 0
                min: 12345
                name: parameter
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_method 
            a: 0
            dba: signature
            i: 0
            min: 12345
            name: param_sep
            r: 1
            rest: ''
            s: 0
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: signature
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*IN_DECL = 0; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24693
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: signature
            i: 0
            min: 24693
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: signature
                i: 0
                min: 3
                r: 1
                s: 0
                text: -->
              - !!perl/hash:RE_method 
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: typename
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: signature
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SIGIL = '@'; $*CURPAD.{'$?GOTSIG'} ~= '(' ~ substr($*ORIG, $startpos, $.pos - $startpos) ~ ')'; "
signature_01: *70
signature_02: *5
sigterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sigterm
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: sigterm
        i: 0
        min: 2
        r: 1
        s: 0
        text: :(
      - !!perl/hash:RE_meta 
        a: 0
        dba: sigterm
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: sigterm
        i: 0
        min: 12345
        name: fakesignature
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: sigterm
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: sigterm
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'sigterm')
spacey: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: spacey
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: !!perl/hash:RE_cclass 
          a: 0
          dba: spacey
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ \\s \\# ]"
      s: 0
special_variable__S_144Dollar_a2_: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: special_variable__S_144Dollar_a2_
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $
special_variable__S_145DollarBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_145DollarBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_145DollarBang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $!
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_145DollarBang
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: special_variable__S_145DollarBang
              i: 0
              min: 1
              r: 1
              s: 0
              text: \w
          s: 0
special_variable__S_146DollarBangCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_146DollarBangCur_Ly
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 5
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_146DollarBangCur_Ly
            i: 0
            min: 5
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_146DollarBangCur_Ly
                i: 0
                min: 3
                r: 1
                s: 0
                text: $!{
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_146DollarBangCur_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_146DollarBangCur_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_146DollarBangCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 5
        var: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ($0.Str ~ " variable", 'smart match against $!')
special_variable__S_147DollarSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_147DollarSlash
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_147DollarSlash
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $/
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_147DollarSlash
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: special_variable__S_147DollarSlash
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: special_variable__S_147DollarSlash
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: special_variable__S_147DollarSlash
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: special_variable__S_147DollarSlash
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: =
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_cclass 
                            a: 0
                            dba: special_variable__S_147DollarSlash
                            i: 0
                            min: 1
                            nobind: 1
                            r: 1
                            s: 0
                            text: "[=]"
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: "('$/ variable as input record separator',\n             \"filehandle's :irs attribute\")"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
special_variable__S_148DollarTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_148DollarTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_148DollarTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $~
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_148DollarTilde
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_148DollarTilde
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &76 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_148DollarTilde_01
              dba: special_variable__S_148DollarTilde
              i: 0
              min: 1
              name: special_variable__S_148DollarTilde_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_148DollarTilde_01 0
                  dba: special_variable__S_148DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_148DollarTilde_01 1
                  dba: special_variable__S_148DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_148DollarTilde_01 2
                  dba: special_variable__S_148DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_148DollarTilde_01 3
                  dba: special_variable__S_148DollarTilde
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$~ variable', 'Form module')
special_variable__S_148DollarTilde_01: *76
special_variable__S_149DollarGrave: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_149DollarGrave
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_149DollarGrave
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $`
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_149DollarGrave
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_149DollarGrave
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &105 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_149DollarGrave_01
              dba: special_variable__S_149DollarGrave
              i: 0
              min: 1
              name: special_variable__S_149DollarGrave_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_149DollarGrave_01 0
                  dba: special_variable__S_149DollarGrave
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_149DollarGrave_01 1
                  dba: special_variable__S_149DollarGrave
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_149DollarGrave_01 2
                  dba: special_variable__S_149DollarGrave
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$` variable', 'explicit pattern before <(')
special_variable__S_149DollarGrave_01: *105
special_variable__S_150DollarAt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_150DollarAt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_150DollarAt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $@
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_150DollarAt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$@ variable as eval error', '$!')
special_variable__S_151DollarSharp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_151DollarSharp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_151DollarSharp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $#
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_151DollarSharp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: special_variable__S_151DollarSharp
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: special_variable__S_151DollarSharp
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: special_variable__S_151DollarSharp
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  min: 1
                  var: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: obs
                  nobind: 1
                  rest: ("\$#" ~ $0.Str ~ " variable", '@' ~ $0.Str ~ '.end')
            - !!perl/hash:RE_method 
              min: 0
              name: obs
              nobind: 1
              rest: ('$# variable', '.fmt')
special_variable__S_152DollarDollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_152DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_152DollarDollar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $$
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: special_variable__S_152DollarDollar
          i: 0
          min: 12345
          name: alpha
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_152DollarDollar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_152DollarDollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &96 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_152DollarDollar_01
              dba: special_variable__S_152DollarDollar
              i: 0
              min: 1
              name: special_variable__S_152DollarDollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_152DollarDollar_01 0
                  dba: special_variable__S_152DollarDollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_152DollarDollar_01 1
                  dba: special_variable__S_152DollarDollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_152DollarDollar_01 2
                  dba: special_variable__S_152DollarDollar
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$$ variable', '$*PID')
special_variable__S_152DollarDollar_01: *96
special_variable__S_153DollarPercent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_153DollarPercent
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_153DollarPercent
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $%
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_153DollarPercent
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$% variable', 'Form module')
special_variable__S_154DollarCaretX: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_154DollarCaretX
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_154DollarCaretX
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_154DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        text: "^"
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_cclass 
            a: 0
            dba: special_variable__S_154DollarCaretX
            i: 0
            min: 1
            r: 1
            s: 0
            text: "[A..Z]"
        dba: special_variable__S_154DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        var: letter
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_154DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
      - !!perl/hash:RE_method 
        min: 0
        name: obscaret
        nobind: 1
        rest: ($<sigil>.Str ~ '^' ~ $<letter>.Str, $<sigil>, $<letter>.Str)
special_variable__S_155DollarCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_155DollarCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_155DollarCaret
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $^
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_155DollarCaret
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_155DollarCaret
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &83 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_155DollarCaret_01
              dba: special_variable__S_155DollarCaret
              i: 0
              min: 1
              name: special_variable__S_155DollarCaret_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_155DollarCaret_01 0
                  dba: special_variable__S_155DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_155DollarCaret_01 1
                  dba: special_variable__S_155DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_155DollarCaret_01 2
                  dba: special_variable__S_155DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_155DollarCaret_01 3
                  dba: special_variable__S_155DollarCaret
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$^ variable', 'Form module')
special_variable__S_155DollarCaret_01: *83
special_variable__S_156DollarAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_156DollarAmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_156DollarAmp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $&
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_156DollarAmp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_156DollarAmp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &124 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_156DollarAmp_01
              dba: special_variable__S_156DollarAmp
              i: 0
              min: 1
              name: special_variable__S_156DollarAmp_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_156DollarAmp_01 0
                  dba: special_variable__S_156DollarAmp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_156DollarAmp_01 1
                  dba: special_variable__S_156DollarAmp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_156DollarAmp_01 2
                  dba: special_variable__S_156DollarAmp
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$& variable', '$/ or $()')
special_variable__S_156DollarAmp_01: *124
special_variable__S_157DollarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_157DollarStar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_157DollarStar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $*
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_157DollarStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_157DollarStar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &39 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_157DollarStar_01
              dba: special_variable__S_157DollarStar
              i: 0
              min: 1
              name: special_variable__S_157DollarStar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_157DollarStar_01 0
                  dba: special_variable__S_157DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_157DollarStar_01 1
                  dba: special_variable__S_157DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_157DollarStar_01 2
                  dba: special_variable__S_157DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_157DollarStar_01 3
                  dba: special_variable__S_157DollarStar
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$* variable', '^^ and $$')
special_variable__S_157DollarStar_01: *39
special_variable__S_158DollarThesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_158DollarThesis
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_158DollarThesis
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $)
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_158DollarThesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_158DollarThesis
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &64 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_158DollarThesis_01
              dba: special_variable__S_158DollarThesis
              i: 0
              min: 1
              name: special_variable__S_158DollarThesis_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_158DollarThesis_01 0
                  dba: special_variable__S_158DollarThesis
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_158DollarThesis_01 1
                  dba: special_variable__S_158DollarThesis
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_158DollarThesis_01 2
                  dba: special_variable__S_158DollarThesis
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$) variable', '$*EGID')
special_variable__S_158DollarThesis_01: *64
special_variable__S_159DollarMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_159DollarMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_159DollarMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $-
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_159DollarMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_159DollarMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &27 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_159DollarMinus_01
              dba: special_variable__S_159DollarMinus
              i: 0
              min: 1
              name: special_variable__S_159DollarMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_159DollarMinus_01 0
                  dba: special_variable__S_159DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_159DollarMinus_01 1
                  dba: special_variable__S_159DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_159DollarMinus_01 2
                  dba: special_variable__S_159DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_159DollarMinus_01 3
                  dba: special_variable__S_159DollarMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$- variable', 'Form module')
special_variable__S_159DollarMinus_01: *27
special_variable__S_160DollarEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_160DollarEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_160DollarEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $=
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_160DollarEqual
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_160DollarEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &109 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_160DollarEqual_01
              dba: special_variable__S_160DollarEqual
              i: 0
              min: 1
              name: special_variable__S_160DollarEqual_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_160DollarEqual_01 0
                  dba: special_variable__S_160DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_160DollarEqual_01 1
                  dba: special_variable__S_160DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_160DollarEqual_01 2
                  dba: special_variable__S_160DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_160DollarEqual_01 3
                  dba: special_variable__S_160DollarEqual
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$= variable', 'Form module')
special_variable__S_160DollarEqual_01: *109
special_variable__S_161AtPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_161AtPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_161AtPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "@+"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_161AtPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_161AtPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &91 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_161AtPlus_01
              dba: special_variable__S_161AtPlus
              i: 0
              min: 1
              name: special_variable__S_161AtPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_161AtPlus_01 0
                  dba: special_variable__S_161AtPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_161AtPlus_01 1
                  dba: special_variable__S_161AtPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_161AtPlus_01 2
                  dba: special_variable__S_161AtPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_161AtPlus_01: *91
special_variable__S_162PercentPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_162PercentPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_162PercentPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%+"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_162PercentPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_162PercentPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &56 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_162PercentPlus_01
              dba: special_variable__S_162PercentPlus
              i: 0
              min: 1
              name: special_variable__S_162PercentPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_162PercentPlus_01 0
                  dba: special_variable__S_162PercentPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_162PercentPlus_01 1
                  dba: special_variable__S_162PercentPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_162PercentPlus_01 2
                  dba: special_variable__S_162PercentPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%+ variable', '.to method')
special_variable__S_162PercentPlus_01: *56
special_variable__S_163DollarPlusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_163DollarPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_163DollarPlusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: $+[
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_164AtPlusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_164AtPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_164AtPlusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@+["
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_165AtPlusCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_165AtPlusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_165AtPlusCur_Ly
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@+{"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%+ variable', '.to method')
special_variable__S_166AtMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_166AtMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_166AtMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "@-"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_166AtMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_166AtMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &137 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_166AtMinus_01
              dba: special_variable__S_166AtMinus
              i: 0
              min: 1
              name: special_variable__S_166AtMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_166AtMinus_01 0
                  dba: special_variable__S_166AtMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_166AtMinus_01 1
                  dba: special_variable__S_166AtMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_166AtMinus_01 2
                  dba: special_variable__S_166AtMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_166AtMinus_01: *137
special_variable__S_167PercentMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_167PercentMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_167PercentMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%-"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_167PercentMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_167PercentMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &29 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_167PercentMinus_01
              dba: special_variable__S_167PercentMinus
              i: 0
              min: 1
              name: special_variable__S_167PercentMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_167PercentMinus_01 0
                  dba: special_variable__S_167PercentMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_167PercentMinus_01 1
                  dba: special_variable__S_167PercentMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_167PercentMinus_01 2
                  dba: special_variable__S_167PercentMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%- variable', '.from method')
special_variable__S_167PercentMinus_01: *29
special_variable__S_168DollarMinusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_168DollarMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_168DollarMinusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: $-[
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_169AtMinusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_169AtMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_169AtMinusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@-["
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_170PercentMinusCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_170PercentMinusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_170PercentMinusCur_Ly
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@-{"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%- variable', '.from method')
special_variable__S_171DollarPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_171DollarPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_171DollarPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $+
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_171DollarPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_171DollarPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &13 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_171DollarPlus_01
              dba: special_variable__S_171DollarPlus
              i: 0
              min: 1
              name: special_variable__S_171DollarPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_171DollarPlus_01 0
                  dba: special_variable__S_171DollarPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_171DollarPlus_01 1
                  dba: special_variable__S_171DollarPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_171DollarPlus_01 2
                  dba: special_variable__S_171DollarPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$+ variable', 'Form module')
special_variable__S_171DollarPlus_01: *13
special_variable__S_172DollarCurCaret_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_172DollarCurCaret_Ly
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 12349
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_172DollarCurCaret_Ly
            i: 0
            min: 12349
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: special_variable__S_172DollarCurCaret_Ly
                i: 0
                min: 12345
                name: sigil
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_172DollarCurCaret_Ly
                i: 0
                min: 2
                r: 1
                s: 0
                text: "{^"
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_172DollarCurCaret_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_172DollarCurCaret_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_172DollarCurCaret_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 12349
        var: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obscaret
        nobind: 1
        rest: ($0.Str, $<sigil>, $0.{0}.Str)
special_variable__S_173ColonColonCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_173ColonColonCur_Ly
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_173ColonColonCur_Ly
        i: 0
        min: 2
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_173ColonColonCur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: special_variable__S_173ColonColonCur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
special_variable__S_174DollarCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_174DollarCur_Ly
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 4
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_174DollarCur_Ly
            i: 0
            min: 4
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_cclass 
                a: 0
                dba: special_variable__S_174DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "[$@%]"
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_174DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "{"
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_174DollarCur_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_174DollarCur_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_174DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 4
        var: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ("" ~ $0.Str ~ " variable", "\{" ~ $<sigil>.Str ~ "}(" ~ $0.{0}.Str ~ ")")
special_variable__S_175DollarBra: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_175DollarBra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_175DollarBra
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $[
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_175DollarBra
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_175DollarBra
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &115 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_175DollarBra_01
              dba: special_variable__S_175DollarBra
              i: 0
              min: 1
              name: special_variable__S_175DollarBra_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_175DollarBra_01 0
                  dba: special_variable__S_175DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_175DollarBra_01 1
                  dba: special_variable__S_175DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_175DollarBra_01 2
                  dba: special_variable__S_175DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_175DollarBra_01 3
                  dba: special_variable__S_175DollarBra
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$[ variable', 'user-defined array indices')
special_variable__S_175DollarBra_01: *115
special_variable__S_176DollarKet: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_176DollarKet
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_176DollarKet
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $]
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_176DollarKet
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_176DollarKet
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &133 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_176DollarKet_01
              dba: special_variable__S_176DollarKet
              i: 0
              min: 1
              name: special_variable__S_176DollarKet_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_176DollarKet_01 0
                  dba: special_variable__S_176DollarKet
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_176DollarKet_01 1
                  dba: special_variable__S_176DollarKet
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_176DollarKet_01 2
                  dba: special_variable__S_176DollarKet
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$] variable', '$*PERL_VERSION')
special_variable__S_176DollarKet_01: *133
special_variable__S_177DollarBack: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_177DollarBack
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_177DollarBack
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $\
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_177DollarBack
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_177DollarBack
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &20 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_177DollarBack_01
              dba: special_variable__S_177DollarBack
              i: 0
              min: 1
              name: special_variable__S_177DollarBack_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_177DollarBack_01 0
                  dba: special_variable__S_177DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_177DollarBack_01 1
                  dba: special_variable__S_177DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_177DollarBack_01 2
                  dba: special_variable__S_177DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_177DollarBack_01 3
                  dba: special_variable__S_177DollarBack
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$\\ variable', "the filehandle's :ors attribute")
special_variable__S_177DollarBack_01: *20
special_variable__S_178DollarVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_178DollarVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_178DollarVert
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $|
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_178DollarVert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_178DollarVert
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &45 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_178DollarVert_01
              dba: special_variable__S_178DollarVert
              i: 0
              min: 1
              name: special_variable__S_178DollarVert_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_178DollarVert_01 0
                  dba: special_variable__S_178DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_178DollarVert_01 1
                  dba: special_variable__S_178DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_178DollarVert_01 2
                  dba: special_variable__S_178DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_178DollarVert_01 3
                  dba: special_variable__S_178DollarVert
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$| variable', ':autoflush on open')
special_variable__S_178DollarVert_01: *45
special_variable__S_179DollarColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_179DollarColon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_179DollarColon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "$:"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_179DollarColon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: special_variable__S_179DollarColon
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[\\x20\\t\\n\\],=)}]"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: "('$: variable', 'Form module')"
special_variable__S_180DollarSemi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_180DollarSemi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_180DollarSemi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $;
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_180DollarSemi
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_180DollarSemi
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &71 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_180DollarSemi_01
              dba: special_variable__S_180DollarSemi
              i: 0
              min: 1
              name: special_variable__S_180DollarSemi_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_180DollarSemi_01 0
                  dba: special_variable__S_180DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_180DollarSemi_01 1
                  dba: special_variable__S_180DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_180DollarSemi_01 2
                  dba: special_variable__S_180DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_180DollarSemi_01 3
                  dba: special_variable__S_180DollarSemi
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$; variable', 'real multidimensional hashes')
special_variable__S_180DollarSemi_01: *71
special_variable__S_181DollarSingle: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_181DollarSingle
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_181DollarSingle
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $'
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_181DollarSingle
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_181DollarSingle
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &59 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_181DollarSingle_01
              dba: special_variable__S_181DollarSingle
              i: 0
              min: 1
              name: special_variable__S_181DollarSingle_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_181DollarSingle_01 0
                  dba: special_variable__S_181DollarSingle
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_181DollarSingle_01 1
                  dba: special_variable__S_181DollarSingle
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_181DollarSingle_01 2
                  dba: special_variable__S_181DollarSingle
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")
special_variable__S_181DollarSingle_01: *59
special_variable__S_182DollarDouble: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_182DollarDouble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_182DollarDouble
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: special_variable__S_182DollarDouble
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*INTERPOLATION "
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_182DollarDouble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_182DollarDouble
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &90 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_182DollarDouble_01
              dba: special_variable__S_182DollarDouble
              i: 0
              min: 1
              name: special_variable__S_182DollarDouble_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_182DollarDouble_01 0
                  dba: special_variable__S_182DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_182DollarDouble_01 1
                  dba: special_variable__S_182DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_182DollarDouble_01 2
                  dba: special_variable__S_182DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_182DollarDouble_01 3
                  dba: special_variable__S_182DollarDouble
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$" variable', '.join() method')
special_variable__S_182DollarDouble_01: *90
special_variable__S_183DollarComma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_183DollarComma
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_183DollarComma
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $,
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_183DollarComma
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_183DollarComma
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &36 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_183DollarComma_01
              dba: special_variable__S_183DollarComma
              i: 0
              min: 1
              name: special_variable__S_183DollarComma_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_183DollarComma_01 0
                  dba: special_variable__S_183DollarComma
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_183DollarComma_01 1
                  dba: special_variable__S_183DollarComma
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_183DollarComma_01 2
                  dba: special_variable__S_183DollarComma
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$, variable', ".join() method")
special_variable__S_183DollarComma_01: *36
special_variable__S_184DollarLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_184DollarLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_184DollarLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "['$<']"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_184DollarLt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_184DollarLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: special_variable__S_184DollarLt
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_184DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_184DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \w
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_184DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: special_variable__S_184DollarLt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$< variable', '$*UID')
special_variable__S_185DollarGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_185DollarGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_185DollarGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $>
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_185DollarGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_185DollarGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &22 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_185DollarGt_01
              dba: special_variable__S_185DollarGt
              i: 0
              min: 1
              name: special_variable__S_185DollarGt_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_185DollarGt_01 0
                  dba: special_variable__S_185DollarGt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_185DollarGt_01 1
                  dba: special_variable__S_185DollarGt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_185DollarGt_01 2
                  dba: special_variable__S_185DollarGt
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$> variable', '$*EUID')
special_variable__S_185DollarGt_01: *22
special_variable__S_186DollarDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_186DollarDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_186DollarDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $.
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_186DollarDot
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_186DollarDot
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &35 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_186DollarDot_01
              dba: special_variable__S_186DollarDot
              i: 0
              min: 1
              name: special_variable__S_186DollarDot_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_186DollarDot_01 0
                  dba: special_variable__S_186DollarDot
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_186DollarDot_01 1
                  dba: special_variable__S_186DollarDot
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_186DollarDot_01 2
                  dba: special_variable__S_186DollarDot
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$. variable', "filehandle's .line method")
special_variable__S_186DollarDot_01: *35
special_variable__S_187DollarQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_187DollarQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_187DollarQuestion
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $?
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_187DollarQuestion
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_187DollarQuestion
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &28 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_187DollarQuestion_01
              dba: special_variable__S_187DollarQuestion
              i: 0
              min: 1
              name: special_variable__S_187DollarQuestion_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_187DollarQuestion_01 0
                  dba: special_variable__S_187DollarQuestion
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_187DollarQuestion_01 1
                  dba: special_variable__S_187DollarQuestion
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_187DollarQuestion_01 2
                  dba: special_variable__S_187DollarQuestion
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$? variable as child error', '$!')
special_variable__S_187DollarQuestion_01: *28
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
statement: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $endargs is context = -1
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INTERPOLATION is context<rw> = 0
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: statement
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[\\)\\]\\}]"
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: statement
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: " $ = %*LANG<MAIN>.bless($); "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &48 !!perl/hash:RE_any 
          a: 0
          altname: statement_02
          dba: statement end
          i: 0
          min: 0
          name: statement_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 0
              dba: statement
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: label
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: statement
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement', 'label'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 1
              dba: statement
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: statement_control
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement', 'control'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 2
              dba: statement end
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: EXPR
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement', 'expr'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: statement modifier
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: statement end
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " (@*MEMOS[$.pos]<endstmt> // 0) == 2 "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement modifier
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: statement modifier
                            i: 0
                            min: 12345
                            name: ws
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 12345
                              re: &135 !!perl/hash:RE_any 
                                a: 0
                                altname: statement_05
                                dba: statement modifier loop
                                i: 0
                                min: 12345
                                name: statement_05
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: statement_05 0
                                    dba: statement modifier
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: statement modifier
                                        i: 0
                                        min: 12345
                                        name: statement_mod_loop
                                        r: 1
                                        rest: ''
                                        s: 0
                                      - !!perl/hash:RE_method_internal 
                                        args: $S, 'statement', 'mod loop'
                                        max: 0
                                        min: 0
                                        name: _REDUCE
                                      - !!perl/hash:RE_block 
                                        a: 0
                                        context: void
                                        dba: statement modifier
                                        i: 0
                                        min: 0
                                        r: 1
                                        s: 0
                                        text: "\n                    my $sp = $<EXPR><statement_prefix>;\n                    if $sp and $sp<sym> eq 'do' {\n                       my $s = $<statement_mod_loop>[0]<sym>;\n                       $.obs(\"do...$s\" ,\"repeat...$s\");\n                    }\n                "
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: statement_05 1
                                    dba: statement modifier loop
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: statement modifier
                                        i: 0
                                        min: 12345
                                        name: statement_mod_cond
                                        r: 1
                                        rest: ''
                                        s: 0
                                      - !!perl/hash:RE_method_internal 
                                        args: $S, 'statement', 'mod cond'
                                        max: 0
                                        min: 0
                                        name: _REDUCE
                                      - !!perl/hash:RE_bracket 
                                        decl: []

                                        min: 0
                                        re: !!perl/hash:RE_first 
                                          a: 0
                                          dba: statement modifier loop
                                          i: 0
                                          min: 0
                                          r: 1
                                          s: 0
                                          zyg: 
                                            - !!perl/hash:RE_assertion 
                                              assert: "?"
                                              min: 0
                                              re: !!perl/hash:RE_block 
                                                a: 0
                                                context: bool
                                                dba: statement modifier loop
                                                i: 0
                                                min: 0
                                                nobind: 1
                                                r: 1
                                                s: 0
                                                text: " (@*MEMOS[$.pos]<endstmt> // 0) == 2 "
                                            - !!perl/hash:RE_sequence 
                                              a: 0
                                              dba: statement modifier loop
                                              i: 0
                                              min: 12345
                                              r: 1
                                              s: 0
                                              zyg: 
                                                - !!perl/hash:RE_method 
                                                  a: 0
                                                  dba: statement modifier loop
                                                  i: 0
                                                  min: 12345
                                                  name: ws
                                                  nobind: 1
                                                  r: 1
                                                  rest: ''
                                                  s: 0
                                                - !!perl/hash:RE_quantified_atom 
                                                  atom: !!perl/hash:RE_method 
                                                    a: 0
                                                    dba: statement modifier loop
                                                    i: 0
                                                    min: 12345
                                                    name: statement_mod_loop
                                                    r: 1
                                                    rest: ''
                                                    s: 0
                                                  min: 0
                                                  quant: 
                                                    - "?"
                                                    - ":"
                                                    - ''
                                                    - 0
                                                - !!perl/hash:RE_method_internal 
                                                  args: $S, 'statement', 'mod condloop'
                                                  max: 0
                                                  min: 0
                                                  name: _REDUCE
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement', 'modexpr'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 3
              dba: statement end
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement end
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: statement end
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: ;
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement', 'null'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: statement
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " (@*MEMOS[@*MEMOS[$.pos]<ws>//$.pos]<endargs>//0) == 1 "
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: statement
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \h
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &92 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_10
                      dba: statement
                      i: 0
                      min: 1
                      name: statement_10
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 0
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: ;
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 1
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 2
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 3
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "}"
                  s: 0
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: infixstopper
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Statements must be separated with semicolon")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
statement_02: *48
statement_05: *135
statement_10: *92
statement_control__S_036need: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement_control__S_036need
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $longname
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_036need
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_036need
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: need
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_036need
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &134 !!perl/hash:RE_any 
            a: 0
            altname: statement_control__S_036need_01
            dba: statement_control__S_036need
            i: 0
            min: 12345
            name: statement_control__S_036need_01
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: statement_control__S_036need_01 0
                dba: statement_control__S_036need
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: statement_control__S_036need
                    i: 0
                    min: 12345
                    name: version
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: statement_control__S_036need_01 1
                dba: statement_control__S_036need
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: statement_control__S_036need
                    i: 0
                    min: 12345
                    name: module_name
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: statement_control__S_036need
                    i: 0
                    min: 0
                    r: 1
                    s: 1
                    text: "\n            my $SCOPE is context = 'use';\n            $longname = $<module_name>[*-1]<longname>.Str;\n            $.do_imports($longname, '');\n        "
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: statement_control__S_036need
            i: 0
            min: 1
            r: 1
            s: 1
            text: ","
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_036need_01: *134
statement_control__S_037use: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement_control__S_037use
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $longname
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement_control__S_037use
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $SCOPE is context = 'use'
  kind: token
  min: 61725
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_037use
    i: 0
    min: 61725
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037use
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: use
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037use
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037use
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &95 !!perl/hash:RE_any 
          a: 0
          altname: statement_control__S_037use_01
          dba: statement_control__S_037use
          i: 0
          min: 12345
          name: statement_control__S_037use_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: statement_control__S_037use_01 0
              dba: statement_control__S_037use
              i: 0
              min: 12345
              name: version
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_037use_01 1
              dba: statement_control__S_037use
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_037use
                  i: 0
                  min: 12345
                  name: module_name
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: statement_control__S_037use
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            $longname = $<module_name><longname>.Str;\n        "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: statement_control__S_037use
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement_control__S_037use
                        i: 0
                        min: 24690
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_037use
                            i: 0
                            min: 12345
                            name: spacey
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_037use
                            i: 0
                            min: 12345
                            name: arglist
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: statement_control__S_037use
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: "\n                # XXX cheat on import list for now\n                $.do_imports($longname, $<arglist>);\n            "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: statement_control__S_037use
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $.do_imports($longname, ''); "
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037use
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
statement_control__S_037use_01: *95
statement_control__S_038no: !!perl/hash:RE 
  decl: []

  kind: token
  min: 61725
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_038no
    i: 0
    min: 61725
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 'no'
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_038no
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: statement_control__S_038no
                i: 0
                min: 12345
                name: spacey
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: statement_control__S_038no
                i: 0
                min: 12345
                name: arglist
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
statement_control__S_039if: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_039if
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039if
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: if
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039if
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039if
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12350
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_039if
            i: 0
            min: 12350
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_bracket 
                decl: []

                min: 0
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_039if
                      i: 0
                      min: 0
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: statement_control__S_039if
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 6
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: statement_control__S_039if
                                i: 0
                                min: 6
                                r: 1
                                s: 1
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: statement_control__S_039if
                                    i: 0
                                    min: 4
                                    r: 1
                                    s: 1
                                    text: else
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_meta 
                                      a: 0
                                      dba: statement_control__S_039if
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: \s
                                    min: 0
                                    quant: 
                                      - "*"
                                      - ":"
                                      - ''
                                      - 0
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: statement_control__S_039if
                                    i: 0
                                    min: 2
                                    r: 1
                                    s: 1
                                    text: if
                            s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_039if
                      i: 0
                      min: 0
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Please use 'elsif'")
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_string 
                a: 0
                dba: statement_control__S_039if
                i: 0
                min: 5
                r: 1
                s: 1
                text: elsif
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: spacey
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: xblock
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                dba: statement_control__S_039if
                i: 0
                min: 12345
                r: 1
                s: 1
                var: elsif
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method_internal 
                args: $S, 'statement_control__S_039if', 'elsif'
                max: 0
                min: 0
                name: _REDUCE
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12349
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_039if
            i: 0
            min: 12349
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_string 
                a: 0
                dba: statement_control__S_039if
                i: 0
                min: 4
                r: 1
                s: 1
                text: else
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: spacey
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: pblock
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                dba: statement_control__S_039if
                i: 0
                min: 12345
                r: 1
                s: 1
                var: else
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method_internal 
                args: $S, 'statement_control__S_039if', 'else'
                max: 0
                min: 0
                name: _REDUCE
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_040unless: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_040unless
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040unless
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: unless
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040unless
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040unless
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: statement_control__S_040unless
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_040unless
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement_control__S_040unless
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 4
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: statement_control__S_040unless
                        i: 0
                        min: 4
                        r: 1
                        s: 1
                        text: else
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_040unless
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("unless does not take \"else\" in Perl 6; please rewrite using \"if\"")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_041while: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_041while
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041while
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: while
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041while
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_041while
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_041while
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 5
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_041while
                      i: 0
                      min: 5
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 3
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: statement_control__S_041while
                              i: 0
                              min: 3
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_string 
                                    a: 0
                                    dba: statement_control__S_041while
                                    i: 0
                                    min: 2
                                    r: 1
                                    s: 1
                                    text: my
                                  min: 0
                                  quant: 
                                    - "?"
                                    - ":"
                                    - ''
                                    - 0
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: ws
                                  nobind: 1
                                  noquant: 1
                                  rest: ''
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: statement_control__S_041while
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: $
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: statement_control__S_041while
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 1
                                    text: \w
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: ws
                                  nobind: 1
                                  noquant: 1
                                  rest: ''
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: statement_control__S_041while
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: =
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: <
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: statement_control__S_041while
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: $
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: statement_control__S_041while
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \w
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ">"
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: )
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("This appears to be Perl 5 code")
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041while
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_042until: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_042until
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042until
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: until
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042until
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042until
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_043repeat: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37040
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_043repeat
    i: 0
    min: 37040
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043repeat
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: repeat
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043repeat
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12350
        re: &121 !!perl/hash:RE_any 
          a: 0
          altname: statement_control__S_043repeat_01
          dba: statement_control__S_043repeat
          i: 0
          min: 12350
          name: statement_control__S_043repeat_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_043repeat_01 0
              dba: statement_control__S_043repeat
              i: 0
              min: 12350
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 5
                    re: &4 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_control__S_043repeat_02
                      dba: statement_control__S_043repeat
                      i: 0
                      min: 5
                      name: statement_control__S_043repeat_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_02 0
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: while
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_02 1
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: until
                  min: 5
                  var: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_043repeat
                  i: 0
                  min: 12345
                  name: xblock
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_043repeat_01 1
              dba: statement_control__S_043repeat
              i: 0
              min: 24695
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_043repeat
                  i: 0
                  min: 12345
                  name: block
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_043repeat', 'block wu'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 5
                    re: &132 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_control__S_043repeat_03
                      dba: statement_control__S_043repeat
                      i: 0
                      min: 5
                      name: statement_control__S_043repeat_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_03 0
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: while
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_03 1
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: until
                  min: 5
                  var: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_043repeat
                  i: 0
                  min: 12345
                  name: EXPR
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_043repeat', 'expr wu'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_043repeat_01: *121
statement_control__S_043repeat_02: *4
statement_control__S_043repeat_03: *132
statement_control__S_044loop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_044loop
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044loop
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: loop
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044loop
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_paren 
            decl: []

            min: 4
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_044loop
              i: 0
              min: 4
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: (
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_044loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ;
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop', 'e1'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_044loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e2
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ;
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop', 'e2'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_044loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e3
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop', 'e3'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: )
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop', 'eee'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          min: 0
          nobind: 1
          quant: 
            - "?"
            - ":"
            - ''
            - 0
        dba: statement_control__S_044loop
        i: 0
        min: 0
        r: 1
        s: 1
        var: eee
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044loop
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_control__S_044loop', 'block'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_045for: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_045for
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045for
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: for
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045for
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_045for
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_045for
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 3
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_045for
                      i: 0
                      min: 3
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 2
                            r: 1
                            s: 1
                            text: my
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: $
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \w
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("This appears to be Perl 5 code")
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_045for
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_045for
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 4
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_045for
                      i: 0
                      min: 4
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 12345
                            name: EXPR
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ;
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 12345
                            name: EXPR
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ;
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 12345
                            name: EXPR
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: )
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('C-style "for (;;)" loop', '"loop (;;)"')
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045for
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_046given: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_046given
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046given
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: given
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046given
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046given
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_047when: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_047when
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047when
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: when
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047when
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047when
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_048default: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_048default
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048default
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: default
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048default
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048default
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_049BEGIN: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_049BEGIN
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049BEGIN
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: BEGIN
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049BEGIN
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049BEGIN
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_050CHECK: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_050CHECK
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050CHECK
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CHECK
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050CHECK
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050CHECK
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_051INIT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_051INIT
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051INIT
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: INIT
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051INIT
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051INIT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_052END: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_052END
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052END
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: END
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052END
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052END
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_053START: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_053START
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053START
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: START
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053START
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053START
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_054ENTER: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_054ENTER
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054ENTER
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: ENTER
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054ENTER
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054ENTER
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_055LEAVE: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_055LEAVE
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055LEAVE
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: LEAVE
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055LEAVE
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055LEAVE
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_056KEEP: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_056KEEP
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056KEEP
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: KEEP
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056KEEP
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056KEEP
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_057UNDO: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_057UNDO
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057UNDO
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: UNDO
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057UNDO
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057UNDO
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_058FIRST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_058FIRST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058FIRST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: FIRST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058FIRST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058FIRST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_059NEXT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_059NEXT
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059NEXT
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: NEXT
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059NEXT
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059NEXT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_060LAST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_060LAST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060LAST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: LAST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060LAST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060LAST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_061PRE: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_061PRE
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061PRE
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: PRE
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061PRE
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061PRE
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_062POST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_062POST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062POST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: POST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062POST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062POST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_063CATCH: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_063CATCH
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_063CATCH
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CATCH
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_063CATCH
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_063CATCH
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_064CONTROL: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_064CONTROL
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_064CONTROL
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CONTROL
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_064CONTROL
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_064CONTROL
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_065TEMP: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_065TEMP
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_065TEMP
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: TEMP
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_065TEMP
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_065TEMP
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_072if: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_072if
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_072if
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: if
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_072if
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_072if
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_073unless: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_073unless
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_073unless
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: unless
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_073unless
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_073unless
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_074when: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_074when
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_074when
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: when
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_074when
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_074when
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_075while: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_075while
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_075while
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: while
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_075while
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_075while
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_076until: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_076until
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_076until
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: until
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_076until
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_076until
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_077for: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_077for
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_077for
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: for
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_077for
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_077for
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_078given: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_078given
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_078given
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: given
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_078given
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_078given
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_prefix__S_279try: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_279try
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_279try
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: try
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_279try
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_280gather: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_280gather
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_280gather
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: gather
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_280gather
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_281contend: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_281contend
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_281contend
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: contend
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_281contend
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_282async: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_282async
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_282async
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: async
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_282async
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_283maybe: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_283maybe
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_283maybe
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: maybe
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_283maybe
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_284lazy: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_284lazy
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_284lazy
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: lazy
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_284lazy
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_285do: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_285do
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_285do
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: do
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_285do
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_286lift: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement_prefix__S_286lift
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QUASI_QUASH is context = 1
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_286lift
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_286lift
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: lift
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_286lift
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statementlist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statementlist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 0
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &43 !!perl/hash:RE_any 
          a: 0
          altname: statementlist_01
          dba: statement list
          i: 0
          min: 0
          name: statementlist_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 0
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: statement list
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: $
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 1
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement list
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement list
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: statement list
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "[\\)\\]\\}]"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 2
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement list
                      i: 0
                      min: 24690
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: statement list
                          i: 0
                          min: 12345
                          name: statement
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: statement list
                          i: 0
                          min: 12345
                          name: eat_terminator
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statementlist_01: *43
stdstopper: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: stdstopper
      i: 0
      max: 0
      min: 0
      r: 0
      s: 0
      text: my @stub = return self if @*MEMOS[self.pos]<endstmt> :exists
  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: standard stopper
    i: 0
    min: 0
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &60 !!perl/hash:RE_any 
          a: 0
          altname: stdstopper_01
          dba: standard stopper
          i: 0
          min: 0
          name: stdstopper_01
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: stdstopper_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: standard stopper
                i: 0
                min: 12345
                name: terminator
                nobind: 1
                r: 0
                rest: ''
                s: 0
            - !!perl/hash:RE_assertion 
              alt: stdstopper_01 1
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: standard stopper
                i: 0
                min: 12345
                name: unitstopper
                nobind: 1
                r: 0
                rest: ''
                s: 0
            - !!perl/hash:RE_meta 
              a: 0
              alt: stdstopper_01 2
              dba: standard stopper
              i: 0
              min: 0
              r: 0
              s: 0
              text: $
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: standard stopper
        i: 0
        min: 0
        r: 0
        s: 0
        text: " @*MEMOS[$.pos]<endstmt> ||= 1; "
stdstopper_01: *60
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: stopper
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
sublongname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sublongname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: sublongname
        i: 0
        min: 12345
        name: subshortname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: sublongname
          i: 0
          min: 12345
          name: sigterm
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
subshortname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &38 !!perl/hash:RE_any 
      a: 0
      altname: subshortname_01
      dba: subshortname
      i: 0
      min: 12345
      name: subshortname_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: subshortname_01 0
          dba: subshortname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: subshortname
              i: 0
              min: 12345
              name: category
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: subshortname
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_method 
                        a: 0
                        dba: subshortname
                        i: 0
                        min: 12345
                        name: colonpair
                        r: 1
                        rest: ''
                        s: 0
                      min: 12345
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_block 
                      a: 0
                      context: void
                      dba: subshortname
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: " $.add_macro($<category>) if $*IN_DECL; "
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_method 
          a: 0
          alt: subshortname_01 1
          dba: subshortname
          i: 0
          min: 12345
          name: desigilname
          r: 1
          rest: ''
          s: 0
subshortname_01: *38
term__S_066BEGIN: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_066BEGIN
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_066BEGIN
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: BEGIN
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_066BEGIN
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_067CHECK: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_067CHECK
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_067CHECK
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CHECK
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_067CHECK
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_068INIT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_068INIT
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_068INIT
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: INIT
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_068INIT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_069START: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_069START
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_069START
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: START
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_069START
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_070ENTER: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_070ENTER
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_070ENTER
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: ENTER
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_070ENTER
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_071FIRST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_071FIRST
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_071FIRST
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: FIRST
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_071FIRST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_287YOU_ARE_HERE: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_287YOU_ARE_HERE
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_287YOU_ARE_HERE
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: YOU_ARE_HERE
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_287YOU_ARE_HERE
        i: 0
        min: 12345
        name: you_are_here
        nobind: 1
        r: 1
        rest: ''
        s: 0
term__S_288new: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_288new
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: term__S_288new
        i: 0
        min: 3
        r: 1
        s: 0
        text: new
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: term__S_288new
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_288new
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: term__S_288new
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: term__S_288new
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: term__S_288new
              i: 0
              min: 1
              r: 1
              s: 0
              text: ":"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ("C++ constructor syntax", "method call syntax")
term__S_289ColonColonQuestionIDENT: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_289ColonColonQuestionIDENT
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12348
          nobind: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_289ColonColonQuestionIDENT
            i: 0
            min: 12348
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: term__S_289ColonColonQuestionIDENT
                i: 0
                min: 3
                r: 1
                s: 0
                text: ::?
              - !!perl/hash:RE_method 
                a: 0
                dba: term__S_289ColonColonQuestionIDENT
                i: 0
                min: 12345
                name: identifier
                r: 1
                rest: ''
                s: 0
        dba: term__S_289ColonColonQuestionIDENT
        i: 0
        min: 12348
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_289ColonColonQuestionIDENT
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_290undef: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_290undef
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_290undef
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: undef
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_290undef
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_290undef
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_290undef
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_290undef
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_290undef
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: term__S_290undef
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: $/
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: "('$/ variable as input record separator',\n             \"the filehandle's .slurp method\")"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_290undef
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_290undef
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 12346
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_290undef
                      i: 0
                      min: 12346
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_290undef
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: term__S_290undef
                          i: 0
                          min: 12345
                          name: sigil
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: term__S_290undef
                            i: 0
                            min: 12345
                            name: twigil
                            r: 1
                            rest: ''
                            s: 0
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: term__S_290undef
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \w
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('undef as a verb', 'undefine function')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_291continue: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_291continue
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_291continue
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: continue
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_291continue
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_292self: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_292self
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_292self
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: self
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_292self
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_293defer: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_293defer
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_293defer
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: defer
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_293defer
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_294rand: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_294rand
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_294rand
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rand
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_294rand
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_294rand
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_294rand
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_294rand
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: term__S_294rand
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: (
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_294rand
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: &21 !!perl/hash:RE_any 
                            a: 0
                            altname: term__S_294rand_03
                            dba: term__S_294rand
                            i: 0
                            min: 1
                            name: term__S_294rand_03
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_meta 
                                a: 0
                                alt: term__S_294rand_03 0
                                dba: term__S_294rand
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: term__S_294rand_03 1
                                dba: term__S_294rand
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: $
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('rand(N)', 'N.rand or (1..N).pick')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_294rand
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_294rand
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: term__S_294rand
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      text: ()
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('rand()', 'rand')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_294rand_03: *21
term__S_295e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_295e
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_295e
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: e
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_295e
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_296i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_296i
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_296i
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: i
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_296i
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_297pi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_297pi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_297pi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: pi
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_297pi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_298Inf: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_298Inf
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_298Inf
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Inf
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_298Inf
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_299NaN: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_299NaN
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_299NaN
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: NaN
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_299NaN
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_300Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_method 
    a: 0
    dba: term__S_300Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
term__S_301StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_method 
    a: 0
    dba: term__S_301StarStar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "**"
term__S_415DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_415DotDotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_415DotDotDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ...
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_415DotDotDot
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_416QuestionQuestionQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_416QuestionQuestionQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_416QuestionQuestionQuestion
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ???
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_416QuestionQuestionQuestion
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_417BangBangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_417BangBangBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_417BangBangBang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!!!"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_417BangBangBang
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_418identifier: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_418identifier
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $name
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_418identifier
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $pos
  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_418identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_418identifier
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: term__S_418identifier
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: &23 !!perl/hash:RE_any 
                  a: 0
                  altname: term__S_418identifier_02
                  dba: term__S_418identifier
                  i: 0
                  min: 1
                  name: term__S_418identifier_02
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: term__S_418identifier_02 0
                      dba: term__S_418identifier
                      i: 0
                      min: 12345
                      name: unsp
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_string 
                      a: 0
                      alt: term__S_418identifier_02 1
                      dba: term__S_418identifier
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_418identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $name = $<identifier>.Str; $pos = $.pos; "
      - !!perl/hash:RE_method 
        min: 0
        name: args
        rest: ( $.is_name($name) )
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_418identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: " self.add_mystery($name,$pos) unless $<args><invocant>; "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_418identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        if $*BORG and $*BORG.<block> {\n            if not $*BORG.<name> {\n                $*BORG.<culprit> = $<identifier>.cursor($pos);\n                $*BORG.<name> = $name;\n            }\n        }\n    "
term__S_418identifier_02: *23
term__S_419opfunc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_419opfunc
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_419opfunc
        i: 0
        min: 12345
        name: category
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_419opfunc
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_419opfunc
        i: 0
        min: 12345
        name: args
        r: 1
        rest: ''
        s: 0
term__S_420name: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_420name
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $name
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_420name
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $pos
  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_420name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_420name
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_420name
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        $name = $<longname>.Str;\n        $pos = $.pos;\n    "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: type parameter
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: type parameter
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: term__S_420name
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: "\n            $.is_name($<longname>.Str) or substr($<longname>.Str,0,2) eq '::'\n        "
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: term__S_420name
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_420name
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: term__S_420name
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_string 
                                a: 0
                                dba: term__S_420name
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "["
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: term__S_420name
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12347
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: type parameter
                      i: 0
                      min: 12347
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: type parameter
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: "::"
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: type parameter
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_bracket 
                                decl: []

                                min: 1
                                re: &30 !!perl/hash:RE_any 
                                  a: 0
                                  altname: term__S_420name_06
                                  dba: type parameter
                                  i: 0
                                  min: 1
                                  name: term__S_420name_06
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_420name_06 0
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_420name_06 1
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: <
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_420name_06 2
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "{"
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_420name_06 3
                                      dba: type parameter
                                      i: 0
                                      min: 2
                                      r: 1
                                      s: 0
                                      text: <<
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: type parameter
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method_internal 
                          args: $S, 'term__S_420name', 'packagevar '
                          max: 0
                          min: 0
                          name: _REDUCE
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'term__S_420name', 'typename'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              dba: type parameter
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type parameter
                  i: 0
                  min: 12345
                  name: args
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: type parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " self.add_mystery($name,$pos) unless $<args><invocant>; "
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: type parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            if $*BORG and $*BORG.<block> {\n                if not $*BORG.<name> {\n                    $*BORG.<culprit> = $<longname>.cursor($pos);\n                    $*BORG.<name> //= $name;\n                }\n            }\n        "
term__S_420name_06: *30
terminator__S_430Semi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_430Semi
    i: 0
    min: 1
    r: 1
    s: 0
    text: ;
terminator__S_431if: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_431if
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_431if
        i: 0
        min: 2
        r: 1
        s: 0
        text: if
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_431if
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_431if
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_432unless: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12351
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_432unless
    i: 0
    min: 12351
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_432unless
        i: 0
        min: 6
        r: 1
        s: 0
        text: unless
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_432unless
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_432unless
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_433while: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_433while
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_433while
        i: 0
        min: 5
        r: 1
        s: 0
        text: while
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_433while
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_433while
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_434until: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_434until
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_434until
        i: 0
        min: 5
        r: 1
        s: 0
        text: until
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_434until
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_434until
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_435for: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_435for
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_435for
        i: 0
        min: 3
        r: 1
        s: 0
        text: for
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_435for
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_435for
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_436given: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_436given
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_436given
        i: 0
        min: 5
        r: 1
        s: 0
        text: given
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_436given
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_436given
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_437when: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_437when
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_437when
        i: 0
        min: 4
        r: 1
        s: 0
        text: when
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_437when
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_437when
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_438MinusMinusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_438MinusMinusGt
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_438MinusMinusGt
        i: 0
        min: 3
        r: 1
        s: 0
        text: -->
      - !!perl/hash:RE_method_internal 
        args: $S, 'terminator__S_438MinusMinusGt'
        max: 0
        min: 0
        name: _REDUCE
terminator__S_439Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Terminator
  re: !!perl/hash:RE_method 
    a: 0
    dba: terminator__S_439Thesis
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: )
terminator__S_440Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_440Ket
    i: 0
    min: 1
    r: 1
    s: 0
    text: "]"
terminator__S_441Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_441Ly
    i: 0
    min: 1
    r: 1
    s: 0
    text: "}"
terminator__S_442BangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_442BangBang
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_442BangBang
        i: 0
        min: 2
        r: 1
        s: 0
        text: "!!"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: terminator__S_442BangBang
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*GOAL eq '!!' "
termish: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: termish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $SCOPE is context<rw> = "our"
    - !!perl/hash:RE_decl 
      a: 0
      dba: termish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $VAR is context<rw>
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &55 !!perl/hash:RE_any 
          a: 0
          altname: termish_01
          dba: prefix or noun
          i: 0
          min: 12345
          name: termish_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: termish_01 0
              dba: prefix or noun
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: prefix or noun
                    i: 0
                    min: 12345
                    name: PRE
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or noun
                  i: 0
                  min: 12345
                  name: noun
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: termish_01 1
              dba: prefix or noun
              i: 0
              min: 12345
              name: noun
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postfix
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: postfix
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: postfix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $*INTERPOLATION "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: postfix
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: postfix
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_block 
                              a: 0
                              context: bool
                              dba: postfix
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 0
                              text: " $*INTERPOLATION eq '$' "
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 12345
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: postfix
                                i: 0
                                min: 12345
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_method 
                                      a: 0
                                      dba: postfix
                                      i: 0
                                      min: 12345
                                      name: POST
                                      r: 1
                                      rest: ''
                                      s: 0
                                    min: 12345
                                    quant: 
                                      - +
                                      - "!"
                                      - ''
                                      - 1
                                  - !!perl/hash:RE_assertion 
                                    assert: "?"
                                    min: 0
                                    re: !!perl/hash:RE_method_re 
                                      a: 0
                                      dba: postfix
                                      i: 0
                                      min: 0
                                      name: after
                                      nobind: 1
                                      r: 1
                                      re: !!perl/hash:RE 
                                        decl: []

                                        min: 1
                                        re: !!perl/hash:RE_cclass 
                                          a: 0
                                          dba: postfix
                                          i: 0
                                          min: 1
                                          r: 1
                                          s: 0
                                          text: "[ \\] } > ) ]"
                                      s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: postfix
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: postfix
                              i: 0
                              min: 12345
                              name: POST
                              r: 1
                              rest: ''
                              s: 0
                            min: 12345
                            quant: 
                              - +
                              - "!"
                              - ''
                              - 1
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: postfix
                              i: 0
                              min: 0
                              name: after
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_cclass 
                                  a: 0
                                  dba: postfix
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "[ \\] } > ) ]"
                              s: 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: postfix
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $VAR = 0; "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: postfix
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: postfix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $*INTERPOLATION "
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: postfix
                    i: 0
                    min: 12345
                    name: POST
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: postfix
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        self.check_variable($VAR) if $VAR;\n        $.<~CAPS> = $<noun><~CAPS>;\n    "
termish_01: *55
trait: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: trait
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &73 !!perl/hash:RE_any 
          a: 0
          altname: trait_01
          dba: trait
          i: 0
          min: 12345
          name: trait_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 0
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: trait_mod
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 1
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_01: *73
trait_mod__S_269is: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_269is
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_269is
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: is
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_269is
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_269is
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: trait_mod__S_269is
          i: 0
          min: 12345
          name: postcircumfix
          r: 1
          rest: ''
          s: 1
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_270hides: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_270hides
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_270hides
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: hides
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_270hides
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_270hides
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_271does: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: trait_mod__S_271does
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'role'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_271does
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_271does
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: does
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_271does
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_271does
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_272will: !!perl/hash:RE 
  decl: []

  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_272will
    i: 0
    min: 49380
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_272will
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: will
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_272will
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_272will
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_272will
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_273of: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_273of
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_273of
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: of
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_273of
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_273of
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_274as: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_274as
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_274as
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: as
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_274as
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_274as
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_275returns: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_275returns
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_275returns
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: returns
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_275returns
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_275returns
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_276handles: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_276handles
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_276handles
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: handles
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_276handles
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_276handles
        i: 0
        min: 12345
        name: noun
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
tribble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: tribble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: tribble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: nibble
          nobind: 1
          rest: ($lang)
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: left
      - !!perl/hash:RE_var 
        a: 0
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: tribble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: tribble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: tribble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start ne $stop "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: tribble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($lang2)
            - !!perl/hash:RE_sequence 
              a: 0
              dba: tribble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $lang = $lang2.unbalanced($stop); "
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: nibble
                    nobind: 1
                    rest: ($lang)
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
                - !!perl/hash:RE_var 
                  a: 0
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
twigil__S_193Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_193Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
twigil__S_194Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_194Bang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!"
twigil__S_195Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_195Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
twigil__S_196Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: twigil__S_196Colon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: twigil__S_196Colon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ":"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: twigil__S_196Colon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: twigil__S_196Colon
              i: 0
              min: 1
              r: 1
              s: 0
              text: ":"
          s: 0
twigil__S_197Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_197Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
twigil__S_198Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: twigil__S_198Plus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: twigil__S_198Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method 
            min: 0
            name: worry
            nobind: 1
            rest: ("The + twigil is deprecated, use the * twigil instead")
twigil__S_199Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_199Question
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "?"
twigil__S_200Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_200Equal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =
twigil__S_201Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_201Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
type_constraint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_constraint
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &12 !!perl/hash:RE_any 
          a: 0
          altname: type_constraint_01
          dba: type_constraint
          i: 0
          min: 12345
          name: type_constraint_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: type_constraint_01 0
              dba: type_constraint
              i: 0
              min: 12345
              name: value
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: type_constraint_01 1
              dba: type_constraint
              i: 0
              min: 12345
              name: typename
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: type_constraint_01 2
              dba: type_constraint
              i: 0
              min: 12350
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: where
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %chaining)
      - !!perl/hash:RE_method 
        a: 0
        dba: type_constraint
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
type_constraint_01: *12
type_declarator__S_277subset: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: type_declarator__S_277subset
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: type_declarator__S_277subset
        i: 0
        min: 37035
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: type_declarator__S_277subset
            endsym: spacey
            i: 0
            min: 12345
            name: sym
            r: 1
            rest: ''
            s: 0
            sym: subset
          - !!perl/hash:RE_method 
            a: 0
            dba: type_declarator__S_277subset
            i: 0
            min: 12345
            name: spacey
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: type_declarator__S_277subset
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_declarator__S_277subset
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: type_declarator__S_277subset
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: " $.add_name($<longname>.Str); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24692
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: type_declarator__S_277subset
                      i: 0
                      min: 24692
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: type_declarator__S_277subset
                          i: 0
                          min: 2
                          r: 1
                          s: 1
                          text: of
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: type_declarator__S_277subset
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: type_declarator__S_277subset
                          i: 0
                          min: 12345
                          name: typename
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: type_declarator__S_277subset
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 5
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: type_declarator__S_277subset
                      i: 0
                      min: 5
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: type_declarator__S_277subset
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: where
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          min: 0
                          name: EXPR
                          rest: (item %chaining)
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: type_declarator__S_277subset
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed subset")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
type_declarator__S_278enum: !!perl/hash:RE 
  decl: []

  kind: token
  min: 86415
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_declarator__S_278enum
    i: 0
    min: 86415
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_278enum
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: enum
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_278enum
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_278enum
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_278enum
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_278enum
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: type_declarator__S_278enum
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: type_declarator__S_278enum
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: type_declarator__S_278enum
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[ < (  ]"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_278enum
        i: 0
        min: 12345
        name: noun
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_278enum
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: type_declarator__S_278enum
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.add_name($<longname>.Str); $.add_enum($<longname>.Str, $<noun>.Str); "
typename: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: typename
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &123 !!perl/hash:RE_any 
          a: 0
          altname: typename_01
          dba: typename
          i: 0
          min: 12345
          name: typename_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: typename_01 0
              dba: typename
              i: 0
              min: 12348
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: typename
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: ::?
                - !!perl/hash:RE_method 
                  a: 0
                  dba: typename
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: typename_01 1
              dba: typename
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: typename
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: typename
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: "\n        my $longname = $<longname>.Str;\n        if substr($longname, 0, 2) eq '::' {\n            $.add_my_name(substr($longname, 2));\n        }\n        else {\n            $.is_name($longname)\n        }\n      "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: typename
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: typename
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: typename
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: typename
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: typename
                i: 0
                min: 12345
                name: postcircumfix
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: typename
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24692
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: typename
            i: 0
            min: 24692
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: typename
                i: 0
                min: 2
                r: 1
                s: 0
                text: of
              - !!perl/hash:RE_method 
                a: 0
                dba: typename
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: typename
                i: 0
                min: 12345
                name: typename
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
typename_01: *123
unitstopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_meta 
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    text: $
unsp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: unspace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: unsp
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: unsp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: &44 !!perl/hash:RE_any 
                a: 0
                altname: unsp_02
                dba: unsp
                i: 0
                min: 1
                name: unsp_02
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_meta 
                    a: 0
                    alt: unsp_02 0
                    dba: unsp
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  - !!perl/hash:RE_string 
                    a: 0
                    alt: unsp_02 1
                    dba: unsp
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "#"
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &17 !!perl/hash:RE_any 
            a: 0
            altname: unsp_03
            dba: unspace
            i: 0
            min: 0
            name: unsp_03
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 0
                dba: unspace
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 12345
                    name: vws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'unsp', 'vwhite'
                    max: 0
                    min: 0
                    name: _REDUCE
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 1
                dba: unspace
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'unsp', 'unv'
                    max: 0
                    min: 0
                    name: _REDUCE
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 2
                dba: unspace
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_meta 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: $
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: unspace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: " $.moreinput "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
unsp_02: *44
unsp_03: *17
unspacey: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_method 
      a: 0
      dba: unspacey
      i: 0
      min: 12345
      name: unsp
      nobind: 1
      r: 1
      rest: ''
      s: 0
    min: 0
    quant: 
      - "?"
      - ":"
      - ''
      - 0
unv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &2 !!perl/hash:RE_any 
      a: 0
      altname: unv_01
      dba: horizontal whitespace
      i: 0
      min: 1
      name: unv_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 0
          dba: horizontal whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 1
                r: 1
                s: 0
                text: \h
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_method_internal 
              args: $S, 'unv', 'hwhite'
              max: 0
              min: 0
              name: _REDUCE
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 1
          dba: horizontal whitespace
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: horizontal whitespace
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                s: 0
            - !!perl/hash:RE_meta 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 0
              r: 1
              s: 0
              text: "^^"
            - !!perl/hash:RE_method 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 12345
              name: pod_comment
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method_internal 
              args: $S, 'unv', 'pod'
              max: 0
              min: 0
              name: _REDUCE
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 2
          dba: horizontal whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 1
                r: 1
                s: 0
                text: \h
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_string 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 1
              r: 1
              s: 0
              text: "#"
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &61 !!perl/hash:RE_any 
                a: 0
                altname: unv_03
                dba: horizontal whitespace
                i: 0
                min: 0
                name: unv_03
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: unv_03 0
                    dba: horizontal whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 12345
                          name: opener
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                      - !!perl/hash:RE_bracket 
                        decl: []

                        min: 0
                        re: !!perl/hash:RE_first 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_assertion 
                              assert: "!"
                              min: 0
                              re: !!perl/hash:RE_method_re 
                                a: 0
                                dba: horizontal whitespace
                                i: 0
                                min: 0
                                name: after
                                nobind: 1
                                r: 1
                                re: !!perl/hash:RE 
                                  decl: []

                                  min: 1
                                  re: !!perl/hash:RE_sequence 
                                    a: 0
                                    dba: horizontal whitespace
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_meta 
                                        a: 0
                                        dba: horizontal whitespace
                                        i: 0
                                        min: 0
                                        r: 1
                                        s: 0
                                        text: "^^"
                                      - !!perl/hash:RE_meta 
                                        a: 0
                                        dba: horizontal whitespace
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 0
                                        text: .
                                s: 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: panic
                              nobind: 1
                              rest: ("Can't use embedded comments in column 1")
                      - !!perl/hash:RE_method 
                        min: 0
                        name: quibble
                        nobind: 1
                        rest: ($.cursor_fresh( %*LANG<Q> ))
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'unv', 'embedded'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: unv_03 1
                    dba: horizontal whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: horizontal whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: ''
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_meta 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \N
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'unv', 'end'
                        max: 0
                        min: 0
                        name: _REDUCE
unv_01: *2
unv_03: *61
value__S_202quote: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: value__S_202quote
    i: 0
    min: 12345
    name: quote
    r: 1
    rest: ''
    s: 0
value__S_203number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: value__S_203number
    i: 0
    min: 12345
    name: number
    r: 1
    rest: ''
    s: 0
value__S_204version: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: value__S_204version
    i: 0
    min: 12345
    name: version
    r: 1
    rest: ''
    s: 0
variable: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_META is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $sigil = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $twigil = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $name
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: variable
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: variable
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: variable
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n        $sigil = $<sigil>.Str;\n        $*SIGIL ||= $sigil;\n    "
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: variable
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: twigil
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: variable
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 3
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: variable
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: variable
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: "::"
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: &85 !!perl/hash:RE_any 
                              a: 0
                              altname: variable_04
                              dba: variable
                              i: 0
                              min: 1
                              name: variable_04
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_04 0
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "{"
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_04 1
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: <
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_04 2
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "&"
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 2
                  re: &86 !!perl/hash:RE_any 
                    a: 0
                    altname: variable_06
                    dba: variable
                    i: 0
                    min: 2
                    name: variable_06
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: variable_06 0
                        dba: variable
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: variable
                              i: 0
                              min: 12345
                              name: twigil
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: variable
                            i: 0
                            min: 12345
                            name: sublongname
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: variable
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $name = $<sublongname>.Str "
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'variable', 'subnoun'
                            max: 0
                            min: 0
                            name: _REDUCE
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: variable_06 1
                        dba: variable
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: variable
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "["
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: variable
                            extra: "local $::GOAL = ']' "
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: "::"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: infixish
                            rest: (1)
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: variable
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "]"
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: FAILGOAL
                                  nobind: 1
                                  rest: (']' , 'variable')
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: "$::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: name
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: "$:"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: name
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &87 !!perl/hash:RE_any 
                a: 0
                altname: variable_10
                dba: variable
                i: 0
                min: 0
                name: variable_10
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 0
                    dba: variable
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_method 
                          a: 0
                          dba: variable
                          i: 0
                          min: 12345
                          name: twigil
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: desigilname
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: variable
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $name = $<desigilname>.Str "
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable', 'desigilname'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 1
                    dba: variable
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: special_variable
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable', 'special'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 2
                    dba: variable
                    i: 0
                    min: 12346
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_bindnamed 
                        a: 0
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          nobind: 1
                          re: !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: variable
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                        dba: variable
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        var: index
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable', '$0'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 3
                    dba: variable
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: variable
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: &81 !!perl/hash:RE_any 
                              a: 0
                              altname: variable_12
                              dba: variable
                              i: 0
                              min: 1
                              name: variable_12
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_12 0
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: <
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_12 1
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                          s: 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: postcircumfix
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable', '$()'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 4
                    dba: variable
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: variable
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " $*IN_DECL "
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable', 'anondecl'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 5
                    dba: variable
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_noop 
                          a: 0
                          dba: variable
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: variable
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: "\n            if $*INTERPOLATION {\n                return ();\n            }\n            else {\n                $.panic(\"Anonymous variable requires declarator\");\n            }\n          "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $t = $<twigil>; $twigil = $t.[0].Str if @$t; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: variable
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: variable
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $twigil eq '.' "
              - !!perl/hash:RE_bracket 
                decl: []

                min: 0
                re: &88 !!perl/hash:RE_any 
                  a: 0
                  altname: variable_14
                  dba: variable
                  i: 0
                  min: 0
                  name: variable_14
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: variable_14 0
                      dba: variable
                      i: 0
                      min: 12345
                      name: unsp
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_string 
                      a: 0
                      alt: variable_14 1
                      dba: variable
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \
                    - !!perl/hash:RE_assertion 
                      alt: variable_14 2
                      assert: "?"
                      min: 0
                      re: !!perl/hash:RE_noop 
                        a: 0
                        dba: variable
                        i: 0
                        min: 0
                        nobind: 1
                        r: 1
                        s: 0
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: variable
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: variable
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: variable
                i: 0
                min: 12345
                name: postcircumfix
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method_internal 
                args: $S, 'variable', 'methcall'
                max: 0
                min: 0
                name: _REDUCE
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
variable_04: *85
variable_06: *86
variable_10: *87
variable_12: *81
variable_14: *88
variable_declarator: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable_declarator
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: variable_declarator
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: variable_declarator
        i: 0
        min: 12345
        name: variable
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable_declarator
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*IN_DECL = 0; self.add_variable($<variable>.Str) "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: variable_declarator
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: variable_declarator
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &68 !!perl/hash:RE_any 
                      a: 0
                      altname: variable_declarator_02
                      dba: shape definition
                      i: 0
                      min: 12345
                      name: variable_declarator_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 0
                          dba: variable_declarator
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: variable_declarator
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: (
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: variable_declarator
                              extra: "local $::GOAL = ')' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: variable_declarator
                              i: 0
                              min: 12345
                              name: signature
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: variable_declarator
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: variable_declarator
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: )
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: (')' , 'variable_declarator')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 1
                          dba: shape definition
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "["
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: shape definition
                              extra: "local $::GOAL = ']' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: semilist
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "]"
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: (']' , 'shape definition')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 2
                          dba: shape definition
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "{"
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: shape definition
                              extra: "local $::GOAL = '}' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: semilist
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "}"
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: ('}' , 'shape definition')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 3
                          dba: shape definition
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_assertion 
                              assert: "?"
                              min: 0
                              re: !!perl/hash:RE_method_re 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 0
                                name: before
                                nobind: 1
                                r: 1
                                re: !!perl/hash:RE 
                                  decl: []

                                  min: 1
                                  re: !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: <
                                s: 0
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: postcircumfix
                              r: 1
                              rest: ''
                              s: 0
                  min: 0
                  nobind: 1
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                dba: variable_declarator
                i: 0
                min: 0
                r: 1
                s: 0
                var: shape
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: variable_declarator
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: variable_declarator
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
variable_declarator_02: *68
version__S_081v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: version__S_081v
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: version__S_081v
        i: 0
        min: 1
        r: 1
        s: 0
        text: v
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: version__S_081v
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: version__S_081v
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
          s: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: version__S_081v
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: version__S_081v
          i: 0
          min: 12345
          name: vnum
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: version__S_081v
            i: 0
            min: 1
            r: 1
            s: 0
            text: .
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: version__S_081v
          i: 0
          min: 1
          r: 1
          s: 0
          text: +
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
vnum: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: &112 !!perl/hash:RE_any 
    a: 0
    altname: vnum_00
    dba: vnum
    i: 0
    min: 1
    name: vnum_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        alt: vnum_00 0
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: vnum
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_string 
        a: 0
        alt: vnum_00 1
        dba: vnum
        i: 0
        min: 1
        r: 1
        s: 0
        text: "*"
vnum_00: *112
vws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: vertical whitespace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: vertical whitespace
        i: 0
        min: 1
        r: 1
        s: 0
        text: \v
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 9
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: vertical whitespace
            i: 0
            min: 9
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: vertical whitespace
                i: 0
                min: 9
                r: 1
                s: 0
                text: "#DEBUG -1"
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: vertical whitespace
                i: 0
                min: 0
                r: 1
                s: 0
                text: " say \"DEBUG\"; $STD::DEBUG = $*DEBUG = -1; "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: ws
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my @stub = return self if @*MEMOS[self.pos]<ws> :exists
    - !!perl/hash:RE_decl 
      a: 0
      dba: ws
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $startpos = self.pos
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: whitespace
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &41 !!perl/hash:RE_any 
          a: 0
          altname: ws_01
          dba: whitespace
          i: 0
          min: 0
          name: ws_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: ws_01 0
              dba: whitespace
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_cclass 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 1
                    nobind: 1
                    r: 1
                    s: 0
                    text: "[#\\s\\\\]"
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<ws> = $startpos; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: ws_01 1
              dba: whitespace
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                    s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    name: after
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                    s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ":::"
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$startpos]<ws> = undef; "
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Whitespace is required between alphanumeric tokens")
      - !!perl/hash:RE_sequence 
        a: 0
        dba: whitespace
        i: 0
        min: 0
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &131 !!perl/hash:RE_any 
                a: 0
                altname: ws_05
                dba: whitespace
                i: 0
                min: 0
                name: ws_05
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: ws_05 0
                    dba: whitespace
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: ws_05 1
                    dba: whitespace
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 12345
                        name: vws
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 12345
                        name: heredoc
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: ws_05 2
                    dba: whitespace
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: ws_05 3
                    dba: whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $.moreinput "
            min: 0
            quant: 
              - "*"
              - ":"
              - ''
              - 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: whitespace
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n        if ($.pos == $startpos) {\n            @*MEMOS[$.pos]<ws> = undef;\n        }\n        else {\n            @*MEMOS[$.pos]<ws> = $startpos;\n            @*MEMOS[$.pos]<endstmt> = @*MEMOS[$startpos]<endstmt>\n                if @*MEMOS[$startpos]<endstmt> :exists;\n        }\n    "
ws_01: *41
ws_05: *131
xblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: xblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '{'
    - !!perl/hash:RE_decl 
      a: 0
      dba: xblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $BORG is context = {}
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: xblock
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: xblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $BORG.<culprit> //= $<EXPR>.cursor(self.pos) "
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: pblock
        r: 1
        rest: ''
        s: 0
RETREE_END
}

1;
# vim: sw=4 ft=perl
