# Emulate context vars by localizing 'our' vars living in main
our $ACTIONS;
our $CTX;
our $DELIM;
our $GOAL;
our $INVOCANT_IS;
our $INVOCANT_OK;
our $IN_DECL;
our $LANG;
our $ORIG;
our $PARSER;
our $PKG;
our $PKGDECL;
our $SIGIL;
our $VOID;
our $begin_compunit;
our $endargs;
our $endsym;
our $ignoreaccent;
our $ignorecase;
our $inquote;
our $ratchet;
our $sigspace;
our $sym;
our $zone;
our @MEMOS;

our $moreinput;
our $DEBUG;

our %INSTANTIATED;
require 'mangle.pl';
use utf8;

package STD;
use strict;
use warnings;
no warnings 'qw', 'recursion';
use Cursor; # for base class as well as DEBUG constants
use Moose ':all' => { -prefix => "moose_" };
moose_extends('Cursor');
my $retree;
use feature 'state', 'say';
use utf8;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

sub BUILD {
my $self = shift;
$self->_AUTOLEXpeek('termish',$retree);
}

use YAML::Syck;


# should some of these be parser instance attributes?
local $::LANG;
local $::PKGDECL =  "";
local $::PKG =  "";
my @PKGS;
local $::GOAL =  "(eof)";
local $::PARSER;
local $::ACTIONS;
local $::IN_DECL;
local $::SIGIL;
my %MYSTERY;
local $::ORIG;
local @::MEMOS;
local $::VOID;
local $::INVOCANT_OK;
local $::INVOCANT_IS;
my @PADS;

# random rule for debugging, please ignore
## token foo
##      token foo {
##         'foo' <.ws> 'bar' <.ws> 'baz'
##      }

sub foo__PEEK { $_[0]->_AUTOLEXpeek('foo',$retree) }
sub foo {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "foo", 
do {
if (my ($C) = ($C->_EXACT('foo'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('bar'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT('baz');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# =begin comment overview
# 
# This file is designed to be either preprocessed into a grammar with
# action statements or used as-is without any preprocessing.  The {*}
# notation is a no-op action block, but can be identified uniquely via a
# combination of the preceding token or rule name plus any additional text
# following a #= comment.  We put this into a comment rather than using
# a macro so that bootstrap compilers don't have to worry about macros
# yet, and to keep the main grammar relatively uncluttered by action
# statements.  Note that the preprocessor can certainly generate accesses
# to the match state within the action block, so we need not mention it
# explicitly.
# 
# Also, some rules are named by syntactic category plus an additonal symbol
# specified in adverbial form, either in bare :name form or in :sym<name>
# form.  (It does not matter which form you use for identifier symbols,
# except that to specify a symbol "sym" you must use the :sym<sym> form
# of adverb.)  If you use the <sym> rule within the rule, it will parse the
# symbol at that point.  At the final reduction point of a rule, if $sym
# has been set, that is used as the final symbol name for the rule.  This
# need not match the symbol specified as part the rule name; that is just
# for disambiguating the name.  However, if no $sym is set, the original
# symbol will be used by default.
# 
# Note that rules automatically get an implicit {*} at their return, so
# for the TOP rule the implicit action name is also simply "TOP".
# 
# Another nod toward preprocessing is that blocks that contain nested braces
# are delimited by double braces so that the preprocessor does not need to
# understand Perl 6 code.
# 
# This grammar relies on transitive longest-token semantics, though
# initially we made a feeble attempt to order rules so a procedural
# interpretation of alternation could usually produce a correct parse.
# (This is becoming less true over time.)
# 
# =end comment overview

## method TOP ($STOP = undef)
sub TOP {
my $self = shift;
my $STOP = shift() // undef;


if (defined $STOP) {
local $::GOAL =  $STOP;
$self->unitstop($STOP)->comp_unit;
}
else {
$self->comp_unit;
}
}


# XXX shouldn't need this, it should all be defined/imported by the prelude

my @basetypenames = qw[
Object Any Junction Whatever HyperWhatever
Capture Match Signature Proxy Matcher
Package Module Class Role Grammar
Scalar Array Hash KeyHash KeySet KeyBag
Pair List Seq Range Set Bag Mapping
Void Undef Failure Exception
Code Block Routine Sub Macro
Method Submethod Regex

Str Blob
Char Byte Codepoint Grapheme StrPos StrLen Version

Num Complex
num complex

Int  int   int1  int2  int4 int8  int16  int32  int64
Rat  rat   rat1  rat2  rat4 rat8  rat16  rat32  rat64
UInt uint uint1 uint2 uint4 uint8 uint16 uint32 uint64
Buf  buf   buf1  buf2  buf4 buf8  buf16  buf32  buf64

Bit Bool
bit bool

Order Increasing Decreasing
Ordered Callable Positional Associative Abstraction
Ordering KeyExtractor Comparator OrderingPair

IO

KitchenSink
];
push @basetypenames, "True", "False", "Bool::True", "Bool::False";  # in quotes lest gimme5 translate them

## method is_type ($name)
sub is_type {
my $self = shift;
my $name = shift;


for (reverse @PADS) {
return 1 if $_->{$name};
}
return 0;
}

## method add_type ($name)
sub add_type {
my $self = shift;
my $name = shift;


my $typename = main::mangle($name);
my $qualname = ($::PKG // 'GLOBAL') . '::' . $typename;
$PADS[-1]{$typename} = 'TYPE';
$PADS[-1]{$qualname} = 'TYPE';
$PADS[-1]{$name} = 'TYPE';
}

# XXX likewise for routine defs

my @baseroutinenames = qw[
WHAT WHERE meta WHICH VAR WHO WHENCE new
any all none one
not true
next last redo break goto

die exit warn
caller want
eval evalfile
callsame callwith nextsame nextwith lastcall
defined undefine item list slice eager hyper

cat classify
quotemeta
chr ord
p5chop chop p5chomp chomp trim trim_start trim_end
index rindex substr
join split comb pack unpack
uc ucfirst lc lcfirst
normalize
nfc nfd nfkc nfkd
samecase sameaccent
capitalize
chars graphs codes bytes

say print open close printf sprintf slurp unlink link symlink
elems grep map first reduce sort min max uniq push reverse take splice
lines getc

zip each roundrobin caller
return leave pop shift unshift reduce
keys values hash kv key value pairs pair

sign abs floor ceiling round truncate
exp log log10 sqrt roots
rand srand pick
cis unpolar

sin cos tan asin acos atan sec cosec cotan asec acosec
acotan sinh cosh tanh asinh acosh atanh sech cosech cotanh
asech acosech acotanh atan2

plan is ok dies_ok lives_ok skip todo pass flunk force_todo use_ok
isa_ok cmp_ok diag is_deeply isnt like skip_rest unlike nonce
skip_rest eval_dies_ok eval_lives_ok approx is_approx throws_ok version_lt

gmtime localtime time times
gethost getpw chroot getlogin
run runinstead
fork wait kill sleep
];
push @baseroutinenames, "HOW", "fail", "temp", "let";

# please don't add: ref length bless delete exists

my @routinenames;
my %routinenames;

sub init_pads {  
@PKGS = ();
%MYSTERY = ();

@PADS = ();
$PADS[0] = {};
for (@basetypenames) {
$PADS[0]{$_} = 'TYPE';
$PADS[0]{'&' . $_} = 'CODE';
}
for (@baseroutinenames) {
$PADS[0]{'&' . $_} = 'CODE';
}
}

## method is_known ($name)
sub is_known {
my $self = shift;
my $name = shift;


my $aname;
if (substr($name,0,1) eq '&') {
$aname = $name;
}
else {
$aname = '&' . $name;
}
for (reverse @PADS) {
return 1 if $_->{$aname};
return 1 if $_->{$name}; # type as routine?
}
return 0;
}

## method add_routine ($name)
sub add_routine {
my $self = shift;
my $name = shift;


$PADS[-1]{'&' . $name} = 'CODE';
}

# The internal precedence levels are *not* part of the public interface.
# The current values are mere implementation; they may change at any time.
# Users should specify precedence only in relation to existing levels.

our %term            = ('dba' => ('term')            , 'prec' => 'z=');
our %methodcall      = ('dba' => ('methodcall')      , 'prec' => 'y=', 'assoc' => 'unary', 'uassoc' => 'left');
our %autoincrement   = ('dba' => ('autoincrement')   , 'prec' => 'x=', 'assoc' => 'unary', 'uassoc' => 'non');
our %exponentiation  = ('dba' => ('exponentiation')  , 'prec' => 'w=', 'assoc' => 'right', 'assign' => 1);
our %symbolic_unary  = ('dba' => ('symbolic unary')  , 'prec' => 'v=', 'assoc' => 'unary', 'uassoc' => 'left');
our %multiplicative  = ('dba' => ('multiplicative')  , 'prec' => 'u=', 'assoc' => 'left',  'assign' => 1);
our %additive        = ('dba' => ('additive')        , 'prec' => 't=', 'assoc' => 'left',  'assign' => 1);
our %replication     = ('dba' => ('replication')     , 'prec' => 's=', 'assoc' => 'left',  'assign' => 1);
our %concatenation   = ('dba' => ('concatenation')   , 'prec' => 'r=', 'assoc' => 'list',  'assign' => 1);
our %junctive_and    = ('dba' => ('junctive and')    , 'prec' => 'q=', 'assoc' => 'list',  'assign' => 1);
our %junctive_or     = ('dba' => ('junctive or')     , 'prec' => 'p=', 'assoc' => 'list',  'assign' => 1);
our %named_unary     = ('dba' => ('named unary')     , 'prec' => 'o=', 'assoc' => 'unary', 'uassoc' => 'left');
our %nonchaining     = ('dba' => ('nonchaining')     , 'prec' => 'n=', 'assoc' => 'non');
our %chaining        = ('dba' => ('chaining')        , 'prec' => 'm=', 'assoc' => 'chain', 'returns' => 'Bool'); # XXX Bool string, not type
our %tight_and       = ('dba' => ('tight and')       , 'prec' => 'l=', 'assoc' => 'list',  'assign' => 1);
our %tight_or        = ('dba' => ('tight or')        , 'prec' => 'k=', 'assoc' => 'list',  'assign' => 1);
our %conditional     = ('dba' => ('conditional')     , 'prec' => 'j=', 'assoc' => 'right');
our %item_assignment = ('dba' => ('item assignment') , 'prec' => 'i=', 'assoc' => 'right');
our %loose_unary     = ('dba' => ('loose unary')     , 'prec' => 'h=', 'assoc' => 'unary', 'uassoc' => 'left');
our %comma           = ('dba' => ('comma')           , 'prec' => 'g=', 'assoc' => 'list', 'nextterm' => 'nulltermish');
our %list_infix      = ('dba' => ('list infix')      , 'prec' => 'f=', 'assoc' => 'list',  'assign' => 1);
our %list_assignment = ('dba' => ('list assignment') , 'prec' => 'i=', 'assoc' => 'right', 'sub' => 'e=');
our %list_prefix     = ('dba' => ('list prefix')     , 'prec' => 'e=', 'assoc' => 'unary', 'uassoc' => 'left');
our %loose_and       = ('dba' => ('loose and')       , 'prec' => 'd=', 'assoc' => 'list',  'assign' => 1);
our %loose_or        = ('dba' => ('loose or')        , 'prec' => 'c=', 'assoc' => 'list',  'assign' => 1);
our %sequencer       = ('dba' => ('sequencer')       , 'prec' => 'b=', 'assoc' => 'list', 'nextterm' => 'statement');
our %LOOSEST         = ('dba' => ('LOOSEST')         , 'prec' => 'a=!');
our %terminator      = ('dba' => ('terminator')      , 'prec' => 'a=', 'assoc' => 'list');

# "epsilon" tighter than terminator
#constant $LOOSEST = %LOOSEST<prec>;
my $LOOSEST = "a=!"; # XXX preceding line is busted
my $item_assignment_prec = 'i=';


{ package STD::PrecOp;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;

# This is hopefully called on a match to mix in operator info by type.
##     method coerce (Match $m)
sub coerce {
my $self = shift;
my $m = shift;


# $m but= ::?CLASS;
my $var = (ref($self)||$self) . '::o';
my $d = do { no strict 'refs'; \%{$var}}; 
if (not $d->{transparent}) {
for (keys(%$d)) { $m->{O}{$_} = $d->{$_} };
$m->deb("coercing to " . $self) if $::DEBUG & DEBUG::EXPR;
}
$m->{O}{kind} = (ref($self)||$self);
return $m;
}

} ## end role

{ package STD::Transparent;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp)); our %o = ('transparent' => 1);
} ## end class

{ package STD::Term;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %term;
} ## end class
{ package STD::Methodcall;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %methodcall;
} ## end class
{ package STD::Autoincrement;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %autoincrement;
} ## end class
{ package STD::Exponentiation;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %exponentiation;
} ## end class
{ package STD::Symbolic_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %symbolic_unary;
} ## end class
{ package STD::Multiplicative;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %multiplicative;
} ## end class
{ package STD::Additive;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %additive;
} ## end class
{ package STD::Replication;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %replication;
} ## end class
{ package STD::Concatenation;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %concatenation;
} ## end class
{ package STD::Junctive_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %junctive_and;
} ## end class
{ package STD::Junctive_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %junctive_or;
} ## end class
{ package STD::Named_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %named_unary;
} ## end class
{ package STD::Nonchaining;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %nonchaining;
} ## end class
{ package STD::Chaining;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %chaining;
} ## end class
{ package STD::Tight_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %tight_and;
} ## end class
{ package STD::Tight_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %tight_or;
} ## end class
{ package STD::Conditional;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %conditional;
} ## end class
{ package STD::Item_assignment;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %item_assignment;
} ## end class
{ package STD::Loose_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_unary;
} ## end class
{ package STD::Comma;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %comma;
} ## end class
{ package STD::List_infix;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_infix;
} ## end class
{ package STD::List_assignment;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_assignment;
} ## end class
{ package STD::List_prefix;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_prefix;
} ## end class
{ package STD::Loose_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_and;
} ## end class
{ package STD::Loose_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_or;
} ## end class
{ package STD::Sequencer;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %sequencer;
} ## end class
{ package STD::Terminator;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %terminator;
} ## end class

# Categories are designed to be easily extensible in derived grammars
# by merely adding more rules in the same category.  The rules within
# a given category start with the category name followed by a differentiating
# adverbial qualifier to serve (along with the category) as the longer name.

# The endsym context, if specified, says what to implicitly check for in each
# rule right after the initial <sym>.  Normally this is used to make sure
# there's appropriate whitespace.  # Note that endsym isn't called if <sym>
# isn't called.

local $::endsym =  "null";
local $::endargs =  -1;

#proto token category { <...> }
sub category__PEEK { $_[0]->_AUTOLEXpeek('category:*',$retree); }
sub category {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'category') {
$C->deb("Fate passed to category: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'category:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("category trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "category", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_000category (:$sym is context<rw> = 'category')
##      token category:category { <sym> }

sub category__S_000category__PEEK { $_[0]->_AUTOLEXpeek('category__S_000category',$retree) }
sub category__S_000category {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'category';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_000category", 
$C->_PATTERN(qr/\Gcategory/)
);
}

## token category__S_001sigil (:$sym is context<rw> = 'sigil')
##      token category:sigil { <sym> }

sub category__S_001sigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_001sigil',$retree) }
sub category__S_001sigil {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_001sigil", 
$C->_PATTERN(qr/\Gsigil/)
);
}
#proto token sigil { <...> }
sub sigil__PEEK { $_[0]->_AUTOLEXpeek('sigil:*',$retree); }
sub sigil {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'sigil') {
$C->deb("Fate passed to sigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'sigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "sigil", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_002twigil (:$sym is context<rw> = 'twigil')
##      token category:twigil { <sym> }

sub category__S_002twigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_002twigil',$retree) }
sub category__S_002twigil {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'twigil';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_002twigil", 
$C->_PATTERN(qr/\Gtwigil/)
);
}
#proto token twigil { <...> }
sub twigil__PEEK { $_[0]->_AUTOLEXpeek('twigil:*',$retree); }
sub twigil {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'twigil') {
$C->deb("Fate passed to twigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'twigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("twigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "twigil", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_003special_variable (:$sym is context<rw> = 'special_variable')
##      token category:special_variable { <sym> }

sub category__S_003special_variable__PEEK { $_[0]->_AUTOLEXpeek('category__S_003special_variable',$retree) }
sub category__S_003special_variable {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'special_variable';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_003special_variable", 
$C->_PATTERN(qr/\Gspecial_variable/)
);
}
#proto token special_variable { <...> }
sub special_variable__PEEK { $_[0]->_AUTOLEXpeek('special_variable:*',$retree); }
sub special_variable {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'special_variable') {
$C->deb("Fate passed to special_variable: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "special_variable", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_004version (:$sym is context<rw> = 'version')
##      token category:version { <sym> }

sub category__S_004version__PEEK { $_[0]->_AUTOLEXpeek('category__S_004version',$retree) }
sub category__S_004version {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'version';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_004version", 
$C->_PATTERN(qr/\Gversion/)
);
}
#proto token version { <...> }
sub version__PEEK { $_[0]->_AUTOLEXpeek('version:*',$retree); }
sub version {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'version') {
$C->deb("Fate passed to version: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'version:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("version trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "version", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_005module_name (:$sym is context<rw> = 'module_name')
##      token category:module_name { <sym> }

sub category__S_005module_name__PEEK { $_[0]->_AUTOLEXpeek('category__S_005module_name',$retree) }
sub category__S_005module_name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'module_name';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_005module_name", 
$C->_PATTERN(qr/\Gmodule_name/)
);
}
#proto token module_name { <...> }
sub module_name__PEEK { $_[0]->_AUTOLEXpeek('module_name:*',$retree); }
sub module_name {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'module_name') {
$C->deb("Fate passed to module_name: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'module_name:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("module_name trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "module_name", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_006term (:$sym is context<rw> = 'term')
##      token category:term { <sym> }

sub category__S_006term__PEEK { $_[0]->_AUTOLEXpeek('category__S_006term',$retree) }
sub category__S_006term {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'term';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_006term", 
$C->_PATTERN(qr/\Gterm/)
);
}
#proto token term { <...> }
sub term__PEEK { $_[0]->_AUTOLEXpeek('term:*',$retree); }
sub term {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'term') {
$C->deb("Fate passed to term: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "term", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_007quote (:$sym is context<rw> = 'quote')
##      token category:quote { <sym> }

sub category__S_007quote__PEEK { $_[0]->_AUTOLEXpeek('category__S_007quote',$retree) }
sub category__S_007quote {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_007quote", 
$C->_PATTERN(qr/\Gquote/)
);
}
#proto token quote () { <...> }
sub quote__PEEK { $_[0]->_AUTOLEXpeek('quote:*',$retree); }
sub quote {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quote') {
$C->deb("Fate passed to quote: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quote", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_008prefix (:$sym is context<rw> = 'prefix')
##      token category:prefix { <sym> }

sub category__S_008prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_008prefix',$retree) }
sub category__S_008prefix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_008prefix", 
$C->_PATTERN(qr/\Gprefix/)
);
}
#proto token prefix is unary is defequiv(%symbolic_unary) { <...> }
sub prefix__PEEK { $_[0]->_AUTOLEXpeek('prefix:*',$retree); }
sub prefix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'prefix') {
$C->deb("Fate passed to prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_009infix (:$sym is context<rw> = 'infix')
##      token category:infix { <sym> }

sub category__S_009infix__PEEK { $_[0]->_AUTOLEXpeek('category__S_009infix',$retree) }
sub category__S_009infix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_009infix", 
$C->_PATTERN(qr/\Ginfix/)
);
}
#proto token infix is binary is defequiv(%additive) { <...> }
sub infix__PEEK { $_[0]->_AUTOLEXpeek('infix:*',$retree); }
sub infix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix') {
$C->deb("Fate passed to infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_010postfix (:$sym is context<rw> = 'postfix')
##      token category:postfix { <sym> }

sub category__S_010postfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_010postfix',$retree) }
sub category__S_010postfix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postfix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_010postfix", 
$C->_PATTERN(qr/\Gpostfix/)
);
}
#proto token postfix is unary is defequiv(%autoincrement) { <...> }
sub postfix__PEEK { $_[0]->_AUTOLEXpeek('postfix:*',$retree); }
sub postfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'postfix') {
$C->deb("Fate passed to postfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_011dotty (:$sym is context<rw> = 'dotty')
##      token category:dotty { <sym> }

sub category__S_011dotty__PEEK { $_[0]->_AUTOLEXpeek('category__S_011dotty',$retree) }
sub category__S_011dotty {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'dotty';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_011dotty", 
$C->_PATTERN(qr/\Gdotty/)
);
}
#proto token dotty (:$endsym is context = 'unspacey') { <...> }
sub dotty__PEEK { $_[0]->_AUTOLEXpeek('dotty:*',$retree); }
sub dotty {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'dotty') {
$C->deb("Fate passed to dotty: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dotty:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "dotty", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_012circumfix (:$sym is context<rw> = 'circumfix')
##      token category:circumfix { <sym> }

sub category__S_012circumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_012circumfix',$retree) }
sub category__S_012circumfix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'circumfix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_012circumfix", 
$C->_PATTERN(qr/\Gcircumfix/)
);
}
#proto token circumfix { <...> }
sub circumfix__PEEK { $_[0]->_AUTOLEXpeek('circumfix:*',$retree); }
sub circumfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'circumfix') {
$C->deb("Fate passed to circumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'circumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("circumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "circumfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_013postcircumfix (:$sym is context<rw> = 'postcircumfix')
##      token category:postcircumfix { <sym> }

sub category__S_013postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_013postcircumfix',$retree) }
sub category__S_013postcircumfix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postcircumfix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_013postcircumfix", 
$C->_PATTERN(qr/\Gpostcircumfix/)
);
}
#proto token postcircumfix is unary { <...> }  # unary as far as EXPR knows...
sub postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix:*',$retree); }
sub postcircumfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'postcircumfix') {
$C->deb("Fate passed to postcircumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postcircumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postcircumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postcircumfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_014quote_mod (:$sym is context<rw> = 'quote_mod')
##      token category:quote_mod { <sym> }

sub category__S_014quote_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_014quote_mod',$retree) }
sub category__S_014quote_mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote_mod';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_014quote_mod", 
$C->_PATTERN(qr/\Gquote_mod/)
);
}
#proto token quote_mod { <...> }
sub quote_mod__PEEK { $_[0]->_AUTOLEXpeek('quote_mod:*',$retree); }
sub quote_mod {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quote_mod') {
$C->deb("Fate passed to quote_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote_mod:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quote_mod", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_015trait_verb (:$sym is context<rw> = 'trait_verb')
##      token category:trait_verb { <sym> }

sub category__S_015trait_verb__PEEK { $_[0]->_AUTOLEXpeek('category__S_015trait_verb',$retree) }
sub category__S_015trait_verb {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'trait_verb';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_015trait_verb", 
$C->_PATTERN(qr/\Gtrait_verb/)
);
}
#proto token trait_verb (:$endsym is context = 'spacey') { <...> }
sub trait_verb__PEEK { $_[0]->_AUTOLEXpeek('trait_verb:*',$retree); }
sub trait_verb {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'trait_verb') {
$C->deb("Fate passed to trait_verb: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_verb:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_verb trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "trait_verb", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_016trait_auxiliary (:$sym is context<rw> = 'trait_auxiliary')
##      token category:trait_auxiliary { <sym> }

sub category__S_016trait_auxiliary__PEEK { $_[0]->_AUTOLEXpeek('category__S_016trait_auxiliary',$retree) }
sub category__S_016trait_auxiliary {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'trait_auxiliary';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_016trait_auxiliary", 
$C->_PATTERN(qr/\Gtrait_auxiliary/)
);
}
#proto token trait_auxiliary (:$endsym is context = 'spacey') { <...> }
sub trait_auxiliary__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary:*',$retree); }
sub trait_auxiliary {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'trait_auxiliary') {
$C->deb("Fate passed to trait_auxiliary: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_auxiliary:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_auxiliary trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "trait_auxiliary", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_017type_declarator (:$sym is context<rw> = 'type_declarator')
##      token category:type_declarator { <sym> }

sub category__S_017type_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_017type_declarator',$retree) }
sub category__S_017type_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'type_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_017type_declarator", 
$C->_PATTERN(qr/\Gtype_declarator/)
);
}
#proto token type_declarator () { <...> }
sub type_declarator__PEEK { $_[0]->_AUTOLEXpeek('type_declarator:*',$retree); }
sub type_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'type_declarator') {
$C->deb("Fate passed to type_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'type_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "type_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_018scope_declarator (:$sym is context<rw> = 'scope_declarator')
##      token category:scope_declarator { <sym> }

sub category__S_018scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_018scope_declarator',$retree) }
sub category__S_018scope_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'scope_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_018scope_declarator", 
$C->_PATTERN(qr/\Gscope_declarator/)
);
}
#proto token scope_declarator (:$endsym is context = 'nofun') { <...> }
sub scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator:*',$retree); }
sub scope_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'scope_declarator') {
$C->deb("Fate passed to scope_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'scope_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scope_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "scope_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_019package_declarator (:$sym is context<rw> = 'package_declarator')
##      token category:package_declarator { <sym> }

sub category__S_019package_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_019package_declarator',$retree) }
sub category__S_019package_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'package_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_019package_declarator", 
$C->_PATTERN(qr/\Gpackage_declarator/)
);
}
#proto token package_declarator () { <...> }
sub package_declarator__PEEK { $_[0]->_AUTOLEXpeek('package_declarator:*',$retree); }
sub package_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'package_declarator') {
$C->deb("Fate passed to package_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'package_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("package_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "package_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_020multi_declarator (:$sym is context<rw> = 'multi_declarator')
##      token category:multi_declarator { <sym> }

sub category__S_020multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_020multi_declarator',$retree) }
sub category__S_020multi_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'multi_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_020multi_declarator", 
$C->_PATTERN(qr/\Gmulti_declarator/)
);
}
#proto token multi_declarator () { <...> }
sub multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator:*',$retree); }
sub multi_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'multi_declarator') {
$C->deb("Fate passed to multi_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'multi_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("multi_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "multi_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_021routine_declarator (:$sym is context<rw> = 'routine_declarator')
##      token category:routine_declarator { <sym> }

sub category__S_021routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_021routine_declarator',$retree) }
sub category__S_021routine_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'routine_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_021routine_declarator", 
$C->_PATTERN(qr/\Groutine_declarator/)
);
}
#proto token routine_declarator () { <...> }
sub routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator:*',$retree); }
sub routine_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'routine_declarator') {
$C->deb("Fate passed to routine_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "routine_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_022regex_declarator (:$sym is context<rw> = 'regex_declarator')
##      token category:regex_declarator { <sym> }

sub category__S_022regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_022regex_declarator',$retree) }
sub category__S_022regex_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'regex_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_022regex_declarator", 
$C->_PATTERN(qr/\Gregex_declarator/)
);
}
#proto token regex_declarator () { <...> }
sub regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator:*',$retree); }
sub regex_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'regex_declarator') {
$C->deb("Fate passed to regex_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "regex_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_023statement_prefix (:$sym is context<rw> = 'statement_prefix')
##      token category:statement_prefix { <sym> }

sub category__S_023statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_023statement_prefix',$retree) }
sub category__S_023statement_prefix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_prefix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_023statement_prefix", 
$C->_PATTERN(qr/\Gstatement_prefix/)
);
}
#proto rule  statement_prefix () { <...> }
sub statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix:*',$retree); }
sub statement_prefix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_prefix') {
$C->deb("Fate passed to statement_prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_prefix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_024statement_control (:$sym is context<rw> = 'statement_control')
##      token category:statement_control { <sym> }

sub category__S_024statement_control__PEEK { $_[0]->_AUTOLEXpeek('category__S_024statement_control',$retree) }
sub category__S_024statement_control {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_control';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_024statement_control", 
$C->_PATTERN(qr/\Gstatement_control/)
);
}
#proto rule  statement_control (:$endsym is context = 'spacey') { <...> }
sub statement_control__PEEK { $_[0]->_AUTOLEXpeek('statement_control:*',$retree); }
sub statement_control {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_control') {
$C->deb("Fate passed to statement_control: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_control", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_025statement_mod_cond (:$sym is context<rw> = 'statement_mod_cond')
##      token category:statement_mod_cond { <sym> }

sub category__S_025statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('category__S_025statement_mod_cond',$retree) }
sub category__S_025statement_mod_cond {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_mod_cond';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_025statement_mod_cond", 
$C->_PATTERN(qr/\Gstatement_mod_cond/)
);
}
#proto rule  statement_mod_cond (:$endsym is context = 'nofun') { <...> }
sub statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond:*',$retree); }
sub statement_mod_cond {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_mod_cond') {
$C->deb("Fate passed to statement_mod_cond: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_cond:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_cond trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_mod_cond", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_026statement_mod_loop (:$sym is context<rw> = 'statement_mod_loop')
##      token category:statement_mod_loop { <sym> }

sub category__S_026statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('category__S_026statement_mod_loop',$retree) }
sub category__S_026statement_mod_loop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_mod_loop';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_026statement_mod_loop", 
$C->_PATTERN(qr/\Gstatement_mod_loop/)
);
}
#proto rule  statement_mod_loop (:$endsym is context = 'nofun') { <...> }
sub statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop:*',$retree); }
sub statement_mod_loop {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_mod_loop') {
$C->deb("Fate passed to statement_mod_loop: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_loop:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_loop trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_mod_loop", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_027infix_prefix_meta_operator (:$sym is context<rw> = 'infix_prefix_meta_operator')
##      token category:infix_prefix_meta_operator { <sym> }

sub category__S_027infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_027infix_prefix_meta_operator',$retree) }
sub category__S_027infix_prefix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_prefix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_027infix_prefix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_prefix_meta_operator/)
);
}
#proto token infix_prefix_meta_operator is binary { <...> }
sub infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator:*',$retree); }
sub infix_prefix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix_prefix_meta_operator') {
$C->deb("Fate passed to infix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_prefix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_028infix_postfix_meta_operator (:$sym is context<rw> = 'infix_postfix_meta_operator')
##      token category:infix_postfix_meta_operator { <sym> }

sub category__S_028infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_028infix_postfix_meta_operator',$retree) }
sub category__S_028infix_postfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_postfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_028infix_postfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_postfix_meta_operator/)
);
}
#proto token infix_postfix_meta_operator ($op) is binary { <...> }
sub infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator:*',$retree); }
sub infix_postfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix_postfix_meta_operator') {
$C->deb("Fate passed to infix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_postfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_029infix_circumfix_meta_operator (:$sym is context<rw> = 'infix_circumfix_meta_operator')
##      token category:infix_circumfix_meta_operator { <sym> }

sub category__S_029infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_029infix_circumfix_meta_operator',$retree) }
sub category__S_029infix_circumfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_circumfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_029infix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_circumfix_meta_operator/)
);
}
#proto token infix_circumfix_meta_operator is binary { <...> }
sub infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator:*',$retree); }
sub infix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix_circumfix_meta_operator') {
$C->deb("Fate passed to infix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_circumfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_030postfix_prefix_meta_operator (:$sym is context<rw> = 'postfix_prefix_meta_operator')
##      token category:postfix_prefix_meta_operator { <sym> }

sub category__S_030postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_030postfix_prefix_meta_operator',$retree) }
sub category__S_030postfix_prefix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postfix_prefix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_030postfix_prefix_meta_operator", 
$C->_PATTERN(qr/\Gpostfix_prefix_meta_operator/)
);
}
#proto token postfix_prefix_meta_operator is unary { <...> }
sub postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator:*',$retree); }
sub postfix_prefix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'postfix_prefix_meta_operator') {
$C->deb("Fate passed to postfix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postfix_prefix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_031prefix_postfix_meta_operator (:$sym is context<rw> = 'prefix_postfix_meta_operator')
##      token category:prefix_postfix_meta_operator { <sym> }

sub category__S_031prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_031prefix_postfix_meta_operator',$retree) }
sub category__S_031prefix_postfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix_postfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_031prefix_postfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_postfix_meta_operator/)
);
}
#proto token prefix_postfix_meta_operator is unary { <...> }
sub prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator:*',$retree); }
sub prefix_postfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'prefix_postfix_meta_operator') {
$C->deb("Fate passed to prefix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix_postfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_032prefix_circumfix_meta_operator (:$sym is context<rw> = 'prefix_circumfix_meta_operator')
##      token category:prefix_circumfix_meta_operator { <sym> }

sub category__S_032prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_032prefix_circumfix_meta_operator',$retree) }
sub category__S_032prefix_circumfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix_circumfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_032prefix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_circumfix_meta_operator/)
);
}
#proto token prefix_circumfix_meta_operator is unary { <...> }
sub prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator:*',$retree); }
sub prefix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'prefix_circumfix_meta_operator') {
$C->deb("Fate passed to prefix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix_circumfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_033terminator (:$sym is context<rw> = 'terminator')
##      token category:terminator { <sym> }

sub category__S_033terminator__PEEK { $_[0]->_AUTOLEXpeek('category__S_033terminator',$retree) }
sub category__S_033terminator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'terminator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_033terminator", 
$C->_PATTERN(qr/\Gterminator/)
);
}
#proto token terminator { <...> }
sub terminator__PEEK { $_[0]->_AUTOLEXpeek('terminator:*',$retree); }
sub terminator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'terminator') {
$C->deb("Fate passed to terminator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'terminator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("terminator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "terminator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token unspacey
##      token unspacey { <.unsp>? }

sub unspacey__PEEK { $_[0]->_AUTOLEXpeek('unspacey',$retree) }
sub unspacey {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unspacey", 
$C->_OPTr(sub { my $C=shift;
$C->unsp
})
);
}
## token spacey
##      token spacey { <?before \s | '#'> }

sub spacey__PEEK { $_[0]->_AUTOLEXpeek('spacey',$retree) }
sub spacey {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "spacey", 
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'spacey_01') {
$C->deb("Fate passed to spacey_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'spacey_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("spacey_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}
## token nofun
##      token nofun { <!before '(' | '.(' | '\\' > }

sub nofun__PEEK { $_[0]->_AUTOLEXpeek('nofun',$retree) }
sub nofun {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nofun", 
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'nofun_01') {
$C->deb("Fate passed to nofun_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'nofun_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nofun_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_EXACT('.(')
},
sub { my $C=shift;
$C->_EXACT('\\')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
);
}

# Lexical routines

## token ws
##      token ws {
##          :my @stub = return self if @+MEMOS[self.pos]<ws> :exists;
##          :my $startpos = self.pos;
##      
##          :dba('whitespace')
##          [
##              | \h+ <![#\s\\]> { @+MEMOS[$.pos]<ws> = $startpos; }   # common case
##              | <?before \w> <?after \w> :::
##                  { @+MEMOS[$startpos]<ws> = undef; }
##                  <!>        # must \s+ between words
##          ]
##          ||
##          [
##          | <.unsp>
##          | <.vws> <.heredoc>
##          | <.unv>
##          | $ { $.moreinput }
##          ]*
##      
##          {{
##              if ($.pos == $startpos) {
##                  @+MEMOS[$.pos]<ws> = undef;
##              }
##              else {
##                  @+MEMOS[$.pos]<ws> = $startpos;
##                  @+MEMOS[$.pos]<endstmt> = @+MEMOS[$startpos]<endstmt>
##                      if @+MEMOS[$startpos]<endstmt> :exists;
##              }
##          }}
##      }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $MEMOS[$self->{_pos}]{'ws'};
my $startpos = $self->{_pos};


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "ws", 
do { my @gather;
eval { push @gather, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'ws_01') {
$C->deb("Fate passed to ws_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[#\s\\]/)
}))) {
scalar(do {
$MEMOS[$C->{_pos}]{'ws'} = $startpos; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
}, scalar(do {
$MEMOS[$startpos]{'ws'} = undef; 
}, $C))
}, $C->_COMMITRULE())
}, $C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
scalar(do {

if (($C->{_pos} == $startpos)) {
$MEMOS[$C->{_pos}]{'ws'} = undef;
}
else {
$MEMOS[$C->{_pos}]{'ws'} = $startpos;
$MEMOS[$C->{_pos}]{'endstmt'} = $MEMOS[$startpos]{'endstmt'}
if exists $MEMOS[$startpos]{'endstmt'};
}

}, $C)
}, $C->_STARr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'ws_05') {
$C->deb("Fate passed to ws_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->heredoc
}, $C->vws)
},
sub { my $C=shift;
$C->unv
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$C->moreinput 
}, $C)
}, $C->_PATTERN(qr/\G\z/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))} or do { die $@ if $@ };
@gather;
}
);
}

## token unsp
##      token unsp {
##          \\ <?before [\s|'#'] >
##          :dba('unspace')
##          [
##          | <.vws>                     {*}                             #= vwhite
##          | <.unv>                  {*}                                #= unv
##          | $ { $.moreinput }
##          ]*
##      }

sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp',$retree) }
sub unsp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unsp", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unsp_02') {
$C->deb("Fate passed to unsp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unsp_03') {
$C->deb("Fate passed to unsp_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->vws)) {
$C->_REDUCE($S, 'unsp_vwhite');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->unv)) {
$C->_REDUCE($S, 'unsp_unv');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token vws
##      token vws {
##          :dba('vertical whitespace')
##          \v
##          [ '#DEBUG -1' { say "DEBUG"; $STD::DEBUG = $*DEBUG = -1; } ]?
##      }

sub vws__PEEK { $_[0]->_AUTOLEXpeek('vws',$retree) }
sub vws {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "vws", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\n]/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('#DEBUG -1'))) {
scalar(do {
say "DEBUG"; $STD::DEBUG = $::DEBUG = -1; 
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# We provide two mechanisms here:
# 1) define $+moreinput, or
# 2) override moreinput method
## method moreinput ()
sub moreinput {
my $self = shift;


$::moreinput->() if $::moreinput;
}

## token unv
##      token unv {
##         :dba('horizontal whitespace')
##         [
##         | \h+                 {*}                                    #= hwhite
##         | <?before '='> ^^ <.pod_comment>  {*}                    #= pod
##         | \h* '#' [
##               |  <?opener>
##                  [ <!after ^^ . > || <.panic: "Can't use embedded comments in column 1"> ]
##                  <.quibble($.cursor_fresh( ::STD::Q ))>   {*}                               #= embedded
##               | {} \N*            {*}                                 #= end
##               ]
##          ]
##      }

sub unv__PEEK { $_[0]->_AUTOLEXpeek('unv',$retree) }
sub unv {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unv", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unv_01') {
$C->deb("Fate passed to unv_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
$C->_REDUCE($S, 'unv_hwhite');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:^)/))) {
do {
if (my ($C) = ($C->pod_comment)) {
$C->_REDUCE($S, 'unv_pod');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('#'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unv_03') {
$C->deb("Fate passed to unv_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->opener
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=(?s:.))(?m:^)/)
})
})} 
or
eval { push @gather, $C->panic("Can't use embedded comments in column 1")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->quibble($C->cursor_fresh( 'STD::Q' )))) {
$C->_REDUCE($S, 'unv_embedded');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))) {
$C->_REDUCE($S, 'unv_end');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token ident
##      token ident {
##          <.alpha> \w*
##      }

sub ident__PEEK { $_[0]->_AUTOLEXpeek('ident',$retree) }
sub ident {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "ident", 
$C->_PATTERN(qr/\G[_[:alpha:]]((?:\w)*+)/)
);
}

## token apostrophe
##      token apostrophe {
##          <[ ' \- ]>
##      }

sub apostrophe__PEEK { $_[0]->_AUTOLEXpeek('apostrophe',$retree) }
sub apostrophe {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "apostrophe", 
$C->_PATTERN(qr/\G['\-]/)
);
}

## token identifier
##      token identifier {
##          <.ident> [ <.apostrophe> <.ident> ]*
##      }

sub identifier__PEEK { $_[0]->_AUTOLEXpeek('identifier',$retree) }
sub identifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "identifier", 
do {
if (my ($C) = ($C->ident)) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->apostrophe)) {
$C->ident;
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# XXX We need to parse the pod eventually to support $= variables.

## token pod_comment
##      token pod_comment {
##          ^^ '=' <.unsp>?
##          [
##          | 'begin' \h+ <identifier> ::
##              [
##              ||  .*? "\n=" <.unsp>? 'end' \h+ $<identifier>  \N*          {*} #= tagged
##              ||  .*?                                                       {*} #= end
##              ]
##          | 'begin'  :: \h* [ $$ || '#' || <.panic: "Unrecognized token after =begin"> ]
##              [ .*?  "\n=" <.unsp>? 'end'  \N* || <.panic: "=begin without =end"> ]   {*}       #= anon
##          | :: 
##              [ <?before .*? ^^ '=cut'  > <.panic: "Obsolete pod format, please use =begin/=end instead"> ]?
##              \N*                                           {*}       #= misc
##          ]
##      }

sub pod_comment__PEEK { $_[0]->_AUTOLEXpeek('pod_comment',$retree) }
sub pod_comment {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "pod_comment", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'pod_comment_01') {
$C->deb("Fate passed to pod_comment_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pod_comment_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pod_comment_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_tagged')
}, $C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}, $C->_PATTERN(qr/\G\b/))
}, $C->_BACKREFn('identifier'))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G\n=/))
}, $C->_SCANf())} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_end')
}, $C->_SCANf())} or do { die $@ if $@ };
@gather;
}
})
}, $C->_COMMITBRANCH())
}, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))
}, $C->_EXACT('begin'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_anon')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G\n=/))
}, $C->_SCANf())} 
or
eval { push @gather, $C->panic("=begin without =end")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?m:$)/)} 
or
eval { push @gather, $C->_EXACT('#')} 
or
eval { push @gather, $C->panic("Unrecognized token after =begin")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('begin'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_misc')
}, $C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Obsolete pod format, please use =begin/=end instead")
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G\b/)
}, $C->_EXACT('=cut'))
}, $C->_PATTERN(qr/\G(?m:^)/))
}, $C->_SCANf())
}))
})
}))
}, $C->_COMMITBRANCH())
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_EXACT('='))
}, $C->_PATTERN(qr/\G(?m:^)/))
);
}

# Top-level rules

# Note: we only check for the stopper.  We don't check for ^ because
# we might be embedded in something else.
## rule comp_unit
##      rule comp_unit {
##          :my $begin_compunit is context = 1;
##          :my $endargs        is context<rw> = -1;
##      
##          :my $LANG is context;
##          :my $PKGDECL is context = "";
##          :my $PKG is context = "";
##          :my $GOAL is context = "(eof)";
##          :my $PARSER is context<rw>;
##          :my $IN_DECL is context<rw>;
##      
##          { init_pads(); }
##      
##          <statementlist>
##          [ <?unitstopper> || <.panic: "Can't understand next input--giving up"> ]
##          # "CHECK" time...
##          {{
##              if @COMPILING::WORRIES {
##                  warn "Potential difficulties:\n  " ~ join( "\n  ", @COMPILING::WORRIES) ~ "\n";
##              }
##      
##              my %post_types;
##              my %unk_types;
##              my %unk_routines;
##              for keys(%MYSTERY) {
##                  if $.is_type($_) {
##                      # types may not be post-declared
##                      %post_types{$_} = %MYSTERY{$_};
##                      next;
##                  }
##      
##                  next if $.is_known($_);
##      
##                  # just a guess, but good enough to improve error reporting
##                  if $_ lt 'a' {
##                      %unk_types{$_} = %MYSTERY{$_};
##                  }
##                  else {
##                      %unk_routines{$_} = %MYSTERY{$_};
##                  }
##              }
##              if %post_types {
##                  my @tmp = sort keys(%post_types);
##                  warn "Illegally post-declared type" ~ ('s' x (@tmp != 1)) ~ ":\n";
##                  for @tmp {
##                      warn "\t$_ used at ", %post_types{$_}, "\n";
##                  }
##              }
##              if %unk_types {
##                  my @tmp = sort keys(%unk_types);
##                  warn "Undeclared type" ~ ('s' x (@tmp != 1)) ~ ":\n";
##                  for @tmp {
##                      warn "\t$_ used at ", %unk_types{$_}, "\n";
##                  }
##              }
##              if %unk_routines {
##                  my @tmp = sort keys(%unk_routines);
##                  warn "Undeclared routine" ~ ('s' x (@tmp != 1)) ~ ":\n";
##                  for @tmp {
##                      warn "\t$_ used at ", %unk_routines{$_}, "\n";
##                  }
##              }
##          }}
##      }

sub comp_unit__PEEK { $_[0]->_AUTOLEXpeek('comp_unit',$retree) }
sub comp_unit {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::begin_compunit =  1;
local $::endargs =  -1;
local $::LANG;
local $::PKGDECL =  "";
local $::PKG =  "";
local $::GOAL =  "(eof)";
local $::PARSER;
local $::IN_DECL;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "comp_unit", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
init_pads(); 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->unitstopper
}))) {
$C->ws;
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Can't understand next input--giving up"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

if (@COMPILING::WORRIES) {
warn "Potential difficulties:\n  " . join( "\n  ", @COMPILING::WORRIES) . "\n";
}

my %post_types;
my %unk_types;
my %unk_routines;
for (keys(%MYSTERY)) {
if ($C->is_type($_)) {
# types may not be post-declared
$post_types{$_} = $MYSTERY{$_};
next;
}

next if $C->is_known($_);

# just a guess, but good enough to improve error reporting
if ($_ lt 'a') {
$unk_types{$_} = $MYSTERY{$_};
}
else {
$unk_routines{$_} = $MYSTERY{$_};
}
}
if (%post_types) {
my @tmp = sort keys(%post_types);
warn "Illegally post-declared type" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
warn "\t$_ used at ", $post_types{$_}, "\n";
}
}
if (%unk_types) {
my @tmp = sort keys(%unk_types);
warn "Undeclared type" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
warn "\t$_ used at ", $unk_types{$_}, "\n";
}
}
if (%unk_routines) {
my @tmp = sort keys(%unk_routines);
warn "Undeclared routine" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
warn "\t$_ used at ", $unk_routines{$_}, "\n";
}
}

}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# Note: because of the possibility of placeholders we can't determine arity of
# the block syntactically, so this must be determined via semantic analysis.
# Also, pblocks used in an if/unless statement do not treat $_ as a placeholder,
# while most other blocks treat $_ as equivalent to $^x.  Therefore the first
# possible place to check arity is not here but in the rule that calls this
# rule.  (Could also be done in a later pass.)

## token pblock
##      token pblock {
##          :dba('parameterized block')
##          [ <lambda> <signature> ]? <block>
##      }

sub pblock__PEEK { $_[0]->_AUTOLEXpeek('pblock',$retree) }
sub pblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'signature'} = [];
$C->{'lambda'} = [];

$self->_MATCHIFYr($S, "pblock", 
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['lambda'], sub {
my $C = shift;
$C->lambda
}))) {
$C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
});
}
else {
();
}
}
})
}))) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
});
}
else {
();
}
}
);
}

## token lambda
##      token lambda { '->' | '<->' }

sub lambda__PEEK { $_[0]->_AUTOLEXpeek('lambda',$retree) }
sub lambda {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "lambda", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'lambda_00') {
$C->deb("Fate passed to lambda_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'lambda_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("lambda_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('->')
},
sub { my $C=shift;
$C->_EXACT('<->')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

# Look for an expression followed by a required lambda.
## token xblock
##      token xblock {
##          :my $GOAL is context = '{';
##          <EXPR>
##          <.ws>
##          <pblock>
##      }

sub xblock__PEEK { $_[0]->_AUTOLEXpeek('xblock',$retree) }
sub xblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL =  '{';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "xblock", 
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token block
##      token block {
##          '{' ~ '}' <statementlist>
##      
##          [
##          | <?before \h* $$>  # (usual case without comments)
##              { @+MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt simple 
##          | \h* <.unsp>? <?before <[,:]>> {*}                         #= normal 
##          | <.unv>? $$
##              { @+MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt complex
##          | <.unsp>? { @+MEMOS[$.pos]<endargs> = 1; } {*}             #= endargs
##          ]
##      }

sub block__PEEK { $_[0]->_AUTOLEXpeek('block',$retree) }
sub block {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "block", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'block_01') {
$C->deb("Fate passed to block_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'block_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("block_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'block_endstmt_simple_')
}, scalar(do {
$MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?m:$)/)
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'block_normal_')
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[,:]/)
}))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'block_endstmt_complex')
}, scalar(do {
$MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))
}, $C->_PATTERN(qr/\G(?m:$)/))
}, $C->_OPTr(sub { my $C=shift;
$C->unv
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'block_endargs')
}, scalar(do {
$MEMOS[$C->{_pos}]{'endargs'} = 1; 
}, $C))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}' , 'block')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
);
}

## token regex_block
##      token regex_block {
##          :my $lang = ::Regex;
##          :my $GOAL is context = '}';
##      
##          [ <quotepair> <.ws>
##              {
##                  my $kv = $<quotepair>[*-1];
##                  $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                      or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##              }
##          ]*
##      
##          '{'
##          <nibble( $.cursor_fresh($lang).unbalanced('}') )>
##          [ '}' || <.panic: "Unable to parse regex; couldn't find right brace"> ]
##      
##          [
##          | <?before \h* $$>  # (usual case without comments)
##              { @+MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt simple 
##          | \h* <.unsp>? <?before <[,:]>> {*}                         #= normal 
##          | <.unv>? $$
##              { @+MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt complex
##          | <.unsp>? { @+MEMOS[$.pos]<endargs> = 1; }   {*}           #= endargs
##          ]
##      }

sub regex_block__PEEK { $_[0]->_AUTOLEXpeek('regex_block',$retree) }
sub regex_block {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $lang = 'STD::Regex';
local $::GOAL =  '}';


my $C = $self;
my $S = $C->{_pos};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "regex_block", 
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{quotepair}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh($lang)->unbalanced('}') )
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'regex_block_04') {
$C->deb("Fate passed to regex_block_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_block_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_block_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[\x20\t\r])*+)(?m:$)/)
}))) {
do {
if (my ($C) = (scalar(do {
$MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))) {
$C->_REDUCE($S, 'regex_block_endstmt_simple_');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[,:]/)
}))) {
$C->_REDUCE($S, 'regex_block_normal_');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unv
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:$)/))) {
do {
if (my ($C) = (scalar(do {
$MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))) {
$C->_REDUCE($S, 'regex_block_endstmt_complex');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = (scalar(do {
$MEMOS[$C->{_pos}]{'endargs'} = 1; 
}, $C))) {
$C->_REDUCE($S, 'regex_block_endargs');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# statement semantics
## rule statementlist
##      rule statementlist {
##          :my $PARSER is context<rw> = self;
##          :my $INVOCANT_OK is context<rw> = 0;
##          :dba('statement list')
##          [
##          | $
##          | <?before <[\)\]\}]> >
##          | [<statement><eat_terminator> ]*
##          ]
##      }

sub statementlist__PEEK { $_[0]->_AUTOLEXpeek('statementlist',$retree) }
sub statementlist {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::PARSER =  $self;
local $::INVOCANT_OK =  0;


my $C = $self;
my $S = $C->{_pos};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "statementlist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statementlist_01') {
$C->deb("Fate passed to statementlist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statementlist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statementlist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\)\]\}]/))) {
$C->ws;
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# embedded semis, context-dependent semantics
## rule semilist
##      rule semilist {
##          :my $INVOCANT_OK is context<rw> = 0;
##          :dba('semicolon list')
##          [
##          | <?before <[\)\]\}]> >
##          | [<statement><eat_terminator> ]*
##          ]
##      }

sub semilist__PEEK { $_[0]->_AUTOLEXpeek('semilist',$retree) }
sub semilist {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK =  0;


my $C = $self;
my $S = $C->{_pos};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "semilist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'semilist_01') {
$C->deb("Fate passed to semilist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'semilist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("semilist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\)\]\}]/))) {
$C->ws;
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token label
##      token label {
##          :my $label;
##          <identifier> ':' <?before \s> <.ws>
##      
##          [ <?{ $.is_type($label = $<identifier>.text) }>
##            <.panic("Illegal redeclaration of '$label'")>
##          ]?
##      
##          # add label as a pseudo type
##          {{ $.add_type($label); }}
##      
##      }

sub label__PEEK { $_[0]->_AUTOLEXpeek('label',$retree) }
sub label {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $label;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "label", 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $C->is_type($label = $M->{identifier}->text) ;
})
}))) {
$C->panic("Illegal redeclaration of '$label'");
}
else {
();
}
}
})
}))) {
scalar(do {
$C->add_type($label); 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement
##      token statement {
##          :my $endargs is context = -1;
##          <!before <[\)\]\}]> >
##      
##          # this could either be a statement that follows a declaration
##          # or a statement that is within the block of a code declaration
##          <!!{ $ = $+PARSER.bless($); }>
##      
##          [
##          | <label> <statement>                        {*}            #= label
##          | <statement_control>                        {*}            #= control
##          | <EXPR> {*}                                                #= expr
##              :dba('statement end')
##              [
##              || <?{ (@+MEMOS[$.pos]<endstmt> // 0) == 2 }>   # no mod after end-line curly
##              ||
##                  :dba('statement modifier')
##                  <.ws>
##                  [
##                  | <statement_mod_loop> {*}                              #= mod loop
##                  | <statement_mod_cond> {*}                              #= mod cond
##                      :dba('statement modifier loop')
##                      [
##                      || <?{ (@+MEMOS[$.pos]<endstmt> // 0) == 2 }>
##                      || <.ws> <statement_mod_loop>? {*}                  #= mod condloop
##                      ]
##                  ]?
##              ]
##              {*}                                                     #= modexpr
##          | <?before ';'> {*}                                         #= null
##          ]
##      }

sub statement__PEEK { $_[0]->_AUTOLEXpeek('statement',$retree) }
sub statement {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::endargs =  -1;


my $C = $self;
my $S = $C->{_pos};
$C->{'statement_mod_loop'} = [];
$C->{'statement_mod_cond'} = [];

$self->_MATCHIFYr($S, "statement", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$C = $::PARSER->bless($C); 
})
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_02') {
$C->deb("Fate passed to statement_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['label'], sub {
my $C = shift;
$C->label
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_REDUCE($S, 'statement_label');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
}))) {
$C->_REDUCE($S, 'statement_control');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_expr'))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($MEMOS[$C->{_pos}]{'endstmt'} // 0) == 2 
})
})} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_05') {
$C->deb("Fate passed to statement_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
}))) {
$C->_REDUCE($S, 'statement_mod_loop');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_cond'], sub {
my $C = shift;
$C->statement_mod_cond
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond'))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($MEMOS[$C->{_pos}]{'endstmt'} // 0) == 2 
})
})} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
})
}))) {
$C->_REDUCE($S, 'statement_mod_condloop');
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'statement_modexpr');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(';')
}))) {
$C->_REDUCE($S, 'statement_null');
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
);
}


## token eat_terminator
##      token eat_terminator {
##          [
##          || ';'
##          || <?{ @+MEMOS[$.pos]<endstmt> }> <.ws>
##          || <?terminator>
##          || $
##          || {{ if @+MEMOS[$.pos]<ws> { $.pos = @+MEMOS[$.pos]<ws>; } }}   # undo any line transition
##              <.panic: "Syntax error">
##          ]
##      }

sub eat_terminator__PEEK { $_[0]->_AUTOLEXpeek('eat_terminator',$retree) }
sub eat_terminator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "eat_terminator", 
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(';')} 
or
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$MEMOS[$C->{_pos}]{'endstmt'} 
})
}))) {
$C->ws;
}
else {
();
}
}} 
or
eval { push @gather, $C->before( sub { my $C=shift;
$C->terminator
})} 
or
eval { push @gather, $C->_PATTERN(qr/\G\z/)} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
if ($MEMOS[$C->{_pos}]{'ws'}) { $C->{_pos} = $MEMOS[$C->{_pos}]{'ws'}; } 
}, $C))) {
$C->panic("Syntax error");
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
})
);
}

## token statement_control__S_034use (:$endsym is context = 'spacey', :$sym is context<rw> = 'use')
##      token statement_control:use {
##          <sym> :s
##          [
##          | <version>
##          | <module_name><arglist>?
##              {{
##                  my $longname = $<module_name><longname>;
##                  $.add_type($longname.text);
##              }}
##          ]
##      }

sub statement_control__S_034use__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_034use',$retree) }
sub statement_control__S_034use {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'use';


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_034use", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guse/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_034use_01') {
$C->deb("Fate passed to statement_control__S_034use_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_034use_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_034use_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $longname = $M->{module_name}{longname};
$C->add_type($longname->text);
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_035no (:$endsym is context = 'spacey', :$sym is context<rw> = 'no')
##      token statement_control:no {
##          <sym> :s
##          <module_name><arglist>?
##      }

sub statement_control__S_035no__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_035no',$retree) }
sub statement_control__S_035no {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'no';


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_035no", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gno/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_036if (:$endsym is context = 'spacey', :$sym is context<rw> = 'if')
##      token statement_control:if {
##          <sym> :s
##          <xblock>
##          [$<elsif> = (
##              'elsif'<?spacey> <xblock>       {*}                #= elsif
##          )]*
##          [$<else> = (
##              'else'<?spacey> <pblock>       {*}             #= else
##          )]?
##      }

sub statement_control__S_036if__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_036if',$retree) }
sub statement_control__S_036if {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'if';


my $C = $self;
my $S = $C->{_pos};
$C->{'else'} = [];
$C->{'elsif'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_036if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_SUBSUMEr(['elsif'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('elsif'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_036if_elsif'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_SUBSUMEr(['else'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('else'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_036if_else'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_037unless (:$endsym is context = 'spacey', :$sym is context<rw> = 'unless')
##      token statement_control:unless {
##          <sym> :s
##          <xblock>
##          [ <!before 'else'> || <.panic: "unless does not take \"else\" in Perl 6; please rewrite using \"if\""> ]
##      }

sub statement_control__S_037unless__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_037unless',$retree) }
sub statement_control__S_037unless {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'unless';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_037unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('else')
})
}))) {
$C->ws;
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("unless does not take \"else\" in Perl 6; please rewrite using \"if\""))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_038while (:$endsym is context = 'spacey', :$sym is context<rw> = 'while')
##      token statement_control:while {
##          <sym> :s
##          [ <?before '(' ['my'? '$'\w+ '=']? '<' '$'?\w+ '>' ')'>   #'
##              <.panic: "This appears to be Perl 5 code"> ]?
##          <xblock>
##      }

sub statement_control__S_038while__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_038while',$retree) }
sub statement_control__S_038while {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'while';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_038while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT('=');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('$')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_039until (:$endsym is context = 'spacey', :$sym is context<rw> = 'until')
##      token statement_control:until {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_039until__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_039until',$retree) }
sub statement_control__S_039until {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'until';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_039until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_040repeat (:$endsym is context = 'spacey', :$sym is context<rw> = 'repeat')
##      token statement_control:repeat {
##          <sym> :s
##          [
##              | ('while'|'until')
##                <xblock>
##              | <block>                      {*}                      #= block wu
##                ('while'|'until') <EXPR>         {*}                      #= expr wu
##          ]
##      }

sub statement_control__S_040repeat__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_040repeat',$retree) }
sub statement_control__S_040repeat {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'repeat';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_040repeat", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grepeat/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_040repeat_01') {
$C->deb("Fate passed to statement_control__S_040repeat_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_040repeat_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_040repeat_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_040repeat_02') {
$C->deb("Fate passed to statement_control__S_040repeat_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_040repeat_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_040repeat_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_040repeat_block_wu'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_040repeat_03') {
$C->deb("Fate passed to statement_control__S_040repeat_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_040repeat_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_040repeat_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_040repeat_expr_wu'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_041loop (:$endsym is context = 'spacey', :$sym is context<rw> = 'loop')
##      token statement_control:loop {
##          <sym> :s
##          $<eee> = (
##              '('
##                  <e1=EXPR>? ';'   {*}                            #= e1
##                  <e2=EXPR>? ';'   {*}                            #= e2
##                  <e3=EXPR>?       {*}                            #= e3
##              ')'                      {*}                            #= eee
##          )?
##          <block>                     {*}                             #= block
##      }

sub statement_control__S_041loop__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_041loop',$retree) }
sub statement_control__S_041loop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'loop';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_041loop", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gloop/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['eee'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e1','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_041loop_e1'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e2','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_041loop_e2'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e3','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_041loop_e3'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(')'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_041loop_eee'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_041loop_block'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_042for (:$endsym is context = 'spacey', :$sym is context<rw> = 'for')
##      token statement_control:for {
##          <sym> :s
##          [ <?before 'my'? '$'\w+ '(' >
##              <.panic: "This appears to be Perl 5 code"> ]?
##          [ <?before '(' <EXPR>? ';' <EXPR>? ';' <EXPR>? ')' >
##              <.obs('C-style "for (;;)" loop', '"loop (;;)"')> ]?
##          <xblock>
##      }

sub statement_control__S_042for__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_042for',$retree) }
sub statement_control__S_042for {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'for';


my $C = $self;
my $S = $C->{_pos};
$C->{'EXPR'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_042for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(')'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->obs('C-style "for (;;)" loop', '"loop (;;)"'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_control__S_043given (:$endsym is context = 'spacey', :$sym is context<rw> = 'given')
##      token statement_control:given {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_043given__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_043given',$retree) }
sub statement_control__S_043given {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'given';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_043given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_control__S_044when (:$endsym is context = 'spacey', :$sym is context<rw> = 'when')
##      token statement_control:when {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_044when__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_044when',$retree) }
sub statement_control__S_044when {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'when';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_044when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_045default (:$endsym is context = 'spacey', :$sym is context<rw> = 'default')
##      rule statement_control:default {<sym> <block> }

sub statement_control__S_045default__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_045default',$retree) }
sub statement_control__S_045default {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'default';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_045default", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdefault/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_control__S_046BEGIN (:$endsym is context = 'spacey', :$sym is context<rw> = 'BEGIN')
##      rule statement_control:BEGIN   {<sym> <block> }

sub statement_control__S_046BEGIN__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_046BEGIN',$retree) }
sub statement_control__S_046BEGIN {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'BEGIN';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_046BEGIN", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GBEGIN/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_047CHECK (:$endsym is context = 'spacey', :$sym is context<rw> = 'CHECK')
##      rule statement_control:CHECK   {<sym> <block> }

sub statement_control__S_047CHECK__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_047CHECK',$retree) }
sub statement_control__S_047CHECK {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CHECK';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_047CHECK", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCHECK/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_048INIT (:$endsym is context = 'spacey', :$sym is context<rw> = 'INIT')
##      rule statement_control:INIT    {<sym> <block> }

sub statement_control__S_048INIT__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_048INIT',$retree) }
sub statement_control__S_048INIT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'INIT';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_048INIT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GINIT/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_049END (:$endsym is context = 'spacey', :$sym is context<rw> = 'END')
##      rule statement_control:END     {<sym> <block> }

sub statement_control__S_049END__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_049END',$retree) }
sub statement_control__S_049END {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'END';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_049END", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GEND/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_050START (:$endsym is context = 'spacey', :$sym is context<rw> = 'START')
##      rule statement_control:START   {<sym> <block> }

sub statement_control__S_050START__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_050START',$retree) }
sub statement_control__S_050START {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'START';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_050START", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GSTART/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_051ENTER (:$endsym is context = 'spacey', :$sym is context<rw> = 'ENTER')
##      rule statement_control:ENTER   {<sym> <block> }

sub statement_control__S_051ENTER__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_051ENTER',$retree) }
sub statement_control__S_051ENTER {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'ENTER';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_051ENTER", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GENTER/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_052LEAVE (:$endsym is context = 'spacey', :$sym is context<rw> = 'LEAVE')
##      rule statement_control:LEAVE   {<sym> <block> }

sub statement_control__S_052LEAVE__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_052LEAVE',$retree) }
sub statement_control__S_052LEAVE {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'LEAVE';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_052LEAVE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLEAVE/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_053KEEP (:$endsym is context = 'spacey', :$sym is context<rw> = 'KEEP')
##      rule statement_control:KEEP    {<sym> <block> }

sub statement_control__S_053KEEP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_053KEEP',$retree) }
sub statement_control__S_053KEEP {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'KEEP';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_053KEEP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GKEEP/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_054UNDO (:$endsym is context = 'spacey', :$sym is context<rw> = 'UNDO')
##      rule statement_control:UNDO    {<sym> <block> }

sub statement_control__S_054UNDO__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_054UNDO',$retree) }
sub statement_control__S_054UNDO {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'UNDO';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_054UNDO", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GUNDO/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_055FIRST (:$endsym is context = 'spacey', :$sym is context<rw> = 'FIRST')
##      rule statement_control:FIRST   {<sym> <block> }

sub statement_control__S_055FIRST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_055FIRST',$retree) }
sub statement_control__S_055FIRST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'FIRST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_055FIRST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GFIRST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_056NEXT (:$endsym is context = 'spacey', :$sym is context<rw> = 'NEXT')
##      rule statement_control:NEXT    {<sym> <block> }

sub statement_control__S_056NEXT__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_056NEXT',$retree) }
sub statement_control__S_056NEXT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'NEXT';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_056NEXT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GNEXT/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_057LAST (:$endsym is context = 'spacey', :$sym is context<rw> = 'LAST')
##      rule statement_control:LAST    {<sym> <block> }

sub statement_control__S_057LAST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_057LAST',$retree) }
sub statement_control__S_057LAST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'LAST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_057LAST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLAST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_058PRE (:$endsym is context = 'spacey', :$sym is context<rw> = 'PRE')
##      rule statement_control:PRE     {<sym> <block> }

sub statement_control__S_058PRE__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_058PRE',$retree) }
sub statement_control__S_058PRE {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'PRE';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_058PRE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPRE/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_059POST (:$endsym is context = 'spacey', :$sym is context<rw> = 'POST')
##      rule statement_control:POST    {<sym> <block> }

sub statement_control__S_059POST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_059POST',$retree) }
sub statement_control__S_059POST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'POST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_059POST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPOST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_060CATCH (:$endsym is context = 'spacey', :$sym is context<rw> = 'CATCH')
##      rule statement_control:CATCH   {<sym> <block> }

sub statement_control__S_060CATCH__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_060CATCH',$retree) }
sub statement_control__S_060CATCH {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CATCH';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_060CATCH", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCATCH/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_061CONTROL (:$endsym is context = 'spacey', :$sym is context<rw> = 'CONTROL')
##      rule statement_control:CONTROL {<sym> <block> }

sub statement_control__S_061CONTROL__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_061CONTROL',$retree) }
sub statement_control__S_061CONTROL {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CONTROL';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_061CONTROL", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCONTROL/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_062TEMP (:$endsym is context = 'spacey', :$sym is context<rw> = 'TEMP')
##      rule statement_control:TEMP    {<sym> <block> }

sub statement_control__S_062TEMP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_062TEMP',$retree) }
sub statement_control__S_062TEMP {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'TEMP';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_062TEMP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GTEMP/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule term__S_063BEGIN (:$sym is context<rw> = 'BEGIN')
##      rule term:BEGIN   {<sym> <block> }

sub term__S_063BEGIN__PEEK { $_[0]->_AUTOLEXpeek('term__S_063BEGIN',$retree) }
sub term__S_063BEGIN {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'BEGIN';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_063BEGIN", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GBEGIN/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_064CHECK (:$sym is context<rw> = 'CHECK')
##      rule term:CHECK   {<sym> <block> }

sub term__S_064CHECK__PEEK { $_[0]->_AUTOLEXpeek('term__S_064CHECK',$retree) }
sub term__S_064CHECK {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'CHECK';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_064CHECK", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCHECK/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_065INIT (:$sym is context<rw> = 'INIT')
##      rule term:INIT    {<sym> <block> }

sub term__S_065INIT__PEEK { $_[0]->_AUTOLEXpeek('term__S_065INIT',$retree) }
sub term__S_065INIT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'INIT';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_065INIT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GINIT/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_066START (:$sym is context<rw> = 'START')
##      rule term:START   {<sym> <block> }

sub term__S_066START__PEEK { $_[0]->_AUTOLEXpeek('term__S_066START',$retree) }
sub term__S_066START {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'START';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_066START", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GSTART/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_067ENTER (:$sym is context<rw> = 'ENTER')
##      rule term:ENTER   {<sym> <block> }

sub term__S_067ENTER__PEEK { $_[0]->_AUTOLEXpeek('term__S_067ENTER',$retree) }
sub term__S_067ENTER {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ENTER';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_067ENTER", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GENTER/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_068FIRST (:$sym is context<rw> = 'FIRST')
##      rule term:FIRST   {<sym> <block> }

sub term__S_068FIRST__PEEK { $_[0]->_AUTOLEXpeek('term__S_068FIRST',$retree) }
sub term__S_068FIRST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'FIRST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_068FIRST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GFIRST/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule modifier_expr
##      rule modifier_expr { <EXPR> }

sub modifier_expr__PEEK { $_[0]->_AUTOLEXpeek('modifier_expr',$retree) }
sub modifier_expr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "modifier_expr", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_cond__S_069if (:$endsym is context = 'nofun', :$sym is context<rw> = 'if')
##      rule statement_mod_cond:if     {<sym> <modifier_expr> {*} }     #= if

sub statement_mod_cond__S_069if__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_069if',$retree) }
sub statement_mod_cond__S_069if {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'if';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_069if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond__S_069if_if'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_cond__S_070unless (:$endsym is context = 'nofun', :$sym is context<rw> = 'unless')
##      rule statement_mod_cond:unless {<sym> <modifier_expr> {*} }     #= unless

sub statement_mod_cond__S_070unless__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_070unless',$retree) }
sub statement_mod_cond__S_070unless {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'unless';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_070unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond__S_070unless_unless'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_cond__S_071when (:$endsym is context = 'nofun', :$sym is context<rw> = 'when')
##      rule statement_mod_cond:when   {<sym> <modifier_expr> {*} }     #= when

sub statement_mod_cond__S_071when__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_071when',$retree) }
sub statement_mod_cond__S_071when {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'when';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_071when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond__S_071when_when'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_loop__S_072while (:$endsym is context = 'nofun', :$sym is context<rw> = 'while')
##      rule statement_mod_loop:while {<sym> <modifier_expr> {*} }      #= while

sub statement_mod_loop__S_072while__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_072while',$retree) }
sub statement_mod_loop__S_072while {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'while';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_072while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_072while_while'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_loop__S_073until (:$endsym is context = 'nofun', :$sym is context<rw> = 'until')
##      rule statement_mod_loop:until {<sym> <modifier_expr> {*} }      #= until

sub statement_mod_loop__S_073until__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_073until',$retree) }
sub statement_mod_loop__S_073until {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'until';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_073until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_073until_until'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_loop__S_074for (:$endsym is context = 'nofun', :$sym is context<rw> = 'for')
##      rule statement_mod_loop:for   {<sym> <modifier_expr> {*} }      #= for

sub statement_mod_loop__S_074for__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_074for',$retree) }
sub statement_mod_loop__S_074for {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'for';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_074for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_074for_for'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_loop__S_075given (:$endsym is context = 'nofun', :$sym is context<rw> = 'given')
##      rule statement_mod_loop:given {<sym> <modifier_expr> {*} }      #= given

sub statement_mod_loop__S_075given__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_075given',$retree) }
sub statement_mod_loop__S_075given {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'given';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_075given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_075given_given'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token module_name__S_076normal (:$sym is context<rw> = 'normal')
##      token module_name:normal {
##          <longname>
##          [ :dba('generic role') <?{ ($+PKGDECL//'') eq 'role' }> '[' ~ ']' <signature> ]?
##      }

sub module_name__S_076normal__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_076normal',$retree) }
sub module_name__S_076normal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'normal';


my $C = $self;
my $S = $C->{_pos};
$C->{'signature'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "module_name__S_076normal", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'generic role')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
($::PKGDECL//'') eq 'role' 
})
}))
})
})
}, $C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
);
}

## token module_name__S_077deprecated (:$sym is context<rw> = 'deprecated')
##      token module_name:deprecated { 'v6-alpha' }

sub module_name__S_077deprecated__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_077deprecated',$retree) }
sub module_name__S_077deprecated {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'deprecated';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "module_name__S_077deprecated", 
$C->_EXACT('v6-alpha')
);
}

## token vnum
##      token vnum {
##          \d+ | '*'
##      }

sub vnum__PEEK { $_[0]->_AUTOLEXpeek('vnum',$retree) }
sub vnum {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "vnum", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'vnum_00') {
$C->deb("Fate passed to vnum_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'vnum_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("vnum_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token version__S_078v (:$sym is context<rw> = <v>)
##      token version:sym<v> {
##          'v' <?before \d> :: <vnum> ** '.' '+'?
##      }

sub version__S_078v__PEEK { $_[0]->_AUTOLEXpeek('version__S_078v',$retree) }
sub version__S_078v {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(v);


my $C = $self;
my $S = $C->{_pos};
$C->{'vnum'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "version__S_078v", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('+')
})
}, $C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('.')
}, sub { my $C=shift;
$C->_SUBSUME(['vnum'], sub {
my $C = shift;
$C->vnum
})
}))
}, $C->_COMMITBRANCH())
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
}))
}, $C->_EXACT('v'))
);
}

###################################################

## token PRE
##      token PRE {
##          :dba('prefix or meta-prefix')
##          [
##          | <prefix>
##              { $<O> = $<prefix><O>; $<sym> = $<prefix><sym> }
##                                                          {*}         #= prefix
##          | <prefix_circumfix_meta_operator>
##              { $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.text }
##                                                          {*}         #= precircum
##          ]
##          # XXX assuming no precedence change
##          
##          <prefix_postfix_meta_operator>*                 {*}         #= prepost
##          <.ws>
##      }

sub PRE__PEEK { $_[0]->_AUTOLEXpeek('PRE',$retree) }
sub PRE {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'prefix_postfix_meta_operator'} = [];

$self->_MATCHIFYr($S, "PRE", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'PRE_01') {
$C->deb("Fate passed to PRE_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'PRE_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("PRE_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix'], sub {
my $C = shift;
$C->prefix
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{O} = $M->{prefix}{O}; $M->{sym} = $M->{prefix}{sym} ;
}, $C))) {
$C->_REDUCE($S, 'PRE_prefix');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix_circumfix_meta_operator'], sub {
my $C = shift;
$C->prefix_circumfix_meta_operator
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{O} = $M->{prefix_circumfix_meta_operator}{O}; $M->{sym} = $M->{prefix_circumfix_meta_operator}->text ;
}, $C))) {
$C->_REDUCE($S, 'PRE_precircum');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['prefix_postfix_meta_operator'], sub {
my $C = shift;
$C->prefix_postfix_meta_operator
})
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'PRE_prepost'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# (for when you want to tell EXPR that infix already parsed the term)
## token nullterm
##      token nullterm {
##          <?>
##      }

sub nullterm__PEEK { $_[0]->_AUTOLEXpeek('nullterm',$retree) }
sub nullterm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nullterm", 
$C->before( sub { my $C=shift;
$C
})
);
}

## token nulltermish
##      token nulltermish {
##          :dba('null term')
##          [
##          | <?stdstopper>
##          | <termish>?
##          ]
##      }

sub nulltermish__PEEK { $_[0]->_AUTOLEXpeek('nulltermish',$retree) }
sub nulltermish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'termish'} = [];

$self->_MATCHIFYr($S, "nulltermish", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'nulltermish_01') {
$C->deb("Fate passed to nulltermish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'nulltermish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nulltermish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token termish
##      token termish {
##          :dba('prefix or noun')
##          [
##          | <PRE>+ <noun>
##          | <noun>
##          ]
##      
##          # also queue up any postfixes
##          :dba('postfix')
##          [ <?stdstopper> ||
##              <POST>*
##          ]
##      }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'PRE'} = [];
$C->{'POST'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'termish_01') {
$C->deb("Fate passed to termish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'termish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("termish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['PRE'], sub {
my $C = shift;
$C->PRE
})
}))) {
$C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->noun
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->noun
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
$C->stdstopper
})} 
or
eval { push @gather, $C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['POST'], sub {
my $C = shift;
$C->POST
})
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}

## token noun
##      token noun {
##          [
##          | <fatarrow>
##          | <variable>
##          | <package_declarator>
##          | <scope_declarator>
##          | <?before 'multi'|'proto'|'only'> <multi_declarator>
##          | <routine_declarator>
##          | <regex_declarator>
##          | <type_declarator>
##          | <circumfix>
##          | <dotty>
##          | <value>
##          | <capterm>
##          | <sigterm>
##          | <term>
##          | <statement_prefix>
##          | [ <colonpair> <.ws> ]+
##          ]
##      }

sub noun__PEEK { $_[0]->_AUTOLEXpeek('noun',$retree) }
sub noun {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "noun", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'noun_01') {
$C->deb("Fate passed to noun_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'noun_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("noun_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['fatarrow'], sub {
my $C = shift;
$C->fatarrow
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['scope_declarator'], sub {
my $C = shift;
$C->scope_declarator
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'noun_02') {
$C->deb("Fate passed to noun_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'noun_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("noun_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('multi')
},
sub { my $C=shift;
$C->_EXACT('proto')
},
sub { my $C=shift;
$C->_EXACT('only')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['capterm'], sub {
my $C = shift;
$C->capterm
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['statement_prefix'], sub {
my $C = shift;
$C->statement_prefix
})
},
sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}


## token fatarrow
##      token fatarrow {
##          <key=identifier> \h* '=>' <.ws> <val=EXPR(item %item_assignment)>
##      }

sub fatarrow__PEEK { $_[0]->_AUTOLEXpeek('fatarrow',$retree) }
sub fatarrow {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "fatarrow", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['key'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('=>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['val'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token colonpair
##      token colonpair {
##          :my $key;
##          :my $value;
##      
##          ':'
##          :dba('colon pair')
##          [
##          | '!' <identifier>
##              { $key = $<identifier>.text; $value = 0; }
##              {*}                                                     #= false
##          | $<num> = [\d+] <identifier>
##          | <identifier>
##              { $key = $<identifier>.text; }
##              [
##              || <.unsp>? '.'? <postcircumfix> { $value = $<postcircumfix>; }
##              || { $value = 1; }
##              ]
##              {*}                                                     #= value
##          | :dba('signature') '(' ~ ')' <signature>
##          | <postcircumfix>
##              { $key = ""; $value = $<postcircumfix>; }
##              {*}                                                     #= structural
##          | $<var> = (<sigil> {} <twigil>? <desigilname>)
##              { $key = $<var><desigilname>.text; $value = $<var>; }
##              {*}                                                     #= varname
##          ]
##          { $<k> = $key; $<v> = $value; }
##      }

sub colonpair__PEEK { $_[0]->_AUTOLEXpeek('colonpair',$retree) }
sub colonpair {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "colonpair", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{k} = $key; $M->{v} = $value; ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'colonpair_01') {
$C->deb("Fate passed to colonpair_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'colonpair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("colonpair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->text; $value = 0; ;
}, $C))) {
$C->_REDUCE($S, 'colonpair_false');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['num'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->text; ;
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('.')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{postcircumfix}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, scalar(do {
$value = 1; 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'colonpair_value');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'signature')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'colonpair_structural')
}, scalar(do {
my $M = $C;  $key = ""; $value = $M->{postcircumfix}; ;
}, $C))
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'colonpair_varname')
}, scalar(do {
my $M = $C;  $key = $M->{var}{desigilname}->text; $value = $M->{var}; ;
}, $C))
},     $C->_SUBSUME(['var'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
}, scalar(do {

}, $C))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
})}
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_EXACT(':'))
);
}

## token quotepair
##      token quotepair {
##          :my $key;
##          :my $value;
##      
##          ':'
##          :dba('colon pair (restricted)')
##          [
##          | '!' <identifier>
##              { $key = $<identifier>.text; $value = 0; }
##              {*}                                                     #= false
##          | <identifier>
##              { $key = $<identifier>.text; }
##              [
##              || <.unsp>? '.'? <?before '('> <postcircumfix> { $value = $<postcircumfix>; }
##              || { $value = 1; }
##              ]
##              {*}                                                     #= value
##          | $<n>=(\d+) $<id>=(<[a..z]>+)
##              { $key = $<id>.text; $value = $<n>.text; }
##              {*}                                                     #= nth
##          ]
##          { $<k> = $key; $<v> = $value; }
##      }

sub quotepair__PEEK { $_[0]->_AUTOLEXpeek('quotepair',$retree) }
sub quotepair {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quotepair", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quotepair_01') {
$C->deb("Fate passed to quotepair_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quotepair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quotepair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->text; $value = 0; ;
}, $C))) {
$C->_REDUCE($S, 'quotepair_false');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->text; ;
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('.')
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{postcircumfix}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, scalar(do {
$value = 1; 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'quotepair_value');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['n'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['id'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[a-z])++)/)
})}
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{id}->text; $value = $M->{n}->text; ;
}, $C))) {
$C->_REDUCE($S, 'quotepair_nth');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
my $M = $C;  $M->{k} = $key; $M->{v} = $value; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infixish
##      token infixish {
##          :my $infix;
##          <!stdstopper>
##          <!infixstopper>
##          :dba('infix or meta-infix')
##          [
##          | <colonpair> {
##                  $<fake> = 1;
##                  $<sym> = ':';
##                  %<O><prec> = %comma<prec>;  # actual test is non-inclusive of comma!
##                  %<O><assoc> = 'unary';
##                  %<O><uassoc> = 'left';
##              }
##          | '[' ~ ']' <infixish> { $<O> = $<infixish><O> }
##          | <infix_circumfix_meta_operator>
##              { $<O> = $<infix_circumfix_meta_operator><O>;
##                $<sym> = $<infix_circumfix_meta_operator><sym>; }
##          | <infix_prefix_meta_operator>
##              { $<O> = $<infix_prefix_meta_operator><O>;
##                $<sym> = $<infix_prefix_meta_operator><sym>; }
##          | <infix> <!before '='>
##                 { $<O> = $<infix>.<O>; $<sym> = $<infix>.<sym>; }
##          | <infix> <?before '='> <?{ $infix = $<infix>; }> <infix_postfix_meta_operator($infix)>
##                 { $<O> = $<infix_postfix_meta_operator>.<O>; $<sym> = $<infix_postfix_meta_operator>.<sym>; }
##          ]
##      }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $infix;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "infixish", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infixish_01') {
$C->deb("Fate passed to infixish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
scalar(do {
my $M = $C; 
$M->{fake} = 1;
$M->{sym} = ':';
$M->{O}{prec} = $comma{prec};  # actual test is non-inclusive of comma!
$M->{O}{assoc} = 'unary';
$M->{O}{uassoc} = 'left';
;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O} = $M->{infixish}{O} ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'infix or meta-infix')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['infixish'], sub {
my $C = shift;
$C->infixish
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O} = $M->{infix_circumfix_meta_operator}{O};
$M->{sym} = $M->{infix_circumfix_meta_operator}{sym}; ;
}, $C)
}, $C->_SUBSUME(['infix_circumfix_meta_operator'], sub {
my $C = shift;
$C->infix_circumfix_meta_operator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O} = $M->{infix_prefix_meta_operator}{O};
$M->{sym} = $M->{infix_prefix_meta_operator}{sym}; ;
}, $C)
}, $C->_SUBSUME(['infix_prefix_meta_operator'], sub {
my $C = shift;
$C->infix_prefix_meta_operator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O} = $M->{infix}->{'O'}; $M->{sym} = $M->{infix}->{'sym'}; ;
}, $C)
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('=')
})
}))
}, $C->_SUBSUME(['infix'], sub {
my $C = shift;
$C->infix
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O} = $M->{infix_postfix_meta_operator}->{'O'}; $M->{sym} = $M->{infix_postfix_meta_operator}->{'sym'}; ;
}, $C)
}, $C->_SUBSUME(['infix_postfix_meta_operator'], sub {
my $C = shift;
$C->infix_postfix_meta_operator($infix)
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $infix = $M->{infix}; ;
})
}))
}, $C->before(sub { my $C=shift;
$C->_EXACT('=')
}))
}, $C->_SUBSUME(['infix'], sub {
my $C = shift;
$C->infix
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))
);
}

# doing fancy as one rule simplifies LTM
## token dotty__S_079DotStar (:$endsym is context = 'unspacey'  , :$sym is context<rw> = <.*> --> Methodcall)
##      token dotty:sym<.*> ( --> Methodcall) {
##          ('.' [ <[+*?=]> | '^' '!'? ]) :: <.unspacey> <dottyop>
##          { $<sym> = $0.item; }
##      }

sub dotty__S_079DotStar__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_079DotStar',$retree) }
sub dotty__S_079DotStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'unspacey'  ;
local $sym = $args{sym} // q(.*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "dotty__S_079DotStar",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{sym} = $$C{0}->item; ;
}, $C)
}, $C->_SUBSUME(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))
}, $C->unspacey)
}, $C->_COMMITBRANCH())
},     $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'dotty__S_079DotStar_02') {
$C->deb("Fate passed to dotty__S_079DotStar_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dotty__S_079DotStar_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty__S_079DotStar_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G[+*?=]/)
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('^'))) {
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('!')
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
})}
}))
);
}

## token dotty__S_080Dot (:$endsym is context = 'unspacey'  , :$sym is context<rw> = <.> --> Methodcall)
##      token dotty:sym<.> ( --> Methodcall) {
##          <sym> <dottyop>
##      }

sub dotty__S_080Dot__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_080Dot',$retree) }
sub dotty__S_080Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'unspacey'  ;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "dotty__S_080Dot",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\./))) {
do {
if (my ($C) = ($C->unspacey)) {
$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token privop ( --> Methodcall)
##      token privop ( --> Methodcall) {
##          '!' <methodop>
##      }

sub privop__PEEK { $_[0]->_AUTOLEXpeek('privop',$retree) }
sub privop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "privop",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('!'))) {
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
});
}
else {
();
}
}
);
}

## token dottyop
##      token dottyop {
##          :dba('dotty method or postfix')
##          [
##          | <methodop>
##          | <colonpair>
##          | <!alpha> <postop> { $<O> = $<postop><O>; $<sym> = $<postop><sym>; }  # only non-alpha postfixes have dotty form
##          ]
##      }

sub dottyop__PEEK { $_[0]->_AUTOLEXpeek('dottyop',$retree) }
sub dottyop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "dottyop", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'dottyop_01') {
$C->deb("Fate passed to dottyop_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dottyop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dottyop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{postop}{O}; $M->{sym} = $M->{postop}{sym}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# Note, this rule mustn't do anything irreversible because it's used
# as a lookahead by the quote interpolator.

## token POST
##      token POST {
##          <!stdstopper>
##      
##          # last whitespace didn't end here
##          <!{ @+MEMOS[$.pos]<ws> }>
##      
##          [ <.unsp> | '\\' ]?
##      
##          [ ['.' <.unsp>?]? <postfix_prefix_meta_operator> <.unsp>? ]*
##      
##          :dba('postfix')
##          [
##          | <dotty>  { $<O> = $<dotty><O>; $<sym> = $<dotty><sym>; }
##          | <privop> { $<O> = $<privop><O>; $<sym> = $<privop><sym>; }
##          | <postop> { $<O> = $<postop><O>; $<sym> = $<postop><sym>; }
##          ]
##          { $+SIGIL = '@' }
##      }

sub POST__PEEK { $_[0]->_AUTOLEXpeek('POST',$retree) }
sub POST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'postfix_prefix_meta_operator'} = [];

$self->_MATCHIFYr($S, "POST", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$MEMOS[$C->{_pos}]{'ws'} 
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'POST_01') {
$C->deb("Fate passed to POST_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'POST_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
$C->_EXACT('\\')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix_prefix_meta_operator'], sub {
my $C = shift;
$C->postfix_prefix_meta_operator
}))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'POST_04') {
$C->deb("Fate passed to POST_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'POST_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{dotty}{O}; $M->{sym} = $M->{dotty}{sym}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['privop'], sub {
my $C = shift;
$C->privop
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{privop}{O}; $M->{sym} = $M->{privop}{sym}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{postop}{O}; $M->{sym} = $M->{postop}{sym}; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::SIGIL = '@' 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## regex prefix_circumfix_meta_operator__S_081reduce ( :$sym is context<rw> = 'reduce' --> List_prefix)
##      regex prefix_circumfix_meta_operator:reduce (--> List_prefix) {
##          <?before '['\S+']'>
##          $<s> = (
##              '['
##              [
##              | <op=infixish> ']' [''|<?>]
##              | \\<op=infixish> ']' [''|<?>]
##              ]
##          ) <?before <[ \s ( ]> >
##      
##          { $<O> = $<s><op><O>; $<sym> = $<s>.text; }
##      
##          [ <!{ $<O><assoc> eq 'non' }>
##              || <.panic: "Can't reduce a non-associative operator"> ]
##      
##          [ <!{ $<O><prec> eq %conditional<prec> }>
##              || <.panic: "Can't reduce a conditional operator"> ]
##      
##          { $<O><assoc> = 'unary'; $<O><uassoc> = 'left'; }
##      
##      }

sub prefix_circumfix_meta_operator__S_081reduce__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator__S_081reduce',$retree) }
sub prefix_circumfix_meta_operator__S_081reduce {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'reduce';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "prefix_circumfix_meta_operator__S_081reduce",  Cursor::lazymap sub { STD::List_prefix->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O}{assoc} = 'unary'; $M->{O}{uassoc} = 'left'; ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{prec} eq $conditional{prec} ;
})
})} 
or
eval { push @gather, $C->panic("Can't reduce a conditional operator")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{assoc} eq 'non' ;
})
})} 
or
eval { push @gather, $C->panic("Can't reduce a non-associative operator")} or do { die $@ if $@ };
@gather;
}
}))
}, scalar(do {
my $M = $C;  $M->{O} = $M->{s}{op}{O}; $M->{sym} = $M->{s}->text; ;
}, $C))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\s(]/)
}))
},     $C->_SUBSUME(['s'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_081reduce_03') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_081reduce_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_081reduce_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_081reduce_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_081reduce_04') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_081reduce_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_081reduce_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_081reduce_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_081reduce_05') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_081reduce_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_081reduce_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_081reduce_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish
}))
}, $C->_EXACT('\\'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('['))
})}
}))
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT(']')
}, $C->_PLUSg(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))
}, $C->_EXACT('['))
}))
);
}

## token prefix_postfix_meta_operator__S_082Fre (:$sym is context<rw> = <  >)
##      token prefix_postfix_meta_operator:sym<  >    { <sym> | '<<' }

sub prefix_postfix_meta_operator__S_082Fre__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator__S_082Fre',$retree) }
sub prefix_postfix_meta_operator__S_082Fre {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix_postfix_meta_operator__S_082Fre", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_postfix_meta_operator__S_082Fre_00') {
$C->deb("Fate passed to prefix_postfix_meta_operator__S_082Fre_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator__S_082Fre_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator__S_082Fre_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G/)
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token postfix_prefix_meta_operator__S_083Nch (:$sym is context<rw> = <  >)
##      token postfix_prefix_meta_operator:sym<  >    { <sym> | '>>' }

sub postfix_prefix_meta_operator__S_083Nch__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator__S_083Nch',$retree) }
sub postfix_prefix_meta_operator__S_083Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix_prefix_meta_operator__S_083Nch", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'postfix_prefix_meta_operator__S_083Nch_00') {
$C->deb("Fate passed to postfix_prefix_meta_operator__S_083Nch_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator__S_083Nch_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator__S_083Nch_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G/)
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token infix_prefix_meta_operator__S_084Bang (  :$sym is context<rw> = <!> --> Transparent)
##      token infix_prefix_meta_operator:sym<!> ( --> Transparent) {
##          <sym> <!before '!'> {} <infixish>
##      
##          <?{ $<O> = $<infixish><O>; }>
##      
##          [
##          || <?{ ($<O><returns> // '') eq 'Bool' }>
##          || <?{ $<infixish>.text eq '=' }>
##          || <.panic: "Only boolean infix operators may be negated">
##          ]
##      }

sub infix_prefix_meta_operator__S_084Bang__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_084Bang',$retree) }
sub infix_prefix_meta_operator__S_084Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_084Bang",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('!')
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
}))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infixish}{O}; ;
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  ($M->{O}{returns} // '') eq 'Bool' ;
})
})} 
or
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{infixish}->text eq '=' ;
})
})} 
or
eval { push @gather, $C->panic("Only boolean infix operators may be negated")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_prefix_meta_operator__S_085R (  :$sym is context<rw> = <R> --> Transparent)
##      token infix_prefix_meta_operator:sym<R> ( --> Transparent) {
##          <sym> {} <infixish>
##      
##          <?{ $<O> = $<infixish><O>; }>
##      
##      }

sub infix_prefix_meta_operator__S_085R__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_085R',$retree) }
sub infix_prefix_meta_operator__S_085R {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(R);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_085R",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\GR/))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infixish}{O}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

#method lex1 (Str $s) {
#    self.<O>{$s}++ and self.panic("Nested $s metaoperators not allowed");
#    self;
#}

## token infix_circumfix_meta_operator__S_086X (  :$sym is context<rw> = <X> --> List_infix)
##      token infix_circumfix_meta_operator:sym<X> ( --> List_infix) {
##          X {}
##          [ <infixish> X?  # XXX temporarily
##              <?{ $<O> = $<infixish>[0]<O>; }>
##          ]?
##      }

sub infix_circumfix_meta_operator__S_086X__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_086X',$retree) }
sub infix_circumfix_meta_operator__S_086X {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(X);


my $C = $self;
my $S = $C->{_pos};
$C->{'infixish'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_086X",  map { STD::List_infix->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('X'))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('X')
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infixish}[0]{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_circumfix_meta_operator__S_087Fre_Nch (  :$sym is context<rw> = < > --> Transparent)
##      token infix_circumfix_meta_operator:sym< > ( --> Transparent) {
##          [
##          | ''
##          | ''
##          ]
##          {} <infixish> [ '' | '' ]
##          <?{ $<O> := $<infixish><O>; }>
##      }

sub infix_circumfix_meta_operator__S_087Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_087Fre_Nch',$retree) }
sub infix_circumfix_meta_operator__S_087Fre_Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_087Fre_Nch",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_087Fre_Nch_01') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_087Fre_Nch_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_087Fre_Nch_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_087Fre_Nch_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_087Fre_Nch_02') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_087Fre_Nch_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_087Fre_Nch_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_087Fre_Nch_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infixish}{O}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_circumfix_meta_operator__S_088LtLt_GtGt (  :$sym is context<rw> = << >> --> Transparent)
##      token infix_circumfix_meta_operator:sym<< >> ( --> Transparent) {
##          [
##          | '<<'
##          | '>>'
##          ]
##          {} <infixish> [ '<<' | '>>' ]
##          <?{ $<O> := $<infixish><O>; }>
##      }

sub infix_circumfix_meta_operator__S_088LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_088LtLt_GtGt',$retree) }
sub infix_circumfix_meta_operator__S_088LtLt_GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_088LtLt_GtGt",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_088LtLt_GtGt_01') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_088LtLt_GtGt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_088LtLt_GtGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_088LtLt_GtGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_088LtLt_GtGt_02') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_088LtLt_GtGt_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_088LtLt_GtGt_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_088LtLt_GtGt_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infixish}{O}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_postfix_meta_operator__S_089Equal ($op  , :$sym is context<rw> = <=> --> Item_assignment)
##      token infix_postfix_meta_operator:sym<=> ($op --> Item_assignment) {
##          '='
##          { $<O> = $op<O>; }
##      
##          [ <?{ ($<O><assoc> // '') eq 'non'   }> <.panic: "Can't make assignment op out of non-associative operator"> ]?
##          [ <!{ $<O><assign> }> <.panic("Can't make assignment out of " ~ $<O><dba> ~ " operator")> ]?
##      }

sub infix_postfix_meta_operator__S_089Equal__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator__S_089Equal',$retree) }
sub infix_postfix_meta_operator__S_089Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $op = shift;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_postfix_meta_operator__S_089Equal",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{O} = $op->{O}; ;
}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  ($M->{O}{assoc} // '') eq 'non'   ;
})
}))) {
$C->panic("Can't make assignment op out of non-associative operator");
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{assign} ;
})
}))) {
do { my $M = $C;
$C->panic("Can't make assignment out of " . $M->{O}{dba} . " operator")
; };
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_090Paren_Thesis (  :$sym is context<rw> = <( )> --> Methodcall)
##      token postcircumfix:sym<( )> ( --> Methodcall)
##          { :dba('argument list') '(' ~ ')' <semilist> }

sub postcircumfix__S_090Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_090Paren_Thesis',$retree) }
sub postcircumfix__S_090Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_090Paren_Thesis",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

## token postcircumfix__S_091Bra_Ket (  :$sym is context<rw> = <[ ]> --> Methodcall)
##      token postcircumfix:sym<[ ]> ( --> Methodcall)
##          { :dba('subscript') '[' ~ ']' <semilist> }

sub postcircumfix__S_091Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_091Bra_Ket',$retree) }
sub postcircumfix__S_091Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_091Bra_Ket",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'subscript')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
);
}

## token postcircumfix__S_092Cur_Ly (  :$sym is context<rw> = <{ }> --> Methodcall)
##      token postcircumfix:sym<{ }> ( --> Methodcall)
##          { :dba('subscript') '{' ~ '}' <semilist> }

sub postcircumfix__S_092Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_092Cur_Ly',$retree) }
sub postcircumfix__S_092Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_092Cur_Ly",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}' , 'subscript')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
);
}

## token postcircumfix__S_093Lt_Gt (  :$sym is context<rw> = < > --> Methodcall)
##      token postcircumfix:sym< > ( --> Methodcall)
##          { '<' <nibble($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))> [ '>' || <.panic: "Unable to parse quote-words subscript; couldn't find right angle quote"> ] }

sub postcircumfix__S_093Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_093Lt_Gt',$retree) }
sub postcircumfix__S_093Lt_Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_093Lt_Gt",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>')} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_094LtLt_GtGt (  :$sym is context<rw> = << >> --> Methodcall)
##      token postcircumfix:sym<< >> ( --> Methodcall)
##          { '<<' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> [ '>>' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] }

sub postcircumfix__S_094LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_094LtLt_GtGt',$retree) }
sub postcircumfix__S_094LtLt_GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_094LtLt_GtGt",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>>')} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_095Fre_Nch (  :$sym is context<rw> = < > --> Methodcall)
##      token postcircumfix:sym< > ( --> Methodcall)
##          { '' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))> [ '' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] }

sub postcircumfix__S_095Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_095Fre_Nch',$retree) }
sub postcircumfix__S_095Fre_Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_095Fre_Nch",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('',''))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('')} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postop
##      token postop {
##          | <postfix>         { $<O> := $<postfix><O>; $<sym> := $<postfix><sym>; }
##          | <postcircumfix>   { $<O> := $<postcircumfix><O>; $<sym> := $<postcircumfix><sym>; }
##      }

sub postop__PEEK { $_[0]->_AUTOLEXpeek('postop',$retree) }
sub postop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "postop", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'postop_00') {
$C->deb("Fate passed to postop_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postop_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postop_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix'], sub {
my $C = shift;
$C->postfix
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{postfix}{O}; $M->{sym} = $M->{postfix}{sym}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{postcircumfix}{O}; $M->{sym} = $M->{postcircumfix}{sym}; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token methodop
##      token methodop {
##          [
##          | <longname>
##          | <?before '$' | '@' > <variable>
##          | <?before <[ ' " ]> > <quote>
##              { $<quote> ~~ /\W/ or $.panic("Useless use of quotes") }
##          ] <.unsp>? 
##      
##          :dba('method arguments')
##          [
##          | ':' <?before \s> <!{ $+inquote }> <arglist>
##          | <?[.(]> <args>
##          ]?
##      }

sub methodop__PEEK { $_[0]->_AUTOLEXpeek('methodop',$retree) }
sub methodop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'args'} = [];

$self->_MATCHIFYr($S, "methodop", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'methodop_01') {
$C->deb("Fate passed to methodop_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'methodop_02') {
$C->deb("Fate passed to methodop_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('$')
},
sub { my $C=shift;
$C->_EXACT('@')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G['"]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
}))) {
scalar(do {
my $M = $C;  $M->{quote} =~ qr/\W/ or $C->panic("Useless use of quotes") ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'methodop_04') {
$C->deb("Fate passed to methodop_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::inquote 
})
}))) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->_PATTERN(qr/\G[.(]/)
}))) {
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token semiarglist
##      token semiarglist {
##          <arglist> ** ';'
##          <.ws>
##      }

sub semiarglist__PEEK { $_[0]->_AUTOLEXpeek('semiarglist',$retree) }
sub semiarglist {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];

$self->_MATCHIFYr($S, "semiarglist", 
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(';')
}, sub { my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->ws;
}
else {
();
}
}
);
}

## token arglist
##      token arglist {
##          :my $inv_ok = $+INVOCANT_OK;
##          :my StrPos $endargs is context<rw> = 0;
##          :my $GOAL is context = 'endargs';
##          <.ws>
##          :dba('argument list')
##          [
##          | <?stdstopper>
##          | <EXPR(item %list_infix)> {{
##                  my $delims = $<EXPR><delims>;
##                  for @$delims {
##                      if ($_.<sym> // '') eq ':' {
##                          if $inv_ok {
##                              $+INVOCANT_IS = $<EXPR><list>[0];
##                          }
##                      }
##                  }
##              }}
##          ]
##      }

sub arglist__PEEK { $_[0]->_AUTOLEXpeek('arglist',$retree) }
sub arglist {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $inv_ok = $::INVOCANT_OK;
local $::endargs =  0;
local $::GOAL =  'endargs';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "arglist", 
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'arglist_01') {
$C->deb("Fate passed to arglist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'arglist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("arglist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%list_infix)
}))) {
scalar(do {
my $M = $C; 
my $delims = $M->{EXPR}{delims};
for (@$delims) {
if (($_->{'sym'} // '') eq ':') {
if ($inv_ok) {
$::INVOCANT_IS = $M->{EXPR}{list}[0];
}
}
}
;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token circumfix__S_096Cur_Ly (  :$sym is context<rw> = <{ }> --> Term)
##      token circumfix:sym<{ }> ( --> Term) {
##          <?before '{' | <lambda> > <pblock>
##      }

sub circumfix__S_096Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_096Cur_Ly',$retree) }
sub circumfix__S_096Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "circumfix__S_096Cur_Ly",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'circumfix__S_096Cur_Ly_01') {
$C->deb("Fate passed to circumfix__S_096Cur_Ly_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'circumfix__S_096Cur_Ly_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("circumfix__S_096Cur_Ly_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_SUBSUMEr(['lambda'], sub {
my $C = shift;
$C->lambda
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
});
}
else {
();
}
}
);
}

## token variable_declarator
##      token variable_declarator {
##          :my $IN_DECL is context<rw> = 1;
##          <variable>
##          { $IN_DECL = 0; }
##          [   # Is it a shaped array or hash declaration?
##            #  <?{ $<sigil> eq '@' | '%' }>
##              <.unsp>?
##              $<shape> = [
##              | '(' ~ ')' <signature>
##              | :dba('shape definition') '[' ~ ']' <semilist>
##              | :dba('shape definition') '{' ~ '}' <semilist>
##              | <?before '<'> <postcircumfix>
##              ]*
##          ]?
##          <.ws>
##      
##          <trait>*
##      
##          <post_constraint>*
##      }

sub variable_declarator__PEEK { $_[0]->_AUTOLEXpeek('variable_declarator',$retree) }
sub variable_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];
$C->{'signature'} = [];
$C->{'post_constraint'} = [];
$C->{'shape'} = [];
$C->{'postcircumfix'} = [];
$C->{'semilist'} = [];

$self->_MATCHIFY($S, "variable_declarator", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
})
}, $C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
}))
}, $C->ws)
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['shape'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_declarator_02') {
$C->deb("Fate passed to variable_declarator_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_declarator_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_declarator_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'variable_declarator')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'shape definition')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}' , 'shape definition')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
}, $C->before(sub { my $C=shift;
$C->_EXACT('<')
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
})
}))
}, scalar(do {
$IN_DECL = 0; 
}, $C))
}, $C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))
);
}

## rule scoped
##      rule scoped {
##          :dba('scoped declarator')
##          [
##          | <declarator>
##          | <regex_declarator>
##          | <package_declarator>
##          | <fulltypename>+ <multi_declarator>
##          | <multi_declarator>
##      #    | <?before <[A..Z]> > <name> <.panic("Apparent type name " ~ $<name>.text ~ " is not declared yet")>
##          ]
##      }

sub scoped__PEEK { $_[0]->_AUTOLEXpeek('scoped',$retree) }
sub scoped {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'fulltypename'} = [];

$self->_MATCHIFYr($S, "scoped", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'scoped_01') {
$C->deb("Fate passed to scoped_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'scoped_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scoped_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token scope_declarator__S_097my (:$endsym is context = 'nofun', :$sym is context<rw> = 'my')
##      token scope_declarator:my       { <sym> <scoped> }

sub scope_declarator__S_097my__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_097my',$retree) }
sub scope_declarator__S_097my {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'my';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_097my", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmy/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_098our (:$endsym is context = 'nofun', :$sym is context<rw> = 'our')
##      token scope_declarator:our      { <sym> <scoped> }

sub scope_declarator__S_098our__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_098our',$retree) }
sub scope_declarator__S_098our {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'our';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_098our", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gour/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_099state (:$endsym is context = 'nofun', :$sym is context<rw> = 'state')
##      token scope_declarator:state    { <sym> <scoped> }

sub scope_declarator__S_099state__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_099state',$retree) }
sub scope_declarator__S_099state {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'state';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_099state", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gstate/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_100constant (:$endsym is context = 'nofun', :$sym is context<rw> = 'constant')
##      token scope_declarator:constant { <sym> <scoped> }

sub scope_declarator__S_100constant__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_100constant',$retree) }
sub scope_declarator__S_100constant {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'constant';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_100constant", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gconstant/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_101has (:$endsym is context = 'nofun', :$sym is context<rw> = 'has')
##      token scope_declarator:has      { <sym> <scoped> }

sub scope_declarator__S_101has__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_101has',$retree) }
sub scope_declarator__S_101has {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'has';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_101has", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghas/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
}
);
}


## token package_declarator__S_102class (:$sym is context<rw> = 'class')
##      token package_declarator:class {
##          :my $PKGDECL is context = 'class';
##          <sym> <package_def>
##      }

sub package_declarator__S_102class__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_102class',$retree) }
sub package_declarator__S_102class {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'class';
local $::PKGDECL =  'class';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_102class", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gclass/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_103grammar (:$sym is context<rw> = 'grammar')
##      token package_declarator:grammar {
##          :my $PKGDECL is context = 'grammar';
##          <sym> <package_def>
##      }

sub package_declarator__S_103grammar__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_103grammar',$retree) }
sub package_declarator__S_103grammar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'grammar';
local $::PKGDECL =  'grammar';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_103grammar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggrammar/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_104module (:$sym is context<rw> = 'module')
##      token package_declarator:module {
##          :my $PKGDECL is context = 'module';
##          <sym> <package_def>
##      }

sub package_declarator__S_104module__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_104module',$retree) }
sub package_declarator__S_104module {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'module';
local $::PKGDECL =  'module';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_104module", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmodule/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_105package (:$sym is context<rw> = 'package')
##      token package_declarator:package {
##          :my $PKGDECL is context = 'package';
##          <sym> <package_def>
##      }

sub package_declarator__S_105package__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_105package',$retree) }
sub package_declarator__S_105package {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'package';
local $::PKGDECL =  'package';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_105package", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gpackage/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_106role (:$sym is context<rw> = 'role')
##      token package_declarator:role {
##          :my $PKGDECL is context = 'role';
##          <sym> <package_def>
##      }

sub package_declarator__S_106role__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_106role',$retree) }
sub package_declarator__S_106role {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'role';
local $::PKGDECL =  'role';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_106role", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grole/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_107knowhow (:$sym is context<rw> = 'knowhow')
##      token package_declarator:knowhow {
##          :my $PKGDECL is context = 'knowhow';
##          <sym> <package_def>
##      }

sub package_declarator__S_107knowhow__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_107knowhow',$retree) }
sub package_declarator__S_107knowhow {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'knowhow';
local $::PKGDECL =  'knowhow';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_107knowhow", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gknowhow/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_108require (:$sym is context<rw> = 'require')
##      token package_declarator:require {   # here because of declarational aspects
##          <sym> <.ws>
##          [
##          || <module_name> <EXPR>?
##          || <EXPR>
##          ]
##      }

sub package_declarator__S_108require__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_108require',$retree) }
sub package_declarator__S_108require {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'require';


my $C = $self;
my $S = $C->{_pos};
$C->{'EXPR'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_108require", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grequire/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
});
}
else {
();
}
}} 
or
eval { push @gather, $C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_109trusts (:$sym is context<rw> = 'trusts')
##      token package_declarator:trusts {
##          <sym> <.ws>
##          <module_name>
##      }

sub package_declarator__S_109trusts__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_109trusts',$retree) }
sub package_declarator__S_109trusts {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'trusts';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_109trusts", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtrusts/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_110does (:$sym is context<rw> = 'does')
##      token package_declarator:does {
##          <sym> <.ws>
##          <typename>
##      }

sub package_declarator__S_110does__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_110does',$retree) }
sub package_declarator__S_110does {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'does';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_110does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule package_def
##      rule package_def {
##          :my $longname;
##          [
##              <module_name>{
##                  $longname = $<module_name>[0]<longname>;
##                  $.add_type($longname.text);
##              }
##          ]?
##          <trait>*
##          [
##             <?before '{'>
##             {{
##                 # figure out the actual full package name (nested in outer package)
##                  my $pkg = $+PKG // "GLOBAL";
##                  push @PKGS, $pkg;
##                  if $longname {
##                      my $shortname = $longname.<name>.text;
##                      $+PKG = $pkg ~ '::' ~ $shortname;
##                  }
##                  else {
##                      $+PKG = $pkg ~ '::_anon_';
##                  }
##              }}
##              <block>
##              {{
##                  $+PKG = pop(@PKGS);
##              }}
##              {*}                                                     #= block
##          || <?{ $+begin_compunit }> {} <?before ';'>
##              {
##                  $longname orelse $.panic("Compilation unit cannot be anonymous");
##                  my $shortname = $longname.<name>.text;
##                  $+PKG = $shortname;
##                  $+begin_compunit = 0;
##              }
##              {*}                                                     #= semi
##          || <.panic: "Unable to parse " ~ $+PKGDECL ~ " definition">
##          ]
##      }

sub package_def__PEEK { $_[0]->_AUTOLEXpeek('package_def',$retree) }
sub package_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $longname;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];
$C->{'module_name'} = [];

$self->_MATCHIFYr($S, "package_def", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$longname = $M->{module_name}[0]{'longname'};
$C->add_type($longname->text);
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

# figure out the actual full package name (nested in outer package)
my $pkg = $::PKG // "GLOBAL";
push @PKGS, $pkg;
if ($longname) {
my $shortname = $longname->{'name'}->text;
$::PKG = $pkg . '::' . $shortname;
}
else {
$::PKG = $pkg . '::_anon_';
}

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

$::PKG = pop(@PKGS);

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'package_def_block'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::begin_compunit 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(';')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

$longname or $C->panic("Compilation unit cannot be anonymous");
my $shortname = $longname->{'name'}->text;
$::PKG = $shortname;
$::begin_compunit = 0;

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'package_def_semi'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Unable to parse " . $::PKGDECL . " definition"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token declarator
##      token declarator {
##          [
##          | <variable_declarator>
##          | '(' ~ ')' <signature> <trait>*
##          | <routine_declarator>
##          | <regex_declarator>
##          | <type_declarator>
##          ]
##      }

sub declarator__PEEK { $_[0]->_AUTOLEXpeek('declarator',$retree) }
sub declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];

$self->_MATCHIFY($S, "declarator", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'declarator_01') {
$C->deb("Fate passed to declarator_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'declarator_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("declarator_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['variable_declarator'], sub {
my $C = shift;
$C->variable_declarator
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
})
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'declarator')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
$C->_SUBSUME(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
},
sub { my $C=shift;
$C->_SUBSUME(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub { my $C=shift;
$C->_SUBSUME(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token multi_declarator__S_111multi (:$sym is context<rw> = 'multi')
##      token multi_declarator:multi { <sym> <.ws> [ <declarator> || <routine_def> ] }

sub multi_declarator__S_111multi__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_111multi',$retree) }
sub multi_declarator__S_111multi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'multi';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_111multi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmulti/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_112proto (:$sym is context<rw> = 'proto')
##      token multi_declarator:proto { <sym> <.ws> [ <declarator> || <routine_def> ] }

sub multi_declarator__S_112proto__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_112proto',$retree) }
sub multi_declarator__S_112proto {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'proto';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_112proto", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gproto/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_113only (:$sym is context<rw> = 'only')
##      token multi_declarator:only  { <sym> <.ws> [ <declarator> || <routine_def> ] }

sub multi_declarator__S_113only__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_113only',$retree) }
sub multi_declarator__S_113only {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'only';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_113only", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gonly/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_114null (:$sym is context<rw> = 'null')
##      token multi_declarator:null  { <declarator> }

sub multi_declarator__S_114null__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_114null',$retree) }
sub multi_declarator__S_114null {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'null';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_114null", 
$C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
);
}

## token routine_declarator__S_115sub (:$sym is context<rw> = 'sub')
##      token routine_declarator:sub       { <sym> <routine_def> }

sub routine_declarator__S_115sub__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_115sub',$retree) }
sub routine_declarator__S_115sub {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sub';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_115sub", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsub/))) {
$C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
});
}
else {
();
}
}
);
}
## token routine_declarator__S_116method (:$sym is context<rw> = 'method')
##      token routine_declarator:method    { <sym> <method_def> }

sub routine_declarator__S_116method__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_116method',$retree) }
sub routine_declarator__S_116method {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'method';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_116method", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmethod/))) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
}
);
}
## token routine_declarator__S_117submethod (:$sym is context<rw> = 'submethod')
##      token routine_declarator:submethod { <sym> <method_def> }

sub routine_declarator__S_117submethod__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_117submethod',$retree) }
sub routine_declarator__S_117submethod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'submethod';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_117submethod", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubmethod/))) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
}
);
}
## token routine_declarator__S_118macro (:$sym is context<rw> = 'macro')
##      token routine_declarator:macro     { <sym> <macro_def> }

sub routine_declarator__S_118macro__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_118macro',$retree) }
sub routine_declarator__S_118macro {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'macro';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_118macro", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmacro/))) {
$C->_SUBSUMEr(['macro_def'], sub {
my $C = shift;
$C->macro_def
});
}
else {
();
}
}
);
}

## token regex_declarator__S_119regex (:$sym is context<rw> = 'regex')
##      token regex_declarator:regex { <sym>       <regex_def> }

sub regex_declarator__S_119regex__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_119regex',$retree) }
sub regex_declarator__S_119regex {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'regex';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_119regex", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gregex/))) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
}
);
}
## token regex_declarator__S_120token (:$sym is context<rw> = 'token')
##      token regex_declarator:token { <sym>       <regex_def> }

sub regex_declarator__S_120token__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_120token',$retree) }
sub regex_declarator__S_120token {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'token';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_120token", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtoken/))) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
}
);
}
## token regex_declarator__S_121rule (:$sym is context<rw> = 'rule')
##      token regex_declarator:rule  { <sym>       <regex_def> }

sub regex_declarator__S_121rule__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_121rule',$retree) }
sub regex_declarator__S_121rule {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rule';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_121rule", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grule/))) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
}
);
}

# Most of these special variable rules are there simply to catch old p5 brainos

## token special_variable__S_122Dollar_a2_ (:$sym is context<rw> = <$>)
##      token special_variable:sym<$> { <sym> }

sub special_variable__S_122Dollar_a2___PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_122Dollar_a2_',$retree) }
sub special_variable__S_122Dollar_a2_ {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_122Dollar_a2_", 
$C->_PATTERN(qr/\G\$/)
);
}

## token special_variable__S_123DollarBang (:$sym is context<rw> = <$!>)
##      token special_variable:sym<$!> { <sym> <!before \w> }

sub special_variable__S_123DollarBang__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_123DollarBang',$retree) }
sub special_variable__S_123DollarBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_123DollarBang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\!/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
});
}
else {
();
}
}
);
}

## token special_variable__S_124DollarBangCur_Ly (:$sym is context<rw> = <$!{ }>)
##      token special_variable:sym<$!{ }> {
##          # XXX the backslashes are necessary here for bootstrapping, not for P6...
##          ( '$!{' :: (.*?) '}' )
##          <.obs($0.text ~ " variable", 'smart match against $!')>
##      }

sub special_variable__S_124DollarBangCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_124DollarBangCur_Ly',$retree) }
sub special_variable__S_124DollarBangCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($!{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_124DollarBangCur_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
$C->obs($$C{0}->text . " variable", 'smart match against $!')
},     $C->_SUBSUME(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('$!{'))
})}
}))
);
}

## token special_variable__S_125DollarSlash (:$sym is context<rw> = <$/>)
##      token special_variable:sym<$/> {
##          <sym>
##          # XXX assuming nobody ever wants to assign $/ directly anymore...
##          [ <?before \h* '=' <![=]> >
##              <.obs('$/ variable as input record separator',
##                   "filehandle's :irs attribute")>
##          ]?
##      }

sub special_variable__S_125DollarSlash__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_125DollarSlash',$retree) }
sub special_variable__S_125DollarSlash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($/);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_125DollarSlash", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\//))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[=]/)
});
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->obs('$/ variable as input record separator',
"filehandle's :irs attribute");
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token special_variable__S_126DollarTilde (:$sym is context<rw> = <$~>)
##      token special_variable:sym<$~> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$~ variable', 'Form module')>
##      }

sub special_variable__S_126DollarTilde__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_126DollarTilde',$retree) }
sub special_variable__S_126DollarTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_126DollarTilde", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$~ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_126DollarTilde_01') {
$C->deb("Fate passed to special_variable__S_126DollarTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_126DollarTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_126DollarTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\~/))
);
}

## token special_variable__S_127DollarGrave (:$sym is context<rw> = <$`>)
##      token special_variable:sym<$`> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$` variable', 'explicit pattern before <(')>
##      }

sub special_variable__S_127DollarGrave__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_127DollarGrave',$retree) }
sub special_variable__S_127DollarGrave {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($`);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_127DollarGrave", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$` variable', 'explicit pattern before <(')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_127DollarGrave_01') {
$C->deb("Fate passed to special_variable__S_127DollarGrave_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_127DollarGrave_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_127DollarGrave_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\`/))
);
}

## token special_variable__S_128DollarAt (:$sym is context<rw> = <$@>)
##      token special_variable:sym<$@> {
##          <sym> ::
##          <.obs('$@ variable as eval error', '$!')>
##      }

sub special_variable__S_128DollarAt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_128DollarAt',$retree) }
sub special_variable__S_128DollarAt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_128DollarAt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$@ variable as eval error', '$!')
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\@/))
);
}

## token special_variable__S_129DollarSharp (:$sym is context<rw> = <$#>)
##      token special_variable:sym<$#> {
##          <sym> ::
##          [
##          || (\w+) <.obs("\$#" ~ $0.text ~ " variable", "\@\{" ~ $0.text ~ "}.end")>
##          || <.obs('$# variable', '.fmt')>
##          ]
##      }

sub special_variable__S_129DollarSharp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_129DollarSharp',$retree) }
sub special_variable__S_129DollarSharp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($#);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_129DollarSharp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->obs("\$#" . $$C{0}->text . " variable", "\@\{" . $$C{0}->text . "}.end")
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))} 
or
eval { push @gather, $C->obs('$# variable', '.fmt')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\#/))
);
}
## token special_variable__S_130DollarDollar (:$sym is context<rw> = <$$>)
##      token special_variable:sym<$$> {
##          <sym> <!alpha> :: <?before \s | ',' | <terminator> >
##          <.obs('$$ variable', '$*PID')>
##      }

sub special_variable__S_130DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_130DollarDollar',$retree) }
sub special_variable__S_130DollarDollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($$);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_130DollarDollar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$$ variable', '$*PID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_130DollarDollar_01') {
$C->deb("Fate passed to special_variable__S_130DollarDollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_130DollarDollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_130DollarDollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))
}, $C->_PATTERN(qr/\G\$\$/))
);
}
## token special_variable__S_131DollarPercent (:$sym is context<rw> = <$%>)
##      token special_variable:sym<$%> {
##          <sym> ::
##          <.obs('$% variable', 'Form module')>
##      }

sub special_variable__S_131DollarPercent__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_131DollarPercent',$retree) }
sub special_variable__S_131DollarPercent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_131DollarPercent", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$% variable', 'Form module')
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\%/))
);
}

# Note: this works because placeholders are restricted to lowercase
## token special_variable__S_132DollarCaretX (:$sym is context<rw> = <$^X>)
##      token special_variable:sym<$^X> {
##          <sigil> '^' $<letter> = [<[A..Z]>] \W
##          <.obscaret($<sigil>.text ~ '^' ~ $<letter>.text, $<sigil>, $<letter>.text)>
##      }

sub special_variable__S_132DollarCaretX__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_132DollarCaretX',$retree) }
sub special_variable__S_132DollarCaretX {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($^X);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_132DollarCaretX", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_EXACT('^'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['letter'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) {
do { my $M = $C;
$C->obscaret($M->{sigil}->text . '^' . $M->{letter}->text, $M->{sigil}, $M->{letter}->text)
; };
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token special_variable__S_133DollarCaret (:$sym is context<rw> = <$^>)
##      token special_variable:sym<$^> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$^ variable', 'Form module')>
##      }

sub special_variable__S_133DollarCaret__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_133DollarCaret',$retree) }
sub special_variable__S_133DollarCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_133DollarCaret", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$^ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_133DollarCaret_01') {
$C->deb("Fate passed to special_variable__S_133DollarCaret_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_133DollarCaret_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_133DollarCaret_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\^/))
);
}

## token special_variable__S_134DollarAmp (:$sym is context<rw> = <$&>)
##      token special_variable:sym<$&> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$& variable', '$/ or $()')>
##      }

sub special_variable__S_134DollarAmp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_134DollarAmp',$retree) }
sub special_variable__S_134DollarAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_134DollarAmp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$& variable', '$/ or $()')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_134DollarAmp_01') {
$C->deb("Fate passed to special_variable__S_134DollarAmp_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_134DollarAmp_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_134DollarAmp_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\&/))
);
}

## token special_variable__S_135DollarStar (:$sym is context<rw> = <$*>)
##      token special_variable:sym<$*> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$* variable', '^^ and $$')>
##      }

sub special_variable__S_135DollarStar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_135DollarStar',$retree) }
sub special_variable__S_135DollarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_135DollarStar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$* variable', '^^ and $$')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_135DollarStar_01') {
$C->deb("Fate passed to special_variable__S_135DollarStar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_135DollarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_135DollarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\*/))
);
}

## token special_variable__S_136DollarThesis (:$sym is context<rw> = <$)>)
##      token special_variable:sym<$)> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$) variable', '$*EGID')>
##      }

sub special_variable__S_136DollarThesis__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_136DollarThesis',$retree) }
sub special_variable__S_136DollarThesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[$)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_136DollarThesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$) variable', '$*EGID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_136DollarThesis_01') {
$C->deb("Fate passed to special_variable__S_136DollarThesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_136DollarThesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_136DollarThesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\)/))
);
}

## token special_variable__S_137DollarMinus (:$sym is context<rw> = <$->)
##      token special_variable:sym<$-> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$- variable', 'Form module')>
##      }

sub special_variable__S_137DollarMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_137DollarMinus',$retree) }
sub special_variable__S_137DollarMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_137DollarMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$- variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_137DollarMinus_01') {
$C->deb("Fate passed to special_variable__S_137DollarMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_137DollarMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_137DollarMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\-/))
);
}

## token special_variable__S_138DollarEqual (:$sym is context<rw> = <$=>)
##      token special_variable:sym<$=> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$= variable', 'Form module')>
##      }

sub special_variable__S_138DollarEqual__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_138DollarEqual',$retree) }
sub special_variable__S_138DollarEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_138DollarEqual", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$= variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_138DollarEqual_01') {
$C->deb("Fate passed to special_variable__S_138DollarEqual_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_138DollarEqual_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_138DollarEqual_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\=/))
);
}

## token special_variable__S_139AtPlus (:$sym is context<rw> = <@+>)
##      token special_variable:sym<@+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_139AtPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_139AtPlus',$retree) }
sub special_variable__S_139AtPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_139AtPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('@+ variable', '.to method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_139AtPlus_01') {
$C->deb("Fate passed to special_variable__S_139AtPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_139AtPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_139AtPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\@\+/))
);
}

## token special_variable__S_140PercentPlus (:$sym is context<rw> = <%+>)
##      token special_variable:sym<%+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('%+ variable', '.to method')>
##      }

sub special_variable__S_140PercentPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_140PercentPlus',$retree) }
sub special_variable__S_140PercentPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_140PercentPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('%+ variable', '.to method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_140PercentPlus_01') {
$C->deb("Fate passed to special_variable__S_140PercentPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_140PercentPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_140PercentPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\%\+/))
);
}

## token special_variable__S_141DollarPlusBra_Ket (:$sym is context<rw> = <$+[ ]>)
##      token special_variable:sym<$+[ ]> {
##          '$+['
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_141DollarPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_141DollarPlusBra_Ket',$retree) }
sub special_variable__S_141DollarPlusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($+[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_141DollarPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$+['))) {
$C->obs('@+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_142AtPlusBra_Ket (:$sym is context<rw> = <@+[ ]>)
##      token special_variable:sym<@+[ ]> {
##          '@+['
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_142AtPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_142AtPlusBra_Ket',$retree) }
sub special_variable__S_142AtPlusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@+[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_142AtPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@+['))) {
$C->obs('@+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_143AtPlusCur_Ly (:$sym is context<rw> = <@+{ }>)
##      token special_variable:sym<@+{ }> {
##          '@+{'
##          <.obs('%+ variable', '.to method')>
##      }

sub special_variable__S_143AtPlusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_143AtPlusCur_Ly',$retree) }
sub special_variable__S_143AtPlusCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@+{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_143AtPlusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@+{'))) {
$C->obs('%+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_144AtMinus (:$sym is context<rw> = <@->)
##      token special_variable:sym<@-> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_144AtMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_144AtMinus',$retree) }
sub special_variable__S_144AtMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_144AtMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('@- variable', '.from method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_144AtMinus_01') {
$C->deb("Fate passed to special_variable__S_144AtMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_144AtMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_144AtMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\@\-/))
);
}

## token special_variable__S_145PercentMinus (:$sym is context<rw> = <%->)
##      token special_variable:sym<%-> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('%- variable', '.from method')>
##      }

sub special_variable__S_145PercentMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_145PercentMinus',$retree) }
sub special_variable__S_145PercentMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_145PercentMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('%- variable', '.from method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_145PercentMinus_01') {
$C->deb("Fate passed to special_variable__S_145PercentMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_145PercentMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_145PercentMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\%\-/))
);
}

## token special_variable__S_146DollarMinusBra_Ket (:$sym is context<rw> = <$-[ ]>)
##      token special_variable:sym<$-[ ]> {
##          '$-['
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_146DollarMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_146DollarMinusBra_Ket',$retree) }
sub special_variable__S_146DollarMinusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($-[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_146DollarMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$-['))) {
$C->obs('@- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_147AtMinusBra_Ket (:$sym is context<rw> = <@-[ ]>)
##      token special_variable:sym<@-[ ]> {
##          '@-['
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_147AtMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_147AtMinusBra_Ket',$retree) }
sub special_variable__S_147AtMinusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@-[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_147AtMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@-['))) {
$C->obs('@- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_148PercentMinusCur_Ly (:$sym is context<rw> = <%-{ }>)
##      token special_variable:sym<%-{ }> {
##          '@-{'
##          <.obs('%- variable', '.from method')>
##      }

sub special_variable__S_148PercentMinusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_148PercentMinusCur_Ly',$retree) }
sub special_variable__S_148PercentMinusCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(%-{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_148PercentMinusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@-{'))) {
$C->obs('%- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_149DollarPlus (:$sym is context<rw> = <$+>)
##      token special_variable:sym<$+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$+ variable', 'Form module')>
##      }

sub special_variable__S_149DollarPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_149DollarPlus',$retree) }
sub special_variable__S_149DollarPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_149DollarPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$+ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_149DollarPlus_01') {
$C->deb("Fate passed to special_variable__S_149DollarPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_149DollarPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_149DollarPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\+/))
);
}

## token special_variable__S_150DollarCurCaret_Ly (:$sym is context<rw> = <${^ }>)
##      token special_variable:sym<${^ }> {
##          ( <sigil> '{^' :: (.*?) '}' )
##          <.obscaret($0.text, $<sigil>, $0.{0}.text)>
##      }

sub special_variable__S_150DollarCurCaret_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_150DollarCurCaret_Ly',$retree) }
sub special_variable__S_150DollarCurCaret_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(${^ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_150DollarCurCaret_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
do { my $M = $C;
$C->obscaret($$C{0}->text, $M->{sigil}, $$C{0}.{0}->text)
; }
},     $C->_SUBSUME(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{^'))
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
})}
}))
);
}

# XXX should eventually rely on multi instead of nested cases here...
## method obscaret (Str $var, Str $sigil, Str $name)
sub obscaret {
my $self = shift;
my $var = shift;
my $sigil = shift;
my $name = shift;


my $repl = do { do { my $_ = $sigil; if ((0)) {}
elsif ($_ eq '$') {
do { my $_ = $name; if ((0)) {}
elsif ($_ eq 'MATCH') { '$/' }
elsif ($_ eq 'PREMATCH') { 'an explicit pattern before <(' }
elsif ($_ eq 'POSTMATCH') { 'an explicit pattern after )>' }
elsif ($_ eq 'ENCODING') { '$?ENCODING' }
elsif ($_ eq 'UNICODE') { '$?UNICODE' }  # XXX ???
elsif ($_ eq 'TAINT') { '$*TAINT' }
elsif ($_ eq 'OPEN') { 'filehandle introspection' }
elsif ($_ eq 'N') { '$-1' } # XXX ???
elsif ($_ eq 'L') { 'Form module' }
elsif ($_ eq 'A') { 'Form module' }
elsif ($_ eq 'E') { '$!.extended_os_error' }
elsif ($_ eq 'C') { 'COMPILING namespace' }
elsif ($_ eq 'D') { '$*DEBUGGING' }
elsif ($_ eq 'F') { '$*SYSTEM_FD_MAX' }
elsif ($_ eq 'H') { '$?FOO variables' }
elsif ($_ eq 'I') { '$*INPLACE' } # XXX ???
elsif ($_ eq 'O') { '$?OS or $*OS' }
elsif ($_ eq 'P') { 'whatever debugger Perl 6 comes with' }
elsif ($_ eq 'R') { 'an explicit result variable' }
elsif ($_ eq 'S') { 'the context function' } # XXX ???
elsif ($_ eq 'T') { '$*BASETIME' }
elsif ($_ eq 'V') { '$*PERL_VERSION' }
elsif ($_ eq 'W') { '$*WARNING' }
elsif ($_ eq 'X') { '$*EXECUTABLE_NAME' }
else { "a global form such as $sigil*$name" }
};
}
elsif ($_ eq '%') {
do { my $_ = $name; if ((0)) {}
elsif ($_ eq 'H') { '$?FOO variables' }
else { "a global form such as $sigil*$name" }
};
}
else { "a global form such as $sigil*$name" }
};
};
return $self->obs("$var variable", $repl);
}

## token special_variable__S_151ColonColonCur_Ly (:$sym is context<rw> = <::{ }>)
##      token special_variable:sym<::{ }> {
##          '::' <?before '{'>
##      }

sub special_variable__S_151ColonColonCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_151ColonColonCur_Ly',$retree) }
sub special_variable__S_151ColonColonCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(::{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_151ColonColonCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('::'))) {
$C->before(sub { my $C=shift;
$C->_EXACT('{')
});
}
else {
();
}
}
);
}

## token special_variable__S_152DollarCur_Ly (:$sym is context<rw> = <${ }>)
##      token special_variable:sym<${ }> {
##          ( <[$@%]> '{' :: (.*?) '}' )
##          <.obs("" ~ $0.text ~ " variable", "\{" ~ $<sigil>.text ~ "}(" ~ $0.{0}.text ~ ")")>
##      }

sub special_variable__S_152DollarCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_152DollarCur_Ly',$retree) }
sub special_variable__S_152DollarCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(${ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_152DollarCur_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
do { my $M = $C;
$C->obs("" . $$C{0}->text . " variable", "\{" . $M->{sigil}->text . "}(" . $$C{0}.{0}->text . ")")
; }
},     $C->_SUBSUME(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
}, $C->_PATTERN(qr/\G[$@%]/))
})}
}))
);
}

## token special_variable__S_153DollarBra (:$sym is context<rw> = <$[>)
##      token special_variable:sym<$[> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$[ variable', 'user-defined array indices')>
##      }

sub special_variable__S_153DollarBra__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_153DollarBra',$retree) }
sub special_variable__S_153DollarBra {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($[);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_153DollarBra", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$[ variable', 'user-defined array indices')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_153DollarBra_01') {
$C->deb("Fate passed to special_variable__S_153DollarBra_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_153DollarBra_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_153DollarBra_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\[/))
);
}

## token special_variable__S_154DollarKet (:$sym is context<rw> = <$]>)
##      token special_variable:sym<$]> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$] variable', '$*PERL_VERSION')>
##      }

sub special_variable__S_154DollarKet__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_154DollarKet',$retree) }
sub special_variable__S_154DollarKet {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($]);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_154DollarKet", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$] variable', '$*PERL_VERSION')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_154DollarKet_01') {
$C->deb("Fate passed to special_variable__S_154DollarKet_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_154DollarKet_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_154DollarKet_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\]/))
);
}

## token special_variable__S_155DollarBack (:$sym is context<rw> = <$\\>)
##      token special_variable:sym<$\\> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$\\ variable', "the filehandle's :ors attribute")>
##      }

sub special_variable__S_155DollarBack__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_155DollarBack',$retree) }
sub special_variable__S_155DollarBack {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_155DollarBack", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$\\ variable', "the filehandle's :ors attribute")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_155DollarBack_01') {
$C->deb("Fate passed to special_variable__S_155DollarBack_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_155DollarBack_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_155DollarBack_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\\/))
);
}

## token special_variable__S_156DollarVert (:$sym is context<rw> = <$|>)
##      token special_variable:sym<$|> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$| variable', 'Form module')>
##      }

sub special_variable__S_156DollarVert__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_156DollarVert',$retree) }
sub special_variable__S_156DollarVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_156DollarVert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$| variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_156DollarVert_01') {
$C->deb("Fate passed to special_variable__S_156DollarVert_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_156DollarVert_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_156DollarVert_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\|/))
);
}

## token special_variable__S_157DollarColon (:$sym is context<rw> = <$:>)
##      token special_variable:sym<$:> {
##          <sym> <?before <[\x20\t\n\],=)}]> >
##          <.obs('$: variable', 'Form module')>
##      }

sub special_variable__S_157DollarColon__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_157DollarColon',$retree) }
sub special_variable__S_157DollarColon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_157DollarColon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\:/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\n\],=)}]/)
}))) {
$C->obs('$: variable', 'Form module');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token special_variable__S_158DollarSemi (:$sym is context<rw> = <$;>)
##      token special_variable:sym<$;> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$; variable', 'real multidimensional hashes')>
##      }

sub special_variable__S_158DollarSemi__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_158DollarSemi',$retree) }
sub special_variable__S_158DollarSemi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($;);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_158DollarSemi", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$; variable', 'real multidimensional hashes')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_158DollarSemi_01') {
$C->deb("Fate passed to special_variable__S_158DollarSemi_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_158DollarSemi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_158DollarSemi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\;/))
);
}

## token special_variable__S_159DollarSingle (:$sym is context<rw> = <$'>)
##      token special_variable:sym<$'> { #'
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")>
##      }

sub special_variable__S_159DollarSingle__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_159DollarSingle',$retree) }
sub special_variable__S_159DollarSingle {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($');


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_159DollarSingle", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$' . "'" . 'variable', "explicit pattern after )\x3E")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_159DollarSingle_01') {
$C->deb("Fate passed to special_variable__S_159DollarSingle_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_159DollarSingle_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_159DollarSingle_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\'/))
);
}

## token special_variable__S_160DollarDouble (:$sym is context<rw> = <$">)
##      token special_variable:sym<$"> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$" variable', '.join() method')>
##      }

sub special_variable__S_160DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_160DollarDouble',$retree) }
sub special_variable__S_160DollarDouble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($");


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_160DollarDouble", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$" variable', '.join() method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_160DollarDouble_01') {
$C->deb("Fate passed to special_variable__S_160DollarDouble_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_160DollarDouble_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_160DollarDouble_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\"/))
);
}

## token special_variable__S_161DollarComma (:$sym is context<rw> = <$,>)
##      token special_variable:sym<$,> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$, variable', ".join() method")>
##      }

sub special_variable__S_161DollarComma__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_161DollarComma',$retree) }
sub special_variable__S_161DollarComma {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[$,];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_161DollarComma", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$, variable', ".join() method")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_161DollarComma_01') {
$C->deb("Fate passed to special_variable__S_161DollarComma_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_161DollarComma_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_161DollarComma_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\,/))
);
}

## token special_variable__S_162DollarLt (:$sym is context<rw> = ['$<'])
##      token special_variable:sym['$<'] {
##          <sym> :: <!before \s* \w+ \s* '>' >
##          <.obs('$< variable', '$*UID')>
##      }

sub special_variable__S_162DollarLt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_162DollarLt',$retree) }
sub special_variable__S_162DollarLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // ['$<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_162DollarLt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$< variable', '$*UID')
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('>')
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
}, $C->_PATTERN(qr/\G((?:\w)++)/))
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
})
}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\[\'\$\<\'\]/))
);
}

## token special_variable__S_163DollarGt (:$sym is context<rw> = \$>)
##      token special_variable:sym\$> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs("$() variable", '$*EUID')>
##      }

sub special_variable__S_163DollarGt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_163DollarGt',$retree) }
sub special_variable__S_163DollarGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['\$>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_163DollarGt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs("$() variable", '$*EUID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_163DollarGt_01') {
$C->deb("Fate passed to special_variable__S_163DollarGt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_163DollarGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_163DollarGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\>/))
);
}

## token special_variable__S_164DollarDot (:$sym is context<rw> = <$.>)
##      token special_variable:sym<$.> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$. variable', "filehandle's .line method")>
##      }

sub special_variable__S_164DollarDot__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_164DollarDot',$retree) }
sub special_variable__S_164DollarDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_164DollarDot", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$. variable', "filehandle's .line method")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_164DollarDot_01') {
$C->deb("Fate passed to special_variable__S_164DollarDot_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_164DollarDot_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_164DollarDot_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\./))
);
}

## token special_variable__S_165DollarQuestion (:$sym is context<rw> = <$?>)
##      token special_variable:sym<$?> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$? variable as child error', '$!')>
##      }

sub special_variable__S_165DollarQuestion__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_165DollarQuestion',$retree) }
sub special_variable__S_165DollarQuestion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_165DollarQuestion", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$? variable as child error', '$!')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_165DollarQuestion_01') {
$C->deb("Fate passed to special_variable__S_165DollarQuestion_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_165DollarQuestion_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_165DollarQuestion_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\?/))
);
}

# desigilname should only follow a sigil/twigil

## token desigilname
##      token desigilname {
##          [
##          | <?before '$' > <variable>
##          | <longname>
##          ]
##      }

sub desigilname__PEEK { $_[0]->_AUTOLEXpeek('desigilname',$retree) }
sub desigilname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "desigilname", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'desigilname_01') {
$C->deb("Fate passed to desigilname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'desigilname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("desigilname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token variable
##      token variable {
##          <?before <sigil> { $+SIGIL ||= $<sigil>.text } > {}
##          [
##          || '&'
##              [
##              | <twigil>?  <sublongname> {*}                                   #= subnoun
##              | '[' ~ ']' <infixish>
##              ]
##          || <?before '$::('> '$' <name>?
##          || '$::' <name>? # XXX
##          || '$:' <name>? # XXX
##          || [
##              | <sigil> <twigil>? <desigilname> {*}                                    #= desigilname
##                  [ <?{ my $t = $<twigil>; @$t and $t.[0].text eq '.' }>
##                      <.unsp>? <?before '('> <postcircumfix> {*}          #= methcall
##                  ]?
##              | <special_variable> {*}                                    #= special
##              | <sigil> $<index>=[\d+] {*}                                #= $0
##              # Note: $() can also parse as contextualizer in an expression; should have same effect
##              | <sigil> <?before '<' | '('> <postcircumfix> {*}           #= $()
##              | <sigil> <?{ $+IN_DECL }> {*}                              #= anondecl
##              ]
##          ]
##      }

sub variable__PEEK { $_[0]->_AUTOLEXpeek('variable',$retree) }
sub variable {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'name'} = [];
$C->{'twigil'} = [];
$C->{'postcircumfix'} = [];

$self->_MATCHIFY($S, "variable", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_03') {
$C->deb("Fate passed to variable_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['sublongname'], sub {
my $C = shift;
$C->sublongname
}))) {
$C->_REDUCE($S, 'variable_subnoun');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'variable')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['infixish'], sub {
my $C = shift;
$C->infixish
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('&'))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->name
})
})
}, $C->_EXACT('$'))
}, $C->before(sub { my $C=shift;
$C->_EXACT('$::(')
}))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->name
})
})
}, $C->_EXACT('$::'))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->name
})
})
}, $C->_EXACT('$:'))} 
or
eval { push @gather, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_09') {
$C->deb("Fate passed to variable_09: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_09', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_09 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable_methcall')
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->before(sub { my $C=shift;
$C->_EXACT('(')
}))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  my $t = $M->{twigil}; @$t and $t->[0]->text eq '.' ;
})
}))
})
})
}, $C->_REDUCE($S, 'variable_desigilname'))
}, $C->_SUBSUME(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable_special')
}, $C->_SUBSUME(['special_variable'], sub {
my $C = shift;
$C->special_variable
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable_$$C{0}')
},     $C->_SUBSUME(['index'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable_$()')
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_13') {
$C->deb("Fate passed to variable_13: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_13', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_13 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable_anondecl')
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::IN_DECL 
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} or do { die $@ if $@ };
@gather;
}
})
}, scalar(do {

}, $C))
}, $C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
scalar(do {
my $M = $C;  $::SIGIL ||= $M->{sigil}->text ;
}, $C);
}
else {
();
}
}
}))
);
}

# Note, don't reduce on a bare sigil unless you don't want a twigil or
# you otherwise don't care what the longest token is.

## token sigil__S_166Dollar (:$sym is context<rw> = <$>)
##      token sigil:sym<$>  { <sym> }

sub sigil__S_166Dollar__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_166Dollar',$retree) }
sub sigil__S_166Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_166Dollar", 
$C->_PATTERN(qr/\G\$/)
);
}
## token sigil__S_167AtAt (:$sym is context<rw> = <@@>)
##      token sigil:sym<@@> { <sym> }

sub sigil__S_167AtAt__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_167AtAt',$retree) }
sub sigil__S_167AtAt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_167AtAt", 
$C->_PATTERN(qr/\G\@\@/)
);
}
## token sigil__S_168At (:$sym is context<rw> = <@>)
##      token sigil:sym<@>  { <sym> }

sub sigil__S_168At__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_168At',$retree) }
sub sigil__S_168At {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_168At", 
$C->_PATTERN(qr/\G\@/)
);
}
## token sigil__S_169Percent (:$sym is context<rw> = <%>)
##      token sigil:sym<%>  { <sym> }

sub sigil__S_169Percent__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_169Percent',$retree) }
sub sigil__S_169Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_169Percent", 
$C->_PATTERN(qr/\G\%/)
);
}
## token sigil__S_170Amp (:$sym is context<rw> = <&>)
##      token sigil:sym<&>  { <sym> }

sub sigil__S_170Amp__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_170Amp',$retree) }
sub sigil__S_170Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_170Amp", 
$C->_PATTERN(qr/\G\&/)
);
}

## token twigil__S_171Dot (:$sym is context<rw> = <.>)
##      token twigil:sym<.> { <sym> }

sub twigil__S_171Dot__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_171Dot',$retree) }
sub twigil__S_171Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_171Dot", 
$C->_PATTERN(qr/\G\./)
);
}
## token twigil__S_172Bang (:$sym is context<rw> = <!>)
##      token twigil:sym<!> { <sym> }

sub twigil__S_172Bang__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_172Bang',$retree) }
sub twigil__S_172Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_172Bang", 
$C->_PATTERN(qr/\G\!/)
);
}
## token twigil__S_173Caret (:$sym is context<rw> = <^>)
##      token twigil:sym<^> { <sym> }

sub twigil__S_173Caret__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_173Caret',$retree) }
sub twigil__S_173Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_173Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
## token twigil__S_174Colon (:$sym is context<rw> = <:>)
##      token twigil:sym<:> { <sym> <!before ':'> }

sub twigil__S_174Colon__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_174Colon',$retree) }
sub twigil__S_174Colon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_174Colon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(':')
})
});
}
else {
();
}
}
);
}
## token twigil__S_175Star (:$sym is context<rw> = <*>)
##      token twigil:sym<*> { <sym> }

sub twigil__S_175Star__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_175Star',$retree) }
sub twigil__S_175Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_175Star", 
$C->_PATTERN(qr/\G\*/)
);
}
## token twigil__S_176Plus (:$sym is context<rw> = <+>)
##      token twigil:sym<+> { <sym> }

sub twigil__S_176Plus__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_176Plus',$retree) }
sub twigil__S_176Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_176Plus", 
$C->_PATTERN(qr/\G\+/)
);
}
## token twigil__S_177Question (:$sym is context<rw> = <?>)
##      token twigil:sym<?> { <sym> }

sub twigil__S_177Question__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_177Question',$retree) }
sub twigil__S_177Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_177Question", 
$C->_PATTERN(qr/\G\?/)
);
}
## token twigil__S_178Equal (:$sym is context<rw> = <=>)
##      token twigil:sym<=> { <sym> }

sub twigil__S_178Equal__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_178Equal',$retree) }
sub twigil__S_178Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_178Equal", 
$C->_PATTERN(qr/\G\=/)
);
}

## token deflongname
##      token deflongname {
##          :dba('name to be defined')
##          <name>
##          # XXX too soon
##          [ <colonpair>+ { $.add_macro($<name>) if $+IN_DECL; } ]?
##          { $.add_routine($<name>.text) if $+IN_DECL; }
##      }

sub deflongname__PEEK { $_[0]->_AUTOLEXpeek('deflongname',$retree) }
sub deflongname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "deflongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{name}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C;  $C->add_routine($M->{name}->text) if $::IN_DECL; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token longname
##      token longname {
##          <name> <colonpair>*
##      }

sub longname__PEEK { $_[0]->_AUTOLEXpeek('longname',$retree) }
sub longname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "longname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
});
}
else {
();
}
}
);
}

## token name
##      token name {
##          [
##          | <identifier> <morename>*
##          | <morename>+
##          ]
##      }

sub name__PEEK { $_[0]->_AUTOLEXpeek('name',$retree) }
sub name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'morename'} = [];

$self->_MATCHIFYr($S, "name", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'name_01') {
$C->deb("Fate passed to name_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'name_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("name_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token morename
##      token morename {
##          '::'
##          [
##              <?before '(' | <alpha> >
##              [
##              | <identifier>
##              | :dba('indirect name') '(' ~ ')' <EXPR>
##              ]
##          ]?
##      }

sub morename__PEEK { $_[0]->_AUTOLEXpeek('morename',$retree) }
sub morename {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'identifier'} = [];
$C->{'EXPR'} = [];

$self->_MATCHIFY($S, "morename", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'morename_03') {
$C->deb("Fate passed to morename_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'indirect name')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'morename_02') {
$C->deb("Fate passed to morename_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
})
})
}, $C->_EXACT('::'))
);
}

## token subshortname
##      token subshortname {
##          [
##          | <category>
##              [ <colonpair>+ { $.add_macro($<category>) if $+IN_DECL; } ]?
##          | <desigilname> { $.add_routine($<desigilname>.text) if $+IN_DECL; }
##          ]
##      }

sub subshortname__PEEK { $_[0]->_AUTOLEXpeek('subshortname',$retree) }
sub subshortname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "subshortname", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'subshortname_01') {
$C->deb("Fate passed to subshortname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'subshortname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("subshortname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{category}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))) {
scalar(do {
my $M = $C;  $C->add_routine($M->{desigilname}->text) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token sublongname
##      token sublongname {
##          <subshortname> <sigterm>?
##      }

sub sublongname__PEEK { $_[0]->_AUTOLEXpeek('sublongname',$retree) }
sub sublongname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'sigterm'} = [];

$self->_MATCHIFYr($S, "sublongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['subshortname'], sub {
my $C = shift;
$C->subshortname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
});
}
else {
();
}
}
);
}

#token subcall {
#    # XXX should this be sublongname?
#    <subshortname> <.unsp>? '.'? '(' ~ ')' <semilist>
#    {*}
#}

#token packagevar {
#    # Note: any ::() are handled within <name>, and subscript must be final part.
#    # A bare ::($foo) is not considered a variable, but ::($foo)::<$bar> is.
#    # (The point being that we want a sigil either first or last but not both.)
#    <?before [\w+] ** '::' [ '<' | '' | '{' ]> ::
#    <name> '::' <postcircumfix> {*}                            #= FOO::<$x>
#}

## token value
##      token value {
##          [
##          | <quote>
##          | <number>
##          | <version>
##      #    | <packagevar>     # XXX see term:name for now
##      #    | <fulltypename>   # XXX see term:name for now
##          ]
##      }

sub value__PEEK { $_[0]->_AUTOLEXpeek('value',$retree) }
sub value {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "value", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'value_01') {
$C->deb("Fate passed to value_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'value_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("value_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token typename
##      token typename {
##          [
##          | '::?'<identifier>                 # parse ::?CLASS as special case
##          | <longname>
##            <?{{
##              my $longname = $<longname>.text;
##              if substr($longname, 0, 2) eq '::' {
##                  $.add_type(substr($longname, 2));
##              }
##              else {
##                  $.is_type($longname)
##              }
##            }}>
##          ]
##          # parametric type?
##          <.unsp>? [ <?before '['> <postcircumfix> ]?
##      }

sub typename__PEEK { $_[0]->_AUTOLEXpeek('typename',$retree) }
sub typename {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'postcircumfix'} = [];

$self->_MATCHIFYr($S, "typename", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'typename_01') {
$C->deb("Fate passed to typename_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'typename_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("typename_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
my $longname = $M->{longname}->text;
if (substr($longname, 0, 2) eq '::') {
$C->add_type(substr($longname, 2));
}
else {
$C->is_type($longname)
}
;
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule fulltypename
##      rule fulltypename {<typename>['|'<typename>]*
##          [ of <fulltypename> ]?
##      }

sub fulltypename__PEEK { $_[0]->_AUTOLEXpeek('fulltypename',$retree) }
sub fulltypename {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'typename'} = [];
$C->{'fulltypename'} = [];

$self->_MATCHIFYr($S, "fulltypename", 
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('of'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token number
##      token number {
##          [
##          | <dec_number>
##          | <integer>
##          | <rad_number>
##          ]
##      }

sub number__PEEK { $_[0]->_AUTOLEXpeek('number',$retree) }
sub number {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "number", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'number_01') {
$C->deb("Fate passed to number_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'number_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("number_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['dec_number'], sub {
my $C = shift;
$C->dec_number
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token integer
##      token integer {
##          [
##          | 0 [ b <[01]>+           [ _ <[01]>+ ]*
##              | o <[0..7]>+         [ _ <[0..7]>+ ]*
##              | x <[0..9a..fA..F]>+ [ _ <[0..9a..fA..F]>+ ]*
##              | d \d+               [ _ \d+]*
##              | \d+[_\d+]*
##                  { $.worry("Leading 0 does not indicate octal in Perl 6") }
##              ]
##          | \d+[_\d+]*
##          ]
##      }

sub integer__PEEK { $_[0]->_AUTOLEXpeek('integer',$retree) }
sub integer {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "integer", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'integer_01') {
$C->deb("Fate passed to integer_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'integer_02') {
$C->deb("Fate passed to integer_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('b'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[01])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[01])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('o'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-7])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-7])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('x'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('d'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
}))) {
scalar(do {
$C->worry("Leading 0 does not indicate octal in Perl 6") 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token radint
##      token radint {
##          [
##          | <integer>
##          | <?before ':'> <rad_number> <?{
##                              defined $<rad_number><intpart>
##                              and
##                              not defined $<rad_number><fracpart>
##                          }>
##          ]
##      }

sub radint__PEEK { $_[0]->_AUTOLEXpeek('radint',$retree) }
sub radint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "radint", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'radint_01') {
$C->deb("Fate passed to radint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'radint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("radint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
defined $M->{rad_number}{intpart}
and
not defined $M->{rad_number}{fracpart}
;
})
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token escale
##      token escale {
##          <[Ee]> <[+\-]>? \d+[_\d+]*
##      }

sub escale__PEEK { $_[0]->_AUTOLEXpeek('escale',$retree) }
sub escale {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "escale", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[Ee]/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[+\-])?+)/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# careful to distinguish from both integer and 42.method
## token dec_number
##      token dec_number {
##          :dba('decimal number')
##          [
##          | $<coeff> = [           '.' \d+[_\d+]* ] <escale>?
##          | $<coeff> = [\d+[_\d+]* '.' \d+[_\d+]* ] <escale>?
##          | $<coeff> = [\d+[_\d+]*                ] <escale>
##          ]
##      }

sub dec_number__PEEK { $_[0]->_AUTOLEXpeek('dec_number',$retree) }
sub dec_number {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'escale'} = [];

$self->_MATCHIFYr($S, "dec_number", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'dec_number_01') {
$C->deb("Fate passed to dec_number_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dec_number_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dec_number_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
})
}))) {
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token rad_number
##      token rad_number {
##          ':' $<radix> = [\d+] <.unsp>?      # XXX optional dot here?
##          {}           # don't recurse in lexer
##          :dba('number in radix notation')
##          [
##          || '<'
##                  $<intpart> = [ <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]
##                  $<fracpart> = [ '.' <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]?
##                  [ '*' <base=radint> '**' <exp=radint> ]?
##             '>'
##      #      { make radcalc($<radix>, $<intpart>, $<fracpart>, $<base>, $<exp>) }
##          || <?before '['> <postcircumfix>
##          || <?before '('> <postcircumfix>
##          ]
##      }

sub rad_number__PEEK { $_[0]->_AUTOLEXpeek('rad_number',$retree) }
sub rad_number {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'exp'} = [];
$C->{'base'} = [];

$self->_MATCHIFYr($S, "rad_number", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['radix'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['intpart'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['fracpart'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
})
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['base'], sub {
my $C = shift;
$C->radint
}))) {
do {
if (my ($C) = ($C->_EXACT('**'))) {
$C->_SUBSUMEr(['exp'], sub {
my $C = shift;
$C->radint
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token octint
##      token octint {
##          <[ 0..7 ]>+ [ _ <[ 0..7 ]>+ ]*
##      }

sub octint__PEEK { $_[0]->_AUTOLEXpeek('octint',$retree) }
sub octint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "octint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-7])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-7])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token hexint
##      token hexint {
##          <[ 0..9 a..f A..F ]>+ [ _ <[ 0..9 a..f A..F ]>+ ]*
##      }

sub hexint__PEEK { $_[0]->_AUTOLEXpeek('hexint',$retree) }
sub hexint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "hexint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

our @herestub_queue;

{ package STD::Herestub;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_has 'delim' => (is => 'rw');    moose_has 'orignode' => (is => 'rw');    moose_has 'lang' => (is => 'rw');} ## end class

{ package STD::herestop;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##     token stopper
##          token stopper { ^^ {*} $<ws>=(\h*?) $+DELIM \h* <.unv>?? $$ \v? }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "stopper", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G((?:[\n])?+)/)
}, $C->_PATTERN(qr/\G(?m:$)/))
}, $C->_OPTf(sub { my $C=shift;
$C->unv
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_EXACT($::DELIM))
},     $C->_SUBSUME(['ws'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
})
})}
}))
}, $C->_REDUCE($S, 'stopper'))
}, $C->_PATTERN(qr/\G(?m:^)/))
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        text: "^^"
      - !!perl/hash:RE_method_internal 
        args: $S, 'stopper'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 0
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: stopper
              i: 0
              min: 1
              r: 1
              s: 0
              text: \h
            min: 0
            quant: 
              - "*"
              - "?"
              - ''
              - 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        var: ws
      - !!perl/hash:RE_var 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        var: $+DELIM
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: stopper
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: stopper
          i: 0
          min: 12345
          name: unv
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - "?"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        text: $$
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: stopper
          i: 0
          min: 1
          r: 1
          s: 0
          text: \v
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
RETREE_END
}
} ## end role

# XXX be sure to temporize @herestub_queue on reentry to new line of heredocs

## method heredoc ()
sub heredoc {
my $self = shift;


local $CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
return if $self->peek;
my $here = $self;
while (my $herestub = shift @herestub_queue) {
local $::DELIM =  $herestub->delim;
my $lang = $herestub->lang->mixin( 'STD::herestop' );
my $doc;
if (($doc) = $here->nibble($lang)) {
$here = $doc->trim_heredoc();
$herestub->orignode->{doc} = $doc;
}
else {
$self->panic("Ending delimiter $DELIM not found");
}
}
return $self->cursor($here->{_pos});  # return to initial type
}

#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}

#proto token escape { <...> }
sub escape__PEEK { $_[0]->_AUTOLEXpeek('escape:*',$retree); }
sub escape {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'escape') {
$C->deb("Fate passed to escape: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'escape:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "escape", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}

## token starter
##      token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
## token escape__S_179none (:$sym is context<rw> = 'none')
##      token escape:none { <!> }

sub escape__S_179none__PEEK { $_[0]->_AUTOLEXpeek('escape__S_179none',$retree) }
sub escape__S_179none {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'none';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_179none", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

## token babble ($l)
##      token babble ($l) {
##          :my $lang = $l;
##          :my $start;
##          :my $stop;
##      
##          <.ws>
##          [ <quotepair> <.ws>
##              {
##                  my $kv = $<quotepair>[*-1];
##                  $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                      or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##              }
##          ]*
##      
##          {
##              ($start,$stop) = $.peek_delimiters();
##              $lang = $start ne $stop ?? $lang.balanced($start,$stop)
##                                      !! $lang.unbalanced($stop);
##              $<B> = [$lang,$start,$stop];
##          }
##      }

sub babble__PEEK { $_[0]->_AUTOLEXpeek('babble',$retree) }
sub babble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang = $l;
my $start;
my $stop;


my $C = $self;
my $S = $C->{_pos};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "babble", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{quotepair}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
($start,$stop) = $C->peek_delimiters();
$lang = $start ne $stop ? $lang->balanced($start,$stop)
: $lang->unbalanced($stop);
$M->{B} = [$lang,$start,$stop];
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quibble ($l)
##      token quibble ($l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <nibble($lang)> $stop
##      
##          {{
##              if $lang<_herelang> {
##                  push @herestub_queue,
##                      STD::Herestub.new(
##                          delim => $<nibble><nibbles>[0],
##                          orignode => $,
##                          lang => $lang<_herelang>,
##                      );
##              }
##          }}
##      }

sub quibble__PEEK { $_[0]->_AUTOLEXpeek('quibble',$retree) }
sub quibble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
scalar(do {
my $M = $C; 
if ($lang->{_herelang}) {
push @herestub_queue,
STD::Herestub->new(
delim => $M->{nibble}{nibbles}[0],
orignode => $C,
lang => $lang->{_herelang},
);
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token sibble ($l, $lang2)
##      token sibble ($l, $lang2) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <left=nibble($lang)> $stop 
##          [ <?{ $start ne $stop }>
##              <.ws>
##              [ '=' || <.panic: "Missing '='"> ]
##              <.ws>
##              <right=EXPR(item %item_assignment)>
##          || 
##              { $lang = $lang2.unbalanced($stop); }
##              <right=nibble($lang)> $stop
##          ]
##      }

sub sibble__PEEK { $_[0]->_AUTOLEXpeek('sibble',$retree) }
sub sibble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "sibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('=')} 
or
eval { push @gather, $C->panic("Missing '='")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token tribble ($l, $lang2 = $l)
##      token tribble ($l, $lang2 = $l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <left=nibble($lang)> $stop 
##          [ <?{ $start ne $stop }>
##              <.ws> <quibble($lang2)>
##          || 
##              { $lang = $lang2.unbalanced($stop); }
##              <right=nibble($lang)> $stop
##          ]
##      }

sub tribble__PEEK { $_[0]->_AUTOLEXpeek('tribble',$retree) }
sub tribble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift() // $l;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "tribble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($lang2)
});
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quasiquibble ($l)
##      token quasiquibble ($l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          [
##          || <?{ $start eq '{' }> [ :lang($lang) <block> ]
##          || $start [ :lang($lang) <statementlist> ] $stop
##          ]
##      }

sub quasiquibble__PEEK { $_[0]->_AUTOLEXpeek('quasiquibble',$retree) }
sub quasiquibble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quasiquibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start eq '{' 
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
});
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# note: polymorphic over many quote languages, we hope
## token nibbler
##      token nibbler {
##          :my $text = '';
##          :my @nibbles = ();
##          :my $multiline = 0;
##          :my $nibble;
##          { $<firstpos> = self.pos; }
##          [ <!before <stopper> >
##              [
##              || <starter> <nibbler> <stopper>
##                              {
##                                  my $n = $<nibbler>[*-1]<nibbles>;
##                                  my @n = @$n;
##                                  $text ~= $<starter>[*-1].text ~ shift(@n);
##                                  $text = (@n ?? pop(@n) !! '') ~ $<stopper>[*-1].text;
##                                  push @nibbles, @n;
##                              }
##              || <escape>   {
##                                  push @nibbles, $text, $<escape>[*-1];
##                                  $text = '';
##                              }
##              || .
##                              {{
##                                  my $ch = substr($ORIG, $.pos-1, 1);
##                                  $text ~= $ch;
##                                  if $ch ~~ "\n" {
##                                      $multiline++;
##                                  }
##                              }}
##              ]
##          ]*
##          {
##              push @nibbles, $text; $<nibbles> = [@nibbles];
##              $<lastpos> = $.pos;
##              $<nibbler> :delete;
##              $<escape> :delete;
##              $COMPILING::LAST_NIBBLE = $;
##              $COMPILING::LAST_NIBBLE_MULTILINE = $ if $multiline;
##          }
##      }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $text = '';
my @nibbles = ();
my $multiline = 0;
my $nibble;


my $C = $self;
my $S = $C->{_pos};
$C->{'nibbler'} = [];
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'escape'} = [];

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{firstpos} = $self->{_pos}; ;
}, $C))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
scalar(do {
my $M = $C; 
my $n = $M->{nibbler}[-1]{'nibbles'};
my @n = @$n;
$text .= $M->{starter}[-1]->text . shift(@n);
$text = (@n ? pop(@n) : '') . $M->{stopper}[-1]->text;
push @nibbles, @n;
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['escape'], sub {
my $C = shift;
$C->escape
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $text, $M->{escape}[-1];
$text = '';
;
}, $C);
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_PATTERN(qr/\G(?s:.)/))) {
scalar(do {

my $ch = substr($ORIG, $C->{_pos}-1, 1);
$text .= $ch;
if ($ch =~ "\n") {
$multiline++;
}

}, $C);
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $text; $M->{nibbles} = [@nibbles];
$M->{lastpos} = $C->{_pos};
delete $M->{nibbler};
delete $M->{escape};
$COMPILING::LAST_NIBBLE = $C;
$COMPILING::LAST_NIBBLE_MULTILINE = $C if $multiline;
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

# and this is what makes nibbler polymorphic...
## method nibble ($lang)
sub nibble {
my $self = shift;
my $lang = shift;


my $outerlang = (ref($self)||$self);
local $::LANG =  $outerlang;
$self->cursor_fresh($lang)->nibbler;
}


## token quote__S_180Single_Single (:$sym is context<rw> = <' '>)
##      token quote:sym<' '>   { "'" <nibble($.cursor_fresh( ::STD::Q ).tweak(:q).unbalanced("'"))> "'" }

sub quote__S_180Single_Single__PEEK { $_[0]->_AUTOLEXpeek('quote__S_180Single_Single',$retree) }
sub quote__S_180Single_Single {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(' ')];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_180Single_Single", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G'/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->unbalanced("'"))
}))) {
$C->_PATTERN(qr/\G'/);
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_181Double_Double (:$sym is context<rw> = <" ">)
##      token quote:sym<" ">   { '"' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).unbalanced('"'))> '"' }

sub quote__S_181Double_Double__PEEK { $_[0]->_AUTOLEXpeek('quote__S_181Double_Double',$retree) }
sub quote__S_181Double_Double {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(" ")];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_181Double_Double", 
do {
if (my ($C) = ($C->_EXACT('"'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->unbalanced('"'))
}))) {
$C->_EXACT('"');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_182Fre_Nch (:$sym is context<rw> = < >)
##      token quote:sym< >   { '' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))> '' }

sub quote__S_182Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('quote__S_182Fre_Nch',$retree) }
sub quote__S_182Fre_Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_182Fre_Nch", 
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('',''))
}))) {
$C->_EXACT('');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_183LtLt_GtGt (:$sym is context<rw> = << >>)
##      token quote:sym<< >> { '<<' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> '>>' }

sub quote__S_183LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('quote__S_183LtLt_GtGt',$retree) }
sub quote__S_183LtLt_GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_183LtLt_GtGt", 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
$C->_EXACT('>>');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_184Lt_Gt (:$sym is context<rw> = < >)
##      token quote:sym< >   { '<' <nibble($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))> '>' }

sub quote__S_184Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('quote__S_184Lt_Gt',$retree) }
sub quote__S_184Lt_Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_184Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_185Slash_Slash (:$sym is context<rw> = </ />)
##      token quote:sym</ />   {
##          '/' <nibble( $.cursor_fresh( ::Regex ).unbalanced("/") )> [ '/' || <.panic: "Unable to parse regex; couldn't find final '/'"> ]
##          <.old_rx_mods>?
##      }

sub quote__S_185Slash_Slash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_185Slash_Slash',$retree) }
sub quote__S_185Slash_Slash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(/ /)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_185Slash_Slash", 
do {
if (my ($C) = ($C->_EXACT('/'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh( 'STD::Regex' )->unbalanced("/") )
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('/')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find final '/'")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_OPTr(sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# handle composite forms like qww
## token quote__S_186qq (:$sym is context<rw> = 'qq')
##      token quote:qq {
##          :my $qm;
##          'qq'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.text } <.ws> <quibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( ::STD::Q ).tweak(:qq))>
##          ]
##      }

sub quote__S_186qq__PEEK { $_[0]->_AUTOLEXpeek('quote__S_186qq',$retree) }
sub quote__S_186qq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';
my $qm;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_186qq", 
do {
if (my ($C) = ($C->_EXACT('qq'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quote__S_186qq_01') {
$C->deb("Fate passed to quote__S_186qq_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_186qq_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_186qq_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{quote_mod}->text ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
## token quote__S_187q (:$sym is context<rw> = 'q')
##      token quote:q {
##          :my $qm;
##          'q'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.text } <quibble($.cursor_fresh( ::STD::Q ).tweak(:q).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( ::STD::Q ).tweak(:q))>
##          ]
##      }

sub quote__S_187q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_187q',$retree) }
sub quote__S_187q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'q';
my $qm;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_187q", 
do {
if (my ($C) = ($C->_EXACT('q'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quote__S_187q_01') {
$C->deb("Fate passed to quote__S_187q_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_187q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_187q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{quote_mod}->text ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token quote__S_188Q (:$sym is context<rw> = 'Q')
##      token quote:Q {
##          :my $qm;
##          'Q'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.text } <quibble($.cursor_fresh( ::STD::Q ).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( ::STD::Q ))>
##          ]
##      }

sub quote__S_188Q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_188Q',$retree) }
sub quote__S_188Q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';
my $qm;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_188Q", 
do {
if (my ($C) = ($C->_EXACT('Q'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quote__S_188Q_01') {
$C->deb("Fate passed to quote__S_188Q_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_188Q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_188Q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{quote_mod}->text ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token quote_mod__S_189w (:$sym is context<rw> = 'w')
##      token quote_mod:w  { <sym> }

sub quote_mod__S_189w__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_189w',$retree) }
sub quote_mod__S_189w {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_189w", 
$C->_PATTERN(qr/\Gw/)
);
}
## token quote_mod__S_190ww (:$sym is context<rw> = 'ww')
##      token quote_mod:ww { <sym> }

sub quote_mod__S_190ww__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_190ww',$retree) }
sub quote_mod__S_190ww {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ww';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_190ww", 
$C->_PATTERN(qr/\Gww/)
);
}
## token quote_mod__S_191x (:$sym is context<rw> = 'x')
##      token quote_mod:x  { <sym> }

sub quote_mod__S_191x__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_191x',$retree) }
sub quote_mod__S_191x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_191x", 
$C->_PATTERN(qr/\Gx/)
);
}
## token quote_mod__S_192to (:$sym is context<rw> = 'to')
##      token quote_mod:to { <sym> }

sub quote_mod__S_192to__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_192to',$retree) }
sub quote_mod__S_192to {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'to';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_192to", 
$C->_PATTERN(qr/\Gto/)
);
}
## token quote_mod__S_193s (:$sym is context<rw> = 's')
##      token quote_mod:s  { <sym> }

sub quote_mod__S_193s__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_193s',$retree) }
sub quote_mod__S_193s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_193s", 
$C->_PATTERN(qr/\Gs/)
);
}
## token quote_mod__S_194a (:$sym is context<rw> = 'a')
##      token quote_mod:a  { <sym> }

sub quote_mod__S_194a__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_194a',$retree) }
sub quote_mod__S_194a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_194a", 
$C->_PATTERN(qr/\Ga/)
);
}
## token quote_mod__S_195h (:$sym is context<rw> = 'h')
##      token quote_mod:h  { <sym> }

sub quote_mod__S_195h__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_195h',$retree) }
sub quote_mod__S_195h {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_195h", 
$C->_PATTERN(qr/\Gh/)
);
}
## token quote_mod__S_196f (:$sym is context<rw> = 'f')
##      token quote_mod:f  { <sym> }

sub quote_mod__S_196f__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_196f',$retree) }
sub quote_mod__S_196f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_196f", 
$C->_PATTERN(qr/\Gf/)
);
}
## token quote_mod__S_197c (:$sym is context<rw> = 'c')
##      token quote_mod:c  { <sym> }

sub quote_mod__S_197c__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_197c',$retree) }
sub quote_mod__S_197c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_197c", 
$C->_PATTERN(qr/\Gc/)
);
}
## token quote_mod__S_198b (:$sym is context<rw> = 'b')
##      token quote_mod:b  { <sym> }

sub quote_mod__S_198b__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_198b',$retree) }
sub quote_mod__S_198b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_198b", 
$C->_PATTERN(qr/\Gb/)
);
}

## token quote__S_199rx (:$sym is context<rw> = 'rx')
##      token quote:rx {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( ::Regex ) )>
##          <!old_rx_mods>
##      }

sub quote__S_199rx__PEEK { $_[0]->_AUTOLEXpeek('quote__S_199rx',$retree) }
sub quote__S_199rx {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rx';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_199rx", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grx/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( 'STD::Regex' ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_200m (:$sym is context<rw> = 'm')
##      token quote:m  {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( ::Regex ) )>
##          <!old_rx_mods>
##      }

sub quote__S_200m__PEEK { $_[0]->_AUTOLEXpeek('quote__S_200m',$retree) }
sub quote__S_200m {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'm';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_200m", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( 'STD::Regex' ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_201mm (:$sym is context<rw> = 'mm')
##      token quote:mm {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( ::Regex ).tweak(:s))>
##          <!old_rx_mods>
##      }

sub quote__S_201mm__PEEK { $_[0]->_AUTOLEXpeek('quote__S_201mm',$retree) }
sub quote__S_201mm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mm';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_201mm", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( 'STD::Regex' )->tweak('s' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_202s (:$sym is context<rw> = 's')
##      token quote:s {
##          <sym>  <!before '('>
##          <pat=sibble( $.cursor_fresh( ::Regex ), $.cursor_fresh( ::STD::Q ).tweak(:qq))>
##          <!old_rx_mods>
##      }

sub quote__S_202s__PEEK { $_[0]->_AUTOLEXpeek('quote__S_202s',$retree) }
sub quote__S_202s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_202s", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( 'STD::Regex' ), $C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_203ss (:$sym is context<rw> = 'ss')
##      token quote:ss {
##          <sym>  <!before '('>
##          <pat=sibble( $.cursor_fresh( ::Regex ).tweak(:s), $.cursor_fresh( ::STD::Q ).tweak(:qq))>
##          <!old_rx_mods>
##      }

sub quote__S_203ss__PEEK { $_[0]->_AUTOLEXpeek('quote__S_203ss',$retree) }
sub quote__S_203ss {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ss';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_203ss", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gss/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( 'STD::Regex' )->tweak('s' => 1), $C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_204tr (:$sym is context<rw> = 'tr')
##      token quote:tr {
##          <sym>  <!before '('> <pat=tribble( $.cursor_fresh( ::STD::Q ).tweak(:q))>
##          <!old_tr_mods>
##      }

sub quote__S_204tr__PEEK { $_[0]->_AUTOLEXpeek('quote__S_204tr',$retree) }
sub quote__S_204tr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'tr';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_204tr", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtr/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->tribble( $C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_tr_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token old_rx_mods
##      token old_rx_mods {
##          (< i g s m x c e >+) 
##          {{
##              given $0.text {
##                  $_ ~~ /i/ and $.worryobs('/i',':i');
##                  $_ ~~ /g/ and $.worryobs('/g',':g');
##                  $_ ~~ /s/ and $.worryobs('/s','^^ and $$ anchors');
##                  $_ ~~ /m/ and $.worryobs('/m','. or \N');
##                  $_ ~~ /x/ and $.worryobs('/x','normal default whitespace');
##                  $_ ~~ /c/ and $.worryobs('/c',':c or :p');
##                  $_ ~~ /e/ and $.worryobs('/e','interpolated {...} or s{} = ... form');
##                  $.obs('suffix regex modifiers','prefix adverbs');
##              }
##          }}
##      }

sub old_rx_mods__PEEK { $_[0]->_AUTOLEXpeek('old_rx_mods',$retree) }
sub old_rx_mods {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "old_rx_mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< i g s m x c e > )
})
})}
}))) {
scalar(do {

do { my $_ = $$C{0}->text; if ((0)) {}
$_ =~ qr/i/ and $C->worryobs('/i',':i');
$_ =~ qr/g/ and $C->worryobs('/g',':g');
$_ =~ qr/s/ and $C->worryobs('/s','^^ and $$ anchors');
$_ =~ qr/m/ and $C->worryobs('/m','. or \N');
$_ =~ qr/x/ and $C->worryobs('/x','normal default whitespace');
$_ =~ qr/c/ and $C->worryobs('/c',':c or :p');
$_ =~ qr/e/ and $C->worryobs('/e','interpolated {...} or s{} = ... form');
$C->obs('suffix regex modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
}
);
}

## token old_tr_mods
##      token old_tr_mods {
##          (< c d s ] >+) 
##          {{
##              given $0.text {
##                  $_ ~~ /c/ and $.worryobs('/c',':c');
##                  $_ ~~ /d/ and $.worryobs('/g',':d');
##                  $_ ~~ /s/ and $.worryobs('/s',':s');
##                  $.obs('suffix transliteration modifiers','prefix adverbs');
##              }
##          }}
##      }

sub old_tr_mods__PEEK { $_[0]->_AUTOLEXpeek('old_tr_mods',$retree) }
sub old_tr_mods {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "old_tr_mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< c d s ] > )
})
})}
}))) {
scalar(do {

do { my $_ = $$C{0}->text; if ((0)) {}
$_ =~ qr/c/ and $C->worryobs('/c',':c');
$_ =~ qr/d/ and $C->worryobs('/g',':d');
$_ =~ qr/s/ and $C->worryobs('/s',':s');
$C->obs('suffix transliteration modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
}
);
}


## token quote__S_205quasi (:$sym is context<rw> = 'quasi')
##      token quote:quasi {
##          <sym>  <!before '('> <quasiquibble($.cursor_fresh( ::STD::Quasi ))>
##      }

sub quote__S_205quasi__PEEK { $_[0]->_AUTOLEXpeek('quote__S_205quasi',$retree) }
sub quote__S_205quasi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quasi';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_205quasi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gquasi/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
$C->_SUBSUMEr(['quasiquibble'], sub {
my $C = shift;
$C->quasiquibble($C->cursor_fresh( 'STD::Quasi' ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX should eventually be derived from current Unicode tables.
our %open2close = (
"\x{0028}" => "\x{0029}", "\x{003C}" => "\x{003E}", "\x{005B}" => "\x{005D}",
"\x{007B}" => "\x{007D}", "\x{00AB}" => "\x{00BB}", "\x{0F3A}" => "\x{0F3B}",
"\x{0F3C}" => "\x{0F3D}", "\x{169B}" => "\x{169C}", "\x{2039}" => "\x{203A}",
"\x{2045}" => "\x{2046}", "\x{207D}" => "\x{207E}", "\x{208D}" => "\x{208E}",
"\x{2208}" => "\x{220B}", "\x{2209}" => "\x{220C}", "\x{220A}" => "\x{220D}",
"\x{2215}" => "\x{29F5}", "\x{223C}" => "\x{223D}", "\x{2243}" => "\x{22CD}",
"\x{2252}" => "\x{2253}", "\x{2254}" => "\x{2255}", "\x{2264}" => "\x{2265}",
"\x{2266}" => "\x{2267}", "\x{2268}" => "\x{2269}", "\x{226A}" => "\x{226B}",
"\x{226E}" => "\x{226F}", "\x{2270}" => "\x{2271}", "\x{2272}" => "\x{2273}",
"\x{2274}" => "\x{2275}", "\x{2276}" => "\x{2277}", "\x{2278}" => "\x{2279}",
"\x{227A}" => "\x{227B}", "\x{227C}" => "\x{227D}", "\x{227E}" => "\x{227F}",
"\x{2280}" => "\x{2281}", "\x{2282}" => "\x{2283}", "\x{2284}" => "\x{2285}",
"\x{2286}" => "\x{2287}", "\x{2288}" => "\x{2289}", "\x{228A}" => "\x{228B}",
"\x{228F}" => "\x{2290}", "\x{2291}" => "\x{2292}", "\x{2298}" => "\x{29B8}",
"\x{22A2}" => "\x{22A3}", "\x{22A6}" => "\x{2ADE}", "\x{22A8}" => "\x{2AE4}",
"\x{22A9}" => "\x{2AE3}", "\x{22AB}" => "\x{2AE5}", "\x{22B0}" => "\x{22B1}",
"\x{22B2}" => "\x{22B3}", "\x{22B4}" => "\x{22B5}", "\x{22B6}" => "\x{22B7}",
"\x{22C9}" => "\x{22CA}", "\x{22CB}" => "\x{22CC}", "\x{22D0}" => "\x{22D1}",
"\x{22D6}" => "\x{22D7}", "\x{22D8}" => "\x{22D9}", "\x{22DA}" => "\x{22DB}",
"\x{22DC}" => "\x{22DD}", "\x{22DE}" => "\x{22DF}", "\x{22E0}" => "\x{22E1}",
"\x{22E2}" => "\x{22E3}", "\x{22E4}" => "\x{22E5}", "\x{22E6}" => "\x{22E7}",
"\x{22E8}" => "\x{22E9}", "\x{22EA}" => "\x{22EB}", "\x{22EC}" => "\x{22ED}",
"\x{22F0}" => "\x{22F1}", "\x{22F2}" => "\x{22FA}", "\x{22F3}" => "\x{22FB}",
"\x{22F4}" => "\x{22FC}", "\x{22F6}" => "\x{22FD}", "\x{22F7}" => "\x{22FE}",
"\x{2308}" => "\x{2309}", "\x{230A}" => "\x{230B}", "\x{2329}" => "\x{232A}",
"\x{23B4}" => "\x{23B5}", "\x{2768}" => "\x{2769}", "\x{276A}" => "\x{276B}",
"\x{276C}" => "\x{276D}", "\x{276E}" => "\x{276F}", "\x{2770}" => "\x{2771}",
"\x{2772}" => "\x{2773}", "\x{2774}" => "\x{2775}", "\x{27C3}" => "\x{27C4}",
"\x{27C5}" => "\x{27C6}", "\x{27D5}" => "\x{27D6}", "\x{27DD}" => "\x{27DE}",
"\x{27E2}" => "\x{27E3}", "\x{27E4}" => "\x{27E5}", "\x{27E6}" => "\x{27E7}",
"\x{27E8}" => "\x{27E9}", "\x{27EA}" => "\x{27EB}", "\x{2983}" => "\x{2984}",
"\x{2985}" => "\x{2986}", "\x{2987}" => "\x{2988}", "\x{2989}" => "\x{298A}",
"\x{298B}" => "\x{298C}", "\x{298D}" => "\x{298E}", "\x{298F}" => "\x{2990}",
"\x{2991}" => "\x{2992}", "\x{2993}" => "\x{2994}", "\x{2995}" => "\x{2996}",
"\x{2997}" => "\x{2998}", "\x{29C0}" => "\x{29C1}", "\x{29C4}" => "\x{29C5}",
"\x{29CF}" => "\x{29D0}", "\x{29D1}" => "\x{29D2}", "\x{29D4}" => "\x{29D5}",
"\x{29D8}" => "\x{29D9}", "\x{29DA}" => "\x{29DB}", "\x{29F8}" => "\x{29F9}",
"\x{29FC}" => "\x{29FD}", "\x{2A2B}" => "\x{2A2C}", "\x{2A2D}" => "\x{2A2E}",
"\x{2A34}" => "\x{2A35}", "\x{2A3C}" => "\x{2A3D}", "\x{2A64}" => "\x{2A65}",
"\x{2A79}" => "\x{2A7A}", "\x{2A7D}" => "\x{2A7E}", "\x{2A7F}" => "\x{2A80}",
"\x{2A81}" => "\x{2A82}", "\x{2A83}" => "\x{2A84}", "\x{2A8B}" => "\x{2A8C}",
"\x{2A91}" => "\x{2A92}", "\x{2A93}" => "\x{2A94}", "\x{2A95}" => "\x{2A96}",
"\x{2A97}" => "\x{2A98}", "\x{2A99}" => "\x{2A9A}", "\x{2A9B}" => "\x{2A9C}",
"\x{2AA1}" => "\x{2AA2}", "\x{2AA6}" => "\x{2AA7}", "\x{2AA8}" => "\x{2AA9}",
"\x{2AAA}" => "\x{2AAB}", "\x{2AAC}" => "\x{2AAD}", "\x{2AAF}" => "\x{2AB0}",
"\x{2AB3}" => "\x{2AB4}", "\x{2ABB}" => "\x{2ABC}", "\x{2ABD}" => "\x{2ABE}",
"\x{2ABF}" => "\x{2AC0}", "\x{2AC1}" => "\x{2AC2}", "\x{2AC3}" => "\x{2AC4}",
"\x{2AC5}" => "\x{2AC6}", "\x{2ACD}" => "\x{2ACE}", "\x{2ACF}" => "\x{2AD0}",
"\x{2AD1}" => "\x{2AD2}", "\x{2AD3}" => "\x{2AD4}", "\x{2AD5}" => "\x{2AD6}",
"\x{2AEC}" => "\x{2AED}", "\x{2AF7}" => "\x{2AF8}", "\x{2AF9}" => "\x{2AFA}",
"\x{2E02}" => "\x{2E03}", "\x{2E04}" => "\x{2E05}", "\x{2E09}" => "\x{2E0A}",
"\x{2E0C}" => "\x{2E0D}", "\x{2E1C}" => "\x{2E1D}", "\x{3008}" => "\x{3009}",
"\x{300A}" => "\x{300B}", "\x{300C}" => "\x{300D}", "\x{300E}" => "\x{300F}",
"\x{3010}" => "\x{3011}", "\x{3014}" => "\x{3015}", "\x{3016}" => "\x{3017}",
"\x{3018}" => "\x{3019}", "\x{301A}" => "\x{301B}", "\x{301D}" => "\x{301E}",
"\x{FD3E}" => "\x{FD3F}", "\x{FE17}" => "\x{FE18}", "\x{FE35}" => "\x{FE36}",
"\x{FE37}" => "\x{FE38}", "\x{FE39}" => "\x{FE3A}", "\x{FE3B}" => "\x{FE3C}",
"\x{FE3D}" => "\x{FE3E}", "\x{FE3F}" => "\x{FE40}", "\x{FE41}" => "\x{FE42}",
"\x{FE43}" => "\x{FE44}", "\x{FE47}" => "\x{FE48}", "\x{FE59}" => "\x{FE5A}",
"\x{FE5B}" => "\x{FE5C}", "\x{FE5D}" => "\x{FE5E}", "\x{FF08}" => "\x{FF09}",
"\x{FF1C}" => "\x{FF1E}", "\x{FF3B}" => "\x{FF3D}", "\x{FF5B}" => "\x{FF5D}",
"\x{FF5F}" => "\x{FF60}", "\x{FF62}" => "\x{FF63}",
);

## token opener
##      token opener {
##        <[\x0028 \x003C \x005B
##          \x007B \x00AB \x0F3A
##          \x0F3C \x169B \x2039
##          \x2045 \x207D \x208D
##          \x2208 \x2209 \x220A
##          \x2215 \x223C \x2243
##          \x2252 \x2254 \x2264
##          \x2266 \x2268 \x226A
##          \x226E \x2270 \x2272
##          \x2274 \x2276 \x2278
##          \x227A \x227C \x227E
##          \x2280 \x2282 \x2284
##          \x2286 \x2288 \x228A
##          \x228F \x2291 \x2298
##          \x22A2 \x22A6 \x22A8
##          \x22A9 \x22AB \x22B0
##          \x22B2 \x22B4 \x22B6
##          \x22C9 \x22CB \x22D0
##          \x22D6 \x22D8 \x22DA
##          \x22DC \x22DE \x22E0
##          \x22E2 \x22E4 \x22E6
##          \x22E8 \x22EA \x22EC
##          \x22F0 \x22F2 \x22F3
##          \x22F4 \x22F6 \x22F7
##          \x2308 \x230A \x2329
##          \x23B4 \x2768 \x276A
##          \x276C \x276E \x2770
##          \x2772 \x2774 \x27C3
##          \x27C5 \x27D5 \x27DD
##          \x27E2 \x27E4 \x27E6
##          \x27E8 \x27EA \x2983
##          \x2985 \x2987 \x2989
##          \x298B \x298D \x298F
##          \x2991 \x2993 \x2995
##          \x2997 \x29C0 \x29C4
##          \x29CF \x29D1 \x29D4
##          \x29D8 \x29DA \x29F8
##          \x29FC \x2A2B \x2A2D
##          \x2A34 \x2A3C \x2A64
##          \x2A79 \x2A7D \x2A7F
##          \x2A81 \x2A83 \x2A8B
##          \x2A91 \x2A93 \x2A95
##          \x2A97 \x2A99 \x2A9B
##          \x2AA1 \x2AA6 \x2AA8
##          \x2AAA \x2AAC \x2AAF
##          \x2AB3 \x2ABB \x2ABD
##          \x2ABF \x2AC1 \x2AC3
##          \x2AC5 \x2ACD \x2ACF
##          \x2AD1 \x2AD3 \x2AD5
##          \x2AEC \x2AF7 \x2AF9
##          \x2E02 \x2E04 \x2E09
##          \x2E0C \x2E1C \x3008
##          \x300A \x300C \x300E
##          \x3010 \x3014 \x3016
##          \x3018 \x301A \x301D
##          \xFD3E \xFE17 \xFE35
##          \xFE37 \xFE39 \xFE3B
##          \xFE3D \xFE3F \xFE41
##          \xFE43 \xFE47 \xFE59
##          \xFE5B \xFE5D \xFF08
##          \xFF1C \xFF3B \xFF5B
##          \xFF5F \xFF62]>
##      }

sub opener__PEEK { $_[0]->_AUTOLEXpeek('opener',$retree) }
sub opener {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "opener", 
$C->_PATTERN(qr/\G[\x{0028}\x{003C}\x{005B}\x{007B}\x{00AB}\x{0F3A}\x{0F3C}\x{169B}\x{2039}\x{2045}\x{207D}\x{208D}\x{2208}\x{2209}\x{220A}\x{2215}\x{223C}\x{2243}\x{2252}\x{2254}\x{2264}\x{2266}\x{2268}\x{226A}\x{226E}\x{2270}\x{2272}\x{2274}\x{2276}\x{2278}\x{227A}\x{227C}\x{227E}\x{2280}\x{2282}\x{2284}\x{2286}\x{2288}\x{228A}\x{228F}\x{2291}\x{2298}\x{22A2}\x{22A6}\x{22A8}\x{22A9}\x{22AB}\x{22B0}\x{22B2}\x{22B4}\x{22B6}\x{22C9}\x{22CB}\x{22D0}\x{22D6}\x{22D8}\x{22DA}\x{22DC}\x{22DE}\x{22E0}\x{22E2}\x{22E4}\x{22E6}\x{22E8}\x{22EA}\x{22EC}\x{22F0}\x{22F2}\x{22F3}\x{22F4}\x{22F6}\x{22F7}\x{2308}\x{230A}\x{2329}\x{23B4}\x{2768}\x{276A}\x{276C}\x{276E}\x{2770}\x{2772}\x{2774}\x{27C3}\x{27C5}\x{27D5}\x{27DD}\x{27E2}\x{27E4}\x{27E6}\x{27E8}\x{27EA}\x{2983}\x{2985}\x{2987}\x{2989}\x{298B}\x{298D}\x{298F}\x{2991}\x{2993}\x{2995}\x{2997}\x{29C0}\x{29C4}\x{29CF}\x{29D1}\x{29D4}\x{29D8}\x{29DA}\x{29F8}\x{29FC}\x{2A2B}\x{2A2D}\x{2A34}\x{2A3C}\x{2A64}\x{2A79}\x{2A7D}\x{2A7F}\x{2A81}\x{2A83}\x{2A8B}\x{2A91}\x{2A93}\x{2A95}\x{2A97}\x{2A99}\x{2A9B}\x{2AA1}\x{2AA6}\x{2AA8}\x{2AAA}\x{2AAC}\x{2AAF}\x{2AB3}\x{2ABB}\x{2ABD}\x{2ABF}\x{2AC1}\x{2AC3}\x{2AC5}\x{2ACD}\x{2ACF}\x{2AD1}\x{2AD3}\x{2AD5}\x{2AEC}\x{2AF7}\x{2AF9}\x{2E02}\x{2E04}\x{2E09}\x{2E0C}\x{2E1C}\x{3008}\x{300A}\x{300C}\x{300E}\x{3010}\x{3014}\x{3016}\x{3018}\x{301A}\x{301D}\x{FD3E}\x{FE17}\x{FE35}\x{FE37}\x{FE39}\x{FE3B}\x{FE3D}\x{FE3F}\x{FE41}\x{FE43}\x{FE47}\x{FE59}\x{FE5B}\x{FE5D}\x{FF08}\x{FF1C}\x{FF3B}\x{FF5B}\x{FF5F}\x{FF62}]/)
);
}

# assumes whitespace is eaten already

## method peek_delimiters
sub peek_delimiters {
my $self = shift;


my $pos = $self->{_pos};
my $startpos = $pos;
my $char = substr($ORIG,$pos++,1);
if ($char =~ qr/^\s$/) {
$self->panic("Whitespace not allowed as delimiter");
}

# XXX not defined yet
#    <?before <+isPe> > {
#        self.panic("Use a closing delimiter for an opener is reserved");
#    }

my $rightbrack = $open2close{$char};
if (not defined $rightbrack) {
return $char, $char;
}
while (substr($ORIG,$pos,1) eq $char) {
$pos++;
}
my $len = $pos - $startpos;
my $start = $char x $len;
my $stop = $rightbrack x $len;
return $start, $stop;
}

{ package STD::startstop;
sub __instantiate__ { my $self = shift;
my ($start,$stop) = @_;
my $mangle = ::mangle($start,$stop);
my $mixin = "STD::startstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$start' => $start,'$stop' => $stop } }
##     token starter
##          token starter { $start }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "starter", 
$C->_EXACT($start)
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: starter
    i: 0
    min: 0
    r: 1
    s: 0
    var: $start
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::stop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::stop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token starter
##          token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::unitstop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::unitstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token unitstopper
##          token unitstopper { $stop }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
unitstopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role
## token unitstopper
##      } # end role
##      
##      token unitstopper { $ }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_PATTERN(qr/\G\z/)
);
}

## method balanced ($start,$stop)
sub balanced {
my $self = shift;
my $start = shift;
my $stop = shift;

$self->mixin( 'STD::startstop'->__instantiate__($start,$stop) ); }
## method unbalanced ($stop)
sub unbalanced {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::stop'->__instantiate__($stop) ); }
## method unitstop ($stop)
sub unitstop {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::unitstop'->__instantiate__($stop) ); }

## token codepoint
##      token codepoint {
##          '[' {} ( [<!before ']'> .]*? ) ']'
##      }

sub codepoint__PEEK { $_[0]->_AUTOLEXpeek('codepoint',$retree) }
sub codepoint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "codepoint", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT(']')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_STARf(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?s:.)/)
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(']')
})
}))
})
})
})}
}))
}, scalar(do {

}, $C))
}, $C->_EXACT('['))
);
}

## method truly ($bool,$opt)
sub truly {
my $self = shift;
my $bool = shift;
my $opt = shift;


return $self if $bool;
$self->panic("Can't negate $opt adverb");
}

{ package STD::Q;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
{ package STD::Q::b1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_206Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <sym> <item=backslash> }

sub escape__S_206Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_206Back',$retree) }
sub escape__S_206Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_206Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##         token backslash__S_207qq (:$sym is context<rw> = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $.cursor_fresh($+LANG).quote(); } }

sub backslash__S_207qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_207qq',$retree) }
sub backslash__S_207qq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_207qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{quote} = $C->cursor_fresh($::LANG)->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_208Back (:$sym is context<rw> = <\\>)
##              token backslash:sym<\\> { <text=sym> }

sub backslash__S_208Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_208Back',$retree) }
sub backslash__S_208Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_208Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_209stopper (:$sym is context<rw> = 'stopper')
##              token backslash:stopper { <text=stopper> }

sub backslash__S_209stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_209stopper',$retree) }
sub backslash__S_209stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'stopper';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_209stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}
##         token backslash__S_210a (:$sym is context<rw> = 'a')
##              token backslash:a { <sym> }

sub backslash__S_210a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_210a',$retree) }
sub backslash__S_210a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_210a", 
$C->_PATTERN(qr/\Ga/)
);
}
##         token backslash__S_211b (:$sym is context<rw> = 'b')
##              token backslash:b { <sym> }

sub backslash__S_211b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_211b',$retree) }
sub backslash__S_211b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_211b", 
$C->_PATTERN(qr/\Gb/)
);
}
##         token backslash__S_212c (:$sym is context<rw> = 'c')
##              token backslash:c { <sym>
##                  [
##                  | <codepoint>
##                  | \d+
##                  | [ <[ ?.._ ]> || <.panic: "Unrecognized \\c character"> ]
##                  ]
##              }

sub backslash__S_212c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_212c',$retree) }
sub backslash__S_212c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_212c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gc/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_212c_01') {
$C->deb("Fate passed to backslash__S_212c_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_212c_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_212c_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['codepoint'], sub {
my $C = shift;
$C->codepoint
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G[?-_]/)} 
or
eval { push @gather, $C->panic("Unrecognized \\c character")} or do { die $@ if $@ };
@gather;
}
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##         token backslash__S_213e (:$sym is context<rw> = 'e')
##              token backslash:e { <sym> }

sub backslash__S_213e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_213e',$retree) }
sub backslash__S_213e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_213e", 
$C->_PATTERN(qr/\Ge/)
);
}
##         token backslash__S_214f (:$sym is context<rw> = 'f')
##              token backslash:f { <sym> }

sub backslash__S_214f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_214f',$retree) }
sub backslash__S_214f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_214f", 
$C->_PATTERN(qr/\Gf/)
);
}
##         token backslash__S_215n (:$sym is context<rw> = 'n')
##              token backslash:n { <sym> }

sub backslash__S_215n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_215n',$retree) }
sub backslash__S_215n {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_215n", 
$C->_PATTERN(qr/\Gn/)
);
}
##         token backslash__S_216o (:$sym is context<rw> = 'o')
##              token backslash:o { <sym> [ <octint> | '[' <octint>**',' ']' ] }

sub backslash__S_216o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_216o',$retree) }
sub backslash__S_216o {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{_pos};
$C->{'octint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_216o", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Go/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_216o_01') {
$C->deb("Fate passed to backslash__S_216o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_216o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_216o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
}))) {
$C->_EXACT(']');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##         token backslash__S_217r (:$sym is context<rw> = 'r')
##              token backslash:r { <sym> }

sub backslash__S_217r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_217r',$retree) }
sub backslash__S_217r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_217r", 
$C->_PATTERN(qr/\Gr/)
);
}
##         token backslash__S_218t (:$sym is context<rw> = 't')
##              token backslash:t { <sym> }

sub backslash__S_218t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_218t',$retree) }
sub backslash__S_218t {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_218t", 
$C->_PATTERN(qr/\Gt/)
);
}
##         token backslash__S_219x (:$sym is context<rw> = 'x')
##              token backslash:x { <sym> [ <hexint> | '[' [<.ws><hexint><.ws> ] ** ',' ']' ] }

sub backslash__S_219x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_219x',$retree) }
sub backslash__S_219x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'hexint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_219x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gx/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_219x_01') {
$C->deb("Fate passed to backslash__S_219x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_219x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_219x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_EXACT(']');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##         token backslash__S_2200 (:$sym is context<rw> = <0>)
##              token backslash:sym<0> { <sym> }

sub backslash__S_2200__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_2200',$retree) }
sub backslash__S_2200 {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(0);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "backslash__S_2200", 
$C->_PATTERN(qr/\G0/)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_207qq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_207qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_207qq
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: backslash__S_207qq
              i: 0
              min: 1
              r: 1
              s: 0
              text: q
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_207qq
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<quote> = $.cursor_fresh($+LANG).quote(); "
backslash__S_208Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_208Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_208Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_209stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_209stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_209stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_210a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_210a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
backslash__S_211b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_211b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_212c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_212c
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_212c
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: c
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &3 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_212c_01
          dba: backslash__S_212c
          i: 0
          min: 0
          name: backslash__S_212c_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_212c_01 0
              dba: backslash__S_212c
              i: 0
              min: 12345
              name: codepoint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              alt: backslash__S_212c_01 1
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: backslash__S_212c
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_bracket 
              alt: backslash__S_212c_01 2
              decl: []

              min: 0
              re: !!perl/hash:RE_first 
                a: 0
                dba: backslash__S_212c
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_cclass 
                    a: 0
                    dba: backslash__S_212c
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "[ ?.._ ]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Unrecognized \\c character")
backslash__S_212c_01: *3
backslash__S_213e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_213e
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_214f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_214f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_215n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_215n
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_216o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_216o
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_216o
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: o
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_216o_01
          dba: backslash__S_216o
          i: 0
          min: 12345
          name: backslash__S_216o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_216o_01 0
              dba: backslash__S_216o
              i: 0
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_216o_01 1
              dba: backslash__S_216o
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_216o
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: backslash__S_216o
                    i: 0
                    min: 12345
                    name: octint
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_216o
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_216o
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_216o_01: *1
backslash__S_217r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_217r
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_218t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_218t
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_219x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_219x
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_219x
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &2 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_219x_01
          dba: backslash__S_219x
          i: 0
          min: 12345
          name: backslash__S_219x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_219x_01 0
              dba: backslash__S_219x
              i: 0
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_219x_01 1
              dba: backslash__S_219x
              i: 0
              min: 37037
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_219x
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 37035
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_219x
                      i: 0
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_219x
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_219x
                          i: 0
                          min: 12345
                          name: hexint
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_219x
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                  min: 37035
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_219x
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_219x
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_219x_01: *2
backslash__S_2200: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_2200
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 0
escape__S_206Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_206Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: escape__S_206Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: escape__S_206Back
          i: 0
          min: 12345
          name: backslash
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: escape__S_206Back
        i: 0
        min: 12345
        r: 1
        s: 0
        var: item
RETREE_END
}
} ## end role

{ package STD::Q::b0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_221Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <!> }

sub escape__S_221Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_221Back',$retree) }
sub escape__S_221Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_221Back", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_221Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_221Back
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_222Cur_Ly (:$sym is context<rw> = <{ }>)
##              token escape:sym<{ }> { <?before '{'> [ :lang($+LANG) <block> ] }

sub escape__S_222Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_222Cur_Ly',$retree) }
sub escape__S_222Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_222Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_222Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_222Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_222Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_222Cur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: escape__S_222Cur_Ly
          i: 0
          lang: ($+LANG)
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: escape__S_222Cur_Ly
              i: 0
              lang: ($+LANG)
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($+LANG);  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: escape__S_222Cur_Ly
              i: 0
              lang: ($+LANG)
              min: 12345
              name: block
              r: 1
              rest: ''
              s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_223Cur_Ly (:$sym is context<rw> = <{ }>)
##              token escape:sym<{ }> { <!> }

sub escape__S_223Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_223Cur_Ly',$retree) }
sub escape__S_223Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_223Cur_Ly", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_223Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_223Cur_Ly
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::s1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_224Dollar (:$sym is context<rw> = <$>)
##              token escape:sym<$> { <?before '$'> [ :lang($+LANG) <variable> <extrapost>? ] || <.panic: "Non-variable \$ must be backslashed"> }

sub escape__S_224Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_224Dollar',$retree) }
sub escape__S_224Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'extrapost'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_224Dollar", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['extrapost'], sub {
my $C = shift;
$C->extrapost
})
});
}
else {
();
}
}
});
}
else {
();
}
}} 
or
eval { push @gather, $C->panic("Non-variable \$ must be backslashed")} or do { die $@ if $@ };
@gather;
}
);
}
##         token special_variable__S_225DollarDouble (:$sym is context<rw> = <$">)
##              token special_variable:sym<$"> {
##                  '$' <stopper>
##                  <.panic: "Can't use a \$ in the last position of an interpolating string">
##              }

sub special_variable__S_225DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_225DollarDouble',$retree) }
sub special_variable__S_225DollarDouble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($");


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_225DollarDouble", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->panic("Can't use a \$ in the last position of an interpolating string");
}
else {
();
}
};
}
else {
();
}
}
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_224Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: escape__S_224Dollar
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: escape__S_224Dollar
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_assertion 
            assert: "?"
            min: 0
            re: !!perl/hash:RE_method_re 
              a: 0
              dba: escape__S_224Dollar
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE 
                decl: []

                min: 1
                re: !!perl/hash:RE_string 
                  a: 0
                  dba: escape__S_224Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: $
              s: 0
          - !!perl/hash:RE_bracket 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: escape__S_224Dollar
              i: 0
              lang: ($+LANG)
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_224Dollar
                  i: 0
                  lang: ($+LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($+LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_224Dollar
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: escape__S_224Dollar
                    i: 0
                    lang: ($+LANG)
                    min: 12345
                    name: extrapost
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Non-variable \$ must be backslashed")
special_variable__S_225DollarDouble: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_225DollarDouble
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_225DollarDouble
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_225DollarDouble
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Can't use a \$ in the last position of an interpolating string")
RETREE_END
}
} ## end role

{ package STD::Q::s0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_226Dollar (:$sym is context<rw> = <$>)
##              token escape:sym<$> { <!> }

sub escape__S_226Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_226Dollar',$retree) }
sub escape__S_226Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_226Dollar", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
##         token special_variable__S_227DollarDouble (:$sym is context<rw> = <$">)
##              token special_variable:sym<$"> { <!> }

sub special_variable__S_227DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_227DollarDouble',$retree) }
sub special_variable__S_227DollarDouble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($");


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_227DollarDouble", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_226Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_226Dollar
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
special_variable__S_227DollarDouble: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: special_variable__S_227DollarDouble
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::a1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_228At (:$sym is context<rw> = <@>)
##              token escape:sym<@> { <?before '@'> [ :lang($+LANG) <variable> <extrapost> | <!> ] }

sub escape__S_228At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_228At',$retree) }
sub escape__S_228At {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_228At", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('@')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'escape__S_228At_02') {
$C->deb("Fate passed to escape__S_228At_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::a1', 'escape__S_228At_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_228At_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
$C->_SUBSUMEr(['extrapost'], sub {
my $C = shift;
$C->extrapost
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
} # trap ABORTBRANCH from variable's ::
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_228At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_228At
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_228At
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_228At
              i: 0
              min: 1
              r: 1
              s: 0
              text: "@"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_228At_02
          dba: escape__S_228At
          i: 0
          lang: ($+LANG)
          min: 0
          name: escape__S_228At_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_228At_02 0
              dba: escape__S_228At
              i: 0
              lang: ($+LANG)
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_228At
                  i: 0
                  lang: ($+LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($+LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_228At
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_228At
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: extrapost
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_assertion 
              alt: escape__S_228At_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_228At
                i: 0
                lang: ($+LANG)
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_228At_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::a0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_229At (:$sym is context<rw> = <@>)
##              token escape:sym<@> { <!> }

sub escape__S_229At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_229At',$retree) }
sub escape__S_229At {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_229At", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_229At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_229At
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::h1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_230Percent (:$sym is context<rw> = <%>)
##              token escape:sym<%> { <?before '%'> [ :lang($+LANG) <variable> <extrapost> | <!> ] }

sub escape__S_230Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_230Percent',$retree) }
sub escape__S_230Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_230Percent", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('%')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'escape__S_230Percent_02') {
$C->deb("Fate passed to escape__S_230Percent_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::h1', 'escape__S_230Percent_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_230Percent_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
$C->_SUBSUMEr(['extrapost'], sub {
my $C = shift;
$C->extrapost
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_230Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_230Percent
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_230Percent
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_230Percent
              i: 0
              min: 1
              r: 1
              s: 0
              text: "%"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_230Percent_02
          dba: escape__S_230Percent
          i: 0
          lang: ($+LANG)
          min: 0
          name: escape__S_230Percent_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_230Percent_02 0
              dba: escape__S_230Percent
              i: 0
              lang: ($+LANG)
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_230Percent
                  i: 0
                  lang: ($+LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($+LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_230Percent
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_230Percent
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: extrapost
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_assertion 
              alt: escape__S_230Percent_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_230Percent
                i: 0
                lang: ($+LANG)
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_230Percent_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::h0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_231Percent (:$sym is context<rw> = <%>)
##              token escape:sym<%> { <!> }

sub escape__S_231Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_231Percent',$retree) }
sub escape__S_231Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_231Percent", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_231Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_231Percent
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::f1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_232Amp (:$sym is context<rw> = <&>)
##              token escape:sym<&> { <?before '&'> [ :lang($+LANG) <variable> <extrapost> | <!> ] }

sub escape__S_232Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_232Amp',$retree) }
sub escape__S_232Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_232Amp", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('&')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'escape__S_232Amp_02') {
$C->deb("Fate passed to escape__S_232Amp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::f1', 'escape__S_232Amp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_232Amp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
$C->_SUBSUMEr(['extrapost'], sub {
my $C = shift;
$C->extrapost
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_232Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_232Amp
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_232Amp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_232Amp
              i: 0
              min: 1
              r: 1
              s: 0
              text: "&"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_232Amp_02
          dba: escape__S_232Amp
          i: 0
          lang: ($+LANG)
          min: 0
          name: escape__S_232Amp_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_232Amp_02 0
              dba: escape__S_232Amp
              i: 0
              lang: ($+LANG)
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_232Amp
                  i: 0
                  lang: ($+LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($+LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_232Amp
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_232Amp
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: extrapost
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_assertion 
              alt: escape__S_232Amp_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_232Amp
                i: 0
                lang: ($+LANG)
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_232Amp_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::f0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_233Amp (:$sym is context<rw> = <&>)
##              token escape:sym<&> { <!> }

sub escape__S_233Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_233Amp',$retree) }
sub escape__S_233Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_233Amp", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_233Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_233Amp
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::w1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->comb }
} ## end role

{ package STD::Q::w0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::ww1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->comb }
} ## end role

{ package STD::Q::ww0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::x1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->run }
} ## end role

{ package STD::Q::x0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::q;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token stopper
##              token stopper { \' }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('\'')
);
}

##         token escape__S_234Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <sym> <item=backslash> }

sub escape__S_234Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_234Back',$retree) }
sub escape__S_234Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_234Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}

##         token backslash__S_235qq (:$sym is context<rw> = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $.cursor_fresh($+LANG).quote(); } }

sub backslash__S_235qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_235qq',$retree) }
sub backslash__S_235qq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_235qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{quote} = $C->cursor_fresh($::LANG)->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_236Back (:$sym is context<rw> = <\\>)
##              token backslash:sym<\\> { <text=sym> }

sub backslash__S_236Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_236Back',$retree) }
sub backslash__S_236Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_236Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_237stopper (:$sym is context<rw> = 'stopper')
##              token backslash:stopper { <text=stopper> }

sub backslash__S_237stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_237stopper',$retree) }
sub backslash__S_237stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'stopper';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_237stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}

# in single quotes, keep backslash on random character by default
##         token backslash__S_238misc (:$sym is context<rw> = 'misc')
##              token backslash:misc { {} (.) { $<text> = "\\" ~ $0.text; } }

sub backslash__S_238misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_238misc',$retree) }
sub backslash__S_238misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_238misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G(?s:.)/)
})}
}))) {
scalar(do {
my $M = $C;  $M->{text} = "\\" . $$C{0}->text; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_235qq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_235qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_235qq
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: backslash__S_235qq
              i: 0
              min: 1
              r: 1
              s: 0
              text: q
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_235qq
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<quote> = $.cursor_fresh($+LANG).quote(); "
backslash__S_236Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_236Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_236Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_237stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_237stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_237stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_238misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_238misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_238misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_meta 
            a: 0
            dba: backslash__S_238misc
            i: 0
            min: 1
            r: 1
            s: 0
            text: .
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_238misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<text> = \"\\\\\" ~ $0.text; "
escape__S_234Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_234Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: escape__S_234Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: escape__S_234Back
          i: 0
          min: 12345
          name: backslash
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: escape__S_234Back
        i: 0
        min: 12345
        r: 1
        s: 0
        var: item
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: "'"
RETREE_END
}
} ## end role

{ package STD::Q::qq;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::Q::b1 STD::Q::c1 STD::Q::s1 STD::Q::a1 STD::Q::h1 STD::Q::f1));
##         token stopper
##              token stopper { \" }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('"')
);
}
# in double quotes, omit backslash on random \W backslash by default
##         token backslash__S_239misc (:$sym is context<rw> = 'misc')
##              token backslash:misc { {} [ (\W) { $<text> = $0.text; } | $<x>=(\w) <.panic("Unrecognized backslash sequence: '\\" ~ $<x>.text ~ "'")> ] }

sub backslash__S_239misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_239misc',$retree) }
sub backslash__S_239misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_239misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_239misc_01') {
$C->deb("Fate passed to backslash__S_239misc_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::qq', 'backslash__S_239misc_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_239misc_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
}))) {
scalar(do {
my $M = $C;  $M->{text} = $$C{0}->text; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['x'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})}
}))) {
do { my $M = $C;
$C->panic("Unrecognized backslash sequence: '\\" . $M->{x}->text . "'")
; };
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_239misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_239misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_239misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_239misc_01
          dba: backslash__S_239misc
          i: 0
          min: 1
          name: backslash__S_239misc_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_239misc_01 0
              dba: backslash__S_239misc
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_meta 
                      a: 0
                      dba: backslash__S_239misc
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \W
                  min: 1
                  var: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: backslash__S_239misc
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<text> = $0.text; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_239misc_01 1
              dba: backslash__S_239misc
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_meta 
                      a: 0
                      dba: backslash__S_239misc
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \w
                  dba: backslash__S_239misc
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: x
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: "(\"Unrecognized backslash sequence: '\\\\\" ~ $<x>.text ~ \"'\")"
backslash__S_239misc_01: *1
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: "\""
RETREE_END
}
} ## end role

{ package STD::Q::p5;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'i') {
my $i = $v;  $self }
elsif ($k eq 'm') {
my $m = $v;  $self }
elsif ($k eq 's') {
my $s = $v;  $self }
elsif ($k eq 'x') {
my $x = $v;  $self }
elsif ($k eq 'p') {
my $p = $v;  $self }
elsif ($k eq 'c') {
my $c = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks
} ## end role

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}

elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->truly($q,':q'); $self->mixin( 'STD::Q::q' ); }

elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->truly($qq, ':qq'); $self->mixin( 'STD::Q::qq' ); }

elsif ($k eq 'backslash' or $k eq 'b') {
my $b = $v;  $self->mixin($b ? 'STD::Q::b1' : 'STD::Q::b0') }
elsif ($k eq 'scalar' or $k eq 's') {
my $s = $v;  $self->mixin($s ? 'STD::Q::s1' : 'STD::Q::s0') }
elsif ($k eq 'array' or $k eq 'a') {
my $a = $v;  $self->mixin($a ? 'STD::Q::a1' : 'STD::Q::a0') }
elsif ($k eq 'hash' or $k eq 'h') {
my $h = $v;  $self->mixin($h ? 'STD::Q::h1' : 'STD::Q::h0') }
elsif ($k eq 'function' or $k eq 'f') {
my $f = $v;  $self->mixin($f ? 'STD::Q::f1' : 'STD::Q::f0') }
elsif ($k eq 'closure' or $k eq 'c') {
my $c = $v;  $self->mixin($c ? 'STD::Q::c1' : 'STD::Q::c0') }

elsif ($k eq 'exec' or $k eq 'x') {
my $x = $v;  $self->mixin($x ? 'STD::Q::x1' : 'STD::Q::x0') }
elsif ($k eq 'words' or $k eq 'w') {
my $w = $v;  $self->mixin($w ? 'STD::Q::w1' : 'STD::Q::w0') }
elsif ($k eq 'quotewords' or $k eq 'ww') {
my $ww = $v;  $self->mixin($ww ? 'STD::Q::ww1' : 'STD::Q::ww0') }

elsif ($k eq 'heredoc' or $k eq 'to') {
my $to = $v;  $self->truly($to, ':to'); $self->cursor_herelang; }

elsif ($k eq 'regex') {
my $regex = $v; 
return 'STD::Q::Regex';
}

elsif ($k eq 'trans') {
my $trans = $v; 
return 'STD::Q::Trans';
}

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quote modifier: " . @k);
}
else { die 'NOMATCH' }
} # end tweaks


} ## end grammar

{ package STD::Quasi;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));##     token term__S_240unquote (:$sym is context<rw> = 'unquote')
##          token term:unquote {
##              <starter><starter><starter> <EXPR> <stopper><stopper><stopper>
##          }

sub term__S_240unquote__PEEK { $_[0]->_AUTOLEXpeek('term__S_240unquote',$retree) }
sub term__S_240unquote {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unquote';


my $C = $self;
my $S = $C->{_pos};
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_240unquote", 
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'ast') {
my $ast = $v;  $self; } # XXX some transformer operating on the normal AST?
elsif ($k eq 'lang') {
my $lang = $v;  $self->cursor_fresh( $lang ); }
elsif ($k eq 'unquote') {
my $unquote = $v;  $self; } # XXX needs to override unquote
elsif ($k eq 'COMPILING') {
my $COMPILING = $v;  $self; } # XXX needs to lazify the lexical lookups somehow

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quasiquote modifier: " . @k);
}
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
term__S_240unquote: !!perl/hash:RE 
  decl: []

  kind: token
  min: 86415
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_240unquote
    i: 0
    min: 86415
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_240unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_240unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_240unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_240unquote
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_240unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_240unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_240unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
RETREE_END
}
} ## end grammar

# Note, backtracks!  So POST must not commit to anything permanent.
## regex extrapost
##      regex extrapost {
##          :my $inquote is context = 1;
##          <POST>*
##          # XXX Shouldn't need a backslash on anything but the right square here
##          <?after <[ \] } > ) ]> > 
##      }

sub extrapost__PEEK { $_[0]->_AUTOLEXpeek('extrapost',$retree) }
sub extrapost {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::inquote =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'POST'} = [];

$self->_MATCHIFY($S, "extrapost", 
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
})
})
}, $C->_STARg(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
}))
);
}

## rule multisig
##      rule multisig {
##          [
##              ':'?'(' ~ ')' <signature>
##          ]
##          ** '|'
##      }

sub multisig__PEEK { $_[0]->_AUTOLEXpeek('multisig',$retree) }
sub multisig {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'signature'} = [];

$self->_MATCHIFY($S, "multisig", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('|')
}, sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')', 'multisig')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
}, $C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))
}, $C->ws)
})
}))
}, $C->ws)
);
}

## rule routine_def
##      rule routine_def {
##          :my $IN_DECL is context<rw> = 1;
##          [ '&'<deflongname>? | <deflongname> ]? [ <multisig> | <trait> ]*
##          <!{
##              $ = $+PARSER.bless($);
##              $IN_DECL = 0;
##          }>
##          <block>:!s
##      }

sub routine_def__PEEK { $_[0]->_AUTOLEXpeek('routine_def',$retree) }
sub routine_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "routine_def", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'routine_def_01') {
$C->deb("Fate passed to routine_def_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_def_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'routine_def_02') {
$C->deb("Fate passed to routine_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$C = $::PARSER->bless($C);
$IN_DECL = 0;

})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule method_def
##      rule method_def {
##          [
##          | <[ ! ^ ]>?<longname> [ <multisig> | <trait> ]*
##          | <multisig> <trait>*
##          | <sigil> '.'
##              :dba('subscript signature')
##              [
##              | '(' ~ ')' <signature>
##              | '[' ~ ']' <signature>
##              | '{' ~ '}' <signature>
##              | <?before '<'> <postcircumfix>
##              ]
##              <trait>*
##          | <?>
##          ]
##          <block>:!s
##      }

sub method_def__PEEK { $_[0]->_AUTOLEXpeek('method_def',$retree) }
sub method_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFY($S, "method_def", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['block'], sub {
my $C = shift;
$C->block
})
}, $C->ws)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'method_def_01') {
$C->deb("Fate passed to method_def_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[!^])?+)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'method_def_02') {
$C->deb("Fate passed to method_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
}))
}, $C->ws)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'method_def_03') {
$C->deb("Fate passed to method_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']'))
}, $C->ws)
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}'))
}, $C->ws)
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->ws)
}, $C->before(sub { my $C=shift;
$C->_EXACT('<')
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
}, $C->ws)
}, $C->_EXACT('.'))
}, $C->ws)
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->before( sub { my $C=shift;
$C
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
);
}

## rule regex_def
##      rule regex_def {
##          :my $IN_DECL is context<rw> = 1;
##          [ '&'<deflongname>? | <deflongname> ]?
##          [ [ ':'?'(' <signature> ')'] | <trait> ]*
##          { $IN_DECL = 0; }
##          <regex_block>:!s
##      }

sub regex_def__PEEK { $_[0]->_AUTOLEXpeek('regex_def',$retree) }
sub regex_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'deflongname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "regex_def", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'regex_def_01') {
$C->deb("Fate passed to regex_def_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_def_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'regex_def_02') {
$C->deb("Fate passed to regex_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$IN_DECL = 0; 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['regex_block'], sub {
my $C = shift;
$C->regex_block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule macro_def
##      rule macro_def {
##          :my $IN_DECL is context<rw> = 1;
##          [ '&'<deflongname>? | <deflongname> ]? [ <multisig> | <trait> ]*
##          <!{
##              $ = $+PARSER.bless($);
##              $IN_DECL = 0;
##          }>
##          <block>:!s
##      }

sub macro_def__PEEK { $_[0]->_AUTOLEXpeek('macro_def',$retree) }
sub macro_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "macro_def", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'macro_def_01') {
$C->deb("Fate passed to macro_def_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'macro_def_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'macro_def_02') {
$C->deb("Fate passed to macro_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'macro_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$C = $::PARSER->bless($C);
$IN_DECL = 0;

})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule trait
##      rule trait {
##          [
##          | <trait_verb>
##          | <trait_auxiliary>
##          | <colonpair>
##          ]
##      }

sub trait__PEEK { $_[0]->_AUTOLEXpeek('trait',$retree) }
sub trait {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "trait", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'trait_01') {
$C->deb("Fate passed to trait_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['trait_verb'], sub {
my $C = shift;
$C->trait_verb
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['trait_auxiliary'], sub {
my $C = shift;
$C->trait_auxiliary
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token trait_auxiliary__S_241is (:$endsym is context = 'spacey', :$sym is context<rw> = 'is')
##      token trait_auxiliary:is {
##          <sym> <.ws> <longname><postcircumfix>?
##      }

sub trait_auxiliary__S_241is__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary__S_241is',$retree) }
sub trait_auxiliary__S_241is {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'is';


my $C = $self;
my $S = $C->{_pos};
$C->{'postcircumfix'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_auxiliary__S_241is", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gis/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_auxiliary__S_242does (:$endsym is context = 'spacey', :$sym is context<rw> = 'does')
##      token trait_auxiliary:does {
##          :my $PKGDECL is context = 'role';
##          <sym> <.ws> <module_name>
##      }

sub trait_auxiliary__S_242does__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary__S_242does',$retree) }
sub trait_auxiliary__S_242does {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'does';
local $::PKGDECL =  'role';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_auxiliary__S_242does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_auxiliary__S_243will (:$endsym is context = 'spacey', :$sym is context<rw> = 'will')
##      token trait_auxiliary:will {
##          <sym> <.ws> <identifier> <.ws> <block>
##      }

sub trait_auxiliary__S_243will__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary__S_243will',$retree) }
sub trait_auxiliary__S_243will {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'will';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_auxiliary__S_243will", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwill/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule trait_verb__S_244of (:$endsym is context = 'spacey', :$sym is context<rw> = 'of')
##      rule trait_verb:of      {<sym> <fulltypename> }

sub trait_verb__S_244of__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_244of',$retree) }
sub trait_verb__S_244of {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'of';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_244of", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gof/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule trait_verb__S_245as (:$endsym is context = 'spacey', :$sym is context<rw> = 'as')
##      rule trait_verb:as      {<sym> <fulltypename> }

sub trait_verb__S_245as__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_245as',$retree) }
sub trait_verb__S_245as {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'as';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_245as", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gas/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule trait_verb__S_246returns (:$endsym is context = 'spacey', :$sym is context<rw> = 'returns')
##      rule trait_verb:returns {<sym> <fulltypename> }

sub trait_verb__S_246returns__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_246returns',$retree) }
sub trait_verb__S_246returns {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'returns';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_246returns", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Greturns/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule trait_verb__S_247handles (:$endsym is context = 'spacey', :$sym is context<rw> = 'handles')
##      rule trait_verb:handles {<sym> <EXPR> }

sub trait_verb__S_247handles__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_247handles',$retree) }
sub trait_verb__S_247handles {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'handles';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_247handles", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghandles/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token capterm
##      token capterm {
##          '\\'
##          [
##          | '(' <capture>? ')'
##          | <?before \S> <termish>
##          ]
##      }

sub capterm__PEEK { $_[0]->_AUTOLEXpeek('capterm',$retree) }
sub capterm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'capture'} = [];

$self->_MATCHIFYr($S, "capterm", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'capterm_01') {
$C->deb("Fate passed to capterm_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'capterm_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("capterm_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['capture'], sub {
my $C = shift;
$C->capture
})
}))) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## rule capture
##      rule capture {
##          :my $INVOCANT_OK is context<rw> = 1;
##          <EXPR>
##      }

sub capture__PEEK { $_[0]->_AUTOLEXpeek('capture',$retree) }
sub capture {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK =  1;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "capture", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token sigterm
##      token sigterm {
##          ':(' ~ ')' <signature>
##      }

sub sigterm__PEEK { $_[0]->_AUTOLEXpeek('sigterm',$retree) }
sub sigterm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "sigterm", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'sigterm')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT(':('))
);
}

## rule param_sep
##      rule param_sep { [','|':'|';'|';;'] }

sub param_sep__PEEK { $_[0]->_AUTOLEXpeek('param_sep',$retree) }
sub param_sep {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "param_sep", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'param_sep_01') {
$C->deb("Fate passed to param_sep_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'param_sep_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_sep_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT(':')
},
sub { my $C=shift;
$C->_EXACT(';')
},
sub { my $C=shift;
$C->_EXACT(';;')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token signature
##      token signature {
##          # XXX incorrectly scopes &infix:<x> parameters to outside following block
##          :my $IN_DECL is context<rw> = 1;
##          :my $zone is context<rw> = 'posreq';
##          <.ws>
##          [
##          | <?before '-->' | ')' | ']' | '{' | ':'<!before ':' > >
##          | <parameter>
##          ] ** <param_sep>
##          <.ws>
##          [ '-->' <.ws> <fulltypename> ]?
##          { $IN_DECL = 0; $+SIGIL = '@' }
##      }

sub signature__PEEK { $_[0]->_AUTOLEXpeek('signature',$retree) }
sub signature {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL =  1;
local $::zone =  'posreq';


my $C = $self;
my $S = $C->{_pos};
$C->{'parameter'} = [];
$C->{'param_sep'} = [];
$C->{'fulltypename'} = [];

$self->_MATCHIFYr($S, "signature", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_SUBSUMEr(['param_sep'], sub {
my $C = shift;
$C->param_sep
})
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'signature_01') {
$C->deb("Fate passed to signature_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'signature_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'signature_02') {
$C->deb("Fate passed to signature_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'signature_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('-->')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(':')
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
},
sub { my $C=shift;
$C->_SUBSUMEr(['parameter'], sub {
my $C = shift;
$C->parameter
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-->'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {
$IN_DECL = 0; $::SIGIL = '@' 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token type_declarator__S_248subset (:$sym is context<rw> = 'subset')
##      token type_declarator:subset {
##          <sym> :s
##          <longname> { $.add_type($<longname>.text); }
##          [ of <fulltypename> ]?
##          [where <EXPR(item %chaining)> ]?    # (EXPR can parse multiple where clauses)
##      }

sub type_declarator__S_248subset__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_248subset',$retree) }
sub type_declarator__S_248subset {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'subset';


my $C = $self;
my $S = $C->{_pos};
$C->{'fulltypename'} = [];
$C->{'EXPR'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "type_declarator__S_248subset", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubset/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $C->add_type($M->{longname}->text); ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('of'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token type_declarator__S_249enum (:$sym is context<rw> = 'enum')
##      token type_declarator:enum {
##          :my $l;
##          <sym> <.ws>
##          [ $l = <longname> :: { $.add_type($l.text); } <.ws> ]?
##          <EXPR> <.ws>
##      }

sub type_declarator__S_249enum__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_249enum',$retree) }
sub type_declarator__S_249enum {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'enum';
my $l;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "type_declarator__S_249enum", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, scalar(do {
$C->add_type($l->text); 
}, $C))
}, $C->_COMMITBRANCH())
}, ($l = $C->longname))
})
}))
}, $C->ws)
}, $C->_PATTERN(qr/\Genum/))
);
}

## rule type_constraint
##      rule type_constraint {
##          [
##          | <value>
##          | <fulltypename>
##          | where <EXPR(item %chaining)>
##          ]
##      }

sub type_constraint__PEEK { $_[0]->_AUTOLEXpeek('type_constraint',$retree) }
sub type_constraint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "type_constraint", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'type_constraint_01') {
$C->deb("Fate passed to type_constraint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'type_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule post_constraint
##      rule post_constraint {
##          [
##          | '[' ~ ']' <signature>
##          | '(' ~ ')' <signature>
##          | where <EXPR(item %chaining)>
##          ]
##      }

sub post_constraint__PEEK { $_[0]->_AUTOLEXpeek('post_constraint',$retree) }
sub post_constraint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "post_constraint", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'post_constraint_01') {
$C->deb("Fate passed to post_constraint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'post_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("post_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']', 'post_constraint')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']'))
}, $C->ws)
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')', 'post_constraint')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))
}, $C->ws)
}, $C->_EXACT('where'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
);
}

## token named_param
##      token named_param {
##          :my $GOAL is context = ')';
##          ':'
##          [
##          | <name=identifier> '(' <.ws>
##              [ <named_param> | <param_var> <.ws> ]
##              [ ')' || <.panic: "Unable to parse named parameter; couldn't find right parenthesis"> ]
##          | <param_var>
##          ]
##      }

sub named_param__PEEK { $_[0]->_AUTOLEXpeek('named_param',$retree) }
sub named_param {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL =  ')';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "named_param", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'named_param_01') {
$C->deb("Fate passed to named_param_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'named_param_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'named_param_02') {
$C->deb("Fate passed to named_param_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'named_param_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Unable to parse named parameter; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token param_var
##      token param_var {
##          [
##          | '[' ~ ']' <signature>
##          | '(' ~ ')' <signature>
##          | <sigil> <twigil>?
##              [
##                  # Is it a longname declaration?
##              || <?{ $<sigil>.text eq '&' }> <?ident> {}
##                  <identifier=sublongname>
##      
##              ||  # Is it a shaped array or hash declaration?
##                  <?{ $<sigil>.text eq '@' || $<sigil>.text eq '%' }>
##                  <identifier>?
##                  <?before <[ \< \( \[ \{ ]> >
##                  <postcircumfix>
##      
##                  # ordinary parameter name
##              || <identifier>
##              || <[/!]>
##      
##                  # bare sigil?
##              ]?
##          ]
##      }

sub param_var__PEEK { $_[0]->_AUTOLEXpeek('param_var',$retree) }
sub param_var {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'identifier'} = [];
$C->{'twigil'} = [];
$C->{'postcircumfix'} = [];

$self->_MATCHIFY($S, "param_var", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'param_var_01') {
$C->deb("Fate passed to param_var_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'param_var_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_var_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'param_var')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'param_var')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['identifier'], sub {
my $C = shift;
$C->sublongname
})
}, scalar(do {

}, $C))
}, $C->before( sub { my $C=shift;
$C->ident
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{sigil}->text eq '&' ;
})
}))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\<\(\[\{]/)
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['identifier'], sub {
my $C = shift;
$C->identifier
})
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{sigil}->text eq '@' || $M->{sigil}->text eq '%' ;
})
}))} 
or
eval { push @gather, $C->_SUBSUME(['identifier'], sub {
my $C = shift;
$C->identifier
})} 
or
eval { push @gather, $C->_PATTERN(qr/\G[\/!]/)} or do { die $@ if $@ };
@gather;
}
})
})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token parameter
##      token parameter {
##          :my $kind;
##          :my $quant = '';
##          :my $q;
##      
##          # XXX fake out LTM till we get * working right
##          <?before
##              [
##              | <type_constraint>
##              | <param_var>
##              | '*' <param_var>
##              | '|' <param_var>
##              | '\\' <param_var>
##              | <named_param>
##              ]
##          >
##      
##          <type_constraint>*
##          [
##          | '*' <param_var>   { $quant = '*'; $kind = '*'; }
##          | '|' <param_var>   { $quant = '|'; $kind = '*'; }
##          | '\\' <param_var>  { $quant = '\\'; $kind = '!'; }
##          |   [
##              | <param_var>   { $quant = ''; $kind = '!'; }
##              | <named_param> { $quant = ''; $kind = '*'; }
##              ]
##              [
##              | '?'           { $quant = '?'; $kind = '?' }
##              | '!'           { $quant = '!'; $kind = '!' }
##              | <?>
##              ]
##          | <?>               { $quant = ''; $kind = '!'; }
##          ]
##      
##          <trait>*
##      
##          <post_constraint>*
##      
##          [
##              <default_value> {{
##                  given $quant {
##                    when '!' { $.panic("Can't put a default on a required parameter") }
##                    when '*' { $.panic("Can't put a default on a slurpy parameter") }
##                    when '|' { $.panic("Can't put a default on an slurpy capture parameter") }
##                    when '\\' { $.panic("Can't put a default on a capture parameter") }
##                  }
##                  $kind = '?';
##              }}
##          ]?
##      
##          {
##              $<quant> = $quant;
##              $<kind> = $kind;
##          }
##      
##          # enforce zone constraints
##          {{
##              given $kind {
##                  when '!' {
##                      given $+zone {
##                          when 'posopt' {
##      $.panic("Can't put required parameter after optional parameters");
##                          }
##                          when 'var' {
##      $.panic("Can't put required parameter after variadic parameters");
##                          }
##                      }
##                  }
##                  when '?' {
##                      given $+zone {
##                          when 'posreq' { $+zone = 'posopt' }
##                          when 'var' {
##      $.panic("Can't put optional positional parameter after variadic parameters");
##                          }
##                      }
##                  }
##                  when '*' {
##                      $+zone = 'var';
##                  }
##              }
##          }}
##      }

sub parameter__PEEK { $_[0]->_AUTOLEXpeek('parameter',$retree) }
sub parameter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $kind;
my $quant = '';
my $q;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];
$C->{'default_value'} = [];
$C->{'post_constraint'} = [];
$C->{'type_constraint'} = [];

$self->_MATCHIFYr($S, "parameter", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_02') {
$C->deb("Fate passed to parameter_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('\\'))) {
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_03') {
$C->deb("Fate passed to parameter_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\'; $kind = '!'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_04') {
$C->deb("Fate passed to parameter_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = ''; $kind = '*'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_05') {
$C->deb("Fate passed to parameter_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('?'))) {
scalar(do {
$quant = '?'; $kind = '?' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
scalar(do {
$quant = '!'; $kind = '!' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['default_value'], sub {
my $C = shift;
$C->default_value
}))) {
scalar(do {

do { my $_ = $quant; if ((0)) {}
elsif ($_ eq '!') { $C->panic("Can't put a default on a required parameter") }
elsif ($_ eq '*') { $C->panic("Can't put a default on a slurpy parameter") }
elsif ($_ eq '|') { $C->panic("Can't put a default on an slurpy capture parameter") }
elsif ($_ eq '\\') { $C->panic("Can't put a default on a capture parameter") }
};
$kind = '?';

}, $C);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$M->{quant} = $quant;
$M->{kind} = $kind;
;
}, $C))) {
scalar(do {

do { my $_ = $kind; if ((0)) {}
elsif ($_ eq '!') {
do { my $_ = $::zone; if ((0)) {}
elsif ($_ eq 'posopt') {
$C->panic("Can't put required parameter after optional parameters");
}
elsif ($_ eq 'var') {
$C->panic("Can't put required parameter after variadic parameters");
}
};
}
elsif ($_ eq '?') {
do { my $_ = $::zone; if ((0)) {}
elsif ($_ eq 'posreq') { $::zone = 'posopt' }
elsif ($_ eq 'var') {
$C->panic("Can't put optional positional parameter after variadic parameters");
}
};
}
elsif ($_ eq '*') {
$::zone = 'var';
}
};

}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule default_value
##      rule default_value {
##          '=' <EXPR(item %item_assignment)>
##      }

sub default_value__PEEK { $_[0]->_AUTOLEXpeek('default_value',$retree) }
sub default_value {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "default_value", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_prefix__S_250do (:$sym is context<rw> = 'do')
##      token statement_prefix:do      { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_250do__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_250do',$retree) }
sub statement_prefix__S_250do {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'do';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_250do", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdo/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_251try (:$sym is context<rw> = 'try')
##      token statement_prefix:try     { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_251try__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_251try',$retree) }
sub statement_prefix__S_251try {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'try';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_251try", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtry/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_252gather (:$sym is context<rw> = 'gather')
##      token statement_prefix:gather  { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_252gather__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_252gather',$retree) }
sub statement_prefix__S_252gather {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'gather';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_252gather", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggather/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_253contend (:$sym is context<rw> = 'contend')
##      token statement_prefix:contend { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_253contend__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_253contend',$retree) }
sub statement_prefix__S_253contend {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'contend';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_253contend", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gcontend/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_254async (:$sym is context<rw> = 'async')
##      token statement_prefix:async   { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_254async__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_254async',$retree) }
sub statement_prefix__S_254async {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'async';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_254async", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gasync/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_255maybe (:$sym is context<rw> = 'maybe')
##      token statement_prefix:maybe   { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_255maybe__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_255maybe',$retree) }
sub statement_prefix__S_255maybe {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'maybe';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_255maybe", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmaybe/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_256lazy (:$sym is context<rw> = 'lazy')
##      token statement_prefix:lazy    { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_256lazy__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_256lazy',$retree) }
sub statement_prefix__S_256lazy {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lazy';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_256lazy", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glazy/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## term

## token term__S_257ColonColonQuestionIDENT (  :$sym is context<rw> = <::?IDENT> --> Term)
##      token term:sym<::?IDENT> ( --> Term) {
##          $<sym> = [ '::?' <identifier> ] 
##      }

sub term__S_257ColonColonQuestionIDENT__PEEK { $_[0]->_AUTOLEXpeek('term__S_257ColonColonQuestionIDENT',$retree) }
sub term__S_257ColonColonQuestionIDENT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::?IDENT);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_257ColonColonQuestionIDENT",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token term__S_258undef (  :$sym is context<rw> = <undef> --> Term)
##      token term:sym<undef> ( --> Term) {
##          <sym> 
##          [ <?before \h*'$/' >
##              <.obs('$/ variable as input record separator',
##                   "the filehandle's .slurp method")>
##          ]?
##          [ <?before \h*<variable> >
##              <.obs('undef as a verb', 'undefine function')>
##          ]?
##      }

sub term__S_258undef__PEEK { $_[0]->_AUTOLEXpeek('term__S_258undef',$retree) }
sub term__S_258undef {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(undef);


my $C = $self;
my $S = $C->{_pos};
$C->{'variable'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_258undef",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gundef/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_EXACT('$/');
}
else {
();
}
}
}))) {
$C->obs('$/ variable as input record separator',
"the filehandle's .slurp method");
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
});
}
else {
();
}
}
}))) {
$C->obs('undef as a verb', 'undefine function');
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_259continue (  :$sym is context<rw> = <continue> --> Term)
##      token term:sym<continue> ( --> Term)
##          { <sym>  }

sub term__S_259continue__PEEK { $_[0]->_AUTOLEXpeek('term__S_259continue',$retree) }
sub term__S_259continue {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(continue);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_259continue",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gcontinue\b/)
);
}

## token term__S_260self (  :$sym is context<rw> = <self> --> Term)
##      token term:sym<self> ( --> Term)
##          { <sym>  }

sub term__S_260self__PEEK { $_[0]->_AUTOLEXpeek('term__S_260self',$retree) }
sub term__S_260self {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(self);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_260self",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gself\b/)
);
}

## token term__S_261defer (  :$sym is context<rw> = <defer> --> Term)
##      token term:sym<defer> ( --> Term)
##          { <sym>  }

sub term__S_261defer__PEEK { $_[0]->_AUTOLEXpeek('term__S_261defer',$retree) }
sub term__S_261defer {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(defer);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_261defer",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gdefer\b/)
);
}

## token term__S_262rand (  :$sym is context<rw> = 'rand' --> Term)
##      token term:rand ( --> Term)
##          { <sym>  [ <?before \h+ [\d|'$']> <.obs('rand(N)', 'N.rand or (1..N).pick')> ]? }

sub term__S_262rand__PEEK { $_[0]->_AUTOLEXpeek('term__S_262rand',$retree) }
sub term__S_262rand {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rand';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_262rand",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grand/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'term__S_262rand_03') {
$C->deb("Fate passed to term__S_262rand_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_262rand_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_262rand_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub { my $C=shift;
$C->_EXACT('$')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
}))) {
$C->obs('rand(N)', 'N.rand or (1..N).pick');
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_263e (  :$sym is context<rw> = 'e' --> Term)
##      token term:e ( --> Term)
##          { <sym>  }

sub term__S_263e__PEEK { $_[0]->_AUTOLEXpeek('term__S_263e',$retree) }
sub term__S_263e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_263e",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Ge\b/)
);
}

## token term__S_264i (  :$sym is context<rw> = 'i' --> Term)
##      token term:i ( --> Term)
##          { <sym>  }

sub term__S_264i__PEEK { $_[0]->_AUTOLEXpeek('term__S_264i',$retree) }
sub term__S_264i {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'i';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_264i",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gi\b/)
);
}

## token term__S_265pi (  :$sym is context<rw> = 'pi' --> Term)
##      token term:pi ( --> Term)
##          { <sym>  }

sub term__S_265pi__PEEK { $_[0]->_AUTOLEXpeek('term__S_265pi',$retree) }
sub term__S_265pi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'pi';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_265pi",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gpi\b/)
);
}

## token term__S_266Inf (  :$sym is context<rw> = 'Inf' --> Term)
##      token term:Inf ( --> Term)
##          { <sym>  }

sub term__S_266Inf__PEEK { $_[0]->_AUTOLEXpeek('term__S_266Inf',$retree) }
sub term__S_266Inf {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Inf';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_266Inf",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\GInf\b/)
);
}

## token term__S_267NaN (  :$sym is context<rw> = 'NaN' --> Term)
##      token term:NaN ( --> Term)
##          { <sym>  }

sub term__S_267NaN__PEEK { $_[0]->_AUTOLEXpeek('term__S_267NaN',$retree) }
sub term__S_267NaN {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'NaN';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_267NaN",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\GNaN\b/)
);
}

## token term__S_268Star (  :$sym is context<rw> = <*> --> Term)
##      token term:sym<*> ( --> Term)
##          { <sym> }

sub term__S_268Star__PEEK { $_[0]->_AUTOLEXpeek('term__S_268Star',$retree) }
sub term__S_268Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_268Star",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\G\*/)
);
}

## token term__S_269StarStar (  :$sym is context<rw> = <**> --> Term)
##      token term:sym<**> ( --> Term)
##          { <sym> }

sub term__S_269StarStar__PEEK { $_[0]->_AUTOLEXpeek('term__S_269StarStar',$retree) }
sub term__S_269StarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_269StarStar",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\G\*\*/)
);
}

## token circumfix__S_270sigil (  :$sym is context<rw> = 'sigil' --> Term)
##      token circumfix:sigil ( --> Term)
##          { :dba('contextualizer') <sigil> '(' ~ ')' <semilist> { $+SIGIL ||= $<sigil>.text } }

sub circumfix__S_270sigil__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_270sigil',$retree) }
sub circumfix__S_270sigil {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_270sigil",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $::SIGIL ||= $M->{sigil}->text ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'contextualizer')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
);
}

#token circumfix:typecast ( --> Term)
#    { <typename> '(' ~ ')' <semilist> }

## token circumfix__S_271Paren_Thesis (  :$sym is context<rw> = <( )> --> Term)
##      token circumfix:sym<( )> ( --> Term)
##          { :dba('parenthesized expression') '(' ~ ')' <semilist> }

sub circumfix__S_271Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_271Paren_Thesis',$retree) }
sub circumfix__S_271Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_271Paren_Thesis",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'parenthesized expression')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

## token circumfix__S_272Bra_Ket (  :$sym is context<rw> = <[ ]> --> Term)
##      token circumfix:sym<[ ]> ( --> Term)
##          { :dba('array composer') '[' ~ ']' <semilist> }

sub circumfix__S_272Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_272Bra_Ket',$retree) }
sub circumfix__S_272Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_272Bra_Ket",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'array composer')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
);
}

## methodcall

## token postfix__S_273i (  :$sym is context<rw> = <i> --> Methodcall)
##      token postfix:sym<i> ( --> Methodcall)
##          { <sym>  }

sub postfix__S_273i__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_273i',$retree) }
sub postfix__S_273i {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_273i",  map { STD::Methodcall->coerce($_) } 
$C->_PATTERN(qr/\Gi\b/)
);
}

## token infix__S_274Dot (:$sym is context<rw> = <.>)
##      token infix:sym<.> ()
##          { '.' <[\]\)\},:\s\$"']> <.obs('. to concatenate strings', '~')> }

sub infix__S_274Dot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_274Dot',$retree) }
sub infix__S_274Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_274Dot", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\]\)\},:\s\$"']/))) {
$C->obs('. to concatenate strings', '~');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postfix__S_275MinusGt (:$sym is context<rw> = ['->'])
##      token postfix:sym['->'] ()
##          { '->' <.obs('-> to call a method', '.')> }

sub postfix__S_275MinusGt__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_275MinusGt',$retree) }
sub postfix__S_275MinusGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // ['->'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_275MinusGt", 
do {
if (my ($C) = ($C->_EXACT('->'))) {
$C->obs('-> to call a method', '.');
}
else {
();
}
}
);
}

## autoincrement
## token postfix__S_276PlusPlus (  :$sym is context<rw> = <++> --> Autoincrement)
##      token postfix:sym<++> ( --> Autoincrement)
##          { <sym> }

sub postfix__S_276PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_276PlusPlus',$retree) }
sub postfix__S_276PlusPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(++);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_276PlusPlus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\+\+/)
);
}

## token postfix__S_277MinusMinus (  :$sym is context<rw> = <--> --> Autoincrement)
##      token postfix:sym<--> ( --> Autoincrement)
##          { <sym> }

sub postfix__S_277MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_277MinusMinus',$retree) }
sub postfix__S_277MinusMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(--);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_277MinusMinus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\-\-/)
);
}

## token prefix__S_278PlusPlus (  :$sym is context<rw> = <++> --> Autoincrement)
##      token prefix:sym<++> ( --> Autoincrement)
##          { <sym> }

sub prefix__S_278PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_278PlusPlus',$retree) }
sub prefix__S_278PlusPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(++);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_278PlusPlus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\+\+/)
);
}

## token prefix__S_279MinusMinus (  :$sym is context<rw> = <--> --> Autoincrement)
##      token prefix:sym<--> ( --> Autoincrement)
##          { <sym> }

sub prefix__S_279MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_279MinusMinus',$retree) }
sub prefix__S_279MinusMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(--);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_279MinusMinus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\-\-/)
);
}

## exponentiation
## token infix__S_280StarStar (  :$sym is context<rw> = <**> --> Exponentiation)
##      token infix:sym<**> ( --> Exponentiation)
##          { <sym> }

sub infix__S_280StarStar__PEEK { $_[0]->_AUTOLEXpeek('infix__S_280StarStar',$retree) }
sub infix__S_280StarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_280StarStar",  map { STD::Exponentiation->coerce($_) } 
$C->_PATTERN(qr/\G\*\*/)
);
}

## symbolic unary
## token prefix__S_281Bang (  :$sym is context<rw> = <!> --> Symbolic_unary)
##      token prefix:sym<!> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_281Bang__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_281Bang',$retree) }
sub prefix__S_281Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_281Bang",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\!/)
);
}

## token prefix__S_282Plus (  :$sym is context<rw> = <+> --> Symbolic_unary)
##      token prefix:sym<+> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_282Plus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_282Plus',$retree) }
sub prefix__S_282Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_282Plus",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\+/)
);
}

## token prefix__S_283Minus (  :$sym is context<rw> = <-> --> Symbolic_unary)
##      token prefix:sym<-> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_283Minus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_283Minus',$retree) }
sub prefix__S_283Minus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_283Minus",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\-/)
);
}

## token prefix__S_284Tilde (  :$sym is context<rw> = <~> --> Symbolic_unary)
##      token prefix:sym<~> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_284Tilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_284Tilde',$retree) }
sub prefix__S_284Tilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_284Tilde",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}

## token prefix__S_285Question (  :$sym is context<rw> = <?> --> Symbolic_unary)
##      token prefix:sym<?> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_285Question__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_285Question',$retree) }
sub prefix__S_285Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_285Question",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\?/)
);
}

## token prefix__S_286Equal (  :$sym is context<rw> = <=> --> Symbolic_unary)
##      token prefix:sym<=> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_286Equal__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_286Equal',$retree) }
sub prefix__S_286Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_286Equal",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\=/)
);
}

## token prefix__S_287TildeCaret (  :$sym is context<rw> = <~^> --> Symbolic_unary)
##      token prefix:sym<~^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_287TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_287TildeCaret',$retree) }
sub prefix__S_287TildeCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_287TildeCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\~\^/)
);
}

## token prefix__S_288PlusCaret (  :$sym is context<rw> = <+^> --> Symbolic_unary)
##      token prefix:sym<+^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_288PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_288PlusCaret',$retree) }
sub prefix__S_288PlusCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_288PlusCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\+\^/)
);
}

## token prefix__S_289QuestionCaret (  :$sym is context<rw> = <?^> --> Symbolic_unary)
##      token prefix:sym<?^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_289QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_289QuestionCaret',$retree) }
sub prefix__S_289QuestionCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_289QuestionCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\?\^/)
);
}

## token prefix__S_290Caret (  :$sym is context<rw> = <^> --> Symbolic_unary)
##      token prefix:sym<^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_290Caret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_290Caret',$retree) }
sub prefix__S_290Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_290Caret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\^/)
);
}

## token prefix__S_291Vert (  :$sym is context<rw> = <|> --> Symbolic_unary)
##      token prefix:sym<|> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_291Vert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_291Vert',$retree) }
sub prefix__S_291Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_291Vert",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}


## multiplicative
## token infix__S_292Star (  :$sym is context<rw> = <*> --> Multiplicative)
##      token infix:sym<*> ( --> Multiplicative)
##          { <sym> }

sub infix__S_292Star__PEEK { $_[0]->_AUTOLEXpeek('infix__S_292Star',$retree) }
sub infix__S_292Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_292Star",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\*/)
);
}

## token infix__S_293Slash (  :$sym is context<rw> = </> --> Multiplicative)
##      token infix:sym</> ( --> Multiplicative)
##          { <sym> }

sub infix__S_293Slash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_293Slash',$retree) }
sub infix__S_293Slash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(/);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_293Slash",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\//)
);
}

## token infix__S_294div (  :$sym is context<rw> = <div> --> Multiplicative)
##      token infix:sym<div> ( --> Multiplicative)
##          { <sym> }

sub infix__S_294div__PEEK { $_[0]->_AUTOLEXpeek('infix__S_294div',$retree) }
sub infix__S_294div {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(div);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_294div",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\Gdiv/)
);
}

## token infix__S_295Percent (  :$sym is context<rw> = <%> --> Multiplicative)
##      token infix:sym<%> ( --> Multiplicative)
##          { <sym> <?{ $<O><returns> = 'Bool'; }> }

sub infix__S_295Percent__PEEK { $_[0]->_AUTOLEXpeek('infix__S_295Percent',$retree) }
sub infix__S_295Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_295Percent",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\%/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{returns} = 'Bool'; ;
})
});
}
else {
();
}
}
);
}   # Allow !% operator

## token infix__S_296mod (  :$sym is context<rw> = <mod> --> Multiplicative)
##      token infix:sym<mod> ( --> Multiplicative)
##          { <sym> }

sub infix__S_296mod__PEEK { $_[0]->_AUTOLEXpeek('infix__S_296mod',$retree) }
sub infix__S_296mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(mod);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_296mod",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\Gmod/)
);
}

## token infix__S_297PlusAmp (  :$sym is context<rw> = <+&> --> Multiplicative)
##      token infix:sym<+&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_297PlusAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_297PlusAmp',$retree) }
sub infix__S_297PlusAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_297PlusAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\+\&/)
);
}

## token infix__S_298PlusLt (  :$sym is context<rw> =  +<  --> Multiplicative)
##      token infix:sym +<  ( --> Multiplicative)
##          { <sym> <!before '<'> }

sub infix__S_298PlusLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_298PlusLt',$retree) }
sub infix__S_298PlusLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['+<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_298PlusLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\</))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('<')
})
});
}
else {
();
}
}
);
}

## token infix__S_299LtLt (  :$sym is context<rw> =  <<  --> Multiplicative)
##      token infix:sym <<  ( --> Multiplicative)
##          { <sym> \s <.obs('<< to do left shift', '+< or ~<')> }

sub infix__S_299LtLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_299LtLt',$retree) }
sub infix__S_299LtLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_299LtLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\</))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('<< to do left shift', '+< or ~<');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_300GtGt (  :$sym is context<rw> =  >>  --> Multiplicative)
##      token infix:sym >>  ( --> Multiplicative)
##          { <sym> \s <.obs('>> to do right shift', '+> or ~>')> }

sub infix__S_300GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_300GtGt',$retree) }
sub infix__S_300GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_300GtGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>\>/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('>> to do right shift', '+> or ~>');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_301PlusGt (  :$sym is context<rw> =  +>  --> Multiplicative)
##      token infix:sym +>  ( --> Multiplicative)
##          { <sym> <!before '>'> }

sub infix__S_301PlusGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_301PlusGt',$retree) }
sub infix__S_301PlusGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['+>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_301PlusGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\>/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
});
}
else {
();
}
}
);
}

## token infix__S_302TildeAmp (  :$sym is context<rw> = <~&> --> Multiplicative)
##      token infix:sym<~&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_302TildeAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_302TildeAmp',$retree) }
sub infix__S_302TildeAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_302TildeAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\~\&/)
);
}

## token infix__S_303QuestionAmp (  :$sym is context<rw> = <?&> --> Multiplicative)
##      token infix:sym<?&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_303QuestionAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_303QuestionAmp',$retree) }
sub infix__S_303QuestionAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_303QuestionAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\?\&/)
);
}

## token infix__S_304TildeLt (  :$sym is context<rw> =  ~<  --> Multiplicative)
##      token infix:sym ~<  ( --> Multiplicative)
##          { <sym> <!before '<'> }

sub infix__S_304TildeLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_304TildeLt',$retree) }
sub infix__S_304TildeLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['~<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_304TildeLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\</))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('<')
})
});
}
else {
();
}
}
);
}

## token infix__S_305TildeGt (  :$sym is context<rw> =  ~>  --> Multiplicative)
##      token infix:sym ~>  ( --> Multiplicative)
##          { <sym> <!before '>'> }

sub infix__S_305TildeGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_305TildeGt',$retree) }
sub infix__S_305TildeGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['~>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_305TildeGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\>/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
});
}
else {
();
}
}
);
}


## additive
## token infix__S_306Plus (  :$sym is context<rw> = <+> --> Additive)
##      token infix:sym<+> ( --> Additive)
##          { <sym> }

sub infix__S_306Plus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_306Plus',$retree) }
sub infix__S_306Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_306Plus",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+/)
);
}

## token infix__S_307Minus (  :$sym is context<rw> = <-> --> Additive)
##      token infix:sym<-> ( --> Additive)
##          { <sym> }

sub infix__S_307Minus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_307Minus',$retree) }
sub infix__S_307Minus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_307Minus",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\-/)
);
}

## token infix__S_308PlusVert (  :$sym is context<rw> = <+|> --> Additive)
##      token infix:sym<+|> ( --> Additive)
##          { <sym> }

sub infix__S_308PlusVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_308PlusVert',$retree) }
sub infix__S_308PlusVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_308PlusVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+\|/)
);
}

## token infix__S_309PlusCaret (  :$sym is context<rw> = <+^> --> Additive)
##      token infix:sym<+^> ( --> Additive)
##          { <sym> }

sub infix__S_309PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_309PlusCaret',$retree) }
sub infix__S_309PlusCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_309PlusCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+\^/)
);
}

## token infix__S_310TildeVert (  :$sym is context<rw> = <~|> --> Additive)
##      token infix:sym<~|> ( --> Additive)
##          { <sym> }

sub infix__S_310TildeVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_310TildeVert',$retree) }
sub infix__S_310TildeVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_310TildeVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~\|/)
);
}

## token infix__S_311TildeCaret (  :$sym is context<rw> = <~^> --> Additive)
##      token infix:sym<~^> ( --> Additive)
##          { <sym> }

sub infix__S_311TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_311TildeCaret',$retree) }
sub infix__S_311TildeCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_311TildeCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~\^/)
);
}

## token infix__S_312QuestionVert (  :$sym is context<rw> = <?|> --> Additive)
##      token infix:sym<?|> ( --> Additive)
##          { <sym> }

sub infix__S_312QuestionVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_312QuestionVert',$retree) }
sub infix__S_312QuestionVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_312QuestionVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\?\|/)
);
}

## token infix__S_313QuestionCaret (  :$sym is context<rw> = <?^> --> Additive)
##      token infix:sym<?^> ( --> Additive)
##          { <sym> }

sub infix__S_313QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_313QuestionCaret',$retree) }
sub infix__S_313QuestionCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_313QuestionCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\?\^/)
);
}

## replication
# Note: no word boundary check after x, relies on longest token for x2 xx2 etc
## token infix__S_314x (  :$sym is context<rw> = <x> --> Replication)
##      token infix:sym<x> ( --> Replication)
##          { <sym> }

sub infix__S_314x__PEEK { $_[0]->_AUTOLEXpeek('infix__S_314x',$retree) }
sub infix__S_314x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(x);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_314x",  map { STD::Replication->coerce($_) } 
$C->_PATTERN(qr/\Gx/)
);
}

## token infix__S_315xx (  :$sym is context<rw> = <xx> --> Replication)
##      token infix:sym<xx> ( --> Replication)
##          { <sym> }

sub infix__S_315xx__PEEK { $_[0]->_AUTOLEXpeek('infix__S_315xx',$retree) }
sub infix__S_315xx {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(xx);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_315xx",  map { STD::Replication->coerce($_) } 
$C->_PATTERN(qr/\Gxx/)
);
}

## concatenation
## token infix__S_316Tilde (  :$sym is context<rw> = <~> --> Concatenation)
##      token infix:sym<~> ( --> Concatenation)
##          { <sym> }

sub infix__S_316Tilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_316Tilde',$retree) }
sub infix__S_316Tilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_316Tilde",  map { STD::Concatenation->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}


## junctive and (all)
## token infix__S_317Amp (  :$sym is context<rw> = <&> --> Junctive_and)
##      token infix:sym<&> ( --> Junctive_and)
##          { <sym> }

sub infix__S_317Amp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_317Amp',$retree) }
sub infix__S_317Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_317Amp",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\G\&/)
);
}

## token infix__S_318also (  :$sym is context<rw> = <also> --> Junctive_and)
##      token infix:sym<also> ( --> Junctive_and)
##          { <sym> }

sub infix__S_318also__PEEK { $_[0]->_AUTOLEXpeek('infix__S_318also',$retree) }
sub infix__S_318also {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(also);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_318also",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\Galso/)
);
}


## junctive or (any)
## token infix__S_319Vert (  :$sym is context<rw> = <|> --> Junctive_or)
##      token infix:sym<|> ( --> Junctive_or)
##          { <sym> }

sub infix__S_319Vert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_319Vert',$retree) }
sub infix__S_319Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_319Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}

## token infix__S_320Caret (  :$sym is context<rw> = <^> --> Junctive_or)
##      token infix:sym<^> ( --> Junctive_or)
##          { <sym> }

sub infix__S_320Caret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_320Caret',$retree) }
sub infix__S_320Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_320Caret",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\^/)
);
}


## named unary examples
# (need \s* to win LTM battle with listops)
## token prefix__S_321sleep (  :$sym is context<rw> = 'sleep' --> Named_unary)
##      token prefix:sleep ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_321sleep__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_321sleep',$retree) }
sub prefix__S_321sleep {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sleep';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_321sleep",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsleep/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_322abs (  :$sym is context<rw> = 'abs' --> Named_unary)
##      token prefix:abs ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_322abs__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_322abs',$retree) }
sub prefix__S_322abs {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'abs';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_322abs",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gabs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_323int (  :$sym is context<rw> = 'int' --> Named_unary)
##      token prefix:int ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_323int__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_323int',$retree) }
sub prefix__S_323int {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'int';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_323int",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gint/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_324let (  :$sym is context<rw> = 'let' --> Named_unary)
##      token prefix:let ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_324let__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_324let',$retree) }
sub prefix__S_324let {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'let';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_324let",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glet/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_325temp (  :$sym is context<rw> = 'temp' --> Named_unary)
##      token prefix:temp ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_325temp__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_325temp',$retree) }
sub prefix__S_325temp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'temp';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_325temp",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtemp/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}


## nonchaining binary
## token infix__S_326LtEqualGt (  :$sym is context<rw> =  <=>  --> Nonchaining)
##      token infix:sym <=>  ( --> Nonchaining)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_326LtEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_326LtEqualGt',$retree) }
sub infix__S_326LtEqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<=>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_326LtEqualGt",  map { STD::Nonchaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\=\>/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{returns} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_327cmp (  :$sym is context<rw> = 'cmp' --> Nonchaining)
##      token infix:cmp ( --> Nonchaining)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_327cmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_327cmp',$retree) }
sub infix__S_327cmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'cmp';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_327cmp",  map { STD::Nonchaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gcmp/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{returns} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_328leg (  :$sym is context<rw> = 'leg' --> Nonchaining)
##      token infix:leg ( --> Nonchaining)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_328leg__PEEK { $_[0]->_AUTOLEXpeek('infix__S_328leg',$retree) }
sub infix__S_328leg {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'leg';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_328leg",  map { STD::Nonchaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gleg/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{returns} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_329but (  :$sym is context<rw> = 'but' --> Nonchaining)
##      token infix:but ( --> Nonchaining)
##          { <sym> }

sub infix__S_329but__PEEK { $_[0]->_AUTOLEXpeek('infix__S_329but',$retree) }
sub infix__S_329but {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'but';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_329but",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gbut/)
);
}

## token infix__S_330does (  :$sym is context<rw> = 'does' --> Nonchaining)
##      token infix:does ( --> Nonchaining)
##          { <sym> }

sub infix__S_330does__PEEK { $_[0]->_AUTOLEXpeek('infix__S_330does',$retree) }
sub infix__S_330does {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'does';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_330does",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gdoes/)
);
}

## token infix__S_331DotDot (  :$sym is context<rw> = <..> --> Nonchaining)
##      token infix:sym<..> ( --> Nonchaining)
##          { <sym> }

sub infix__S_331DotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_331DotDot',$retree) }
sub infix__S_331DotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(..);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_331DotDot",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\.\./)
);
}

## token infix__S_332CaretDotDot (  :$sym is context<rw> = <^..> --> Nonchaining)
##      token infix:sym<^..> ( --> Nonchaining)
##          { <sym> }

sub infix__S_332CaretDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_332CaretDotDot',$retree) }
sub infix__S_332CaretDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^..);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_332CaretDotDot",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^\.\./)
);
}

## token infix__S_333DotDotCaret (  :$sym is context<rw> = <..^> --> Nonchaining)
##      token infix:sym<..^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_333DotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_333DotDotCaret',$retree) }
sub infix__S_333DotDotCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(..^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_333DotDotCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\.\.\^/)
);
}

## token infix__S_334CaretDotDotCaret (  :$sym is context<rw> = <^..^> --> Nonchaining)
##      token infix:sym<^..^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_334CaretDotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_334CaretDotDotCaret',$retree) }
sub infix__S_334CaretDotDotCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^..^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_334CaretDotDotCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^\.\.\^/)
);
}


## chaining binary
## token infix__S_335EqualEqual (  :$sym is context<rw> = <==> --> Chaining)
##      token infix:sym<==> ( --> Chaining)
##          { <sym> <!before '=' > }

sub infix__S_335EqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_335EqualEqual',$retree) }
sub infix__S_335EqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(==);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_335EqualEqual",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('=')
})
});
}
else {
();
}
}
);
}

## token infix__S_336BangEqual (  :$sym is context<rw> = <!=> --> Chaining)
##      token infix:sym<!=> ( --> Chaining)
##          { <sym> <?before \s> }

sub infix__S_336BangEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_336BangEqual',$retree) }
sub infix__S_336BangEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_336BangEqual",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\=/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
});
}
else {
();
}
}
);
}

## token infix__S_337Lt (  :$sym is context<rw> =  <  --> Chaining)
##      token infix:sym <  ( --> Chaining)
##          { <sym> }

sub infix__S_337Lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_337Lt',$retree) }
sub infix__S_337Lt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_337Lt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\</)
);
}

## token infix__S_338LtEqual (  :$sym is context<rw> =  <=  --> Chaining)
##      token infix:sym <=  ( --> Chaining)
##          { <sym> }

sub infix__S_338LtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_338LtEqual',$retree) }
sub infix__S_338LtEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_338LtEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\<\=/)
);
}

## token infix__S_339Gt (  :$sym is context<rw> =  >  --> Chaining)
##      token infix:sym >  ( --> Chaining)
##          { <sym> }

sub infix__S_339Gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_339Gt',$retree) }
sub infix__S_339Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_339Gt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\>/)
);
}

## token infix__S_340GtEqual (  :$sym is context<rw> =  >=  --> Chaining)
##      token infix:sym >=  ( --> Chaining)
##          { <sym> }

sub infix__S_340GtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_340GtEqual',$retree) }
sub infix__S_340GtEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_340GtEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\>\=/)
);
}

## token infix__S_341TildeTilde (  :$sym is context<rw> = <~~> --> Chaining)
##      token infix:sym<~~> ( --> Chaining)
##          { <sym> }

sub infix__S_341TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_341TildeTilde',$retree) }
sub infix__S_341TildeTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_341TildeTilde",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\~\~/)
);
}

# XXX should move to inside meta !
## token infix__S_342BangTilde (  :$sym is context<rw> = <!~> --> Chaining)
##      token infix:sym<!~> ( --> Chaining)
##          { <sym> \s <.obs('!~ to do negated pattern matching', '!~~')> }

sub infix__S_342BangTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_342BangTilde',$retree) }
sub infix__S_342BangTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_342BangTilde",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\~/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('!~ to do negated pattern matching', '!~~');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_343EqualTilde (  :$sym is context<rw> = <=~> --> Chaining)
##      token infix:sym<=~> ( --> Chaining)
##          { <sym> <.obs('=~ to do pattern matching', '~~')> }

sub infix__S_343EqualTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_343EqualTilde',$retree) }
sub infix__S_343EqualTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_343EqualTilde",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\~/))) {
$C->obs('=~ to do pattern matching', '~~');
}
else {
();
}
}
);
}

## token infix__S_344eq (  :$sym is context<rw> = <eq> --> Chaining)
##      token infix:sym<eq> ( --> Chaining)
##          { <sym> }

sub infix__S_344eq__PEEK { $_[0]->_AUTOLEXpeek('infix__S_344eq',$retree) }
sub infix__S_344eq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(eq);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_344eq",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Geq/)
);
}

## token infix__S_345ne (  :$sym is context<rw> = <ne> --> Chaining)
##      token infix:sym<ne> ( --> Chaining)
##          { <sym> }

sub infix__S_345ne__PEEK { $_[0]->_AUTOLEXpeek('infix__S_345ne',$retree) }
sub infix__S_345ne {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ne);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_345ne",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gne/)
);
}

## token infix__S_346lt (  :$sym is context<rw> = <lt> --> Chaining)
##      token infix:sym<lt> ( --> Chaining)
##          { <sym> }

sub infix__S_346lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_346lt',$retree) }
sub infix__S_346lt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(lt);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_346lt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Glt/)
);
}

## token infix__S_347le (  :$sym is context<rw> = <le> --> Chaining)
##      token infix:sym<le> ( --> Chaining)
##          { <sym> }

sub infix__S_347le__PEEK { $_[0]->_AUTOLEXpeek('infix__S_347le',$retree) }
sub infix__S_347le {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(le);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_347le",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gle/)
);
}

## token infix__S_348gt (  :$sym is context<rw> = <gt> --> Chaining)
##      token infix:sym<gt> ( --> Chaining)
##          { <sym> }

sub infix__S_348gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_348gt',$retree) }
sub infix__S_348gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(gt);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_348gt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Ggt/)
);
}

## token infix__S_349ge (  :$sym is context<rw> = <ge> --> Chaining)
##      token infix:sym<ge> ( --> Chaining)
##          { <sym> }

sub infix__S_349ge__PEEK { $_[0]->_AUTOLEXpeek('infix__S_349ge',$retree) }
sub infix__S_349ge {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ge);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_349ge",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gge/)
);
}

## token infix__S_350EqualColonEqual (  :$sym is context<rw> = <=:=> --> Chaining)
##      token infix:sym<=:=> ( --> Chaining)
##          { <sym> }

sub infix__S_350EqualColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_350EqualColonEqual',$retree) }
sub infix__S_350EqualColonEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=:=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_350EqualColonEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\=\:\=/)
);
}

## token infix__S_351EqualEqualEqual (  :$sym is context<rw> = <===> --> Chaining)
##      token infix:sym<===> ( --> Chaining)
##          { <sym> }

sub infix__S_351EqualEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_351EqualEqualEqual',$retree) }
sub infix__S_351EqualEqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(===);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_351EqualEqualEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\=\=\=/)
);
}

## token infix__S_352eqv (  :$sym is context<rw> = <eqv> --> Chaining)
##      token infix:sym<eqv> ( --> Chaining)
##          { <sym> }

sub infix__S_352eqv__PEEK { $_[0]->_AUTOLEXpeek('infix__S_352eqv',$retree) }
sub infix__S_352eqv {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(eqv);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_352eqv",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Geqv/)
);
}

## token infix__S_353before (  :$sym is context<rw> = <before> --> Chaining)
##      token infix:sym<before> ( --> Chaining)
##          { <sym> }

sub infix__S_353before__PEEK { $_[0]->_AUTOLEXpeek('infix__S_353before',$retree) }
sub infix__S_353before {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(before);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_353before",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gbefore/)
);
}

## token infix__S_354after (  :$sym is context<rw> = <after> --> Chaining)
##      token infix:sym<after> ( --> Chaining)
##          { <sym> }

sub infix__S_354after__PEEK { $_[0]->_AUTOLEXpeek('infix__S_354after',$retree) }
sub infix__S_354after {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(after);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_354after",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gafter/)
);
}


## tight and
## token infix__S_355AmpAmp (  :$sym is context<rw> = <&&> --> Tight_and)
##      token infix:sym<&&> ( --> Tight_and)
##          { <sym> }

sub infix__S_355AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_355AmpAmp',$retree) }
sub infix__S_355AmpAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_355AmpAmp",  map { STD::Tight_and->coerce($_) } 
$C->_PATTERN(qr/\G\&\&/)
);
}


## tight or
## token infix__S_356VertVert (  :$sym is context<rw> = <||> --> Tight_or)
##      token infix:sym<||> ( --> Tight_or)
##          { <sym> }

sub infix__S_356VertVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_356VertVert',$retree) }
sub infix__S_356VertVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_356VertVert",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\|\|/)
);
}

## token infix__S_357CaretCaret (  :$sym is context<rw> = <^^> --> Tight_or)
##      token infix:sym<^^> ( --> Tight_or)
##          { <sym> }

sub infix__S_357CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_357CaretCaret',$retree) }
sub infix__S_357CaretCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_357CaretCaret",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\^\^/)
);
}

## token infix__S_358SlashSlash (  :$sym is context<rw> = <//> --> Tight_or)
##      token infix:sym<//> ( --> Tight_or)
##          { <sym> }

sub infix__S_358SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_358SlashSlash',$retree) }
sub infix__S_358SlashSlash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(//);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_358SlashSlash",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\/\//)
);
}

## token infix__S_359min (  :$sym is context<rw> = <min> --> Tight_or)
##      token infix:sym<min> ( --> Tight_or)
##          { <sym> }

sub infix__S_359min__PEEK { $_[0]->_AUTOLEXpeek('infix__S_359min',$retree) }
sub infix__S_359min {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(min);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_359min",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\Gmin/)
);
}

## token infix__S_360max (  :$sym is context<rw> = <max> --> Tight_or)
##      token infix:sym<max> ( --> Tight_or)
##          { <sym> }

sub infix__S_360max__PEEK { $_[0]->_AUTOLEXpeek('infix__S_360max',$retree) }
sub infix__S_360max {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(max);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_360max",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\Gmax/)
);
}


## conditional
## token infix__S_361QuestionQuestion_BangBang (  :$sym is context<rw> = <?? !!> --> Conditional)
##      token infix:sym<?? !!> ( --> Conditional) {
##          :my $GOAL is context = '!!';
##          '??'
##          <.ws>
##          <EXPR(item %item_assignment)>
##          [ '!!' ||
##              [
##              || <?before '='> <.panic: "Assignment not allowed within ??!!">
##              || <?before '::'> <.panic: "Please use !! rather than ::">
##              || <?before <infixish>>    # Note: a tight infix would have parsed right
##                  <.panic: "Precedence too loose within ??!!; use ??()!! instead ">
##              || <.panic: "Found ?? but no !!; possible precedence problem">
##              ]
##          ]
##      }

sub infix__S_361QuestionQuestion_BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_361QuestionQuestion_BangBang',$retree) }
sub infix__S_361QuestionQuestion_BangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(?? !!)];
local $::GOAL =  '!!';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_361QuestionQuestion_BangBang",  map { STD::Conditional->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('??'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('!!')} 
or
eval { push @gather, $C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
$C->panic("Assignment not allowed within ??!!");
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('::')
}))) {
$C->panic("Please use !! rather than ::");
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}))) {
$C->panic("Precedence too loose within ??!!; use ??()!! instead ");
}
else {
();
}
}} 
or
eval { push @gather, $C->panic("Found ?? but no !!; possible precedence problem")} or do { die $@ if $@ };
@gather;
}
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_362Question (  :$sym is context<rw> = <?> --> Conditional)
##      token infix:sym<?> ( --> Conditional)
##          { <sym> <.obs('?: for the conditional operator', '??!!')> }

sub infix__S_362Question__PEEK { $_[0]->_AUTOLEXpeek('infix__S_362Question',$retree) }
sub infix__S_362Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_362Question",  map { STD::Conditional->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->obs('?: for the conditional operator', '??!!');
}
else {
();
}
}
);
}

## token infix__S_363ff (  :$sym is context<rw> = <ff> --> Conditional)
##      token infix:sym<ff> ( --> Conditional)
##          { <sym> }

sub infix__S_363ff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_363ff',$retree) }
sub infix__S_363ff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_363ff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gff/)
);
}

## token infix__S_364Caretff (  :$sym is context<rw> = <^ff> --> Conditional)
##      token infix:sym<^ff> ( --> Conditional)
##          { <sym> }

sub infix__S_364Caretff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_364Caretff',$retree) }
sub infix__S_364Caretff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^ff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_364Caretff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^ff/)
);
}

## token infix__S_365ffCaret (  :$sym is context<rw> = <ff^> --> Conditional)
##      token infix:sym<ff^> ( --> Conditional)
##          { <sym> }

sub infix__S_365ffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_365ffCaret',$retree) }
sub infix__S_365ffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_365ffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gff\^/)
);
}

## token infix__S_366CaretffCaret (  :$sym is context<rw> = <^ff^> --> Conditional)
##      token infix:sym<^ff^> ( --> Conditional)
##          { <sym> }

sub infix__S_366CaretffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_366CaretffCaret',$retree) }
sub infix__S_366CaretffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^ff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_366CaretffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^ff\^/)
);
}

## token infix__S_367fff (  :$sym is context<rw> = <fff> --> Conditional)
##      token infix:sym<fff> ( --> Conditional)
##          { <sym> }

sub infix__S_367fff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_367fff',$retree) }
sub infix__S_367fff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(fff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_367fff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gfff/)
);
}

## token infix__S_368Caretfff (  :$sym is context<rw> = <^fff> --> Conditional)
##      token infix:sym<^fff> ( --> Conditional)
##          { <sym> }

sub infix__S_368Caretfff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_368Caretfff',$retree) }
sub infix__S_368Caretfff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^fff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_368Caretfff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^fff/)
);
}

## token infix__S_369fffCaret (  :$sym is context<rw> = <fff^> --> Conditional)
##      token infix:sym<fff^> ( --> Conditional)
##          { <sym> }

sub infix__S_369fffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_369fffCaret',$retree) }
sub infix__S_369fffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(fff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_369fffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gfff\^/)
);
}

## token infix__S_370CaretfffCaret (  :$sym is context<rw> = <^fff^> --> Conditional)
##      token infix:sym<^fff^> ( --> Conditional)
##          { <sym> }

sub infix__S_370CaretfffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_370CaretfffCaret',$retree) }
sub infix__S_370CaretfffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^fff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_370CaretfffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^fff\^/)
);
}

## assignment
# There is no "--> type" because assignment may be coerced to either
# item assignment or list assignment at "make" time.

## token infix__S_371Equal (:$sym is context<rw> = <=>)
##      token infix:sym<=> ()
##      {
##          <sym>
##          { $ = $+SIGIL eq '$' 
##              ?? STD::Item_assignment.coerce($)
##              !! STD::List_assignment.coerce($);
##          }
##      }

sub infix__S_371Equal__PEEK { $_[0]->_AUTOLEXpeek('infix__S_371Equal',$retree) }
sub infix__S_371Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_371Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
scalar(do {
$C = $::SIGIL eq '$' 
? STD::Item_assignment->coerce($C)
: STD::List_assignment->coerce($C);

}, $C);
}
else {
();
}
}
);
}

## token infix__S_372ColonEqual (  :$sym is context<rw> = <:=> --> Item_assignment)
##      token infix:sym<:=> ( --> Item_assignment)
##          { <sym> }

sub infix__S_372ColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_372ColonEqual',$retree) }
sub infix__S_372ColonEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_372ColonEqual",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\:\=/)
);
}

## token infix__S_373ColonColonEqual (  :$sym is context<rw> = <::=> --> Item_assignment)
##      token infix:sym<::=> ( --> Item_assignment)
##          { <sym> }

sub infix__S_373ColonColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_373ColonColonEqual',$retree) }
sub infix__S_373ColonColonEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_373ColonColonEqual",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\:\:\=/)
);
}

## token infix__S_374DotEqual (  :$sym is context<rw> = <.=> --> Item_assignment)
##      token infix:sym<.=> ( --> Item_assignment) {
##          <sym> <.ws>
##          [ <?before \w+';' | 'new'|'sort'|'subst'|'trans'|'reverse'|'uniq'|'map'|'samecase'|'substr' > || <worryobs('.= as append operator', '~=')> ]
##          { $<O><nextterm> = 'dottyop' }
##      }

sub infix__S_374DotEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_374DotEqual',$retree) }
sub infix__S_374DotEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_374DotEqual",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\=/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix__S_374DotEqual_02') {
$C->deb("Fate passed to infix__S_374DotEqual_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_374DotEqual_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_374DotEqual_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
$C->_EXACT(';');
}
else {
();
}
}
},
sub { my $C=shift;
$C->_EXACT('new')
},
sub { my $C=shift;
$C->_EXACT('sort')
},
sub { my $C=shift;
$C->_EXACT('subst')
},
sub { my $C=shift;
$C->_EXACT('trans')
},
sub { my $C=shift;
$C->_EXACT('reverse')
},
sub { my $C=shift;
$C->_EXACT('uniq')
},
sub { my $C=shift;
$C->_EXACT('map')
},
sub { my $C=shift;
$C->_EXACT('samecase')
},
sub { my $C=shift;
$C->_EXACT('substr')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} 
or
eval { push @gather, $C->_SUBSUMEr(['worryobs'], sub {
my $C = shift;
$C->worryobs('.= as append operator', '~=')
})} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{O}{nextterm} = 'dottyop' ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_375EqualGt (  :$sym is context<rw> =  =>  --> Item_assignment)
##      token infix:sym =>  ( --> Item_assignment)
##          { <sym> }

sub infix__S_375EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_375EqualGt',$retree) }
sub infix__S_375EqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['=>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_375EqualGt",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\=\>/)
);
}

# Note, other assignment ops generated by infix_postfix_meta_operator rule

## loose unary
## token prefix__S_376true (  :$sym is context<rw> = <true> --> Loose_unary)
##      token prefix:sym<true> ( --> Loose_unary)
##          { <sym>  }

sub prefix__S_376true__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_376true',$retree) }
sub prefix__S_376true {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(true);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_376true",  map { STD::Loose_unary->coerce($_) } 
$C->_PATTERN(qr/\Gtrue\b/)
);
}

## token prefix__S_377not (  :$sym is context<rw> = <not> --> Loose_unary)
##      token prefix:sym<not> ( --> Loose_unary)
##          { <sym>  }

sub prefix__S_377not__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_377not',$retree) }
sub prefix__S_377not {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(not);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_377not",  map { STD::Loose_unary->coerce($_) } 
$C->_PATTERN(qr/\Gnot\b/)
);
}

## list item separator
## token infix__S_378Comma (  :$sym is context<rw> = <,> --> Comma)
##      token infix:sym<,> ( --> Comma)
##          { <sym> { $<O><assign> = 1 } }

sub infix__S_378Comma__PEEK { $_[0]->_AUTOLEXpeek('infix__S_378Comma',$retree) }
sub infix__S_378Comma {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[,];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_378Comma",  map { STD::Comma->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\,/))) {
scalar(do {
my $M = $C;  $M->{O}{assign} = 1 ;
}, $C);
}
else {
();
}
}
);
}

## token infix__S_379Colon (  :$sym is context<rw> = <:> --> Comma)
##      token infix:sym<:> ( --> Comma)
##          { <sym> <?before \s | <terminator> >
##              { $.panic("Illegal use of colon as invocant marker") unless $+INVOCANT_OK--; }
##          }

sub infix__S_379Colon__PEEK { $_[0]->_AUTOLEXpeek('infix__S_379Colon',$retree) }
sub infix__S_379Colon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_379Colon",  map { STD::Comma->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix__S_379Colon_01') {
$C->deb("Fate passed to infix__S_379Colon_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_379Colon_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_379Colon_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$C->panic("Illegal use of colon as invocant marker") unless $::INVOCANT_OK--; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_380p5EqualGt (  :$sym is context<rw> =  p5=>  --> Comma)
##      token infix:sym p5=>  ( --> Comma)
##          { <sym> }

sub infix__S_380p5EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_380p5EqualGt',$retree) }
sub infix__S_380p5EqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['p5=>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_380p5EqualGt",  map { STD::Comma->coerce($_) } 
$C->_PATTERN(qr/\Gp5\=\>/)
);
}

## token infix__S_381Z (  :$sym is context<rw> = <Z> --> List_infix)
##      token infix:sym<Z> ( --> List_infix)
##          { <sym> }

sub infix__S_381Z__PEEK { $_[0]->_AUTOLEXpeek('infix__S_381Z',$retree) }
sub infix__S_381Z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(Z);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_381Z",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\GZ/)
);
}

## token infix__S_382minmax (  :$sym is context<rw> = <minmax> --> List_infix)
##      token infix:sym<minmax> ( --> List_infix)
##          { <sym> }

sub infix__S_382minmax__PEEK { $_[0]->_AUTOLEXpeek('infix__S_382minmax',$retree) }
sub infix__S_382minmax {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(minmax);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_382minmax",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\Gminmax/)
);
}

## token infix__S_383DotDotDot (  :$sym is context<rw> = <...> --> List_infix)
##      token infix:sym<...> ( --> List_infix)
##          { <sym> }

sub infix__S_383DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_383DotDotDot',$retree) }
sub infix__S_383DotDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_383DotDotDot",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\G\.\.\./)
);
}

## token term__S_384DotDotDot (  :$sym is context<rw> = <...> --> List_prefix)
##      token term:sym<...> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_384DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('term__S_384DotDotDot',$retree) }
sub term__S_384DotDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{_pos};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_384DotDotDot",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\.\./))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_385QuestionQuestionQuestion (  :$sym is context<rw> = <???> --> List_prefix)
##      token term:sym<???> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_385QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('term__S_385QuestionQuestionQuestion',$retree) }
sub term__S_385QuestionQuestionQuestion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(???);


my $C = $self;
my $S = $C->{_pos};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_385QuestionQuestionQuestion",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\?\?/))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_386BangBangBang (  :$sym is context<rw> = <!!!> --> List_prefix)
##      token term:sym<!!!> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_386BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('term__S_386BangBangBang',$retree) }
sub term__S_386BangBangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!!);


my $C = $self;
my $S = $C->{_pos};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_386BangBangBang",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\!\!/))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_387sigil (  :$sym is context<rw> = 'sigil' --> List_prefix)
##      token term:sigil ( --> List_prefix)
##      {
##          <sigil> <?before \s> <arglist>
##          { $<sym> = $<sigil>.item; }
##      }

sub term__S_387sigil__PEEK { $_[0]->_AUTOLEXpeek('term__S_387sigil',$retree) }
sub term__S_387sigil {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_387sigil",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C;  $M->{sym} = $M->{sigil}->item; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# token term:typecast ( --> List_prefix)
#     { <typename> <?spacey> <arglist> { $<sym> = $<typename>.item; } }

# force identifier(), identifier.(), etc. to be a function call always
## token term__S_388identifier (  :$sym is context<rw> = 'identifier' --> Term )
##      token term:identifier ( --> Term )
##      {
##          :my $t;
##          <identifier> <?before ['.'?'(']?>
##          { $t = $<identifier>.text; }
##          <args( $.is_type($t) )>
##          {{
##              %MYSTERY{$t} ~= $.lineof($.pos) ~ ' ' unless $<args><invocant> or $.is_known($t);
##          }}
##      }

sub term__S_388identifier__PEEK { $_[0]->_AUTOLEXpeek('term__S_388identifier',$retree) }
sub term__S_388identifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'identifier';
my $t;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_388identifier",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('.')
}))) {
$C->_EXACT('(');
}
else {
();
}
}
})
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $t = $M->{identifier}->text; ;
}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args( $C->is_type($t) )
}))) {
scalar(do {
my $M = $C; 
$MYSTERY{$t} .= $C->lineof($C->{_pos}) . ' ' unless $M->{args}{invocant} or $C->is_known($t);
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_389opfunc (  :$sym is context<rw> = 'opfunc' --> Term )
##      token term:opfunc ( --> Term )
##      {
##          <category> <colonpair>+ <args>
##      }

sub term__S_389opfunc__PEEK { $_[0]->_AUTOLEXpeek('term__S_389opfunc',$retree) }
sub term__S_389opfunc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'opfunc';


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_389opfunc",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token args ($istype = 0)
##      token args ($istype = 0) {
##          :my $listopish = 0;
##          :my $GOAL is context = '';
##          :my $INVOCANT_OK is context<rw> = 1;
##          :my $INVOCANT_IS is context<rw>;
##          [
##          | :dba('argument list') '.(' ~ ')' <semiarglist> {*}             #= func args
##          | :dba('argument list') '(' ~ ')' <semiarglist> {*}              #= func args
##          | :dba('argument list') <.unsp> '.'? '(' ~ ')' <semiarglist> {*} #= func args
##          |  { $listopish = 1 } [<?before \s> <!{ $istype }> <.ws> <!infixstopper> <arglist>]?
##          ]
##          { $<invocant> = $INVOCANT_IS; }
##      
##          :dba('extra arglist after (...):')
##          [
##          || <?{ $listopish }>
##          || ':' <?before \s> <moreargs=arglist>    # either switch to listopiness
##          || {{ $<O> = {}; }}   # or allow adverbs (XXX needs hoisting?)
##          ]
##      }

sub args__PEEK { $_[0]->_AUTOLEXpeek('args',$retree) }
sub args {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $istype = shift() // 0;
my $listopish = 0;
local $::GOAL =  '';
local $::INVOCANT_OK =  1;
local $::INVOCANT_IS;


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];

$self->_MATCHIFY($S, "args", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$listopish 
})
})} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['moreargs'], sub {
my $C = shift;
$C->arglist
})
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
}, $C->_EXACT(':'))} 
or
eval { push @gather, scalar(do {
my $M = $C;  $M->{O} = {}; ;
}, $C)} or do { die $@ if $@ };
@gather;
}
})
}, scalar(do {
my $M = $C;  $M->{invocant} = $INVOCANT_IS; ;
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'args_01') {
$C->deb("Fate passed to args_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'args_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("args_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args_func_args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('.('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args_func_args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args_func_args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
}, $C->_OPTr(sub { my $C=shift;
$C->_EXACT('.')
}))
}, $C->unsp)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['arglist'], sub {
my $C = shift;
$C->arglist
})
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))
}, $C->ws)
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$istype 
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
})
})
}, scalar(do {
$listopish = 1 
}, $C))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

# names containing :: may or may not be function calls
# bare identifier without parens also handled here if no other rule parses it
## token term__S_390name (  :$sym is context<rw> = 'name' --> Term)
##      token term:name ( --> Term)
##      {
##          <longname>
##          [
##          ||  <?{
##                  $.is_type($<longname>.text) or substr($<longname>.text,0,2) eq '::'
##              }>
##              # parametric type?
##              <.unsp>? [ <?before '['> <postcircumfix> ]?
##              :dba('type parameter')
##              [
##                  '::'
##                  <?before [ '' | '<' | '{' | '<<' ] > <postcircumfix>
##                  {*}                                                 #= packagevar 
##              ]?
##              {*}                                                     #= typename
##      
##          # unrecognized names are assumed to be post-declared listops.
##          || <args>?
##          ]
##      }

sub term__S_390name__PEEK { $_[0]->_AUTOLEXpeek('term__S_390name',$retree) }
sub term__S_390name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'name';


my $C = $self;
my $S = $C->{_pos};
$C->{'args'} = [];
$C->{'postcircumfix'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_390name",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
$C->is_type($M->{longname}->text) or substr($M->{longname}->text,0,2) eq '::'
;
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'term__S_390name_06') {
$C->deb("Fate passed to term__S_390name_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_390name_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_390name_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->_REDUCE($S, 'term__S_390name_packagevar_');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_REDUCE($S, 'term__S_390name_typename');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}

## loose and
## token infix__S_391and (  :$sym is context<rw> = <and> --> Loose_and)
##      token infix:sym<and> ( --> Loose_and)
##          { <sym> }

sub infix__S_391and__PEEK { $_[0]->_AUTOLEXpeek('infix__S_391and',$retree) }
sub infix__S_391and {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(and);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_391and",  map { STD::Loose_and->coerce($_) } 
$C->_PATTERN(qr/\Gand/)
);
}

## token infix__S_392andthen (  :$sym is context<rw> = <andthen> --> Loose_and)
##      token infix:sym<andthen> ( --> Loose_and)
##          { <sym> }

sub infix__S_392andthen__PEEK { $_[0]->_AUTOLEXpeek('infix__S_392andthen',$retree) }
sub infix__S_392andthen {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(andthen);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_392andthen",  map { STD::Loose_and->coerce($_) } 
$C->_PATTERN(qr/\Gandthen/)
);
}

## loose or
## token infix__S_393or (  :$sym is context<rw> = <or> --> Loose_or)
##      token infix:sym<or> ( --> Loose_or)
##          { <sym> }

sub infix__S_393or__PEEK { $_[0]->_AUTOLEXpeek('infix__S_393or',$retree) }
sub infix__S_393or {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(or);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_393or",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gor/)
);
}

## token infix__S_394orelse (  :$sym is context<rw> = <orelse> --> Loose_or)
##      token infix:sym<orelse> ( --> Loose_or)
##          { <sym> }

sub infix__S_394orelse__PEEK { $_[0]->_AUTOLEXpeek('infix__S_394orelse',$retree) }
sub infix__S_394orelse {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(orelse);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_394orelse",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gorelse/)
);
}

## token infix__S_395xor (  :$sym is context<rw> = <xor> --> Loose_or)
##      token infix:sym<xor> ( --> Loose_or)
##          { <sym> }

sub infix__S_395xor__PEEK { $_[0]->_AUTOLEXpeek('infix__S_395xor',$retree) }
sub infix__S_395xor {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(xor);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_395xor",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gxor/)
);
}

## sequencer
## token infix__S_396LtEqualEqual (  :$sym is context<rw> =  <==  --> Sequencer)
##      token infix:sym <==  ( --> Sequencer)
##          { <sym> }

sub infix__S_396LtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_396LtEqualEqual',$retree) }
sub infix__S_396LtEqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<=='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_396LtEqualEqual",  map { STD::Sequencer->coerce($_) } 
$C->_PATTERN(qr/\G\<\=\=/)
);
}

## token infix__S_397EqualEqualGt (  :$sym is context<rw> =  ==>  --> Sequencer)
##      token infix:sym ==>  ( --> Sequencer)
##          { <sym> {*} }

sub infix__S_397EqualEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_397EqualEqualGt',$retree) }
sub infix__S_397EqualEqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['==>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_397EqualEqualGt",  map { STD::Sequencer->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>/))) {
$C->_REDUCE($S, 'infix__S_397EqualEqualGt');
}
else {
();
}
}
);
}              #'

## token infix__S_398LtLtEqualEqual (  :$sym is context<rw> =  <<==  --> Sequencer)
##      token infix:sym <<==  ( --> Sequencer)
##          { <sym> }

sub infix__S_398LtLtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_398LtLtEqualEqual',$retree) }
sub infix__S_398LtLtEqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<=='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_398LtLtEqualEqual",  map { STD::Sequencer->coerce($_) } 
$C->_PATTERN(qr/\G\<\<\=\=/)
);
}

## token infix__S_399EqualEqualGtGt (  :$sym is context<rw> =  ==>>  --> Sequencer)
##      token infix:sym ==>>  ( --> Sequencer)
##          { <sym> {*} }

sub infix__S_399EqualEqualGtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_399EqualEqualGtGt',$retree) }
sub infix__S_399EqualEqualGtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['==>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_399EqualEqualGtGt",  map { STD::Sequencer->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>\>/))) {
$C->_REDUCE($S, 'infix__S_399EqualEqualGtGt');
}
else {
();
}
}
);
}              #'

## expression terminator
# Note: must always be called as <?terminator> or <?before ...<terminator>...>

## token terminator__S_400Semi (  :$sym is context<rw> = <;> --> Terminator)
##      token terminator:sym<;> ( --> Terminator)
##          { ';' }

sub terminator__S_400Semi__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_400Semi',$retree) }
sub terminator__S_400Semi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(;);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_400Semi",  map { STD::Terminator->coerce($_) } 
$C->_EXACT(';')
);
}

## token terminator__S_401if (  :$sym is context<rw> = <if> --> Terminator)
##      token terminator:sym<if> ( --> Terminator)
##          { 'if'  <.nofun> }

sub terminator__S_401if__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_401if',$retree) }
sub terminator__S_401if {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(if);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_401if",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('if'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_402unless (  :$sym is context<rw> = <unless> --> Terminator)
##      token terminator:sym<unless> ( --> Terminator)
##          { 'unless'  <.nofun> }

sub terminator__S_402unless__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_402unless',$retree) }
sub terminator__S_402unless {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(unless);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_402unless",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('unless'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_403while (  :$sym is context<rw> = <while> --> Terminator)
##      token terminator:sym<while> ( --> Terminator)
##          { 'while'  <.nofun> }

sub terminator__S_403while__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_403while',$retree) }
sub terminator__S_403while {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(while);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_403while",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('while'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_404until (  :$sym is context<rw> = <until> --> Terminator)
##      token terminator:sym<until> ( --> Terminator)
##          { 'until'  <.nofun> }

sub terminator__S_404until__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_404until',$retree) }
sub terminator__S_404until {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(until);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_404until",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('until'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_405for (  :$sym is context<rw> = <for> --> Terminator)
##      token terminator:sym<for> ( --> Terminator)
##          { 'for'  <.nofun> }

sub terminator__S_405for__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_405for',$retree) }
sub terminator__S_405for {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(for);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_405for",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('for'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_406given (  :$sym is context<rw> = <given> --> Terminator)
##      token terminator:sym<given> ( --> Terminator)
##          { 'given'  <.nofun> }

sub terminator__S_406given__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_406given',$retree) }
sub terminator__S_406given {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(given);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_406given",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('given'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_407when (  :$sym is context<rw> = <when> --> Terminator)
##      token terminator:sym<when> ( --> Terminator)
##          { 'when'  <.nofun> }

sub terminator__S_407when__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_407when',$retree) }
sub terminator__S_407when {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(when);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_407when",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('when'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_408MinusMinusGt (  :$sym is context<rw> =  -->  --> Terminator)
##      token terminator:sym -->  ( --> Terminator)
##          { '-->' {*} }

sub terminator__S_408MinusMinusGt__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_408MinusMinusGt',$retree) }
sub terminator__S_408MinusMinusGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['-->'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_408MinusMinusGt",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('-->'))) {
$C->_REDUCE($S, 'terminator__S_408MinusMinusGt');
}
else {
();
}
}
);
}              #'

## token terminator__S_409Thesis (  :$sym is context<rw> = <)> --> Terminator)
##      token terminator:sym<)> ( --> Terminator)
##          { <sym> }

sub terminator__S_409Thesis__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_409Thesis',$retree) }
sub terminator__S_409Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_409Thesis",  map { STD::Terminator->coerce($_) } 
$C->_PATTERN(qr/\G\)/)
);
}

## token terminator__S_410Ket (  :$sym is context<rw> = <]> --> Terminator)
##      token terminator:sym<]> ( --> Terminator)
##          { ']' }

sub terminator__S_410Ket__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_410Ket',$retree) }
sub terminator__S_410Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(]);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_410Ket",  map { STD::Terminator->coerce($_) } 
$C->_EXACT(']')
);
}

## token terminator__S_411Ly (  :$sym is context<rw> = <}> --> Terminator)
##      token terminator:sym<}> ( --> Terminator)
##          { '}' }

sub terminator__S_411Ly__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_411Ly',$retree) }
sub terminator__S_411Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(});


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_411Ly",  map { STD::Terminator->coerce($_) } 
$C->_EXACT('}')
);
}

## token terminator__S_412BangBang (  :$sym is context<rw> = <!!> --> Terminator)
##      token terminator:sym<!!> ( --> Terminator)
##          { '!!' <?{ $+GOAL eq '!!' }> }

sub terminator__S_412BangBang__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_412BangBang',$retree) }
sub terminator__S_412BangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_412BangBang",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('!!'))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
});
}
else {
();
}
}
);
}

# disallow &[] and such as infix
# token infix:sigil ( --> Term )
#     { <sigil><-[&]> <.worry: "Sigiled form not allowed where infix expected"> <!> }

## regex infixstopper
##      regex infixstopper {
##          :dba('infix stopper')
##          [
##          | <?before <stopper> >
##          | <?before '!!' > <?{ $+GOAL eq '!!' }>
##          | <?before '{' | <lambda> > <?{ ($+GOAL eq '{' or $+GOAL eq 'endargs') and @+MEMOS[$.pos]<ws> }>
##          | <?{ $+GOAL eq 'endargs' and @+MEMOS[$.pos]<endargs> }>
##          ]
##      }

sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper',$retree) }
sub infixstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "infixstopper", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infixstopper_01') {
$C->deb("Fate passed to infixstopper_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
})
}, $C->before(sub { my $C=shift;
$C->_EXACT('!!')
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
($::GOAL eq '{' or $::GOAL eq 'endargs') and $MEMOS[$C->{_pos}]{'ws'} 
})
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infixstopper_04') {
$C->deb("Fate passed to infixstopper_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixstopper_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_SUBSUME(['lambda'], sub {
my $C = shift;
$C->lambda
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq 'endargs' and $MEMOS[$C->{_pos}]{'endargs'} 
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# overridden in subgrammars
## token stopper
##      token stopper { <!> }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

# hopefully we can include these tokens in any outer LTM matcher
## regex stdstopper
##      regex stdstopper {
##          :my @stub = return self if @+MEMOS[self.pos]<endstmt> :exists;
##          :dba('standard stopper')
##          [
##          | <?terminator>
##          | <?unitstopper>
##          | $                                 # unlikely, check last (normal LTM behavior)
##          ]
##          { @+MEMOS[$.pos]<endstmt> ||= 1; }
##      }

sub stdstopper__PEEK { $_[0]->_AUTOLEXpeek('stdstopper',$retree) }
sub stdstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $MEMOS[$self->{_pos}]{'endstmt'};


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "stdstopper", 
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$MEMOS[$C->{_pos}]{'endstmt'} ||= 1; 
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'stdstopper_01') {
$C->deb("Fate passed to stdstopper_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'stdstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("stdstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->terminator
})
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->unitstopper
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

# A fairly complete operator precedence parser

## method EXPR ($preclvl)
sub EXPR {
my $self = shift;
my $preclvl = shift;


local $CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
if ($self->peek) {
return $self->_AUTOLEXpeek('EXPR', $retree);
}
my $preclim = $preclvl ? $preclvl->{'prec'} // $LOOSEST : $LOOSEST;
local $::inquote =  0;
local $::SIGIL =  '';
my @termstack;
my @opstack;
my $termish = 'termish';

push @opstack, { 'O' => \%terminator, 'sym' => '' };         # (just a sentinel value)

my $here = $self;
my $S = $here->{_pos};
$self->deb("In EXPR, at $S") if $::DEBUG & DEBUG::EXPR;

my $reduce = sub {
$self->deb("entering reduce, termstack == ", 0+@termstack, " opstack == ", 0+@opstack) if $::DEBUG & DEBUG::EXPR;
my $op = pop @opstack;
my $sym = $op->{sym};
do { my $_ = $op->{O}{assoc} // 'unary'; if ((0)) {}
elsif ($_ eq 'chain') {
$self->deb("reducing chain") if $::DEBUG & DEBUG::EXPR;
my @chain;
push @chain, pop(@termstack);
push @chain, $op;
while (@opstack) {
last if $op->{O}{prec} ne $opstack[-1]{'O'}{'prec'};
push @chain, pop(@termstack);
push @chain, pop(@opstack);
}
push @chain, pop(@termstack);
@chain = reverse @chain if @chain > 1;
my $startpos = $chain[0]->{_pos};
my $nop = $op->cursor_fresh();
$nop->{chain} = [@chain];
$nop->{_arity} = 'CHAIN';
push @termstack, $nop->_REDUCE($startpos, 'EXPR');
}
elsif ($_ eq 'list') {
$self->deb("reducing list") if $::DEBUG & DEBUG::EXPR;
my @list;
my @delims = $op;
push @list, pop(@termstack);
while (@opstack) {
$self->deb($sym . " vs " . $opstack[-1]{'sym'}) if $::DEBUG & DEBUG::EXPR;
last if $sym ne $opstack[-1]{'sym'};
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
else {
$self->worry("Missing term in " . $sym . " list");
}
push @delims, pop(@opstack);
}
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
elsif ($sym ne ',') {
$self->worry("Missing final term in '" . $sym . "' list");
}
@list = reverse @list if @list > 1;
my $startpos = $list[0]->{_pos};
@delims = reverse @delims if @delims > 1;
my $nop = $op->cursor_fresh();
$nop->{sym} = $sym;
$nop->{O} = $op->{O};
$nop->{list} = [@list];
$nop->{delims} = [@delims];
$nop->{_arity} = 'LIST';
push @termstack, $nop->_REDUCE($startpos, 'EXPR');
}
elsif ($_ eq 'unary') {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
my @list;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
$op->{arg} = (pop @termstack);
if (($op->{arg}{_from} < $op->{_from})) {
$op->{_from} = $op->{arg}{_from};
}
if (($op->{arg}{_pos} > $op->{_pos})) {
$op->{_pos} = $op->{arg}{_pos};
}
$op->{_arity} = 'UNARY';
push @termstack, $op->_REDUCE($op->{_from}, 'EXPR');
}
else {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
my @list;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

$op->{right} = (pop @termstack);
$op->{left} = (pop @termstack);
$op->{_from} = $op->{left}{_from};
$op->{_pos} = $op->{right}{_pos};
$op->{_arity} = 'BINARY';
$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
push @termstack, $op->_REDUCE($op->{_from}, 'EXPR');
}
};
};

TERM:
for (;;) {
$self->deb("In loop, at ", $here->{_pos}) if $::DEBUG & DEBUG::EXPR;
my $oldpos = $here->{_pos};
$here = $here->cursor_fresh();
$SIGIL = $opstack[-1]{'O'}{'prec'} gt $item_assignment_prec ? '@' : '';
my @t = $here->$termish;

if (not @t or not $here = $t[0] or ($here->{_pos} == $oldpos and $termish eq 'termish')) {
return ();
# $here->panic("Failed to parse a required term");
}
$termish = 'termish';

# interleave prefix and postfix, pretend they're infixish
my $M = $here;

# note that we push loose stuff onto opstack before tight stuff
my @pre;
my $tmp;
@pre = @$tmp if $tmp = ( delete $M->{PRE} );
my @post;
@post = reverse @$tmp if $tmp = ( delete $M->{POST} );
while (@pre and @post) {
my $postO = $post[0]{'O'};
my $preO = $pre[0]{'O'};
if ($postO->{prec} lt $preO->{prec}) {
push @opstack, shift @post;
}
elsif ($postO->{prec} gt $preO->{prec}) {
push @opstack, shift @pre;
}
elsif ($postO->{uassoc} eq 'left') {
push @opstack, shift @post;
}
elsif ($postO->{uassoc} eq 'right') {
push @opstack, shift @pre;
}
else {
$here->panic('"' . $pre[0]{'sym'} . '" and "' . $post[0]{'sym'} . '" are not associative');
}
}
push @opstack, @pre,@post;

push @termstack, $here;
$self->deb("after push: " . (0+@termstack)) if $::DEBUG & DEBUG::EXPR;

for (;;) {     # while we see adverbs
$oldpos = $here->{_pos};
last TERM if ($MEMOS[$oldpos]{'endstmt'} // 0) == 2;
$here = $here->cursor_fresh->ws;
my @infix = $here->cursor_fresh->infixish();
last TERM unless @infix;
my $infix = $infix[0];
last TERM unless $infix->{_pos} > $oldpos;

if (not $infix->{sym}) {
die $infix->dump if $::DEBUG & DEBUG::EXPR;
}

my $inO = $infix->{O};
my $inprec = $inO->{prec};
if (not defined $inprec) {
$self->deb("No prec given in infix!") if $::DEBUG & DEBUG::EXPR;
die $infix->dump if $::DEBUG & DEBUG::EXPR;
$inprec = $terminator{prec};
}

if ($inprec le $preclim) {
my $dba = $preclvl->{'dba'};
my $h = $::HIGHEXPECT;
my $k = 'infix or meta-infix';
delete $h->{$k};
$h->{"infix or meta-infix (with precedence tighter than $dba)"} = 1;
last TERM;
}

$here = $infix->cursor_fresh->ws();

# substitute precedence for listops
$inO->{prec} = $inO->{sub} if $inO->{sub};

# Does new infix (or terminator) force any reductions?
while ($opstack[-1]{'O'}{'prec'} gt $inprec) {
$reduce->();
}

# Not much point in reducing the sentinels...
last if $inprec lt $LOOSEST;

if ($infix->{fake}) {
my $adverbs = $termstack[-1]{'ADV'} ||= [];
push @$adverbs, $infix->{colonpair};
next;  # not really an infix, so keep trying
}

# Equal precedence, so use associativity to decide.
if ($opstack[-1]{'O'}{'prec'} eq $inprec) {
do { my $_ = $inO->{assoc}; if ((0)) {}
elsif ($_ eq 'non') { $here->panic('"' . $infix->text . '" is not associative') }
elsif ($_ eq 'left') { $reduce->() }   # reduce immediately
elsif ($_ eq 'right') { }            # just shift
elsif ($_ eq 'chain') { }            # just shift
elsif ($_ eq 'unary') { }            # just shift
elsif ($_ eq 'list') {              # if op differs reduce else shift
# $reduce->() if $infix->{sym} ne $opstack[-1]{'sym'};
}
else { $here->panic('Unknown associativity "' . $_ . '" for "' . $infix->{sym} . '"') }
};
}

$termish = $inO->{nextterm} if $inO->{nextterm};
push @opstack, $infix;              # The Shift
last;
}
}
$reduce->() while 0+@opstack > 1;
if (@termstack) {
0+@termstack == 1 or $here->panic("Internal operator parser error, termstack == " . (+@termstack));
$termstack[0]{'_from'} = $self->{_pos};
$termstack[0]{'_pos'} = $here->{_pos};
}
$self->_MATCHIFYr($S, "EXPR", @termstack);
}

#################################################
## Regex
#################################################

{ package STD::Regex;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'Perl5' or $k eq 'P5') {
my $P5 = $v;  $self->cursor_fresh( 'STD::Q' )->mixin( 'STD::Q::q' )->mixin( 'STD::Q::p5' ) }
elsif ($k eq 'overlap' or $k eq 'ov') {
my $ov = $v;  $self }
elsif ($k eq 'exhaustive' or $k eq 'ex') {
my $ex = $v;  $self }
elsif ($k eq 'continue' or $k eq 'c') {
my $c = $v;  $self }
elsif ($k eq 'pos' or $k eq 'p') {
my $p = $v;  $self }
elsif ($k eq 'sigspace' or $k eq 's') {
my $s = $v;  $self }
elsif ($k eq 'ratchet' or $k eq 'r') {
my $r = $v;  $self }
elsif ($k eq 'global' or $k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'ignorecase' or $k eq 'i') {
my $i = $v;  $self }
elsif ($k eq 'ignoreaccent' or $k eq 'a') {
my $a = $v;  $self }
elsif ($k eq 'samecase' or $k eq 'ii') {
my $ii = $v;  $self }
elsif ($k eq 'sameaccent' or $k eq 'aa') {
my $aa = $v;  $self }
elsif ($k eq 'nth') {
my $nth = $v;  $self }
elsif ($k eq 'st' or $k eq 'nd') {
my $nd = $v;  $self }
elsif ($k eq 'rd' or $k eq 'th') {
my $th = $v;  $self }
elsif ($k eq 'x') {
my $x = $v;  $self }
elsif ($k eq 'bytes') {
my $bytes = $v;  $self }
elsif ($k eq 'codes') {
my $codes = $v;  $self }
elsif ($k eq 'graphs') {
my $graphs = $v;  $self }
elsif ($k eq 'chars') {
my $chars = $v;  $self }
elsif ($k eq 'rw') {
my $rw = $v;  $self->panic(":rw not implemented") }
elsif ($k eq 'keepall') {
my $keepall = $v;  $self->panic(":keepall not implemented") }
elsif ($k eq 'panic') {
my $panic = $v;  $self->panic(":panic not implemented") }
else { die 'NOMATCH' }
} # end tweaks

##     token category__S_413metachar (:$sym is context<rw> = 'metachar')
##          token category:metachar { <sym> }

sub category__S_413metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_413metachar',$retree) }
sub category__S_413metachar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'metachar';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_413metachar", 
$C->_PATTERN(qr/\Gmetachar/)
);
}
#proto token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "metachar", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_414backslash (:$sym is context<rw> = 'backslash')
##          token category:backslash { <sym> }

sub category__S_414backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_414backslash',$retree) }
sub category__S_414backslash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'backslash';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_414backslash", 
$C->_PATTERN(qr/\Gbackslash/)
);
}
#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_415assertion (:$sym is context<rw> = 'assertion')
##          token category:assertion { <sym> }

sub category__S_415assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_415assertion',$retree) }
sub category__S_415assertion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'assertion';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_415assertion", 
$C->_PATTERN(qr/\Gassertion/)
);
}
#proto token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "assertion", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_416quantifier (:$sym is context<rw> = 'quantifier')
##          token category:quantifier { <sym> }

sub category__S_416quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_416quantifier',$retree) }
sub category__S_416quantifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quantifier';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_416quantifier", 
$C->_PATTERN(qr/\Gquantifier/)
);
}
#proto token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quantifier", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_417mod_internal (:$sym is context<rw> = 'mod_internal')
##          token category:mod_internal { <sym> }

sub category__S_417mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_417mod_internal',$retree) }
sub category__S_417mod_internal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod_internal';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_417mod_internal", 
$C->_PATTERN(qr/\Gmod_internal/)
);
}
#proto token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "mod_internal", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


#proto token rxinfix { <...> }
sub rxinfix__PEEK { $_[0]->_AUTOLEXpeek('rxinfix:*',$retree); }
sub rxinfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'rxinfix') {
$C->deb("Fate passed to rxinfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'rxinfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("rxinfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "rxinfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token ws
##          token ws {
##              <?{ $+sigspace }>
##              || [ <?before \s | '#'> <nextsame> ]?   # still get all the pod goodness, hopefully
##          }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
my @origargs = @_;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'nextsame'} = [];

$self->_MATCHIFYr($S, "ws", 
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$::sigspace 
})
})} 
or
eval { push @gather, $C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'ws_03') {
$C->deb("Fate passed to ws_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'ws_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['nextsame'], sub {
my $C = shift;
$self->SUPER::ws(@origargs)
});
}
else {
();
}
}
})
})} or do { die $@ if $@ };
@gather;
}
);
}

##     token normspace
##          token normspace {
##              <?before \s | '#'> [ :lang($.cursor_fresh($+LANG)) <.ws> ]
##          }

sub normspace__PEEK { $_[0]->_AUTOLEXpeek('normspace',$retree) }
sub normspace {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "normspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'normspace_01') {
$C->deb("Fate passed to normspace_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'normspace_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("normspace_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->ws
});
}
else {
();
}
}
);
}

# suppress fancy end-of-line checking
##     token codeblock
##          token codeblock {
##              :my $GOAL is context = '}';
##              '{' :: [ :lang($.cursor_fresh($+LANG)) <statementlist> ]
##              [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
##          }

sub codeblock__PEEK { $_[0]->_AUTOLEXpeek('codeblock',$retree) }
sub codeblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL =  '}';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "codeblock", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->panic("Unable to parse statement list; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
);
}

##     rule nibbler
##          rule nibbler {
##              :my $sigspace    is context<rw> = $+sigspace    // 0;
##              :my $ratchet     is context<rw> = $+ratchet     // 0;
##              :my $ignorecase is context<rw> = $+ignorecase // 0;
##              :my $ignoreaccent    is context<rw> = $+ignoreaccent    // 0;
##              [ \s* < || | && & > ]?
##              <EXPR>
##          }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::sigspace =  $::sigspace    // 0;
local $::ratchet =  $::ratchet     // 0;
local $::ignorecase =  $::ignorecase // 0;
local $::ignoreaccent =  $::ignoreaccent    // 0;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_ARRAY( qw< || | && & > ))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token termish
##          token termish {
##              <.ws>
##              <quantified_atom>+
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantified_atom'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->ws)) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
});
}
else {
();
}
}
);
}
##     token infixish
##          token infixish {
##              <!infixstopper>
##              <!stdstopper>
##              <rxinfix>
##              {
##                  $<O> = $<rxinfix><O>;
##                  $<sym> = $<rxinfix><sym>;
##              }
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rxinfix'], sub {
my $C = shift;
$C->rxinfix
}))) {
scalar(do {
my $M = $C; 
$M->{O} = $M->{rxinfix}{O};
$M->{sym} = $M->{rxinfix}{sym};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token rxinfix__S_418VertVert (  :$sym is context<rw> = <||> --> Tight_or )
##          token rxinfix:sym<||> ( --> Tight_or ) { <sym> }

sub rxinfix__S_418VertVert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_418VertVert',$retree) }
sub rxinfix__S_418VertVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_418VertVert",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\|\|/)
);
}
##     token rxinfix__S_419AmpAmp (  :$sym is context<rw> = <&&> --> Tight_and )
##          token rxinfix:sym<&&> ( --> Tight_and ) { <sym> }

sub rxinfix__S_419AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_419AmpAmp',$retree) }
sub rxinfix__S_419AmpAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_419AmpAmp",  map { STD::Tight_and->coerce($_) } 
$C->_PATTERN(qr/\G\&\&/)
);
}
##     token rxinfix__S_420Vert (  :$sym is context<rw> = <|> --> Junctive_or )
##          token rxinfix:sym<|> ( --> Junctive_or ) { <sym> }

sub rxinfix__S_420Vert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_420Vert',$retree) }
sub rxinfix__S_420Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_420Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}
##     token rxinfix__S_421Amp (  :$sym is context<rw> = <&> --> Junctive_and )
##          token rxinfix:sym<&> ( --> Junctive_and ) { <sym> }

sub rxinfix__S_421Amp__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_421Amp',$retree) }
sub rxinfix__S_421Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_421Amp",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\G\&/)
);
}
##     token rxinfix__S_422Tilde (  :$sym is context<rw> = <~> --> Additive )
##          token rxinfix:sym<~> ( --> Additive ) { <sym> }

sub rxinfix__S_422Tilde__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_422Tilde',$retree) }
sub rxinfix__S_422Tilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_422Tilde",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}

##     token quantified_atom
##          token quantified_atom {
##              <!stopper>
##              <!rxinfix>
##              <atom>
##              [ <.ws> <quantifier>
##      #            <?{ $<atom>.max_width }>
##      #                || <.panic: "Can't quantify zero-width atom">
##              ]?
##              <.ws>
##          }

sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom',$retree) }
sub quantified_atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantifier'} = [];

$self->_MATCHIFYr($S, "quantified_atom", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->rxinfix
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
});
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token atom
##          token atom {
##              :dba('regex atom')
##              [
##              | \w
##              | <metachar> ::
##              | <.panic: "Unrecognized regex metacharacter">
##              ]
##          }

sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom',$retree) }
sub atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "atom", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'atom_01') {
$C->deb("Fate passed to atom_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'atom_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("atom_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_COMMITBRANCH()
}, $C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
}))
},
sub { my $C=shift;
$C->panic("Unrecognized regex metacharacter")
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# sequence stoppers
##     token metachar__S_423Gt (:$sym is context<rw> =  > )
##          token metachar:sym >  { '>'  :: <fail> }

sub metachar__S_423Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_423Gt',$retree) }
sub metachar__S_423Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_423Gt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('>'))
);
}
##     token metachar__S_424AmpAmp (:$sym is context<rw> = <&&>)
##          token metachar:sym<&&>  { '&&' :: <fail> }

sub metachar__S_424AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_424AmpAmp',$retree) }
sub metachar__S_424AmpAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_424AmpAmp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('&&'))
);
}
##     token metachar__S_425Amp (:$sym is context<rw> = <&>)
##          token metachar:sym<&>   { '&'  :: <fail> }

sub metachar__S_425Amp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_425Amp',$retree) }
sub metachar__S_425Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_425Amp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('&'))
);
}
##     token metachar__S_426VertVert (:$sym is context<rw> = <||>)
##          token metachar:sym<||>  { '||' :: <fail> }

sub metachar__S_426VertVert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_426VertVert',$retree) }
sub metachar__S_426VertVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_426VertVert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('||'))
);
}
##     token metachar__S_427Vert (:$sym is context<rw> = <|>)
##          token metachar:sym<|>   { '|'  :: <fail> }

sub metachar__S_427Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_427Vert',$retree) }
sub metachar__S_427Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_427Vert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('|'))
);
}
##     token metachar__S_428Ket (:$sym is context<rw> = <]>)
##          token metachar:sym<]>   { ']'  :: <fail> }

sub metachar__S_428Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_428Ket',$retree) }
sub metachar__S_428Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(]);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_428Ket", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(']'))
);
}
##     token metachar__S_429Thesis (:$sym is context<rw> = <)>)
##          token metachar:sym<)>   { ')'  :: <fail> }

sub metachar__S_429Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_429Thesis',$retree) }
sub metachar__S_429Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_429Thesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(')'))
);
}

##     token metachar__S_430quant (:$sym is context<rw> = 'quant')
##          token metachar:quant { <quantifier> <.panic: "quantifier quantifies nothing"> }

sub metachar__S_430quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_430quant',$retree) }
sub metachar__S_430quant {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quant';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_430quant", 
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->panic("quantifier quantifies nothing");
}
else {
();
}
}
);
}

# "normal" metachars

##     token metachar__S_431sigwhite (:$sym is context<rw> = 'sigwhite')
##          token metachar:sigwhite {
##              <normspace>
##          }

sub metachar__S_431sigwhite__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_431sigwhite',$retree) }
sub metachar__S_431sigwhite {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigwhite';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_431sigwhite", 
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
);
}

##     token metachar__S_432Cur_Ly (:$sym is context<rw> = <{ }>)
##          token metachar:sym<{ }> {
##              <?before '{'>
##              <codeblock>
##              {{ $/<sym> := <{ }> }}
##          }

sub metachar__S_432Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_432Cur_Ly',$retree) }
sub metachar__S_432Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_432Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw({ })] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_433mod (:$sym is context<rw> = 'mod')
##          token metachar:mod {
##              <mod_internal>
##              { $/<sym> := $<mod_internal><sym> }
##          }

sub metachar__S_433mod__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_433mod',$retree) }
sub metachar__S_433mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_433mod", 
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_internal'], sub {
my $C = shift;
$C->mod_internal
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = $M->{mod_internal}{sym} ;
}, $C);
}
else {
();
}
}
);
}

##     token metachar__S_434Colon (:$sym is context<rw> = <:>)
##          token metachar:sym<:> {
##              <sym>
##          }

sub metachar__S_434Colon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_434Colon',$retree) }
sub metachar__S_434Colon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_434Colon", 
$C->_PATTERN(qr/\G\:/)
);
}

##     token metachar__S_435ColonColon (:$sym is context<rw> = <::>)
##          token metachar:sym<::> {
##              <sym>
##          }

sub metachar__S_435ColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_435ColonColon',$retree) }
sub metachar__S_435ColonColon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_435ColonColon", 
$C->_PATTERN(qr/\G\:\:/)
);
}

##     token metachar__S_436ColonColonColon (:$sym is context<rw> = <:::>)
##          token metachar:sym<:::> {
##              <sym>
##          }

sub metachar__S_436ColonColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_436ColonColonColon',$retree) }
sub metachar__S_436ColonColonColon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:::);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_436ColonColonColon", 
$C->_PATTERN(qr/\G\:\:\:/)
);
}

##     token metachar__S_437Bra_Ket (:$sym is context<rw> = <[ ]>)
##          token metachar:sym<[ ]> {
##              '[' {} [:lang(self.unbalanced(']')) <nibbler>]
##              [ ']' || <.panic: "Unable to parse regex; couldn't find right bracket"> ]
##              { $/<sym> := <[ ]> }
##          }

sub metachar__S_437Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_437Bra_Ket',$retree) }
sub metachar__S_437Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_437Bra_Ket", 
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(']'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right bracket")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw([ ])] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_438Paren_Thesis (:$sym is context<rw> = <( )>)
##          token metachar:sym<( )> {
##              '(' {} [:lang(self.unbalanced(')')) <nibbler>]
##              [ ')' || <.panic: "Unable to parse regex; couldn't find right parenthesis"> ]
##              { $/<sym> := <( )> }
##          }

sub metachar__S_438Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_438Paren_Thesis',$retree) }
sub metachar__S_438Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_438Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw[( )]] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_439LtParen (:$sym is context<rw> =  <( )
##          token metachar:sym <(  { '<(' }

sub metachar__S_439LtParen__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_439LtParen',$retree) }
sub metachar__S_439LtParen {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<('];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_439LtParen", 
$C->_EXACT('<(')
);
}
##     token metachar__S_440ThesisGt (:$sym is context<rw> =  )> )
##          token metachar:sym )>  { ')>' }

sub metachar__S_440ThesisGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_440ThesisGt',$retree) }
sub metachar__S_440ThesisGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //[')>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_440ThesisGt", 
$C->_EXACT(')>')
);
}

##     token metachar__S_441LtLt (:$sym is context<rw> =  << )
##          token metachar:sym <<  { '<<' }

sub metachar__S_441LtLt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_441LtLt',$retree) }
sub metachar__S_441LtLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_441LtLt", 
$C->_EXACT('<<')
);
}
##     token metachar__S_442GtGt (:$sym is context<rw> =  >> )
##          token metachar:sym >>  { '>>' }

sub metachar__S_442GtGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_442GtGt',$retree) }
sub metachar__S_442GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_442GtGt", 
$C->_EXACT('>>')
);
}
##     token metachar__S_443Fre (:$sym is context<rw> = <  >)
##          token metachar:sym<  > { '' }

sub metachar__S_443Fre__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_443Fre',$retree) }
sub metachar__S_443Fre {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_443Fre", 
$C->_EXACT('')
);
}
##     token metachar__S_444Nch (:$sym is context<rw> = <  >)
##          token metachar:sym<  > { '' }

sub metachar__S_444Nch__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_444Nch',$retree) }
sub metachar__S_444Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_444Nch", 
$C->_EXACT('')
);
}

##     token metachar__S_445qw (:$sym is context<rw> = 'qw')
##          token metachar:qw {
##              <?before '<' \s >  # (note required whitespace)
##              <quote>
##          }

sub metachar__S_445qw__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_445qw',$retree) }
sub metachar__S_445qw {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qw';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_445qw", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('<'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
});
}
else {
();
}
}
);
}

##     token metachar__S_446Lt_Gt (:$sym is context<rw> = < >)
##          token metachar:sym< > {
##              '<' <unsp>? {} <assertion>
##              [ '>' || <.panic: "regex assertion not terminated by angle bracket"> ]
##          }

sub metachar__S_446Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_446Lt_Gt',$retree) }
sub metachar__S_446Lt_Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'unsp'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_446Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>')} 
or
eval { push @gather, $C->panic("regex assertion not terminated by angle bracket")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_447Back (:$sym is context<rw> = <\\>)
##          token metachar:sym<\\> { <sym> <backslash> }

sub metachar__S_447Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_447Back',$retree) }
sub metachar__S_447Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_447Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##     token metachar__S_448Dot (:$sym is context<rw> = <.>)
##          token metachar:sym<.>  { <sym> }

sub metachar__S_448Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_448Dot',$retree) }
sub metachar__S_448Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_448Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token metachar__S_449CaretCaret (:$sym is context<rw> = <^^>)
##          token metachar:sym<^^> { <sym> }

sub metachar__S_449CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_449CaretCaret',$retree) }
sub metachar__S_449CaretCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_449CaretCaret", 
$C->_PATTERN(qr/\G\^\^/)
);
}
##     token metachar__S_450Caret (:$sym is context<rw> = <^>)
##          token metachar:sym<^>  { <sym> }

sub metachar__S_450Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_450Caret',$retree) }
sub metachar__S_450Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_450Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
##     token metachar__S_451DollarDollar (:$sym is context<rw> = <$$>)
##          token metachar:sym<$$> {
##              <sym>
##              [ (\w+) <.obs("\$\$" ~ $0.text ~ " to deref var inside a regex", "\$(\$" ~ $0.text ~ ")")> ]?
##          }

sub metachar__S_451DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_451DollarDollar',$retree) }
sub metachar__S_451DollarDollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($$);


my $C = $self;
my $S = $C->{_pos};
$C->{'0'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_451DollarDollar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\$/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))) {
$C->obs("\$\$" . $$C{0}->text . " to deref var inside a regex", "\$(\$" . $$C{0}->text . ")");
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}
##     token metachar__S_452Dollar (:$sym is context<rw> = <$>)
##          token metachar:sym<$>  {
##              '$'
##              <?before
##              | \s
##              | '|'
##              | '&'
##              | ')'
##              | ']'
##              | '>'
##              | $
##              | <stopper>
##              >
##          }

sub metachar__S_452Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_452Dollar',$retree) }
sub metachar__S_452Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_452Dollar", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'metachar__S_452Dollar_01') {
$C->deb("Fate passed to metachar__S_452Dollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar__S_452Dollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar__S_452Dollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('|')
},
sub { my $C=shift;
$C->_EXACT('&')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('>')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token metachar__S_453Single_Single (:$sym is context<rw> = <' '>)
##          token metachar:sym<' '> { <?before "'"> [:lang($.cursor_fresh($+LANG)) <quote>] }

sub metachar__S_453Single_Single__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_453Single_Single',$retree) }
sub metachar__S_453Single_Single {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(' ')];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_453Single_Single", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G'/)
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}
##     token metachar__S_454Double_Double (:$sym is context<rw> = <" ">)
##          token metachar:sym<" "> { <?before '"'> [:lang($.cursor_fresh($+LANG)) <quote>] }

sub metachar__S_454Double_Double__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_454Double_Double',$retree) }
sub metachar__S_454Double_Double {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(" ")];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_454Double_Double", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('"')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}

##     token metachar__S_455var (:$sym is context<rw> = 'var')
##          token metachar:var {
##              <!before '$$'>
##              <?before <sigil>>
##              [:lang($.cursor_fresh($+LANG)) <variable> <.ws> ]
##              $<binding> = ( <.ws> '=' <.ws> <quantified_atom> )?
##              { $<sym> = $<variable>.item; }
##          }

sub metachar__S_455var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_455var',$retree) }
sub metachar__S_455var {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'var';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_455var", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('$$')
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
$C->ws;
}
else {
();
}
}
}))) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['binding'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
scalar(do {
my $M = $C;  $M->{sym} = $M->{variable}->item; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token backslash__S_456unspace (:$sym is context<rw> = 'unspace')
##          token backslash:unspace { <?before \s> <.SUPER::ws> }

sub backslash__S_456unspace__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_456unspace',$retree) }
sub backslash__S_456unspace {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unspace';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_456unspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
$C->SUPER::ws;
}
else {
();
}
}
);
}

##     token backslash__S_4570 (:$sym is context<rw> = <0>)
##          token backslash:sym<0> { '0' <!before <[0..7]> > }

sub backslash__S_4570__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_4570',$retree) }
sub backslash__S_4570 {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(0);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "backslash__S_4570", 
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[0-7]/)
})
});
}
else {
();
}
}
);
}

##     token backslash__S_458A (:$sym is context<rw> = 'A')
##          token backslash:A { <sym> <.obs('\\A as beginning-of-string matcher', '^')> }

sub backslash__S_458A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_458A',$retree) }
sub backslash__S_458A {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'A';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_458A", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GA/))) {
$C->obs('\\A as beginning-of-string matcher', '^');
}
else {
();
}
}
);
}
##     token backslash__S_459a (:$sym is context<rw> = 'a')
##          token backslash:a { <sym> <.panic: "\\a is allowed only in strings, not regexes"> }

sub backslash__S_459a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_459a',$retree) }
sub backslash__S_459a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_459a", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ga/))) {
$C->panic("\\a is allowed only in strings, not regexes");
}
else {
();
}
}
);
}
##     token backslash__S_460b (:$sym is context<rw> = 'b')
##          token backslash:b { :i <sym> }

sub backslash__S_460b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_460b',$retree) }
sub backslash__S_460b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_460b", 
$C->_PATTERN(qr/\G(?i:b)/)
);
}
##     token backslash__S_461c (:$sym is context<rw> = 'c')
##          token backslash:c { :i <sym>
##              [
##              | <codepoint>
##              | \d+
##              | [ <[ ?.._ ]> || <.panic: "Unrecognized \\c character"> ]
##              ]
##          }

sub backslash__S_461c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_461c',$retree) }
sub backslash__S_461c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_461c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:c)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_461c_01') {
$C->deb("Fate passed to backslash__S_461c_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_461c_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_461c_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['codepoint'], sub {
my $C = shift;
$C->codepoint
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:[?-_])/)} 
or
eval { push @gather, $C->panic("Unrecognized \\c character")} or do { die $@ if $@ };
@gather;
}
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_462d (:$sym is context<rw> = 'd')
##          token backslash:d { :i <sym> }

sub backslash__S_462d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_462d',$retree) }
sub backslash__S_462d {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'd';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_462d", 
$C->_PATTERN(qr/\G(?i:d)/)
);
}
##     token backslash__S_463e (:$sym is context<rw> = 'e')
##          token backslash:e { :i <sym> }

sub backslash__S_463e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_463e',$retree) }
sub backslash__S_463e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_463e", 
$C->_PATTERN(qr/\G(?i:e)/)
);
}
##     token backslash__S_464f (:$sym is context<rw> = 'f')
##          token backslash:f { :i <sym> }

sub backslash__S_464f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_464f',$retree) }
sub backslash__S_464f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_464f", 
$C->_PATTERN(qr/\G(?i:f)/)
);
}
##     token backslash__S_465h (:$sym is context<rw> = 'h')
##          token backslash:h { :i <sym> }

sub backslash__S_465h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_465h',$retree) }
sub backslash__S_465h {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_465h", 
$C->_PATTERN(qr/\G(?i:h)/)
);
}
##     token backslash__S_466n (:$sym is context<rw> = 'n')
##          token backslash:n { :i <sym> }

sub backslash__S_466n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_466n',$retree) }
sub backslash__S_466n {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_466n", 
$C->_PATTERN(qr/\G(?i:n)/)
);
}
##     token backslash__S_467o (:$sym is context<rw> = 'o')
##          token backslash:o { :i <sym> [ <octint> | '['<octint>[','<octint>]*']' ] }

sub backslash__S_467o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_467o',$retree) }
sub backslash__S_467o {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{_pos};
$C->{'octint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_467o", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:o)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_467o_01') {
$C->deb("Fate passed to backslash__S_467o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_467o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_467o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\[)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\,)/))) {
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
});
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G(?i:\])/);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_468Q (:$sym is context<rw> = 'Q')
##          token backslash:Q { <sym> <.obs('\\Q as quotemeta', 'quotes or literal variable match')> }

sub backslash__S_468Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_468Q',$retree) }
sub backslash__S_468Q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_468Q", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GQ/))) {
$C->obs('\\Q as quotemeta', 'quotes or literal variable match');
}
else {
();
}
}
);
}
##     token backslash__S_469r (:$sym is context<rw> = 'r')
##          token backslash:r { :i <sym> }

sub backslash__S_469r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_469r',$retree) }
sub backslash__S_469r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_469r", 
$C->_PATTERN(qr/\G(?i:r)/)
);
}
##     token backslash__S_470s (:$sym is context<rw> = 's')
##          token backslash:s { :i <sym> }

sub backslash__S_470s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_470s',$retree) }
sub backslash__S_470s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_470s", 
$C->_PATTERN(qr/\G(?i:s)/)
);
}
##     token backslash__S_471t (:$sym is context<rw> = 't')
##          token backslash:t { :i <sym> }

sub backslash__S_471t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_471t',$retree) }
sub backslash__S_471t {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_471t", 
$C->_PATTERN(qr/\G(?i:t)/)
);
}
##     token backslash__S_472v (:$sym is context<rw> = 'v')
##          token backslash:v { :i <sym> }

sub backslash__S_472v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_472v',$retree) }
sub backslash__S_472v {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'v';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_472v", 
$C->_PATTERN(qr/\G(?i:v)/)
);
}
##     token backslash__S_473w (:$sym is context<rw> = 'w')
##          token backslash:w { :i <sym> }

sub backslash__S_473w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_473w',$retree) }
sub backslash__S_473w {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_473w", 
$C->_PATTERN(qr/\G(?i:w)/)
);
}
##     token backslash__S_474x (:$sym is context<rw> = 'x')
##          token backslash:x { :i <sym> [ <hexint> | '[' [<.ws><hexint><.ws> ] ** ',' ']' ] }

sub backslash__S_474x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_474x',$retree) }
sub backslash__S_474x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'hexint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_474x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:x)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_474x_01') {
$C->deb("Fate passed to backslash__S_474x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_474x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_474x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\[)/))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_PATTERN(qr/\G(?i:\,)/)
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G(?i:\])/);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_475z (:$sym is context<rw> = 'z')
##          token backslash:z { <sym> <.obs('\\z as end-of-string matcher', '$')> }

sub backslash__S_475z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_475z',$retree) }
sub backslash__S_475z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'z';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_475z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gz/))) {
$C->obs('\\z as end-of-string matcher', '$');
}
else {
();
}
}
);
}
##     token backslash__S_476Z (:$sym is context<rw> = 'Z')
##          token backslash:Z { <sym> <.obs('\\Z as end-of-string matcher', '\\n?$')> }

sub backslash__S_476Z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_476Z',$retree) }
sub backslash__S_476Z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Z';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_476Z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GZ/))) {
$C->obs('\\Z as end-of-string matcher', '\\n?$');
}
else {
();
}
}
);
}
##     token backslash__S_477misc (:$sym is context<rw> = 'misc')
##          token backslash:misc { $<litchar>=(\W) }

sub backslash__S_477misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_477misc',$retree) }
sub backslash__S_477misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_477misc", 
$C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
})
);
}
##     token backslash__S_478oops (:$sym is context<rw> = 'oops')
##          token backslash:oops { <.panic: "Unrecognized regex backslash sequence"> }

sub backslash__S_478oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_478oops',$retree) }
sub backslash__S_478oops {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_478oops", 
$C->panic("Unrecognized regex backslash sequence")
);
}

##     token assertion__S_479DotDotDot (:$sym is context<rw> = <...>)
##          token assertion:sym<...> { <sym> }

sub assertion__S_479DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_479DotDotDot',$retree) }
sub assertion__S_479DotDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_479DotDotDot", 
$C->_PATTERN(qr/\G\.\.\./)
);
}
##     token assertion__S_480QuestionQuestionQuestion (:$sym is context<rw> = <???>)
##          token assertion:sym<???> { <sym> }

sub assertion__S_480QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_480QuestionQuestionQuestion',$retree) }
sub assertion__S_480QuestionQuestionQuestion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(???);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_480QuestionQuestionQuestion", 
$C->_PATTERN(qr/\G\?\?\?/)
);
}
##     token assertion__S_481BangBangBang (:$sym is context<rw> = <!!!>)
##          token assertion:sym<!!!> { <sym> }

sub assertion__S_481BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_481BangBangBang',$retree) }
sub assertion__S_481BangBangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_481BangBangBang", 
$C->_PATTERN(qr/\G\!\!\!/)
);
}

##     token assertion__S_482Question (:$sym is context<rw> = <?>)
##          token assertion:sym<?> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_482Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_482Question',$retree) }
sub assertion__S_482Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_482Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_482Question_01') {
$C->deb("Fate passed to assertion__S_482Question_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_482Question_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_482Question_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_483Bang (:$sym is context<rw> = <!>)
##          token assertion:sym<!> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_483Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_483Bang',$retree) }
sub assertion__S_483Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_483Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_483Bang_01') {
$C->deb("Fate passed to assertion__S_483Bang_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_483Bang_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_483Bang_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_484Star (:$sym is context<rw> = <*>)
##          token assertion:sym<*> { <sym> [ <?before '>'> | <.ws> <nibbler> ] }

sub assertion__S_484Star__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_484Star',$retree) }
sub assertion__S_484Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_484Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_484Star_01') {
$C->deb("Fate passed to assertion__S_484Star_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_484Star_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_484Star_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_485Cur_Ly (:$sym is context<rw> = <{ }>)
##          token assertion:sym<{ }> { <codeblock> }

sub assertion__S_485Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_485Cur_Ly',$retree) }
sub assertion__S_485Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_485Cur_Ly", 
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
);
}

##     token assertion__S_486variable (:$sym is context<rw> = 'variable')
##          token assertion:variable {
##              <?before <sigil>>  # note: semantics must be determined per-sigil
##              [:lang($.cursor_fresh($+LANG).unbalanced('>')) <variable=EXPR(item %LOOSEST)>]
##          }

sub assertion__S_486variable__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_486variable',$retree) }
sub assertion__S_486variable {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'variable';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_486variable", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;    $C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->EXPR(\%LOOSEST)
})
});
}
else {
();
}
}
);
}

##     token assertion__S_487method (:$sym is context<rw> = 'method')
##          token assertion:method {
##              '.' [
##                  | <?before <alpha> > <assertion>
##                  | [ :lang($.cursor_fresh($+LANG).unbalanced('>')) <dottyop> ]
##                  ]
##          }

sub assertion__S_487method__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_487method',$retree) }
sub assertion__S_487method {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'method';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_487method", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_487method_01') {
$C->deb("Fate passed to assertion__S_487method_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_487method_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_487method_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_488name (:$sym is context<rw> = 'name')
##          token assertion:name { [ :lang($.cursor_fresh($+LANG).unbalanced('>')) <longname> ]
##                                          [
##                                          | <?before '>' >
##                                          | <.ws> <nibbler>
##                                          | '=' <assertion>
##                                          | ':' <.ws>
##                                              [ :lang($.cursor_fresh($+LANG).unbalanced('>')) <arglist> ]
##                                          | '(' {}
##                                              [ :lang($.cursor_fresh($+LANG)) <arglist> ]
##                                              [ ')' || <.panic: "Assertion call missing right parenthesis"> ]
##                                          ]?
##          }

sub assertion__S_488name__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_488name',$retree) }
sub assertion__S_488name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'name';


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'nibbler'} = [];
$C->{'assertion'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_488name", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_488name_02') {
$C->deb("Fate passed to assertion__S_488name_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_488name_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_488name_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Assertion call missing right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}

##     token assertion__S_489Bra (:$sym is context<rw> = <[>)
##          token assertion:sym<[> { <?before '['> <cclass_elem>+ }

sub assertion__S_489Bra__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_489Bra',$retree) }
sub assertion__S_489Bra {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q([);


my $C = $self;
my $S = $C->{_pos};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_489Bra", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_490Plus (:$sym is context<rw> = <+>)
##          token assertion:sym<+> { <?before '+'> <cclass_elem>+ }

sub assertion__S_490Plus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_490Plus',$retree) }
sub assertion__S_490Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_490Plus", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('+')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_491Minus (:$sym is context<rw> = <->)
##          token assertion:sym<-> { <?before '-'> <cclass_elem>+ }

sub assertion__S_491Minus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_491Minus',$retree) }
sub assertion__S_491Minus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{_pos};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_491Minus", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('-')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_492Dot (:$sym is context<rw> = <.>)
##          token assertion:sym<.> { <sym> }

sub assertion__S_492Dot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_492Dot',$retree) }
sub assertion__S_492Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_492Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token assertion__S_493Comma (:$sym is context<rw> = <,>)
##          token assertion:sym<,> { <sym> }

sub assertion__S_493Comma__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_493Comma',$retree) }
sub assertion__S_493Comma {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[,];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_493Comma", 
$C->_PATTERN(qr/\G\,/)
);
}
##     token assertion__S_494TildeTilde (:$sym is context<rw> = <~~>)
##          token assertion:sym<~~> { <sym> [ <?before '>'> | \d+ | <desigilname> ] }

sub assertion__S_494TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_494TildeTilde',$retree) }
sub assertion__S_494TildeTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_494TildeTilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\~/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_494TildeTilde_01') {
$C->deb("Fate passed to assertion__S_494TildeTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_494TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_494TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_495bogus (:$sym is context<rw> = 'bogus')
##          token assertion:bogus { <.panic: "Unrecognized regex assertion"> }

sub assertion__S_495bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_495bogus',$retree) }
sub assertion__S_495bogus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'bogus';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_495bogus", 
$C->panic("Unrecognized regex assertion")
);
}

##     token sign
##          token sign { '+' | '-' | <?> }

sub sign__PEEK { $_[0]->_AUTOLEXpeek('sign',$retree) }
sub sign {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "sign", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'sign_00') {
$C->deb("Fate passed to sign_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'sign_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sign_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('+')
},
sub { my $C=shift;
$C->_EXACT('-')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}
##     token cclass_elem
##          token cclass_elem {
##              :dba('character class element')
##              <sign>
##              <.normspace>?
##              [
##              | <name>
##              | <before '['> <quibble($.cursor_fresh( ::STD::Q ).tweak(:q))> # XXX parse as q[] for now
##              ]
##              <.normspace>?
##          }

sub cclass_elem__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem',$retree) }
sub cclass_elem {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "cclass_elem", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sign'], sub {
my $C = shift;
$C->sign
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->normspace
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'cclass_elem_01') {
$C->deb("Fate passed to cclass_elem_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'cclass_elem_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("cclass_elem_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_OPTr(sub { my $C=shift;
$C->normspace
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_arg
##          token mod_arg { :dba('modifier argument') '(' ~ ')' <semilist> }

sub mod_arg__PEEK { $_[0]->_AUTOLEXpeek('mod_arg',$retree) }
sub mod_arg {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "mod_arg", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'modifier argument')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

##     token mod_internal__S_496Colonmy (:$sym is context<rw> = <:my>)
##          token mod_internal:sym<:my>    { ':' <?before 'my' \s > [:lang($.cursor_fresh($+LANG)) <statement> <eat_terminator> ] }

sub mod_internal__S_496Colonmy__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_496Colonmy',$retree) }
sub mod_internal__S_496Colonmy {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:my);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_496Colonmy", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('my'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
});
}
else {
();
}
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX needs some generalization

##     token mod_internal__S_497Coloni (:$sym is context<rw> = <:i>)
##          token mod_internal:sym<:i>    { $<sym>=[':i'|':ignorecase']  { $+ignorecase = 1 } }

sub mod_internal__S_497Coloni__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_497Coloni',$retree) }
sub mod_internal__S_497Coloni {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_497Coloni", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_497Coloni_01') {
$C->deb("Fate passed to mod_internal__S_497Coloni_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_497Coloni_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_497Coloni_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignorecase = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_498ColonBangi (:$sym is context<rw> = <:!i>)
##          token mod_internal:sym<:!i>   { $<sym>=[':!i'|':!ignorecase']  { $+ignorecase = 0 } }

sub mod_internal__S_498ColonBangi__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_498ColonBangi',$retree) }
sub mod_internal__S_498ColonBangi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_498ColonBangi", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_498ColonBangi_01') {
$C->deb("Fate passed to mod_internal__S_498ColonBangi_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_498ColonBangi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_498ColonBangi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!i')
},
sub { my $C=shift;
$C->_EXACT(':!ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignorecase = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_499ColoniParen_Thesis (:$sym is context<rw> = <:i( )>)
##          token mod_internal:sym<:i( )> { $<sym>=[':i'|':ignorecase'] <mod_arg> { $+ignorecase = eval $<mod_arg>.text } }

sub mod_internal__S_499ColoniParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_499ColoniParen_Thesis',$retree) }
sub mod_internal__S_499ColoniParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:i( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_499ColoniParen_Thesis", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_499ColoniParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_499ColoniParen_Thesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_499ColoniParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_499ColoniParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ignorecase = eval $M->{mod_arg}->text ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_500Colon0i (:$sym is context<rw> = <:0i>)
##          token mod_internal:sym<:0i>   { ':' (\d+) ['i'|'ignorecase'] { $+ignorecase = $0 } }

sub mod_internal__S_500Colon0i__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_500Colon0i',$retree) }
sub mod_internal__S_500Colon0i {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_500Colon0i", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_500Colon0i_02') {
$C->deb("Fate passed to mod_internal__S_500Colon0i_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_500Colon0i_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_500Colon0i_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('i')
},
sub { my $C=shift;
$C->_EXACT('ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::ignorecase = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_501Colona (:$sym is context<rw> = <:a>)
##          token mod_internal:sym<:a>    { $<sym>=[':a'|':ignoreaccent']  { $+ignoreaccent = 1 } }

sub mod_internal__S_501Colona__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_501Colona',$retree) }
sub mod_internal__S_501Colona {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:a);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_501Colona", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_501Colona_01') {
$C->deb("Fate passed to mod_internal__S_501Colona_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_501Colona_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_501Colona_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignoreaccent = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_502ColonBanga (:$sym is context<rw> = <:!a>)
##          token mod_internal:sym<:!a>   { $<sym>=[':!a'|':!ignoreaccent']  { $+ignoreaccent = 0 } }

sub mod_internal__S_502ColonBanga__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_502ColonBanga',$retree) }
sub mod_internal__S_502ColonBanga {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!a);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_502ColonBanga", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_502ColonBanga_01') {
$C->deb("Fate passed to mod_internal__S_502ColonBanga_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_502ColonBanga_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_502ColonBanga_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!a')
},
sub { my $C=shift;
$C->_EXACT(':!ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignoreaccent = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_503ColonaParen_Thesis (:$sym is context<rw> = <:a( )>)
##          token mod_internal:sym<:a( )> { $<sym>=[':a'|':ignoreaccent'] <mod_arg> { $+ignoreaccent = eval $<mod_arg>.text } }

sub mod_internal__S_503ColonaParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_503ColonaParen_Thesis',$retree) }
sub mod_internal__S_503ColonaParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:a( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_503ColonaParen_Thesis", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_503ColonaParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_503ColonaParen_Thesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_503ColonaParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_503ColonaParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ignoreaccent = eval $M->{mod_arg}->text ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_504Colon0a (:$sym is context<rw> = <:0a>)
##          token mod_internal:sym<:0a>   { ':' (\d+) ['a'|'ignoreaccent'] { $+ignoreaccent = $0 } }

sub mod_internal__S_504Colon0a__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_504Colon0a',$retree) }
sub mod_internal__S_504Colon0a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0a);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_504Colon0a", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_504Colon0a_02') {
$C->deb("Fate passed to mod_internal__S_504Colon0a_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_504Colon0a_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_504Colon0a_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('a')
},
sub { my $C=shift;
$C->_EXACT('ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::ignoreaccent = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_505Colons (:$sym is context<rw> = <:s>)
##          token mod_internal:sym<:s>    { ':s' 'igspace'?  { $+sigspace = 1 } }

sub mod_internal__S_505Colons__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_505Colons',$retree) }
sub mod_internal__S_505Colons {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:s);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_505Colons", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_506ColonBangs (:$sym is context<rw> = <:!s>)
##          token mod_internal:sym<:!s>   { ':!s' 'igspace'?  { $+sigspace = 0 } }

sub mod_internal__S_506ColonBangs__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_506ColonBangs',$retree) }
sub mod_internal__S_506ColonBangs {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!s);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_506ColonBangs", 
do {
if (my ($C) = ($C->_EXACT(':!s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_507ColonsParen_Thesis (:$sym is context<rw> = <:s( )>)
##          token mod_internal:sym<:s( )> { ':s' 'igspace'? <mod_arg> { $+sigspace = eval $<mod_arg>.text } }

sub mod_internal__S_507ColonsParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_507ColonsParen_Thesis',$retree) }
sub mod_internal__S_507ColonsParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:s( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_507ColonsParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::sigspace = eval $M->{mod_arg}->text ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_508Colon0s (:$sym is context<rw> = <:0s>)
##          token mod_internal:sym<:0s>   { ':' (\d+) 's' 'igspace'?  { $+sigspace = $0 } }

sub mod_internal__S_508Colon0s__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_508Colon0s',$retree) }
sub mod_internal__S_508Colon0s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0s);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_508Colon0s", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_509Colonr (:$sym is context<rw> = <:r>)
##          token mod_internal:sym<:r>    { ':r' 'atchet'?  { $+ratchet = 1 } }

sub mod_internal__S_509Colonr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_509Colonr',$retree) }
sub mod_internal__S_509Colonr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:r);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_509Colonr", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_510ColonBangr (:$sym is context<rw> = <:!r>)
##          token mod_internal:sym<:!r>   { ':!r' 'atchet'?  { $+ratchet = 0 } }

sub mod_internal__S_510ColonBangr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_510ColonBangr',$retree) }
sub mod_internal__S_510ColonBangr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!r);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_510ColonBangr", 
do {
if (my ($C) = ($C->_EXACT(':!r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_511ColonrParen_Thesis (:$sym is context<rw> = <:r( )>)
##          token mod_internal:sym<:r( )> { ':r' 'atchet'?  <mod_arg> { $+ratchet = eval $<mod_arg>.text } }

sub mod_internal__S_511ColonrParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_511ColonrParen_Thesis',$retree) }
sub mod_internal__S_511ColonrParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:r( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_511ColonrParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ratchet = eval $M->{mod_arg}->text ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_512Colon0r (:$sym is context<rw> = <:0r>)
##          token mod_internal:sym<:0r>   { ':' (\d+) 'r' 'atchet'?  { $+ratchet = $0 } }

sub mod_internal__S_512Colon0r__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_512Colon0r',$retree) }
sub mod_internal__S_512Colon0r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0r);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_512Colon0r", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_513ColonPerl5 (:$sym is context<rw> = <:Perl5>)
##          token mod_internal:sym<:Perl5>    { [':Perl5' | ':P5'] [ :lang( $.cursor_fresh( ::STD::P5Regex ).unbalanced($+GOAL) ) <nibbler> ] }

sub mod_internal__S_513ColonPerl5__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_513ColonPerl5',$retree) }
sub mod_internal__S_513ColonPerl5 {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:Perl5);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_513ColonPerl5", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_513ColonPerl5_01') {
$C->deb("Fate passed to mod_internal__S_513ColonPerl5_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_513ColonPerl5_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_513ColonPerl5_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':Perl5')
},
sub { my $C=shift;
$C->_EXACT(':P5')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($::GOAL) );  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
});
}
else {
();
}
}
);
}

##     token mod_internal__S_514adv (:$sym is context<rw> = 'adv')
##          token mod_internal:adv {
##              <?before ':' <identifier> > [ :lang($.cursor_fresh($+LANG)) <quotepair> ] { $/<sym> := : $<quotepair><key> }
##          }

sub mod_internal__S_514adv__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_514adv',$retree) }
sub mod_internal__S_514adv {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'adv';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_514adv", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
})
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} =[':','$<quotepair><key>'] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_515oops (:$sym is context<rw> = 'oops')
##          token mod_internal:oops { ':'\w+ <.panic: "Unrecognized regex modifier"> }

sub mod_internal__S_515oops__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_515oops',$retree) }
sub mod_internal__S_515oops {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_515oops", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
$C->panic("Unrecognized regex modifier");
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantifier__S_516Star (:$sym is context<rw> = <*>)
##          token quantifier:sym<*>  { <sym> <quantmod> }

sub quantifier__S_516Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_516Star',$retree) }
sub quantifier__S_516Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_516Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_517Plus (:$sym is context<rw> = <+>)
##          token quantifier:sym<+>  { <sym> <quantmod> }

sub quantifier__S_517Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_517Plus',$retree) }
sub quantifier__S_517Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_517Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_518Question (:$sym is context<rw> = <?>)
##          token quantifier:sym<?>  { <sym> <quantmod> }

sub quantifier__S_518Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_518Question',$retree) }
sub quantifier__S_518Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_518Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_519StarStar (:$sym is context<rw> = <**>)
##          token quantifier:sym<**> { <sym> :: <normspace>? <quantmod> <normspace>?
##              [
##              | \d+ [ '..' [ \d+ | '*' ] ]?
##              | <codeblock>
##              | <quantified_atom>
##              ]
##          }

sub quantifier__S_519StarStar__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_519StarStar',$retree) }
sub quantifier__S_519StarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{_pos};
$C->{'normspace'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "quantifier__S_519StarStar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantifier__S_519StarStar_01') {
$C->deb("Fate passed to quantifier__S_519StarStar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_519StarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_519StarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantifier__S_519StarStar_03') {
$C->deb("Fate passed to quantifier__S_519StarStar_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_519StarStar_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_519StarStar_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('..'))
})
})
}, $C->_PATTERN(qr/\G((?:\d)++)/))
},
sub { my $C=shift;
$C->_SUBSUME(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
},
sub { my $C=shift;
$C->_SUBSUME(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
}, $C->_SUBSUME(['quantmod'], sub {
my $C = shift;
$C->quantmod
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\*\*/))
);
}

##     token quantifier__S_520TildeTilde (:$sym is context<rw> = <~~>)
##          token quantifier:sym<~~> {
##              [
##              | '!' <sym>
##              | <sym>
##              ]
##              <normspace> <quantified_atom> }

sub quantifier__S_520TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_520TildeTilde',$retree) }
sub quantifier__S_520TildeTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_520TildeTilde", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantifier__S_520TildeTilde_01') {
$C->deb("Fate passed to quantifier__S_520TildeTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_520TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_520TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
$C->_PATTERN(qr/\G\~\~/);
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\~\~/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantmod
##          token quantmod { ':'? [ '?' | '!' | '+' ]? }

sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod',$retree) }
sub quantmod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quantmod", 
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantmod_01') {
$C->deb("Fate passed to quantmod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantmod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantmod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('?')
},
sub { my $C=shift;
$C->_EXACT('!')
},
sub { my $C=shift;
$C->_EXACT('+')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
assertion__S_479DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_479DotDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ...
assertion__S_480QuestionQuestionQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_480QuestionQuestionQuestion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ???
assertion__S_481BangBangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_481BangBangBang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!!!"
assertion__S_482Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_482Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_482Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &2 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_482Question_01
          dba: assertion__S_482Question
          i: 0
          min: 0
          name: assertion__S_482Question_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_482Question_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_482Question
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_482Question
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_482Question_01 1
              dba: assertion__S_482Question
              i: 0
              min: 12345
              name: assertion
              r: 1
              rest: ''
              s: 0
assertion__S_482Question_01: *2
assertion__S_483Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_483Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_483Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &16 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_483Bang_01
          dba: assertion__S_483Bang
          i: 0
          min: 0
          name: assertion__S_483Bang_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_483Bang_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_483Bang
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_483Bang
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_483Bang_01 1
              dba: assertion__S_483Bang
              i: 0
              min: 12345
              name: assertion
              r: 1
              rest: ''
              s: 0
assertion__S_483Bang_01: *16
assertion__S_484Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_484Star
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_484Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &28 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_484Star_01
          dba: assertion__S_484Star
          i: 0
          min: 0
          name: assertion__S_484Star_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_484Star_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_484Star
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_484Star
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_484Star_01 1
              dba: assertion__S_484Star
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_484Star
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_484Star
                  i: 0
                  min: 12345
                  name: nibbler
                  r: 1
                  rest: ''
                  s: 0
assertion__S_484Star_01: *28
assertion__S_485Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_485Cur_Ly
    i: 0
    min: 12345
    name: codeblock
    r: 1
    rest: ''
    s: 0
assertion__S_486variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_486variable
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_486variable
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: assertion__S_486variable
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: assertion__S_486variable
          i: 0
          lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: assertion__S_486variable
              i: 0
              lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_method 
                min: 0
                name: EXPR
                nobind: 1
                rest: (item %LOOSEST)
              dba: assertion__S_486variable
              i: 0
              lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
              min: 0
              r: 1
              s: 0
              var: variable
assertion__S_487method: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_487method
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: assertion__S_487method
        i: 0
        min: 1
        r: 1
        s: 0
        text: .
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &17 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_487method_01
          dba: assertion__S_487method
          i: 0
          min: 12345
          name: assertion__S_487method_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_487method_01 0
              dba: assertion__S_487method
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: assertion__S_487method
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 12345
                      re: !!perl/hash:RE_method 
                        a: 0
                        dba: assertion__S_487method
                        i: 0
                        min: 12345
                        name: alpha
                        r: 1
                        rest: ''
                        s: 0
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_487method
                  i: 0
                  min: 12345
                  name: assertion
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_bracket 
              alt: assertion__S_487method_01 1
              decl: []

              min: 12345
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: assertion__S_487method
                i: 0
                lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_decl 
                    a: 0
                    dba: assertion__S_487method
                    i: 0
                    lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                    max: 0
                    min: 0
                    noquant: 1
                    r: 1
                    s: 0
                    text: "my $newlang = ($C->cursor_fresh($+LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_487method
                    i: 0
                    lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                    min: 12345
                    name: dottyop
                    r: 1
                    rest: ''
                    s: 0
assertion__S_487method_01: *17
assertion__S_488name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_488name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: assertion__S_488name
          i: 0
          lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: assertion__S_488name
              i: 0
              lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: assertion__S_488name
              i: 0
              lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
              min: 12345
              name: longname
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &23 !!perl/hash:RE_any 
            a: 0
            altname: assertion__S_488name_02
            dba: assertion__S_488name
            i: 0
            min: 0
            name: assertion__S_488name_02
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                alt: assertion__S_488name_02 0
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: assertion__S_488name
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: assertion__S_488name
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ">"
                  s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_488name_02 1
                dba: assertion__S_488name
                i: 0
                min: 24690
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_488name
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_488name
                    i: 0
                    min: 12345
                    name: nibbler
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_488name_02 2
                dba: assertion__S_488name
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_488name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_488name
                    i: 0
                    min: 12345
                    name: assertion
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_488name_02 3
                dba: assertion__S_488name
                i: 0
                min: 24691
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_488name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_488name
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_488name
                      i: 0
                      lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_488name
                          i: 0
                          lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($+LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_488name
                          i: 0
                          lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_488name_02 4
                dba: assertion__S_488name
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_488name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: (
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: assertion__S_488name
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: ''
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_488name
                      i: 0
                      lang: ($C->cursor_fresh($+LANG))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_488name
                          i: 0
                          lang: ($C->cursor_fresh($+LANG))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_488name
                          i: 0
                          lang: ($C->cursor_fresh($+LANG))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 0
                    re: !!perl/hash:RE_first 
                      a: 0
                      dba: assertion__S_488name
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: assertion__S_488name
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Assertion call missing right parenthesis")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
assertion__S_488name_02: *23
assertion__S_489Bra: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_489Bra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_489Bra
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_489Bra
              i: 0
              min: 1
              r: 1
              s: 0
              text: "["
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_489Bra
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_490Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_490Plus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_490Plus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_490Plus
              i: 0
              min: 1
              r: 1
              s: 0
              text: +
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_490Plus
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_491Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_491Minus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_491Minus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_491Minus
              i: 0
              min: 1
              r: 1
              s: 0
              text: "-"
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_491Minus
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_492Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_492Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
assertion__S_493Comma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_493Comma
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ","
assertion__S_494TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_494TildeTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_494TildeTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~~
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &12 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_494TildeTilde_01
          dba: assertion__S_494TildeTilde
          i: 0
          min: 0
          name: assertion__S_494TildeTilde_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_494TildeTilde_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_494TildeTilde
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_494TildeTilde
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_quantified_atom 
              alt: assertion__S_494TildeTilde_01 1
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: assertion__S_494TildeTilde
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_494TildeTilde_01 2
              dba: assertion__S_494TildeTilde
              i: 0
              min: 12345
              name: desigilname
              r: 1
              rest: ''
              s: 0
assertion__S_494TildeTilde_01: *12
assertion__S_495bogus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex assertion")
atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &20 !!perl/hash:RE_any 
      a: 0
      altname: atom_01
      dba: regex atom
      i: 0
      min: 0
      name: atom_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_meta 
          a: 0
          alt: atom_01 0
          dba: regex atom
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        - !!perl/hash:RE_sequence 
          a: 0
          alt: atom_01 1
          dba: regex atom
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: regex atom
              i: 0
              min: 12345
              name: metachar
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_meta 
              a: 0
              dba: regex atom
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
        - !!perl/hash:RE_method 
          alt: atom_01 2
          min: 0
          name: panic
          nobind: 1
          rest: ("Unrecognized regex metacharacter")
atom_01: *20
backslash__S_456unspace: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_456unspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_456unspace
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: backslash__S_456unspace
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_456unspace
        i: 0
        min: 12345
        name: SUPER::ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
backslash__S_4570: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_4570
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_4570
        i: 0
        min: 1
        r: 1
        s: 0
        text: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_4570
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: backslash__S_4570
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[0..7]"
          s: 0
backslash__S_458A: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_458A
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_458A
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: A
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\A as beginning-of-string matcher', '^')
backslash__S_459a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_459a
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_459a
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: a
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("\\a is allowed only in strings, not regexes")
backslash__S_460b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_460b
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_461c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_461c
    i: 1
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_461c
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: c
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &6 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_461c_01
          dba: backslash__S_461c
          i: 1
          min: 0
          name: backslash__S_461c_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_461c_01 0
              dba: backslash__S_461c
              i: 1
              min: 12345
              name: codepoint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              alt: backslash__S_461c_01 1
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: backslash__S_461c
                i: 1
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_bracket 
              alt: backslash__S_461c_01 2
              decl: []

              min: 0
              re: !!perl/hash:RE_first 
                a: 0
                dba: backslash__S_461c
                i: 1
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_cclass 
                    a: 0
                    dba: backslash__S_461c
                    i: 1
                    min: 1
                    r: 1
                    s: 0
                    text: "[ ?.._ ]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Unrecognized \\c character")
backslash__S_461c_01: *6
backslash__S_462d: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_462d
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: d
backslash__S_463e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_463e
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_464f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_464f
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_465h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_465h
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
backslash__S_466n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_466n
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_467o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_467o
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_467o
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: o
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &18 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_467o_01
          dba: backslash__S_467o
          i: 1
          min: 12345
          name: backslash__S_467o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_467o_01 0
              dba: backslash__S_467o
              i: 1
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_467o_01 1
              dba: backslash__S_467o
              i: 1
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_467o
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_method 
                  a: 0
                  dba: backslash__S_467o
                  i: 1
                  min: 12345
                  name: octint
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12346
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_467o
                      i: 1
                      min: 12346
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: backslash__S_467o
                          i: 1
                          min: 1
                          r: 1
                          s: 0
                          text: ","
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_467o
                          i: 1
                          min: 12345
                          name: octint
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_467o
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_467o_01: *18
backslash__S_468Q: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_468Q
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_468Q
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Q
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\Q as quotemeta', 'quotes or literal variable match')
backslash__S_469r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_469r
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_470s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_470s
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
backslash__S_471t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_471t
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_472v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_472v
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: v
backslash__S_473w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_473w
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
backslash__S_474x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_474x
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_474x
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &10 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_474x_01
          dba: backslash__S_474x
          i: 1
          min: 12345
          name: backslash__S_474x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_474x_01 0
              dba: backslash__S_474x
              i: 1
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_474x_01 1
              dba: backslash__S_474x
              i: 1
              min: 37037
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_474x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 37035
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_474x
                      i: 1
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_474x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_474x
                          i: 1
                          min: 12345
                          name: hexint
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_474x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                  min: 37035
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_474x
                      i: 1
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_474x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_474x_01: *10
backslash__S_475z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_475z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_475z
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: z
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\z as end-of-string matcher', '$')
backslash__S_476Z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_476Z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_476Z
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Z
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\Z as end-of-string matcher', '\\n?$')
backslash__S_477misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_paren 
      decl: []

      min: 1
      nobind: 1
      re: !!perl/hash:RE_meta 
        a: 0
        dba: backslash__S_477misc
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
    dba: backslash__S_477misc
    i: 0
    min: 1
    r: 1
    s: 0
    var: litchar
backslash__S_478oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex backslash sequence")
category__S_413metachar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_413metachar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: metachar
category__S_414backslash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_414backslash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: backslash
category__S_415assertion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_415assertion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: assertion
category__S_416quantifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_416quantifier
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quantifier
category__S_417mod_internal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_417mod_internal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod_internal
cclass_elem: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: character class element
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: character class element
        i: 0
        min: 12345
        name: sign
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: character class element
          i: 0
          min: 12345
          name: normspace
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &27 !!perl/hash:RE_any 
          a: 0
          altname: cclass_elem_01
          dba: character class element
          i: 0
          min: 0
          name: cclass_elem_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: cclass_elem_01 0
              dba: character class element
              i: 0
              min: 12345
              name: name
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: cclass_elem_01 1
              dba: character class element
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method_re 
                  a: 0
                  dba: character class element
                  i: 0
                  min: 0
                  name: before
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: character class element
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:q))
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: character class element
          i: 0
          min: 12345
          name: normspace
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
cclass_elem_01: *27
codeblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: codeblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codeblock
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codeblock
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: codeblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: codeblock
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: statementlist
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: codeblock
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: codeblock
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse statement list; couldn't find right brace")
infixish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infixish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: rxinfix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infixish
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n            $<O> = $<rxinfix><O>;\n            $<sym> = $<rxinfix><sym>;\n        "
metachar__S_423Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_423Gt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_423Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: ">"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_423Gt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_423Gt
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_424AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_424AmpAmp
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_424AmpAmp
        i: 0
        min: 2
        r: 1
        s: 0
        text: "&&"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_424AmpAmp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_424AmpAmp
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_425Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_425Amp
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_425Amp
        i: 0
        min: 1
        r: 1
        s: 0
        text: "&"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_425Amp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_425Amp
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_426VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_426VertVert
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_426VertVert
        i: 0
        min: 2
        r: 1
        s: 0
        text: "||"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_426VertVert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_426VertVert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_427Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_427Vert
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_427Vert
        i: 0
        min: 1
        r: 1
        s: 0
        text: "|"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_427Vert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_427Vert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_428Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_428Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_428Ket
        i: 0
        min: 1
        r: 1
        s: 0
        text: "]"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_428Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_428Ket
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_429Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_429Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_429Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: )
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_429Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_429Thesis
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_430quant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_430quant
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_430quant
        i: 0
        min: 12345
        name: quantifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("quantifier quantifies nothing")
metachar__S_431sigwhite: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_431sigwhite
    i: 0
    min: 12345
    name: normspace
    r: 1
    rest: ''
    s: 0
metachar__S_432Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_432Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_432Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_432Cur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_432Cur_Ly
        i: 0
        min: 12345
        name: codeblock
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_432Cur_Ly
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <{ }> "
metachar__S_433mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_433mod
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_433mod
        i: 0
        min: 12345
        name: mod_internal
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_433mod
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := $<mod_internal><sym> "
metachar__S_434Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_434Colon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ":"
metachar__S_435ColonColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_435ColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "::"
metachar__S_436ColonColonColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_436ColonColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ":::"
metachar__S_437Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_437Bra_Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_437Bra_Ket
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_437Bra_Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_437Bra_Ket
          i: 0
          lang: ($self->unbalanced(']'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_437Bra_Ket
              i: 0
              lang: ($self->unbalanced(']'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(']'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_437Bra_Ket
              i: 0
              lang: ($self->unbalanced(']'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_437Bra_Ket
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_437Bra_Ket
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right bracket")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_437Bra_Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <[ ]> "
metachar__S_438Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_438Paren_Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_438Paren_Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_438Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_438Paren_Thesis
          i: 0
          lang: ($self->unbalanced(')'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_438Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_438Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_438Paren_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_438Paren_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right parenthesis")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_438Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <( )> "
metachar__S_439LtParen: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_439LtParen
    i: 0
    min: 2
    r: 1
    s: 0
    text: <(
metachar__S_440ThesisGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_440ThesisGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: )>
metachar__S_441LtLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_441LtLt
    i: 0
    min: 2
    r: 1
    s: 0
    text: <<
metachar__S_442GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_442GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: ">>"
metachar__S_443Fre: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_443Fre
    i: 0
    min: 1
    r: 1
    s: 0
    text: 
metachar__S_444Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_444Nch
    i: 0
    min: 1
    r: 1
    s: 0
    text: 
metachar__S_445qw: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_445qw
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_445qw
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_445qw
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: metachar__S_445qw
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: <
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: metachar__S_445qw
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_445qw
        i: 0
        min: 12345
        name: quote
        r: 1
        rest: ''
        s: 0
metachar__S_446Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_446Lt_Gt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_446Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: metachar__S_446Lt_Gt
          i: 0
          min: 12345
          name: unsp
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_446Lt_Gt
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_446Lt_Gt
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_446Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_446Lt_Gt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("regex assertion not terminated by angle bracket")
metachar__S_447Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_447Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_447Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_447Back
        i: 0
        min: 12345
        name: backslash
        r: 1
        rest: ''
        s: 0
metachar__S_448Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_448Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
metachar__S_449CaretCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_449CaretCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^^"
metachar__S_450Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_450Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
metachar__S_451DollarDollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_451DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_451DollarDollar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $$
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: metachar__S_451DollarDollar
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_meta 
                      a: 0
                      dba: metachar__S_451DollarDollar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \w
                    min: 1
                    quant: 
                      - +
                      - ":"
                      - ''
                      - 1
                min: 1
                var: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ("\$\$" ~ $0.text ~ " to deref var inside a regex", "\$(\$" ~ $0.text ~ ")")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
metachar__S_452Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_452Dollar
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_452Dollar
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_452Dollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: &21 !!perl/hash:RE_any 
              a: 0
              altname: metachar__S_452Dollar_01
              dba: metachar__S_452Dollar
              i: 0
              min: 0
              name: metachar__S_452Dollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_452Dollar_01 0
                  dba: metachar__S_452Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_452Dollar_01 1
                  dba: metachar__S_452Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "|"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_452Dollar_01 2
                  dba: metachar__S_452Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "&"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_452Dollar_01 3
                  dba: metachar__S_452Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: )
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_452Dollar_01 4
                  dba: metachar__S_452Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_452Dollar_01 5
                  dba: metachar__S_452Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_452Dollar_01 6
                  dba: metachar__S_452Dollar
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $
                - !!perl/hash:RE_method 
                  a: 0
                  alt: metachar__S_452Dollar_01 7
                  dba: metachar__S_452Dollar
                  i: 0
                  min: 12345
                  name: stopper
                  r: 1
                  rest: ''
                  s: 0
          s: 0
metachar__S_452Dollar_01: *21
metachar__S_453Single_Single: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_453Single_Single
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_453Single_Single
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_double 
              a: 0
              dba: metachar__S_453Single_Single
              i: 0
              min: 1
              r: 1
              s: 0
              text: "'"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_453Single_Single
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_453Single_Single
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_453Single_Single
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: quote
              r: 1
              rest: ''
              s: 0
metachar__S_454Double_Double: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_454Double_Double
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_454Double_Double
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_454Double_Double
              i: 0
              min: 1
              r: 1
              s: 0
              text: "\""
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_454Double_Double
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_454Double_Double
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_454Double_Double
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: quote
              r: 1
              rest: ''
              s: 0
metachar__S_455var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_455var
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_455var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_455var
              i: 0
              min: 2
              r: 1
              s: 0
              text: $$
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_455var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_455var
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_455var
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_455var
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_455var
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: variable
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_455var
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_paren 
            decl: []

            min: 37036
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_455var
              i: 0
              min: 37036
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_455var
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: metachar__S_455var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_455var
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_455var
                  i: 0
                  min: 12345
                  name: quantified_atom
                  r: 1
                  rest: ''
                  s: 0
          min: 0
          nobind: 1
          quant: 
            - "?"
            - ":"
            - ''
            - 0
        dba: metachar__S_455var
        i: 0
        min: 0
        r: 1
        s: 0
        var: binding
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_455var
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $<variable>.item; "
mod_arg: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: modifier argument
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: modifier argument
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: modifier argument
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: modifier argument
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: modifier argument
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: modifier argument
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'modifier argument')
mod_internal__S_496Colonmy: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_496Colonmy
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_496Colonmy
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_496Colonmy
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 3
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_496Colonmy
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: mod_internal__S_496Colonmy
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: my
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: mod_internal__S_496Colonmy
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_496Colonmy
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_496Colonmy
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_496Colonmy
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: statement
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_496Colonmy
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: eat_terminator
              r: 1
              rest: ''
              s: 0
mod_internal__S_497Coloni: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_497Coloni
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &1 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_497Coloni_01
            dba: mod_internal__S_497Coloni
            i: 0
            min: 2
            name: mod_internal__S_497Coloni_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_497Coloni_01 0
                dba: mod_internal__S_497Coloni
                i: 0
                min: 2
                r: 1
                s: 0
                text: :i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_497Coloni_01 1
                dba: mod_internal__S_497Coloni
                i: 0
                min: 11
                r: 1
                s: 0
                text: :ignorecase
        dba: mod_internal__S_497Coloni
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_497Coloni
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_497Coloni
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignorecase = 1 "
mod_internal__S_497Coloni_01: *1
mod_internal__S_498ColonBangi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_498ColonBangi
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 3
          nobind: 1
          re: &4 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_498ColonBangi_01
            dba: mod_internal__S_498ColonBangi
            i: 0
            min: 3
            name: mod_internal__S_498ColonBangi_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_498ColonBangi_01 0
                dba: mod_internal__S_498ColonBangi
                i: 0
                min: 3
                r: 1
                s: 0
                text: :!i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_498ColonBangi_01 1
                dba: mod_internal__S_498ColonBangi
                i: 0
                min: 12
                r: 1
                s: 0
                text: :!ignorecase
        dba: mod_internal__S_498ColonBangi
        i: 0
        min: 3
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_498ColonBangi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_498ColonBangi
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignorecase = 0 "
mod_internal__S_498ColonBangi_01: *4
mod_internal__S_499ColoniParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_499ColoniParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &13 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_499ColoniParen_Thesis_01
            dba: mod_internal__S_499ColoniParen_Thesis
            i: 0
            min: 2
            name: mod_internal__S_499ColoniParen_Thesis_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_499ColoniParen_Thesis_01 0
                dba: mod_internal__S_499ColoniParen_Thesis
                i: 0
                min: 2
                r: 1
                s: 0
                text: :i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_499ColoniParen_Thesis_01 1
                dba: mod_internal__S_499ColoniParen_Thesis
                i: 0
                min: 11
                r: 1
                s: 0
                text: :ignorecase
        dba: mod_internal__S_499ColoniParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_499ColoniParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_499ColoniParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignorecase = eval $<mod_arg>.text "
mod_internal__S_499ColoniParen_Thesis_01: *13
mod_internal__S_500Colon0i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_500Colon0i
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_500Colon0i
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_500Colon0i
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &22 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_500Colon0i_02
          dba: mod_internal__S_500Colon0i
          i: 0
          min: 1
          name: mod_internal__S_500Colon0i_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_500Colon0i_02 0
              dba: mod_internal__S_500Colon0i
              i: 0
              min: 1
              r: 1
              s: 0
              text: i
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_500Colon0i_02 1
              dba: mod_internal__S_500Colon0i
              i: 0
              min: 10
              r: 1
              s: 0
              text: ignorecase
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_500Colon0i
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignorecase = $0 "
mod_internal__S_500Colon0i_02: *22
mod_internal__S_501Colona: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_501Colona
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &5 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_501Colona_01
            dba: mod_internal__S_501Colona
            i: 0
            min: 2
            name: mod_internal__S_501Colona_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_501Colona_01 0
                dba: mod_internal__S_501Colona
                i: 0
                min: 2
                r: 1
                s: 0
                text: :a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_501Colona_01 1
                dba: mod_internal__S_501Colona
                i: 0
                min: 13
                r: 1
                s: 0
                text: :ignoreaccent
        dba: mod_internal__S_501Colona
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_501Colona
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_501Colona
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignoreaccent = 1 "
mod_internal__S_501Colona_01: *5
mod_internal__S_502ColonBanga: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_502ColonBanga
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 3
          nobind: 1
          re: &3 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_502ColonBanga_01
            dba: mod_internal__S_502ColonBanga
            i: 0
            min: 3
            name: mod_internal__S_502ColonBanga_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_502ColonBanga_01 0
                dba: mod_internal__S_502ColonBanga
                i: 0
                min: 3
                r: 1
                s: 0
                text: :!a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_502ColonBanga_01 1
                dba: mod_internal__S_502ColonBanga
                i: 0
                min: 14
                r: 1
                s: 0
                text: :!ignoreaccent
        dba: mod_internal__S_502ColonBanga
        i: 0
        min: 3
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_502ColonBanga
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_502ColonBanga
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignoreaccent = 0 "
mod_internal__S_502ColonBanga_01: *3
mod_internal__S_503ColonaParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_503ColonaParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &14 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_503ColonaParen_Thesis_01
            dba: mod_internal__S_503ColonaParen_Thesis
            i: 0
            min: 2
            name: mod_internal__S_503ColonaParen_Thesis_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_503ColonaParen_Thesis_01 0
                dba: mod_internal__S_503ColonaParen_Thesis
                i: 0
                min: 2
                r: 1
                s: 0
                text: :a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_503ColonaParen_Thesis_01 1
                dba: mod_internal__S_503ColonaParen_Thesis
                i: 0
                min: 13
                r: 1
                s: 0
                text: :ignoreaccent
        dba: mod_internal__S_503ColonaParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_503ColonaParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_503ColonaParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignoreaccent = eval $<mod_arg>.text "
mod_internal__S_503ColonaParen_Thesis_01: *14
mod_internal__S_504Colon0a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_504Colon0a
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_504Colon0a
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_504Colon0a
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &19 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_504Colon0a_02
          dba: mod_internal__S_504Colon0a
          i: 0
          min: 1
          name: mod_internal__S_504Colon0a_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_504Colon0a_02 0
              dba: mod_internal__S_504Colon0a
              i: 0
              min: 1
              r: 1
              s: 0
              text: a
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_504Colon0a_02 1
              dba: mod_internal__S_504Colon0a
              i: 0
              min: 12
              r: 1
              s: 0
              text: ignoreaccent
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_504Colon0a
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignoreaccent = $0 "
mod_internal__S_504Colon0a_02: *19
mod_internal__S_505Colons: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_505Colons
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_505Colons
        i: 0
        min: 2
        r: 1
        s: 0
        text: :s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_505Colons
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_505Colons
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_505Colons
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+sigspace = 1 "
mod_internal__S_506ColonBangs: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_506ColonBangs
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_506ColonBangs
        i: 0
        min: 3
        r: 1
        s: 0
        text: :!s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_506ColonBangs
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_506ColonBangs
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_506ColonBangs
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+sigspace = 0 "
mod_internal__S_507ColonsParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_507ColonsParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_507ColonsParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: :s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_507ColonsParen_Thesis
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_507ColonsParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_507ColonsParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+sigspace = eval $<mod_arg>.text "
mod_internal__S_508Colon0s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_508Colon0s
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_508Colon0s
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_508Colon0s
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_508Colon0s
        i: 0
        min: 1
        r: 1
        s: 0
        text: s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_508Colon0s
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_508Colon0s
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_508Colon0s
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+sigspace = $0 "
mod_internal__S_509Colonr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_509Colonr
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_509Colonr
        i: 0
        min: 2
        r: 1
        s: 0
        text: :r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_509Colonr
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_509Colonr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_509Colonr
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ratchet = 1 "
mod_internal__S_510ColonBangr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_510ColonBangr
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_510ColonBangr
        i: 0
        min: 3
        r: 1
        s: 0
        text: :!r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_510ColonBangr
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_510ColonBangr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_510ColonBangr
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ratchet = 0 "
mod_internal__S_511ColonrParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_511ColonrParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_511ColonrParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: :r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_511ColonrParen_Thesis
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_511ColonrParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_511ColonrParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_511ColonrParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ratchet = eval $<mod_arg>.text "
mod_internal__S_512Colon0r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_512Colon0r
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_512Colon0r
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_512Colon0r
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_512Colon0r
        i: 0
        min: 1
        r: 1
        s: 0
        text: r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_512Colon0r
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_512Colon0r
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_512Colon0r
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ratchet = $0 "
mod_internal__S_513ColonPerl5: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_513ColonPerl5
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 3
        re: &25 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_513ColonPerl5_01
          dba: mod_internal__S_513ColonPerl5
          i: 0
          min: 3
          name: mod_internal__S_513ColonPerl5_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_513ColonPerl5_01 0
              dba: mod_internal__S_513ColonPerl5
              i: 0
              min: 6
              r: 1
              s: 0
              text: :Perl5
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_513ColonPerl5_01 1
              dba: mod_internal__S_513ColonPerl5
              i: 0
              min: 3
              r: 1
              s: 0
              text: :P5
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_513ColonPerl5
          i: 0
          lang: ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($+GOAL) )
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_513ColonPerl5
              i: 0
              lang: ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($+GOAL) )
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($+GOAL) );  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_513ColonPerl5
              i: 0
              lang: ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($+GOAL) )
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
mod_internal__S_513ColonPerl5_01: *25
mod_internal__S_514adv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_514adv
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_514adv
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12346
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_514adv
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: mod_internal__S_514adv
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: mod_internal__S_514adv
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_514adv
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_514adv
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_514adv
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: quotepair
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_514adv
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := : $<quotepair><key> "
mod_internal__S_515oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_515oops
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_515oops
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: mod_internal__S_515oops
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized regex modifier")
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $sigspace    is context<rw> = $+sigspace    // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ratchet     is context<rw> = $+ratchet     // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignorecase is context<rw> = $+ignorecase // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignoreaccent    is context<rw> = $+ignoreaccent    // 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: nibbler
            i: 0
            min: 1
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: \s
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_qw 
                a: 0
                dba: nibbler
                i: 0
                min: 1
                r: 1
                s: 1
                text: < || | && & >
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: nibbler
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
normspace: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: normspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: normspace
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &26 !!perl/hash:RE_any 
              a: 0
              altname: normspace_01
              dba: normspace
              i: 0
              min: 1
              name: normspace_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: normspace_01 0
                  dba: normspace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: normspace_01 1
                  dba: normspace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "#"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: normspace
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: normspace
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: normspace
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
normspace_01: *26
quantified_atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantified_atom
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: stopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: rxinfix
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: atom
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantified_atom
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: quantifier
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
quantifier__S_516Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_516Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_516Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_516Star
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_517Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_517Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_517Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_517Plus
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_518Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_518Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_518Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_518Question
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_519StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_519StarStar
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_519StarStar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "**"
      - !!perl/hash:RE_meta 
        a: 0
        dba: quantifier__S_519StarStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quantifier__S_519StarStar
          i: 0
          min: 12345
          name: normspace
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_519StarStar
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quantifier__S_519StarStar
          i: 0
          min: 12345
          name: normspace
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &7 !!perl/hash:RE_any 
          a: 0
          altname: quantifier__S_519StarStar_01
          dba: quantifier__S_519StarStar
          i: 0
          min: 1
          name: quantifier__S_519StarStar_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quantifier__S_519StarStar_01 0
              dba: quantifier__S_519StarStar
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: quantifier__S_519StarStar
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \d
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 3
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: quantifier__S_519StarStar
                      i: 0
                      min: 3
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: quantifier__S_519StarStar
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: ..
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: &15 !!perl/hash:RE_any 
                            a: 0
                            altname: quantifier__S_519StarStar_03
                            dba: quantifier__S_519StarStar
                            i: 0
                            min: 1
                            name: quantifier__S_519StarStar_03
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_quantified_atom 
                                alt: quantifier__S_519StarStar_03 0
                                atom: !!perl/hash:RE_meta 
                                  a: 0
                                  dba: quantifier__S_519StarStar
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \d
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: quantifier__S_519StarStar_03 1
                                dba: quantifier__S_519StarStar
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "*"
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_519StarStar_01 1
              dba: quantifier__S_519StarStar
              i: 0
              min: 12345
              name: codeblock
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_519StarStar_01 2
              dba: quantifier__S_519StarStar
              i: 0
              min: 12345
              name: quantified_atom
              r: 1
              rest: ''
              s: 0
quantifier__S_519StarStar_01: *7
quantifier__S_519StarStar_03: *15
quantifier__S_520TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_520TildeTilde
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &9 !!perl/hash:RE_any 
          a: 0
          altname: quantifier__S_520TildeTilde_01
          dba: quantifier__S_520TildeTilde
          i: 0
          min: 12345
          name: quantifier__S_520TildeTilde_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quantifier__S_520TildeTilde_01 0
              dba: quantifier__S_520TildeTilde
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: quantifier__S_520TildeTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quantifier__S_520TildeTilde
                  i: 0
                  min: 12345
                  name: sym
                  r: 1
                  rest: ''
                  s: 0
                  sym: ~~
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_520TildeTilde_01 1
              dba: quantifier__S_520TildeTilde
              i: 0
              min: 12345
              name: sym
              r: 1
              rest: ''
              s: 0
              sym: ~~
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_520TildeTilde
        i: 0
        min: 12345
        name: normspace
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_520TildeTilde
        i: 0
        min: 12345
        name: quantified_atom
        r: 1
        rest: ''
        s: 0
quantifier__S_520TildeTilde_01: *9
quantmod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantmod
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: quantmod
          i: 0
          min: 1
          r: 1
          s: 0
          text: ":"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &11 !!perl/hash:RE_any 
            a: 0
            altname: quantmod_01
            dba: quantmod
            i: 0
            min: 1
            name: quantmod_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 0
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: "?"
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 1
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: "!"
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 2
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: +
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantmod_01: *11
rxinfix__S_418VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_418VertVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "||"
rxinfix__S_419AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_419AmpAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&&"
rxinfix__S_420Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_420Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
rxinfix__S_421Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_421Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
rxinfix__S_422Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_422Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
sign: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: &8 !!perl/hash:RE_any 
    a: 0
    altname: sign_00
    dba: sign
    i: 0
    min: 0
    name: sign_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        alt: sign_00 0
        dba: sign
        i: 0
        min: 1
        r: 1
        s: 0
        text: +
      - !!perl/hash:RE_string 
        a: 0
        alt: sign_00 1
        dba: sign
        i: 0
        min: 1
        r: 1
        s: 0
        text: "-"
      - !!perl/hash:RE_assertion 
        alt: sign_00 2
        assert: "?"
        min: 0
        re: !!perl/hash:RE_noop 
          a: 0
          dba: sign
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
sign_00: *8
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: termish
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: termish
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: termish
          i: 0
          min: 12345
          name: quantified_atom
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
ws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: ws
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: ws
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $+sigspace "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: ws
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: ws
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &24 !!perl/hash:RE_any 
                      a: 0
                      altname: ws_03
                      dba: ws
                      i: 0
                      min: 1
                      name: ws_03
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          alt: ws_03 0
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: ws_03 1
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "#"
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: ws
                i: 0
                min: 12345
                name: nextsame
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws_03: *24
RETREE_END
}
} ## end grammar

{ package STD::P5Regex;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'global' or $k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'ignorecase' or $k eq 'i') {
my $i = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks

##     token category__S_521metachar (:$sym is context<rw> = 'metachar')
##          token category:metachar { <sym> }

sub category__S_521metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_521metachar',$retree) }
sub category__S_521metachar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'metachar';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_521metachar", 
$C->_PATTERN(qr/\Gmetachar/)
);
}
#proto token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'metachar:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "metachar", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_522backslash (:$sym is context<rw> = 'backslash')
##          token category:backslash { <sym> }

sub category__S_522backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_522backslash',$retree) }
sub category__S_522backslash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'backslash';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_522backslash", 
$C->_PATTERN(qr/\Gbackslash/)
);
}
#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_523assertion (:$sym is context<rw> = 'assertion')
##          token category:assertion { <sym> }

sub category__S_523assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_523assertion',$retree) }
sub category__S_523assertion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'assertion';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_523assertion", 
$C->_PATTERN(qr/\Gassertion/)
);
}
#proto token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "assertion", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_524quantifier (:$sym is context<rw> = 'quantifier')
##          token category:quantifier { <sym> }

sub category__S_524quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_524quantifier',$retree) }
sub category__S_524quantifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quantifier';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_524quantifier", 
$C->_PATTERN(qr/\Gquantifier/)
);
}
#proto token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'quantifier:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quantifier", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_525mod_internal (:$sym is context<rw> = 'mod_internal')
##          token category:mod_internal { <sym> }

sub category__S_525mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_525mod_internal',$retree) }
sub category__S_525mod_internal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod_internal';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_525mod_internal", 
$C->_PATTERN(qr/\Gmod_internal/)
);
}
#proto token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'mod_internal:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "mod_internal", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


#proto token rxinfix { <...> }
sub rxinfix__PEEK { $_[0]->_AUTOLEXpeek('rxinfix:*',$retree); }
sub rxinfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'rxinfix') {
$C->deb("Fate passed to rxinfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'rxinfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("rxinfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "rxinfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


# suppress fancy end-of-line checking
##     token codeblock
##          token codeblock {
##              :my $GOAL is context = '}';
##              '{' :: [ :lang($.cursor_fresh($+LANG)) <statementlist> ]
##              [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
##          }

sub codeblock__PEEK { $_[0]->_AUTOLEXpeek('codeblock',$retree) }
sub codeblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL =  '}';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "codeblock", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->panic("Unable to parse statement list; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
);
}

##     rule nibbler
##          rule nibbler {
##              :my $ignorecase is context<rw> = $+ignorecase // 0;
##              <EXPR>
##          }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::ignorecase =  $::ignorecase // 0;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token termish
##          token termish {
##              <.ws>  # XXX assuming old /x here?
##              <quantified_atom>+
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantified_atom'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->ws)) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
});
}
else {
();
}
}
);
}
##     token infixish
##          token infixish {
##              <!infixstopper>
##              <!stdstopper>
##              <rxinfix>
##              {
##                  $<O> = $<rxinfix><O>;
##                  $<sym> = $<rxinfix><sym>;
##              }
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rxinfix'], sub {
my $C = shift;
$C->rxinfix
}))) {
scalar(do {
my $M = $C; 
$M->{O} = $M->{rxinfix}{O};
$M->{sym} = $M->{rxinfix}{sym};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token rxinfix__S_526Vert (  :$sym is context<rw> = <|> --> Junctive_or )
##          token rxinfix:sym<|> ( --> Junctive_or ) { <sym> }

sub rxinfix__S_526Vert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_526Vert',$retree) }
sub rxinfix__S_526Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_526Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}

##     token quantified_atom
##          token quantified_atom {
##              <!stopper>
##              <!rxinfix>
##              <atom>
##              [ <.ws> <quantifier>
##      #            <?{ $<atom>.max_width }>
##      #                || <.panic: "Can't quantify zero-width atom">
##              ]?
##              <.ws>
##          }

sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom',$retree) }
sub quantified_atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantifier'} = [];

$self->_MATCHIFYr($S, "quantified_atom", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->rxinfix
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
});
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token atom
##          token atom {
##              [
##              | \w
##              | <metachar>
##              | '\\' :: .
##              ]
##          }

sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom',$retree) }
sub atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "atom", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'atom_01') {
$C->deb("Fate passed to atom_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'atom_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("atom_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?s:.)/)
}, $C->_COMMITBRANCH())
}, $C->_EXACT('\\'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# sequence stoppers
##     token metachar__S_527Vert (:$sym is context<rw> = <|>)
##          token metachar:sym<|>   { '|'  :: <fail> }

sub metachar__S_527Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_527Vert',$retree) }
sub metachar__S_527Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_527Vert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('|'))
);
}
##     token metachar__S_528Thesis (:$sym is context<rw> = <)>)
##          token metachar:sym<)>   { ')'  :: <fail> }

sub metachar__S_528Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_528Thesis',$retree) }
sub metachar__S_528Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_528Thesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(')'))
);
}

##     token metachar__S_529quant (:$sym is context<rw> = 'quant')
##          token metachar:quant { <quantifier> <.panic: "quantifier quantifies nothing"> }

sub metachar__S_529quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_529quant',$retree) }
sub metachar__S_529quant {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quant';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_529quant", 
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->panic("quantifier quantifies nothing");
}
else {
();
}
}
);
}

# "normal" metachars

##     token metachar__S_530Bra_Ket (:$sym is context<rw> = <[ ]>)
##          token metachar:sym<[ ]> {
##              <before '['> <quibble($.cursor_fresh( ::STD::Q ).tweak(:q))> # XXX parse as q[] for now
##          }

sub metachar__S_530Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_530Bra_Ket',$retree) }
sub metachar__S_530Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_530Bra_Ket", 
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
});
}
else {
();
}
}
);
}

##     token metachar__S_531ParenQuestion_Thesis (:$sym is context<rw> = (? ))
##          token metachar:sym(? ) {
##              '(?' {} <assertion>
##              [ ')' || <.panic: "Perl 5 regex assertion not terminated by parenthesis"> ]
##          }

sub metachar__S_531ParenQuestion_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_531ParenQuestion_Thesis',$retree) }
sub metachar__S_531ParenQuestion_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['(?',')'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_531ParenQuestion_Thesis", 
do {
if (my ($C) = ($C->_EXACT('(?'))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Perl 5 regex assertion not terminated by parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_532Paren_Thesis (:$sym is context<rw> = <( )>)
##          token metachar:sym<( )> {
##              '(' {} [:lang(self.unbalanced(')')) <nibbler>]?
##              [ ')' || <.panic: "Unable to parse Perl 5 regex; couldn't find right parenthesis"> ]
##              { $/<sym> := <( )> }
##          }

sub metachar__S_532Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_532Paren_Thesis',$retree) }
sub metachar__S_532Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'nibbler'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_532Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Unable to parse Perl 5 regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw[( )]] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_533Back (:$sym is context<rw> = <\\>)
##          token metachar:sym<\\> { <sym> <backslash> }

sub metachar__S_533Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_533Back',$retree) }
sub metachar__S_533Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_533Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##     token metachar__S_534Dot (:$sym is context<rw> = <.>)
##          token metachar:sym<.>  { <sym> }

sub metachar__S_534Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_534Dot',$retree) }
sub metachar__S_534Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_534Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token metachar__S_535Caret (:$sym is context<rw> = <^>)
##          token metachar:sym<^>  { <sym> }

sub metachar__S_535Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_535Caret',$retree) }
sub metachar__S_535Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_535Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
##     token metachar__S_536Dollar (:$sym is context<rw> = <$>)
##          token metachar:sym<$>  {
##              '$' <?before \W | $>
##          }

sub metachar__S_536Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_536Dollar',$retree) }
sub metachar__S_536Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_536Dollar", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'metachar__S_536Dollar_01') {
$C->deb("Fate passed to metachar__S_536Dollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'metachar__S_536Dollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar__S_536Dollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token metachar__S_537var (:$sym is context<rw> = 'var')
##          token metachar:var {
##              <?before <sigil>\w>
##              <.panic: "Can't interpolate variable in Perl 5 regex">
##          }

sub metachar__S_537var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_537var',$retree) }
sub metachar__S_537var {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'var';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_537var", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
$C->_PATTERN(qr/\G\w/);
}
else {
();
}
}
}))) {
$C->panic("Can't interpolate variable in Perl 5 regex");
}
else {
();
}
}
);
}

##     token backslash__S_538A (:$sym is context<rw> = 'A')
##          token backslash:A { <sym> }

sub backslash__S_538A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_538A',$retree) }
sub backslash__S_538A {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'A';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_538A", 
$C->_PATTERN(qr/\GA/)
);
}
##     token backslash__S_539a (:$sym is context<rw> = 'a')
##          token backslash:a { <sym> }

sub backslash__S_539a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_539a',$retree) }
sub backslash__S_539a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_539a", 
$C->_PATTERN(qr/\Ga/)
);
}
##     token backslash__S_540b (:$sym is context<rw> = 'b')
##          token backslash:b { :i <sym> }

sub backslash__S_540b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_540b',$retree) }
sub backslash__S_540b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_540b", 
$C->_PATTERN(qr/\G(?i:b)/)
);
}
##     token backslash__S_541c (:$sym is context<rw> = 'c')
##          token backslash:c { :i <sym>
##              <[ ?.._ ]> || <.panic: "Unrecognized \\c character">
##          }

sub backslash__S_541c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_541c',$retree) }
sub backslash__S_541c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_541c", 
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:c)(?i:[?-_])/)} 
or
eval { push @gather, $C->panic("Unrecognized \\c character")} or do { die $@ if $@ };
@gather;
}
);
}
##     token backslash__S_542d (:$sym is context<rw> = 'd')
##          token backslash:d { :i <sym> }

sub backslash__S_542d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_542d',$retree) }
sub backslash__S_542d {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'd';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_542d", 
$C->_PATTERN(qr/\G(?i:d)/)
);
}
##     token backslash__S_543e (:$sym is context<rw> = 'e')
##          token backslash:e { :i <sym> }

sub backslash__S_543e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_543e',$retree) }
sub backslash__S_543e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_543e", 
$C->_PATTERN(qr/\G(?i:e)/)
);
}
##     token backslash__S_544f (:$sym is context<rw> = 'f')
##          token backslash:f { :i <sym> }

sub backslash__S_544f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_544f',$retree) }
sub backslash__S_544f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_544f", 
$C->_PATTERN(qr/\G(?i:f)/)
);
}
##     token backslash__S_545h (:$sym is context<rw> = 'h')
##          token backslash:h { :i <sym> }

sub backslash__S_545h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_545h',$retree) }
sub backslash__S_545h {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_545h", 
$C->_PATTERN(qr/\G(?i:h)/)
);
}
##     token backslash__S_546l (:$sym is context<rw> = 'l')
##          token backslash:l { :i <sym> }

sub backslash__S_546l__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_546l',$retree) }
sub backslash__S_546l {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'l';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_546l", 
$C->_PATTERN(qr/\G(?i:l)/)
);
}
##     token backslash__S_547n (:$sym is context<rw> = 'n')
##          token backslash:n { :i <sym> }

sub backslash__S_547n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_547n',$retree) }
sub backslash__S_547n {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_547n", 
$C->_PATTERN(qr/\G(?i:n)/)
);
}
##     token backslash__S_548o (:$sym is context<rw> = 'o')
##          token backslash:o { '0' [ <octint> | '{'<octint>[','<octint>]*'}' ]? }

sub backslash__S_548o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_548o',$retree) }
sub backslash__S_548o {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{_pos};
$C->{'octint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_548o", 
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_548o_01') {
$C->deb("Fate passed to backslash__S_548o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_548o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_548o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(','))) {
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
});
}
else {
();
}
}
})
}))) {
$C->_EXACT('}');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}
##     token backslash__S_549p (:$sym is context<rw> = 'p')
##          token backslash:p { :i <sym> '{' <[\w:]>+ '}' }

sub backslash__S_549p__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_549p',$retree) }
sub backslash__S_549p {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'p';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_549p", 
$C->_PATTERN(qr/\G(?i:p)(?i:\{)((?:(?i:[\w:]))++)(?i:\})/)
);
}
##     token backslash__S_550Q (:$sym is context<rw> = 'Q')
##          token backslash:Q { <sym> }

sub backslash__S_550Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_550Q',$retree) }
sub backslash__S_550Q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_550Q", 
$C->_PATTERN(qr/\GQ/)
);
}
##     token backslash__S_551r (:$sym is context<rw> = 'r')
##          token backslash:r { :i <sym> }

sub backslash__S_551r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_551r',$retree) }
sub backslash__S_551r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_551r", 
$C->_PATTERN(qr/\G(?i:r)/)
);
}
##     token backslash__S_552s (:$sym is context<rw> = 's')
##          token backslash:s { :i <sym> }

sub backslash__S_552s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_552s',$retree) }
sub backslash__S_552s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_552s", 
$C->_PATTERN(qr/\G(?i:s)/)
);
}
##     token backslash__S_553t (:$sym is context<rw> = 't')
##          token backslash:t { :i <sym> }

sub backslash__S_553t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_553t',$retree) }
sub backslash__S_553t {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_553t", 
$C->_PATTERN(qr/\G(?i:t)/)
);
}
##     token backslash__S_554u (:$sym is context<rw> = 'u')
##          token backslash:u { :i <sym> }

sub backslash__S_554u__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_554u',$retree) }
sub backslash__S_554u {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'u';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_554u", 
$C->_PATTERN(qr/\G(?i:u)/)
);
}
##     token backslash__S_555v (:$sym is context<rw> = 'v')
##          token backslash:v { :i <sym> }

sub backslash__S_555v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_555v',$retree) }
sub backslash__S_555v {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'v';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_555v", 
$C->_PATTERN(qr/\G(?i:v)/)
);
}
##     token backslash__S_556w (:$sym is context<rw> = 'w')
##          token backslash:w { :i <sym> }

sub backslash__S_556w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_556w',$retree) }
sub backslash__S_556w {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_556w", 
$C->_PATTERN(qr/\G(?i:w)/)
);
}
##     token backslash__S_557x (:$sym is context<rw> = 'x')
##          token backslash:x { :i <sym> [ <hexint> | '{' [<.ws><hexint><.ws> ] ** ',' '}' ] }

sub backslash__S_557x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_557x',$retree) }
sub backslash__S_557x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'hexint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_557x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:x)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_557x_01') {
$C->deb("Fate passed to backslash__S_557x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_557x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_557x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\{)/))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_PATTERN(qr/\G(?i:\,)/)
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G(?i:\})/);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_558z (:$sym is context<rw> = 'z')
##          token backslash:z { :i <sym> }

sub backslash__S_558z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_558z',$retree) }
sub backslash__S_558z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'z';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_558z", 
$C->_PATTERN(qr/\G(?i:z)/)
);
}
##     token backslash__S_559misc (:$sym is context<rw> = 'misc')
##          token backslash:misc { $<litchar>=(\W) | $<number>=(\d+) }

sub backslash__S_559misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_559misc',$retree) }
sub backslash__S_559misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_559misc", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_559misc_00') {
$C->deb("Fate passed to backslash__S_559misc_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_559misc_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_559misc_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}
##     token backslash__S_560oops (:$sym is context<rw> = 'oops')
##          token backslash:oops { <.panic: "Unrecognized Perl 5 regex backslash sequence"> }

sub backslash__S_560oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_560oops',$retree) }
sub backslash__S_560oops {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_560oops", 
$C->panic("Unrecognized Perl 5 regex backslash sequence")
);
}

##     token assertion__S_561Question (:$sym is context<rw> = <?>)
##          token assertion:sym<?> { <sym> <codeblock> }

sub assertion__S_561Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_561Question',$retree) }
sub assertion__S_561Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_561Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
});
}
else {
();
}
}
);
}
##     token assertion__S_562Cur_Ly (:$sym is context<rw> = <{ }>)
##          token assertion:sym<{ }> { <codeblock> }

sub assertion__S_562Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_562Cur_Ly',$retree) }
sub assertion__S_562Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_562Cur_Ly", 
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
);
}

##     token assertion__S_563Lt (:$sym is context<rw> = <)
##          token assertion:sym< { <sym> <?before '=' | '!'> <assertion> }

sub assertion__S_563Lt__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_563Lt',$retree) }
sub assertion__S_563Lt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_563Lt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\</))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_563Lt_01') {
$C->deb("Fate passed to assertion__S_563Lt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_563Lt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_563Lt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_EXACT('!')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token assertion__S_564Equal (:$sym is context<rw> = <=>)
##          token assertion:sym<=> { <sym> [ <?before ')'> | <rx> ] }

sub assertion__S_564Equal__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_564Equal',$retree) }
sub assertion__S_564Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_564Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_564Equal_01') {
$C->deb("Fate passed to assertion__S_564Equal_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_564Equal_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_564Equal_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_565Bang (:$sym is context<rw> = <!>)
##          token assertion:sym<!> { <sym> [ <?before ')'> | <rx> ] }

sub assertion__S_565Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_565Bang',$retree) }
sub assertion__S_565Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_565Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_565Bang_01') {
$C->deb("Fate passed to assertion__S_565Bang_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_565Bang_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_565Bang_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_566Gt (:$sym is context<rw> = >)
##          token assertion:sym> { <sym> <rx> }

sub assertion__S_566Gt__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_566Gt',$retree) }
sub assertion__S_566Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_566Gt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>/))) {
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
});
}
else {
();
}
}
);
}

##     token rx
##          token rx {
##              #[:lang(self.unbalanced(')')) <nibbler>]
##              <nibbler>
##              [ <?before ')'> || <.panic: "Unable to parse Perl 5 regex; couldn't find right parenthesis"> ]
##          }

sub rx__PEEK { $_[0]->_AUTOLEXpeek('rx',$retree) }
sub rx {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "rx", 
do {
if (my ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
$C->_EXACT(')')
})} 
or
eval { push @gather, $C->panic("Unable to parse Perl 5 regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}

#token assertion'identifier' => 1 { q(longname) [               # is qq right here?
#                                | [qw[?before ')' ]]
#                                | q(.ws) q(nibbler)
#                               ]
#                               [ ':' q(rx) ]?
#}
##     token p5mod
##          token p5mod { <[imox]>* }

sub p5mod__PEEK { $_[0]->_AUTOLEXpeek('p5mod',$retree) }
sub p5mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "p5mod", 
$C->_PATTERN(qr/\G((?:[imox])*+)/)
);
}
##     token p5mods
##          token p5mods { <on=p5mod> [ '-' <off=p5mod> ]? }

sub p5mods__PEEK { $_[0]->_AUTOLEXpeek('p5mods',$retree) }
sub p5mods {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'off'} = [];

$self->_MATCHIFYr($S, "p5mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['on'], sub {
my $C = shift;
$C->p5mod
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-'))) {
$C->_SUBSUMEr(['off'], sub {
my $C = shift;
$C->p5mod
});
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}
##     token assertion__S_567mod (:$sym is context<rw> = 'mod')
##          token assertion:mod { <p5mods> [               # is qq right here?
##                                         | ':' <rx>?
##                                         | <?before ')' >
##                                         ]
##          }

sub assertion__S_567mod__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_567mod',$retree) }
sub assertion__S_567mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod';


my $C = $self;
my $S = $C->{_pos};
$C->{'rx'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_567mod", 
do {
if (my ($C) = ($C->_SUBSUMEr(['p5mods'], sub {
my $C = shift;
$C->p5mods
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_567mod_01') {
$C->deb("Fate passed to assertion__S_567mod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_567mod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_567mod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_568bogus (:$sym is context<rw> = 'bogus')
##          token assertion:bogus { <.panic: "Unrecognized Perl 5 regex assertion"> }

sub assertion__S_568bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_568bogus',$retree) }
sub assertion__S_568bogus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'bogus';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_568bogus", 
$C->panic("Unrecognized Perl 5 regex assertion")
);
}

##     token quantifier__S_569Star (:$sym is context<rw> = <*>)
##          token quantifier:sym<*>  { <sym> <quantmod> }

sub quantifier__S_569Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_569Star',$retree) }
sub quantifier__S_569Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_569Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_570Plus (:$sym is context<rw> = <+>)
##          token quantifier:sym<+>  { <sym> <quantmod> }

sub quantifier__S_570Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_570Plus',$retree) }
sub quantifier__S_570Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_570Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_571Question (:$sym is context<rw> = <?>)
##          token quantifier:sym<?>  { <sym> <quantmod> }

sub quantifier__S_571Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_571Question',$retree) }
sub quantifier__S_571Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_571Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_572Cur_Ly (:$sym is context<rw> = <{ }>)
##          token quantifier:sym<{ }> { '{' \d+ [','\d*]? '}' <quantmod> }

sub quantifier__S_572Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_572Cur_Ly',$retree) }
sub quantifier__S_572Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_572Cur_Ly", 
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(','))) {
$C->_PATTERN(qr/\G((?:\d)*+)/);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('}'))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantmod
##          token quantmod { [ '?' | '+' ]? }

sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod',$retree) }
sub quantmod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quantmod", 
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantmod_01') {
$C->deb("Fate passed to quantmod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'quantmod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantmod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('?')
},
sub { my $C=shift;
$C->_EXACT('+')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
assertion__S_561Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_561Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_561Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_561Question
        i: 0
        min: 12345
        name: codeblock
        r: 1
        rest: ''
        s: 0
assertion__S_562Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_562Cur_Ly
    i: 0
    min: 12345
    name: codeblock
    r: 1
    rest: ''
    s: 0
assertion__S_563Lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_563Lt
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_563Lt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_563Lt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &2 !!perl/hash:RE_any 
              a: 0
              altname: assertion__S_563Lt_01
              dba: assertion__S_563Lt
              i: 0
              min: 1
              name: assertion__S_563Lt_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: assertion__S_563Lt_01 0
                  dba: assertion__S_563Lt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_string 
                  a: 0
                  alt: assertion__S_563Lt_01 1
                  dba: assertion__S_563Lt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_563Lt
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
assertion__S_563Lt_01: *2
assertion__S_564Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_564Equal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_564Equal
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &10 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_564Equal_01
          dba: assertion__S_564Equal
          i: 0
          min: 0
          name: assertion__S_564Equal_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_564Equal_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_564Equal
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_564Equal
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_564Equal_01 1
              dba: assertion__S_564Equal
              i: 0
              min: 12345
              name: rx
              r: 1
              rest: ''
              s: 0
assertion__S_564Equal_01: *10
assertion__S_565Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_565Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_565Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &4 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_565Bang_01
          dba: assertion__S_565Bang
          i: 0
          min: 0
          name: assertion__S_565Bang_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_565Bang_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_565Bang
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_565Bang
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_565Bang_01 1
              dba: assertion__S_565Bang
              i: 0
              min: 12345
              name: rx
              r: 1
              rest: ''
              s: 0
assertion__S_565Bang_01: *4
assertion__S_566Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_566Gt
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_566Gt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ">"
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_566Gt
        i: 0
        min: 12345
        name: rx
        r: 1
        rest: ''
        s: 0
assertion__S_567mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_567mod
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_567mod
        i: 0
        min: 12345
        name: p5mods
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &8 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_567mod_01
          dba: assertion__S_567mod
          i: 0
          min: 0
          name: assertion__S_567mod_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_567mod_01 0
              dba: assertion__S_567mod
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: assertion__S_567mod
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_567mod
                    i: 0
                    min: 12345
                    name: rx
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_assertion 
              alt: assertion__S_567mod_01 1
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_567mod
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_567mod
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
assertion__S_567mod_01: *8
assertion__S_568bogus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized Perl 5 regex assertion")
atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &3 !!perl/hash:RE_any 
      a: 0
      altname: atom_01
      dba: atom
      i: 0
      min: 1
      name: atom_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_meta 
          a: 0
          alt: atom_01 0
          dba: atom
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        - !!perl/hash:RE_method 
          a: 0
          alt: atom_01 1
          dba: atom
          i: 0
          min: 12345
          name: metachar
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: atom_01 2
          dba: atom
          i: 0
          min: 2
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: atom
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            - !!perl/hash:RE_meta 
              a: 0
              dba: atom
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_meta 
              a: 0
              dba: atom
              i: 0
              min: 1
              r: 1
              s: 0
              text: .
atom_01: *3
backslash__S_538A: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_538A
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: A
backslash__S_539a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_539a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
backslash__S_540b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_540b
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_541c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: backslash__S_541c
    i: 1
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: backslash__S_541c
        i: 1
        min: 12346
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: backslash__S_541c
            i: 1
            min: 12345
            name: sym
            r: 1
            rest: ''
            s: 0
            sym: c
          - !!perl/hash:RE_cclass 
            a: 0
            dba: backslash__S_541c
            i: 1
            min: 1
            r: 1
            s: 0
            text: "[ ?.._ ]"
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized \\c character")
backslash__S_542d: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_542d
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: d
backslash__S_543e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_543e
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_544f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_544f
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_545h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_545h
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
backslash__S_546l: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_546l
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: l
backslash__S_547n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_547n
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_548o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_548o
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_548o
        i: 0
        min: 1
        r: 1
        s: 0
        text: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &5 !!perl/hash:RE_any 
            a: 0
            altname: backslash__S_548o_01
            dba: backslash__S_548o
            i: 0
            min: 12345
            name: backslash__S_548o_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                alt: backslash__S_548o_01 0
                dba: backslash__S_548o
                i: 0
                min: 12345
                name: octint
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: backslash__S_548o_01 1
                dba: backslash__S_548o
                i: 0
                min: 12347
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: backslash__S_548o
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "{"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: backslash__S_548o
                    i: 0
                    min: 12345
                    name: octint
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_bracket 
                      decl: []

                      min: 12346
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: backslash__S_548o
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: backslash__S_548o
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: ","
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: backslash__S_548o
                            i: 0
                            min: 12345
                            name: octint
                            r: 1
                            rest: ''
                            s: 0
                    min: 0
                    quant: 
                      - "*"
                      - ":"
                      - ''
                      - 0
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: backslash__S_548o
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "}"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
backslash__S_548o_01: *5
backslash__S_549p: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_549p
    i: 1
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_549p
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: p
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_549p
        i: 1
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: backslash__S_549p
          i: 1
          min: 1
          r: 1
          s: 0
          text: "[\\w:]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_549p
        i: 1
        min: 1
        r: 1
        s: 0
        text: "}"
backslash__S_550Q: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_550Q
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: Q
backslash__S_551r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_551r
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_552s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_552s
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
backslash__S_553t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_553t
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_554u: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_554u
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: u
backslash__S_555v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_555v
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: v
backslash__S_556w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_556w
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
backslash__S_557x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_557x
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_557x
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &7 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_557x_01
          dba: backslash__S_557x
          i: 1
          min: 12345
          name: backslash__S_557x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_557x_01 0
              dba: backslash__S_557x
              i: 1
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_557x_01 1
              dba: backslash__S_557x
              i: 1
              min: 37037
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_557x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 37035
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_557x
                      i: 1
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_557x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_557x
                          i: 1
                          min: 12345
                          name: hexint
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_557x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                  min: 37035
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_557x
                      i: 1
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_557x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "}"
backslash__S_557x_01: *7
backslash__S_558z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_558z
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: z
backslash__S_559misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: &6 !!perl/hash:RE_any 
    a: 0
    altname: backslash__S_559misc_00
    dba: backslash__S_559misc
    i: 0
    min: 1
    name: backslash__S_559misc_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        alt: backslash__S_559misc_00 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_meta 
            a: 0
            dba: backslash__S_559misc
            i: 0
            min: 1
            r: 1
            s: 0
            text: \W
        dba: backslash__S_559misc
        i: 0
        min: 1
        r: 1
        s: 0
        var: litchar
      - !!perl/hash:RE_bindnamed 
        a: 0
        alt: backslash__S_559misc_00 1
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: backslash__S_559misc
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        dba: backslash__S_559misc
        i: 0
        min: 1
        r: 1
        s: 0
        var: number
backslash__S_559misc_00: *6
backslash__S_560oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized Perl 5 regex backslash sequence")
category__S_521metachar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_521metachar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: metachar
category__S_522backslash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_522backslash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: backslash
category__S_523assertion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_523assertion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: assertion
category__S_524quantifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_524quantifier
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quantifier
category__S_525mod_internal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_525mod_internal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod_internal
codeblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: codeblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codeblock
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codeblock
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: codeblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: codeblock
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: statementlist
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: codeblock
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: codeblock
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse statement list; couldn't find right brace")
infixish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infixish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: rxinfix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infixish
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n            $<O> = $<rxinfix><O>;\n            $<sym> = $<rxinfix><sym>;\n        "
metachar__S_527Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_527Vert
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_527Vert
        i: 0
        min: 1
        r: 1
        s: 0
        text: "|"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_527Vert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_527Vert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_528Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_528Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_528Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: )
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_528Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_528Thesis
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_529quant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_529quant
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_529quant
        i: 0
        min: 12345
        name: quantifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("quantifier quantifies nothing")
metachar__S_530Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_530Bra_Ket
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method_re 
        a: 0
        dba: metachar__S_530Bra_Ket
        i: 0
        min: 0
        name: before
        r: 1
        re: !!perl/hash:RE 
          decl: []

          min: 1
          re: !!perl/hash:RE_string 
            a: 0
            dba: metachar__S_530Bra_Ket
            i: 0
            min: 1
            r: 1
            s: 0
            text: "["
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q))
metachar__S_531ParenQuestion_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_531ParenQuestion_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_531ParenQuestion_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: (?
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_531ParenQuestion_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_531ParenQuestion_Thesis
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_531ParenQuestion_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_531ParenQuestion_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Perl 5 regex assertion not terminated by parenthesis")
metachar__S_532Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_532Paren_Thesis
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_532Paren_Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_532Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: metachar__S_532Paren_Thesis
            i: 0
            lang: ($self->unbalanced(')'))
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_decl 
                a: 0
                dba: metachar__S_532Paren_Thesis
                i: 0
                lang: ($self->unbalanced(')'))
                max: 0
                min: 0
                noquant: 1
                r: 1
                s: 0
                text: "my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); "
              - !!perl/hash:RE_method 
                a: 0
                dba: metachar__S_532Paren_Thesis
                i: 0
                lang: ($self->unbalanced(')'))
                min: 12345
                name: nibbler
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_532Paren_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_532Paren_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse Perl 5 regex; couldn't find right parenthesis")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_532Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <( )> "
metachar__S_533Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_533Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_533Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_533Back
        i: 0
        min: 12345
        name: backslash
        r: 1
        rest: ''
        s: 0
metachar__S_534Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_534Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
metachar__S_535Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_535Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
metachar__S_536Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_536Dollar
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_536Dollar
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_536Dollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: &9 !!perl/hash:RE_any 
              a: 0
              altname: metachar__S_536Dollar_01
              dba: metachar__S_536Dollar
              i: 0
              min: 0
              name: metachar__S_536Dollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_536Dollar_01 0
                  dba: metachar__S_536Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \W
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_536Dollar_01 1
                  dba: metachar__S_536Dollar
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $
          s: 0
metachar__S_536Dollar_01: *9
metachar__S_537var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_537var
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_537var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12346
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_537var
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_537var
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: metachar__S_537var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \w
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Can't interpolate variable in Perl 5 regex")
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignorecase is context<rw> = $+ignorecase // 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: nibbler
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
p5mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_cclass 
      a: 0
      dba: p5mod
      i: 0
      min: 1
      r: 1
      s: 0
      text: "[imox]"
    min: 0
    quant: 
      - "*"
      - ":"
      - ''
      - 0
p5mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: p5mods
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: p5mods
          i: 0
          min: 12345
          name: p5mod
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: p5mods
        i: 0
        min: 12345
        r: 1
        s: 0
        var: 'on'
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12346
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: p5mods
            i: 0
            min: 12346
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: p5mods
                i: 0
                min: 1
                r: 1
                s: 0
                text: "-"
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: p5mods
                  i: 0
                  min: 12345
                  name: p5mod
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                dba: p5mods
                i: 0
                min: 12345
                r: 1
                s: 0
                var: 'off'
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantified_atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantified_atom
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: stopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: rxinfix
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: atom
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantified_atom
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: quantifier
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
quantifier__S_569Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_569Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_569Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_569Star
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_570Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_570Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_570Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_570Plus
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_571Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_571Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_571Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_571Question
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_572Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_572Cur_Ly
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quantifier__S_572Cur_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: quantifier__S_572Cur_Ly
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantifier__S_572Cur_Ly
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: quantifier__S_572Cur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: ","
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: quantifier__S_572Cur_Ly
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: quantifier__S_572Cur_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        text: "}"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_572Cur_Ly
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantmod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 1
      re: &1 !!perl/hash:RE_any 
        a: 0
        altname: quantmod_01
        dba: quantmod
        i: 0
        min: 1
        name: quantmod_01
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_string 
            a: 0
            alt: quantmod_01 0
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: "?"
          - !!perl/hash:RE_string 
            a: 0
            alt: quantmod_01 1
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: +
    min: 0
    quant: 
      - "?"
      - ":"
      - ''
      - 0
quantmod_01: *1
rx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: rx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: rx
        i: 0
        min: 12345
        name: nibbler
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: rx
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: rx
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: rx
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse Perl 5 regex; couldn't find right parenthesis")
rxinfix__S_526Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_526Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: termish
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: termish
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: termish
          i: 0
          min: 12345
          name: quantified_atom
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
RETREE_END
}
} ## end grammar

# token panic (Str $s) { <commit> <fail($s)> }

## method panic (Str $s)
sub panic {
my $self = shift;
my $s = shift;


my $m;
my $here = $self;

# Have we backed off recently?
my $highvalid = $self->{_pos} <= $::HIGHWATER;

$here = $self->cursor($::HIGHWATER) if $highvalid;

my $first = $here->lineof($COMPILING::LAST_NIBBLE->{'firstpos'});
my $last = $here->lineof($COMPILING::LAST_NIBBLE->{'lastpos'});
if ($here->lineof($here->{_pos}) == $last and $first != $last) {
$m .= "\n(Possible runaway string from line $first)";
}
else {
$first = $here->lineof($COMPILING::LAST_NIBBLE_MULTILINE->{'firstpos'});
$last = $here->lineof($COMPILING::LAST_NIBBLE_MULTILINE->{'lastpos'});
# the bigger the string (in lines), the further back we suspect it
if ($here->lineof($here->{_pos}) - $last < $last - $first ) {
$m .= "\n(Possible runaway string from line $first to line $last)";
}
}

$m .= "\n" . $s;

if ($highvalid) {
$m .= $::HIGHMESS if $::HIGHMESS;
$::HIGHMESS = $m;
}
else {
# not in backoff, so at "bleeding edge", as it were... therefore probably
# the exception will be caught and re-panicked later, so remember message
$::HIGHMESS .= "\n" . $s;
}

$m .= $here->locmess;

if ($highvalid and %$::HIGHEXPECT) {
my @keys = sort keys %$::HIGHEXPECT;
if (@keys > 1) {
$m .= "\n    expecting any of:\n\t" . join("\n\t", sort keys %$::HIGHEXPECT);
}
else {
$m .= "\n    expecting @keys";
}
}
$m =~ s|Syntax error|Syntax error (two terms in a row?)| if $m =~ qr/infix|nofun/;

if (@COMPILING::WORRIES) {
$m .= "\nOther potential difficulties:\n  " . join( "\n  ", @COMPILING::WORRIES);
}

die "############# PARSE FAILED #############" . $m . "\n";
}

## method worry (Str $s)
sub worry {
my $self = shift;
my $s = shift;


push @COMPILING::WORRIES, $s . $self->locmess;
}

## method locmess ()
sub locmess {
my $self = shift;


my $pre = substr($::ORIG, 0, $self->{_pos});
my $line = $self->lineof($self->{_pos});
$pre = substr($pre, -40, 40);
1 while $pre =~ s!.*\n!!;
my $post = substr($::ORIG, $self->{_pos}, 40);
1 while $post =~ s!(\n.*)!!;
" at " . $COMPILING::FILE . " line $line:\n------> " . $Cursor::GREEN . $pre . $Cursor::RED . 
"$post$Cursor::CLEAR";
}

## method lineof ($p)
sub lineof {
my $self = shift;
my $p = shift;


return 1 unless defined $p;
my $line = $MEMOS[$p]{'L'};
return $line if $line;
$line = 1;
my $pos = 0;
my @text = split(qr/^/,$::ORIG);
for (@text) {
$MEMOS[$pos++]{'L'} = $line
for 1 .. length($_);
$line++;
}
return $MEMOS[$p]{'L'} // 0;
}

## method SETGOAL
sub SETGOAL {
my $self = shift;

}
## method FAILGOAL (Str $stop, Str $name)
sub FAILGOAL {
my $self = shift;
my $stop = shift;
my $name = shift;


$self->panic("Unable to parse $name; couldn't find final '$stop'");
}

# "when" arg assumes more things will become obsolete after Perl 6 comes out...
## method obs (Str $old, Str $new, Str $when = ' in Perl 6')
sub obs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


%$::HIGHEXPECT = ();
$self->panic("Obsolete use of $old;$when please use $new instead");
}

## method worryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub worryobs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


$self->worry("Possible obsolete use of $old;$when please use $new instead");
$self;
}

## vim: expandtab sw=4 ft=perl6
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
POST: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: POST
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: POST
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " @+MEMOS[$.pos]<ws> "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &16 !!perl/hash:RE_any 
            a: 0
            altname: POST_01
            dba: POST
            i: 0
            min: 1
            name: POST_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                alt: POST_01 0
                dba: POST
                i: 0
                min: 12345
                name: unsp
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_string 
                a: 0
                alt: POST_01 1
                dba: POST
                i: 0
                min: 1
                r: 1
                s: 0
                text: \
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: POST
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: POST
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: POST
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_method 
                          a: 0
                          dba: POST
                          i: 0
                          min: 12345
                          name: unsp
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                a: 0
                dba: POST
                i: 0
                min: 12345
                name: postfix_prefix_meta_operator
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: POST
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &47 !!perl/hash:RE_any 
          a: 0
          altname: POST_04
          dba: postfix
          i: 0
          min: 12345
          name: POST_04
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 0
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: dotty
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<dotty><O>; $<sym> = $<dotty><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 1
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: privop
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<privop><O>; $<sym> = $<privop><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 2
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: postop
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<postop><O>; $<sym> = $<postop><sym>; "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: postfix
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+SIGIL = '@' "
POST_01: *16
POST_04: *47
PRE: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix or meta-prefix
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &61 !!perl/hash:RE_any 
          a: 0
          altname: PRE_01
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          name: PRE_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: PRE_01 0
              dba: prefix or meta-prefix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or meta-prefix
                  i: 0
                  min: 12345
                  name: prefix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: prefix or meta-prefix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<prefix><O>; $<sym> = $<prefix><sym> "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'PRE_prefix'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: PRE_01 1
              dba: prefix or meta-prefix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or meta-prefix
                  i: 0
                  min: 12345
                  name: prefix_circumfix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: prefix or meta-prefix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.text "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'PRE_precircum'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          name: prefix_postfix_meta_operator
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method_internal 
        args: $S, 'PRE_prepost'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix or meta-prefix
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
PRE_01: *61
apostrophe: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass 
    a: 0
    dba: apostrophe
    i: 0
    min: 1
    r: 1
    s: 0
    text: "[ ' \\- ]"
arglist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $inv_ok = $+INVOCANT_OK
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my StrPos $endargs is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = 'endargs'
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: argument list
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: arglist
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &26 !!perl/hash:RE_any 
          a: 0
          altname: arglist_01
          dba: argument list
          i: 0
          min: 0
          name: arglist_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: arglist_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: argument list
                i: 0
                min: 12345
                name: stdstopper
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: arglist_01 1
              dba: argument list
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %list_infix)
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: argument list
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            my $delims = $<EXPR><delims>;\n            for @$delims {\n                if ($_.<sym> // '') eq ':' {\n                    if $inv_ok {\n                        $+INVOCANT_IS = $<EXPR><list>[0];\n                    }\n                }\n            }\n        "
arglist_01: *26
args: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $listopish = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INVOCANT_OK is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INVOCANT_IS is context<rw>
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: "extra arglist after (...):"
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &101 !!perl/hash:RE_any 
          a: 0
          altname: args_01
          dba: argument list
          i: 0
          min: 0
          name: args_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 0
              dba: argument list
              i: 0
              min: 12348
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: .(
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semiarglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args_func_args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 1
              dba: argument list
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semiarglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args_func_args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 2
              dba: argument list
              i: 0
              min: 24692
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_string 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semiarglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args_func_args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 3
              dba: argument list
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: argument list
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $listopish = 1 "
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: argument list
                      i: 0
                      min: 24690
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: argument list
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_meta 
                                a: 0
                                dba: argument list
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \s
                            s: 0
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: argument list
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $istype "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: argument list
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_method 
                            a: 0
                            dba: argument list
                            i: 0
                            min: 12345
                            name: infixstopper
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: argument list
                          i: 0
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: args
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<invocant> = $INVOCANT_IS; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: "extra arglist after (...):"
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: "extra arglist after (...):"
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " $listopish "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: "extra arglist after (...):"
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: "extra arglist after (...):"
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: "extra arglist after (...):"
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: "extra arglist after (...):"
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \s
                    s: 0
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: "extra arglist after (...):"
                    i: 0
                    min: 12345
                    name: arglist
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: "extra arglist after (...):"
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: moreargs
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: "extra arglist after (...):"
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $<O> = {}; "
args_01: *101
babble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $lang = $l
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $start
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $stop
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: babble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: babble
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: babble
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: babble
                i: 0
                min: 12345
                name: quotepair
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: babble
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: babble
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            my $kv = $<quotepair>[*-1];\n            $lang = $lang.tweak($kv.<k>, $kv.<v>)\n                or self.panic(\"Unrecognized adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: babble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        ($start,$stop) = $.peek_delimiters();\n        $lang = $start ne $stop ?? $lang.balanced($start,$stop)\n                                !! $lang.unbalanced($stop);\n        $<B> = [$lang,$start,$stop];\n    "
block: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: block
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: block
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: block
        extra: "local $::GOAL = '}' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: block
        i: 0
        min: 12345
        name: statementlist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: block
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: block
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: ('}' , 'block')
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &113 !!perl/hash:RE_any 
          a: 0
          altname: block_01
          dba: block
          i: 0
          min: 0
          name: block_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: block_01 0
              dba: block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 0
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: block
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: block
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: block
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'block_endstmt_simple_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: block_01 1
              dba: block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: block
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[,:]"
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'block_normal_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: block_01 2
              dba: block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: block
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'block_endstmt_complex'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: block_01 3
              dba: block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endargs> = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'block_endargs'
                  max: 0
                  min: 0
                  name: _REDUCE
block_01: *113
capterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: capterm
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: capterm
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &119 !!perl/hash:RE_any 
          a: 0
          altname: capterm_01
          dba: capterm
          i: 0
          min: 2
          name: capterm_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: capterm_01 0
              dba: capterm
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: capterm
                    i: 0
                    min: 12345
                    name: capture
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: )
            - !!perl/hash:RE_sequence 
              a: 0
              alt: capterm_01 1
              dba: capterm
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: capterm
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: capterm
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \S
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 12345
                  name: termish
                  r: 1
                  rest: ''
                  s: 0
capterm_01: *119
capture: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: capture
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 1
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: capture
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: capture
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
category__S_000category: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_000category
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: category
category__S_001sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_001sigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: sigil
category__S_002twigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_002twigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: twigil
category__S_003special_variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_003special_variable
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: special_variable
category__S_004version: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_004version
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: version
category__S_005module_name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_005module_name
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: module_name
category__S_006term: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_006term
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: term
category__S_007quote: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_007quote
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote
category__S_008prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_008prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix
category__S_009infix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_009infix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix
category__S_010postfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_010postfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix
category__S_011dotty: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_011dotty
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: dotty
category__S_012circumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_012circumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: circumfix
category__S_013postcircumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_013postcircumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postcircumfix
category__S_014quote_mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_014quote_mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote_mod
category__S_015trait_verb: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_015trait_verb
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: trait_verb
category__S_016trait_auxiliary: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_016trait_auxiliary
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: trait_auxiliary
category__S_017type_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_017type_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: type_declarator
category__S_018scope_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_018scope_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: scope_declarator
category__S_019package_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_019package_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: package_declarator
category__S_020multi_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_020multi_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: multi_declarator
category__S_021routine_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_021routine_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: routine_declarator
category__S_022regex_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_022regex_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: regex_declarator
category__S_023statement_prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_023statement_prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_prefix
category__S_024statement_control: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_024statement_control
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_control
category__S_025statement_mod_cond: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_025statement_mod_cond
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_cond
category__S_026statement_mod_loop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_026statement_mod_loop
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_loop
category__S_027infix_prefix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_027infix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_prefix_meta_operator
category__S_028infix_postfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_028infix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_postfix_meta_operator
category__S_029infix_circumfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_029infix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_circumfix_meta_operator
category__S_030postfix_prefix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_030postfix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix_prefix_meta_operator
category__S_031prefix_postfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_031prefix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_postfix_meta_operator
category__S_032prefix_circumfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_032prefix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_circumfix_meta_operator
category__S_033terminator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_033terminator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: terminator
circumfix__S_096Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: circumfix__S_096Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: circumfix__S_096Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &81 !!perl/hash:RE_any 
              a: 0
              altname: circumfix__S_096Cur_Ly_01
              dba: circumfix__S_096Cur_Ly
              i: 0
              min: 1
              name: circumfix__S_096Cur_Ly_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: circumfix__S_096Cur_Ly_01 0
                  dba: circumfix__S_096Cur_Ly
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_method 
                  a: 0
                  alt: circumfix__S_096Cur_Ly_01 1
                  dba: circumfix__S_096Cur_Ly
                  i: 0
                  min: 12345
                  name: lambda
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: circumfix__S_096Cur_Ly
        i: 0
        min: 12345
        name: pblock
        r: 1
        rest: ''
        s: 0
circumfix__S_096Cur_Ly_01: *81
circumfix__S_270sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: contextualizer
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: contextualizer
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: contextualizer
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: contextualizer
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: contextualizer
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: contextualizer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: contextualizer
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'contextualizer')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: contextualizer
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+SIGIL ||= $<sigil>.text "
circumfix__S_271Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parenthesized expression
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: parenthesized expression
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: parenthesized expression
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: parenthesized expression
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: parenthesized expression
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: parenthesized expression
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'parenthesized expression')
circumfix__S_272Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: array composer
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: array composer
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_meta 
        a: 0
        dba: array composer
        extra: "local $::GOAL = ']' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: array composer
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: array composer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: array composer
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'array composer')
codepoint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codepoint
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codepoint
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: codepoint
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 0
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: codepoint
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_assertion 
                    assert: "!"
                    min: 0
                    re: !!perl/hash:RE_method_re 
                      a: 0
                      dba: codepoint
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE 
                        decl: []

                        min: 1
                        re: !!perl/hash:RE_string 
                          a: 0
                          dba: codepoint
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                      s: 0
                  - !!perl/hash:RE_meta 
                    a: 0
                    dba: codepoint
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .
            min: 0
            quant: 
              - "*"
              - "?"
              - ''
              - 0
        min: 0
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: codepoint
        i: 0
        min: 1
        r: 1
        s: 0
        text: "]"
colonpair: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: colonpair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $key
    - !!perl/hash:RE_decl 
      a: 0
      dba: colonpair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $value
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: colon pair
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: colonpair
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &31 !!perl/hash:RE_any 
          a: 0
          altname: colonpair_01
          dba: signature
          i: 0
          min: 12345
          name: colonpair_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 0
              dba: colon pair
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.text; $value = 0; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_false'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 1
              dba: colon pair
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: colon pair
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: num
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 2
              dba: colon pair
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.text; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: colon pair
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: colon pair
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: colon pair
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_string 
                              a: 0
                              dba: colon pair
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: .
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: colon pair
                            i: 0
                            min: 12345
                            name: postcircumfix
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: colon pair
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $value = $<postcircumfix>; "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: colon pair
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $value = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_value'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 3
              dba: signature
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: signature
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: signature
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: signature
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: signature
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'signature')
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 4
              dba: signature
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: signature
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = \"\"; $value = $<postcircumfix>; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_structural'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 5
              dba: signature
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 24690
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: signature
                      i: 0
                      min: 24690
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: signature
                          i: 0
                          min: 12345
                          name: sigil
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: signature
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: signature
                            i: 0
                            min: 12345
                            name: twigil
                            r: 1
                            rest: ''
                            s: 0
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: signature
                          i: 0
                          min: 12345
                          name: desigilname
                          r: 1
                          rest: ''
                          s: 0
                  dba: signature
                  i: 0
                  min: 24690
                  r: 1
                  s: 0
                  var: var
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: signature
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<var><desigilname>.text; $value = $<var>; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_varname'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: colon pair
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<k> = $key; $<v> = $value; "
colonpair_01: *31
comp_unit: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $begin_compunit is context = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $endargs        is context<rw> = -1
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $LANG is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PKGDECL is context = ""
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PKG is context = ""
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $GOAL is context = "(eof)"
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PARSER is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw>
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: comp_unit
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        text: " init_pads(); "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: comp_unit
        i: 0
        min: 12345
        name: statementlist
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: comp_unit
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: comp_unit
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method 
                    a: 0
                    dba: comp_unit
                    i: 0
                    min: 12345
                    name: unitstopper
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: comp_unit
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Can't understand next input--giving up")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        text: "\n        if @COMPILING::WORRIES {\n            warn \"Potential difficulties:\\n  \" ~ join( \"\\n  \", @COMPILING::WORRIES) ~ \"\\n\";\n        }\n\n        my %post_types;\n        my %unk_types;\n        my %unk_routines;\n        for keys(%MYSTERY) {\n            if $.is_type($_) {\n                # types may not be post-declared\n                %post_types{$_} = %MYSTERY{$_};\n                next;\n            }\n\n            next if $.is_known($_);\n\n            # just a guess, but good enough to improve error reporting\n            if $_ lt 'a' {\n                %unk_types{$_} = %MYSTERY{$_};\n            }\n            else {\n                %unk_routines{$_} = %MYSTERY{$_};\n            }\n        }\n        if %post_types {\n            my @tmp = sort keys(%post_types);\n            warn \"Illegally post-declared type\" ~ ('s' x (@tmp != 1)) ~ \":\\n\";\n            for @tmp {\n                warn \"\\t$_ used at \", %post_types{$_}, \"\\n\";\n            }\n        }\n        if %unk_types {\n            my @tmp = sort keys(%unk_types);\n            warn \"Undeclared type\" ~ ('s' x (@tmp != 1)) ~ \":\\n\";\n            for @tmp {\n                warn \"\\t$_ used at \", %unk_types{$_}, \"\\n\";\n            }\n        }\n        if %unk_routines {\n            my @tmp = sort keys(%unk_routines);\n            warn \"Undeclared routine\" ~ ('s' x (@tmp != 1)) ~ \":\\n\";\n            for @tmp {\n                warn \"\\t$_ used at \", %unk_routines{$_}, \"\\n\";\n            }\n        }\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
dec_number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 2
    re: &111 !!perl/hash:RE_any 
      a: 0
      altname: dec_number_01
      dba: decimal number
      i: 0
      min: 2
      name: dec_number_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: dec_number_01 0
          dba: decimal number
          i: 0
          min: 2
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 2
                nobind: 1
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: .
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: decimal number
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_bracket 
                        decl: []

                        min: 2
                        re: !!perl/hash:RE_sequence 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: _
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_meta 
                                a: 0
                                dba: decimal number
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              min: 1
                              quant: 
                                - +
                                - ":"
                                - ''
                                - 1
                      min: 0
                      quant: 
                        - "*"
                        - ":"
                        - ''
                        - 0
              dba: decimal number
              i: 0
              min: 2
              r: 1
              s: 0
              var: coeff
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: decimal number
                i: 0
                min: 12345
                name: escale
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: dec_number_01 1
          dba: decimal number
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 3
                nobind: 1
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: decimal number
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_bracket 
                        decl: []

                        min: 2
                        re: !!perl/hash:RE_sequence 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: _
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_meta 
                                a: 0
                                dba: decimal number
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              min: 1
                              quant: 
                                - +
                                - ":"
                                - ''
                                - 1
                      min: 0
                      quant: 
                        - "*"
                        - ":"
                        - ''
                        - 0
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: .
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: decimal number
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_bracket 
                        decl: []

                        min: 2
                        re: !!perl/hash:RE_sequence 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: _
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_meta 
                                a: 0
                                dba: decimal number
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              min: 1
                              quant: 
                                - +
                                - ":"
                                - ''
                                - 1
                      min: 0
                      quant: 
                        - "*"
                        - ":"
                        - ''
                        - 0
              dba: decimal number
              i: 0
              min: 3
              r: 1
              s: 0
              var: coeff
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: decimal number
                i: 0
                min: 12345
                name: escale
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: dec_number_01 2
          dba: decimal number
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 1
                nobind: 1
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: decimal number
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_bracket 
                        decl: []

                        min: 2
                        re: !!perl/hash:RE_sequence 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: _
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_meta 
                                a: 0
                                dba: decimal number
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              min: 1
                              quant: 
                                - +
                                - ":"
                                - ''
                                - 1
                      min: 0
                      quant: 
                        - "*"
                        - ":"
                        - ''
                        - 0
              dba: decimal number
              i: 0
              min: 1
              r: 1
              s: 0
              var: coeff
            - !!perl/hash:RE_method 
              a: 0
              dba: decimal number
              i: 0
              min: 12345
              name: escale
              r: 1
              rest: ''
              s: 0
dec_number_01: *111
declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &11 !!perl/hash:RE_any 
      a: 0
      altname: declarator_01
      dba: declarator
      i: 0
      min: 12345
      name: declarator_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 0
          dba: declarator
          i: 0
          min: 12345
          name: variable_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: declarator_01 1
          dba: declarator
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: declarator
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_meta 
              a: 0
              dba: declarator
              extra: "local $::GOAL = ')' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: declarator
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: declarator
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: declarator
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (')' , 'declarator')
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: declarator
                i: 0
                min: 12345
                name: trait
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 2
          dba: declarator
          i: 0
          min: 12345
          name: routine_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 3
          dba: declarator
          i: 0
          min: 12345
          name: regex_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 4
          dba: declarator
          i: 0
          min: 12345
          name: type_declarator
          r: 1
          rest: ''
          s: 0
declarator_01: *11
default_value: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: default_value
    i: 0
    min: 1
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_string 
        a: 0
        dba: default_value
        i: 0
        min: 1
        r: 1
        s: 1
        text: =
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: EXPR
        rest: (item %item_assignment)
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
deflongname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: name to be defined
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: name to be defined
        i: 0
        min: 12345
        name: name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: name to be defined
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: name to be defined
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 0
                min: 12345
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: name to be defined
                i: 0
                min: 0
                r: 1
                s: 0
                text: " $.add_macro($<name>) if $+IN_DECL; "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: name to be defined
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.add_routine($<name>.text) if $+IN_DECL; "
desigilname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &88 !!perl/hash:RE_any 
      a: 0
      altname: desigilname_01
      dba: desigilname
      i: 0
      min: 12345
      name: desigilname_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: desigilname_01 0
          dba: desigilname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: desigilname
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: desigilname
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: $
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: desigilname
              i: 0
              min: 12345
              name: variable
              r: 1
              rest: ''
              s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: desigilname_01 1
          dba: desigilname
          i: 0
          min: 12345
          name: longname
          r: 1
          rest: ''
          s: 0
desigilname_01: *88
dotty__S_079DotStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: dotty__S_079DotStar
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: dotty__S_079DotStar
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: dotty__S_079DotStar
                i: 0
                min: 1
                r: 1
                s: 0
                text: .
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: &105 !!perl/hash:RE_any 
                  a: 0
                  altname: dotty__S_079DotStar_02
                  dba: dotty__S_079DotStar
                  i: 0
                  min: 1
                  name: dotty__S_079DotStar_02
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_cclass 
                      a: 0
                      alt: dotty__S_079DotStar_02 0
                      dba: dotty__S_079DotStar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "[+*?=]"
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: dotty__S_079DotStar_02 1
                      dba: dotty__S_079DotStar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: dotty__S_079DotStar
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "^"
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: dotty__S_079DotStar
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "!"
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
        min: 2
        var: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: dotty__S_079DotStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_079DotStar
        i: 0
        min: 12345
        name: unspacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_079DotStar
        i: 0
        min: 12345
        name: dottyop
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: dotty__S_079DotStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $0.item; "
dotty__S_079DotStar_02: *105
dotty__S_080Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: dotty__S_080Dot
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_080Dot
        endsym: unspacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: .
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_080Dot
        i: 0
        min: 12345
        name: unspacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_080Dot
        i: 0
        min: 12345
        name: dottyop
        r: 1
        rest: ''
        s: 0
dottyop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &97 !!perl/hash:RE_any 
      a: 0
      altname: dottyop_01
      dba: dotty method or postfix
      i: 0
      min: 12345
      name: dottyop_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: dottyop_01 0
          dba: dotty method or postfix
          i: 0
          min: 12345
          name: methodop
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: dottyop_01 1
          dba: dotty method or postfix
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: dottyop_01 2
          dba: dotty method or postfix
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: dotty method or postfix
                i: 0
                min: 12345
                name: alpha
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: dotty method or postfix
              i: 0
              min: 12345
              name: postop
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: dotty method or postfix
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $<O> = $<postop><O>; $<sym> = $<postop><sym>; "
dottyop_01: *97
eat_terminator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: !!perl/hash:RE_first 
      a: 0
      dba: eat_terminator
      i: 0
      min: 0
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_string 
          a: 0
          dba: eat_terminator
          i: 0
          min: 1
          r: 1
          s: 0
          text: ;
        - !!perl/hash:RE_sequence 
          a: 0
          dba: eat_terminator
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: eat_terminator
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " @+MEMOS[$.pos]<endstmt> "
            - !!perl/hash:RE_method 
              a: 0
              dba: eat_terminator
              i: 0
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
        - !!perl/hash:RE_assertion 
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method 
            a: 0
            dba: eat_terminator
            i: 0
            min: 12345
            name: terminator
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_meta 
          a: 0
          dba: eat_terminator
          i: 0
          min: 0
          r: 1
          s: 0
          text: $
        - !!perl/hash:RE_sequence 
          a: 0
          dba: eat_terminator
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: eat_terminator
              i: 0
              min: 0
              r: 1
              s: 0
              text: " if @+MEMOS[$.pos]<ws> { $.pos = @+MEMOS[$.pos]<ws>; } "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Syntax error")
escale: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escale
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_cclass 
        a: 0
        dba: escale
        i: 0
        min: 1
        r: 1
        s: 0
        text: "[Ee]"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: escale
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[+\\-]"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: escale
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: escale
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: escale
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: escale
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
escape__S_179none: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_179none
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
extrapost: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: extrapost
      i: 0
      max: 0
      min: 0
      r: 0
      s: 0
      text: my $inquote is context = 1
  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: extrapost
    i: 0
    min: 0
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: extrapost
          i: 0
          min: 12345
          name: POST
          r: 0
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - "!"
          - ''
          - 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: extrapost
          i: 0
          min: 0
          name: after
          nobind: 1
          r: 0
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: extrapost
              i: 0
              min: 1
              r: 0
              s: 0
              text: "[ \\] } > ) ]"
          s: 0
fatarrow: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: fatarrow
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: fatarrow
          i: 0
          min: 12345
          name: identifier
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: fatarrow
        i: 0
        min: 12345
        r: 1
        s: 0
        var: key
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: fatarrow
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: fatarrow
        i: 0
        min: 2
        r: 1
        s: 0
        text: =>
      - !!perl/hash:RE_method 
        a: 0
        dba: fatarrow
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: EXPR
          nobind: 1
          rest: (item %item_assignment)
        dba: fatarrow
        i: 0
        min: 0
        r: 1
        s: 0
        var: val
foo: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24699
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: foo
    i: 0
    min: 24699
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: foo
        i: 0
        min: 3
        r: 1
        s: 0
        text: foo
      - !!perl/hash:RE_method 
        a: 0
        dba: foo
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: foo
        i: 0
        min: 3
        r: 1
        s: 0
        text: bar
      - !!perl/hash:RE_method 
        a: 0
        dba: foo
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: foo
        i: 0
        min: 3
        r: 1
        s: 0
        text: baz
fulltypename: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: fulltypename
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: fulltypename
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12346
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: fulltypename
            i: 0
            min: 12346
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: fulltypename
                i: 0
                min: 1
                r: 1
                s: 1
                text: "|"
              - !!perl/hash:RE_method 
                a: 0
                dba: fulltypename
                i: 0
                min: 12345
                name: typename
                r: 1
                rest: ''
                s: 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: fulltypename
            i: 0
            min: 12347
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_string 
                a: 0
                dba: fulltypename
                i: 0
                min: 2
                r: 1
                s: 1
                text: of
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                a: 0
                dba: fulltypename
                i: 0
                min: 12345
                name: fulltypename
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
hexint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: hexint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: hexint
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ 0..9 a..f A..F ]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: hexint
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: hexint
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_cclass 
                  a: 0
                  dba: hexint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[ 0..9 a..f A..F ]"
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
ident: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: ident
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: ident
        i: 0
        min: 12345
        name: alpha
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: ident
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
identifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: identifier
        i: 0
        min: 12345
        name: ident
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: identifier
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: identifier
                i: 0
                min: 12345
                name: apostrophe
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: identifier
                i: 0
                min: 12345
                name: ident
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
infix__S_274Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_274Dot
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix__S_274Dot
        i: 0
        min: 1
        r: 1
        s: 0
        text: .
      - !!perl/hash:RE_cclass 
        a: 0
        dba: infix__S_274Dot
        i: 0
        min: 1
        r: 1
        s: 0
        text: "[\\]\\)\\},:\\s\\$\"']"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('. to concatenate strings', '~')
infix__S_280StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Exponentiation
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_280StarStar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "**"
infix__S_292Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_292Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
infix__S_293Slash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_293Slash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: /
infix__S_294div: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_294div
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: div
infix__S_295Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_295Percent
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_295Percent
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_295Percent
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = 'Bool'; "
infix__S_296mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_296mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod
infix__S_297PlusAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_297PlusAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +&
infix__S_298PlusLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_298PlusLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_298PlusLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +<
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_298PlusLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_298PlusLt
              i: 0
              min: 1
              r: 1
              s: 0
              text: <
          s: 0
infix__S_299LtLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_299LtLt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_299LtLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <<
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_299LtLt
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('<< to do left shift', '+< or ~<')
infix__S_300GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_300GtGt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_300GtGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ">>"
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_300GtGt
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('>> to do right shift', '+> or ~>')
infix__S_301PlusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_301PlusGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_301PlusGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +>
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_301PlusGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_301PlusGt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
          s: 0
infix__S_302TildeAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_302TildeAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~&
infix__S_303QuestionAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_303QuestionAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?&
infix__S_304TildeLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_304TildeLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_304TildeLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~<
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_304TildeLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_304TildeLt
              i: 0
              min: 1
              r: 1
              s: 0
              text: <
          s: 0
infix__S_305TildeGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_305TildeGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_305TildeGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~>
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_305TildeGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_305TildeGt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
          s: 0
infix__S_306Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_306Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
infix__S_307Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_307Minus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "-"
infix__S_308PlusVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_308PlusVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +|
infix__S_309PlusCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_309PlusCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +^
infix__S_310TildeVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_310TildeVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~|
infix__S_311TildeCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_311TildeCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~^
infix__S_312QuestionVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_312QuestionVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?|
infix__S_313QuestionCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_313QuestionCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?^
infix__S_314x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Replication
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_314x
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: x
infix__S_315xx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Replication
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_315xx
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: xx
infix__S_316Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Concatenation
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_316Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
infix__S_317Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_317Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
infix__S_318also: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_318also
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: also
infix__S_319Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_319Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
infix__S_320Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_320Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
infix__S_326LtEqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_326LtEqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_326LtEqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <=>
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_326LtEqualGt
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_327cmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_327cmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_327cmp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: cmp
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_327cmp
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_328leg: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_328leg
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_328leg
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: leg
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_328leg
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_329but: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_329but
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: but
infix__S_330does: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_330does
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: does
infix__S_331DotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_331DotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ..
infix__S_332CaretDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_332CaretDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^.."
infix__S_333DotDotCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_333DotDotCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ..^
infix__S_334CaretDotDotCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_334CaretDotDotCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^..^"
infix__S_335EqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_335EqualEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_335EqualEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_335EqualEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_335EqualEqual
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
          s: 0
infix__S_336BangEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_336BangEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_336BangEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!="
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_336BangEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: infix__S_336BangEqual
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
infix__S_337Lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_337Lt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <
infix__S_338LtEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_338LtEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <=
infix__S_339Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_339Gt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ">"
infix__S_340GtEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_340GtEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ">="
infix__S_341TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_341TildeTilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~~
infix__S_342BangTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_342BangTilde
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_342BangTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!~"
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_342BangTilde
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('!~ to do negated pattern matching', '!~~')
infix__S_343EqualTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_343EqualTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_343EqualTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =~
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('=~ to do pattern matching', '~~')
infix__S_344eq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_344eq
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: eq
infix__S_345ne: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_345ne
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ne
infix__S_346lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_346lt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: lt
infix__S_347le: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_347le
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: le
infix__S_348gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_348gt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: gt
infix__S_349ge: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_349ge
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ge
infix__S_350EqualColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_350EqualColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =:=
infix__S_351EqualEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_351EqualEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ===
infix__S_352eqv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_352eqv
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: eqv
infix__S_353before: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_353before
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: before
infix__S_354after: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_354after
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: after
infix__S_355AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_355AmpAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&&"
infix__S_356VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_356VertVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "||"
infix__S_357CaretCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_357CaretCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^^"
infix__S_358SlashSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_358SlashSlash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: //
infix__S_359min: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_359min
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: min
infix__S_360max: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_360max
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: max
infix__S_361QuestionQuestion_BangBang: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: infix__S_361QuestionQuestion_BangBang
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '!!'
  kind: token
  min: 12347
  pkg: STD::Conditional
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_361QuestionQuestion_BangBang
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix__S_361QuestionQuestion_BangBang
        i: 0
        min: 2
        r: 1
        s: 0
        text: ??
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_361QuestionQuestion_BangBang
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: EXPR
        rest: (item %item_assignment)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix__S_361QuestionQuestion_BangBang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: infix__S_361QuestionQuestion_BangBang
              i: 0
              min: 2
              r: 1
              s: 0
              text: "!!"
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: !!perl/hash:RE_first 
                a: 0
                dba: infix__S_361QuestionQuestion_BangBang
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_361QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_361QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_string 
                              a: 0
                              dba: infix__S_361QuestionQuestion_BangBang
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: =
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Assignment not allowed within ??!!")
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_361QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_361QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_string 
                              a: 0
                              dba: infix__S_361QuestionQuestion_BangBang
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              text: "::"
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Please use !! rather than ::")
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_361QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_361QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 12345
                            re: !!perl/hash:RE_method 
                              a: 0
                              dba: infix__S_361QuestionQuestion_BangBang
                              i: 0
                              min: 12345
                              name: infixish
                              r: 1
                              rest: ''
                              s: 0
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Precedence too loose within ??!!; use ??()!! instead ")
                  - !!perl/hash:RE_method 
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Found ?? but no !!; possible precedence problem")
infix__S_362Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_362Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_362Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: "('?: for the conditional operator', '??!!')"
infix__S_363ff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_363ff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ff
infix__S_364Caretff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_364Caretff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^ff"
infix__S_365ffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_365ffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ff^
infix__S_366CaretffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_366CaretffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^ff^"
infix__S_367fff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_367fff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: fff
infix__S_368Caretfff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_368Caretfff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^fff"
infix__S_369fffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_369fffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: fff^
infix__S_370CaretfffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_370CaretfffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^fff^"
infix__S_371Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_371Equal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_371Equal
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_371Equal
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $ = $+SIGIL eq '$' \n        ?? STD::Item_assignment.coerce($)\n        !! STD::List_assignment.coerce($);\n    "
infix__S_372ColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_372ColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: :=
infix__S_373ColonColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_373ColonColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ::=
infix__S_374DotEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_374DotEqual
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_374DotEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: .=
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_374DotEqual
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix__S_374DotEqual
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix__S_374DotEqual
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 2
                  re: &3 !!perl/hash:RE_any 
                    a: 0
                    altname: infix__S_374DotEqual_02
                    dba: infix__S_374DotEqual
                    i: 0
                    min: 2
                    name: infix__S_374DotEqual_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: infix__S_374DotEqual_02 0
                        dba: infix__S_374DotEqual
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: infix__S_374DotEqual
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \w
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: infix__S_374DotEqual
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: ;
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_374DotEqual_02 1
                        dba: infix__S_374DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: new
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_374DotEqual_02 2
                        dba: infix__S_374DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: sort
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_374DotEqual_02 3
                        dba: infix__S_374DotEqual
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: subst
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_374DotEqual_02 4
                        dba: infix__S_374DotEqual
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: trans
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_374DotEqual_02 5
                        dba: infix__S_374DotEqual
                        i: 0
                        min: 7
                        r: 1
                        s: 0
                        text: reverse
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_374DotEqual_02 6
                        dba: infix__S_374DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: uniq
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_374DotEqual_02 7
                        dba: infix__S_374DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: map
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_374DotEqual_02 8
                        dba: infix__S_374DotEqual
                        i: 0
                        min: 8
                        r: 1
                        s: 0
                        text: samecase
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_374DotEqual_02 9
                        dba: infix__S_374DotEqual
                        i: 0
                        min: 6
                        r: 1
                        s: 0
                        text: substr
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: worryobs
              rest: ('.= as append operator', '~=')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_374DotEqual
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><nextterm> = 'dottyop' "
infix__S_374DotEqual_02: *3
infix__S_375EqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_375EqualGt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =>
infix__S_378Comma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_378Comma
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_378Comma
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ","
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_378Comma
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><assign> = 1 "
infix__S_379Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_379Colon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_379Colon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_379Colon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &92 !!perl/hash:RE_any 
              a: 0
              altname: infix__S_379Colon_01
              dba: infix__S_379Colon
              i: 0
              min: 1
              name: infix__S_379Colon_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: infix__S_379Colon_01 0
                  dba: infix__S_379Colon
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_method 
                  a: 0
                  alt: infix__S_379Colon_01 1
                  dba: infix__S_379Colon
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_379Colon
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.panic(\"Illegal use of colon as invocant marker\") unless $+INVOCANT_OK--; "
infix__S_379Colon_01: *92
infix__S_380p5EqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_380p5EqualGt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: p5=>
infix__S_381Z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_381Z
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: Z
infix__S_382minmax: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_382minmax
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: minmax
infix__S_383DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_383DotDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ...
infix__S_391and: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_391and
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: and
infix__S_392andthen: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_392andthen
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: andthen
infix__S_393or: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_393or
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: or
infix__S_394orelse: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_394orelse
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: orelse
infix__S_395xor: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_395xor
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: xor
infix__S_396LtEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_396LtEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <==
infix__S_397EqualEqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_397EqualEqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_397EqualEqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==>
      - !!perl/hash:RE_method_internal 
        args: $S, 'infix__S_397EqualEqualGt'
        max: 0
        min: 0
        name: _REDUCE
infix__S_398LtLtEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_398LtLtEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <<==
infix__S_399EqualEqualGtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_399EqualEqualGtGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_399EqualEqualGtGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==>>
      - !!perl/hash:RE_method_internal 
        args: $S, 'infix__S_399EqualEqualGtGt'
        max: 0
        min: 0
        name: _REDUCE
infix_circumfix_meta_operator__S_086X: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::List_infix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_circumfix_meta_operator__S_086X
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix_circumfix_meta_operator__S_086X
        i: 0
        min: 1
        r: 1
        s: 0
        text: X
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_circumfix_meta_operator__S_086X
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: infix_circumfix_meta_operator__S_086X
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: infix_circumfix_meta_operator__S_086X
                i: 0
                min: 12345
                name: infixish
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_string 
                  a: 0
                  dba: infix_circumfix_meta_operator__S_086X
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: X
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix_circumfix_meta_operator__S_086X
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $<O> = $<infixish>[0]<O>; "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
infix_circumfix_meta_operator__S_087Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_circumfix_meta_operator__S_087Fre_Nch
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &28 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_087Fre_Nch_01
          dba: infix_circumfix_meta_operator__S_087Fre_Nch
          i: 0
          min: 1
          name: infix_circumfix_meta_operator__S_087Fre_Nch_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_087Fre_Nch_01 0
              dba: infix_circumfix_meta_operator__S_087Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_087Fre_Nch_01 1
              dba: infix_circumfix_meta_operator__S_087Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_circumfix_meta_operator__S_087Fre_Nch
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_circumfix_meta_operator__S_087Fre_Nch
        i: 0
        min: 12345
        name: infixish
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &124 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_087Fre_Nch_02
          dba: infix_circumfix_meta_operator__S_087Fre_Nch
          i: 0
          min: 1
          name: infix_circumfix_meta_operator__S_087Fre_Nch_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_087Fre_Nch_02 0
              dba: infix_circumfix_meta_operator__S_087Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_087Fre_Nch_02 1
              dba: infix_circumfix_meta_operator__S_087Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_circumfix_meta_operator__S_087Fre_Nch
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> := $<infixish><O>; "
infix_circumfix_meta_operator__S_087Fre_Nch_01: *28
infix_circumfix_meta_operator__S_087Fre_Nch_02: *124
infix_circumfix_meta_operator__S_088LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_circumfix_meta_operator__S_088LtLt_GtGt
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &95 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_088LtLt_GtGt_01
          dba: infix_circumfix_meta_operator__S_088LtLt_GtGt
          i: 0
          min: 2
          name: infix_circumfix_meta_operator__S_088LtLt_GtGt_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_088LtLt_GtGt_01 0
              dba: infix_circumfix_meta_operator__S_088LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: <<
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_088LtLt_GtGt_01 1
              dba: infix_circumfix_meta_operator__S_088LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_circumfix_meta_operator__S_088LtLt_GtGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_circumfix_meta_operator__S_088LtLt_GtGt
        i: 0
        min: 12345
        name: infixish
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &96 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_088LtLt_GtGt_02
          dba: infix_circumfix_meta_operator__S_088LtLt_GtGt
          i: 0
          min: 2
          name: infix_circumfix_meta_operator__S_088LtLt_GtGt_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_088LtLt_GtGt_02 0
              dba: infix_circumfix_meta_operator__S_088LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: <<
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_088LtLt_GtGt_02 1
              dba: infix_circumfix_meta_operator__S_088LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_circumfix_meta_operator__S_088LtLt_GtGt
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> := $<infixish><O>; "
infix_circumfix_meta_operator__S_088LtLt_GtGt_01: *95
infix_circumfix_meta_operator__S_088LtLt_GtGt_02: *96
infix_postfix_meta_operator__S_089Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_postfix_meta_operator__S_089Equal
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix_postfix_meta_operator__S_089Equal
        i: 0
        min: 1
        r: 1
        s: 0
        text: =
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_postfix_meta_operator__S_089Equal
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O> = $op<O>; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: infix_postfix_meta_operator__S_089Equal
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix_postfix_meta_operator__S_089Equal
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " ($<O><assoc> // '') eq 'non'   "
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Can't make assignment op out of non-associative operator")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: infix_postfix_meta_operator__S_089Equal
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix_postfix_meta_operator__S_089Equal
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $<O><assign> "
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Can't make assignment out of " ~ $<O><dba> ~ " operator")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
infix_prefix_meta_operator__S_084Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_084Bang
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_084Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix_prefix_meta_operator__S_084Bang
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix_prefix_meta_operator__S_084Bang
              i: 0
              min: 1
              r: 1
              s: 0
              text: "!"
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_prefix_meta_operator__S_084Bang
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_084Bang
        i: 0
        min: 12345
        name: infixish
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_prefix_meta_operator__S_084Bang
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> = $<infixish><O>; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix_prefix_meta_operator__S_084Bang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix_prefix_meta_operator__S_084Bang
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " ($<O><returns> // '') eq 'Bool' "
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix_prefix_meta_operator__S_084Bang
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " $<infixish>.text eq '=' "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Only boolean infix operators may be negated")
infix_prefix_meta_operator__S_085R: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_085R
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_085R
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: R
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_prefix_meta_operator__S_085R
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_085R
        i: 0
        min: 12345
        name: infixish
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_prefix_meta_operator__S_085R
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> = $<infixish><O>; "
infixish: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: infixish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $infix
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix or meta-infix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &116 !!perl/hash:RE_any 
          a: 0
          altname: infixish_01
          dba: infix or meta-infix
          i: 0
          min: 12345
          name: infixish_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 0
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            $<fake> = 1;\n            $<sym> = ':';\n            %<O><prec> = %comma<prec>;  # actual test is non-inclusive of comma!\n            %<O><assoc> = 'unary';\n            %<O><uassoc> = 'left';\n        "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 1
              dba: infix or meta-infix
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: infix or meta-infix
                  extra: "local $::GOAL = ']' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infixish
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: infix or meta-infix
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: infix or meta-infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'infix or meta-infix')
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infixish><O> "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 2
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix_circumfix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_circumfix_meta_operator><O>;\n          $<sym> = $<infix_circumfix_meta_operator><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 3
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix_prefix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_prefix_meta_operator><O>;\n          $<sym> = $<infix_prefix_meta_operator><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 4
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: infix or meta-infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix>.<O>; $<sym> = $<infix>.<sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 5
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: infix or meta-infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                    s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $infix = $<infix>; "
                - !!perl/hash:RE_method 
                  min: 0
                  name: infix_postfix_meta_operator
                  rest: ($infix)
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_postfix_meta_operator>.<O>; $<sym> = $<infix_postfix_meta_operator>.<sym>; "
infixish_01: *116
infixstopper: !!perl/hash:RE 
  decl: []

  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &55 !!perl/hash:RE_any 
      a: 0
      altname: infixstopper_01
      dba: infix stopper
      i: 0
      min: 0
      name: infixstopper_01
      r: 0
      s: 0
      zyg: 
        - !!perl/hash:RE_assertion 
          alt: infixstopper_01 0
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method_re 
            a: 0
            dba: infix stopper
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 0
            re: !!perl/hash:RE 
              decl: []

              min: 12345
              re: !!perl/hash:RE_method 
                a: 0
                dba: infix stopper
                i: 0
                min: 12345
                name: stopper
                r: 0
                rest: ''
                s: 0
            s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: infixstopper_01 1
          dba: infix stopper
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix stopper
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 2
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: infix stopper
                    i: 0
                    min: 2
                    r: 0
                    s: 0
                    text: "!!"
                s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix stopper
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $+GOAL eq '!!' "
        - !!perl/hash:RE_sequence 
          a: 0
          alt: infixstopper_01 2
          dba: infix stopper
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix stopper
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: &78 !!perl/hash:RE_any 
                    a: 0
                    altname: infixstopper_04
                    dba: infix stopper
                    i: 0
                    min: 1
                    name: infixstopper_04
                    r: 0
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infixstopper_04 0
                        dba: infix stopper
                        i: 0
                        min: 1
                        r: 0
                        s: 0
                        text: "{"
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: infixstopper_04 1
                        dba: infix stopper
                        i: 0
                        min: 12345
                        name: lambda
                        r: 0
                        rest: ''
                        s: 0
                s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix stopper
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " ($+GOAL eq '{' or $+GOAL eq 'endargs') and @+MEMOS[$.pos]<ws> "
        - !!perl/hash:RE_assertion 
          alt: infixstopper_01 3
          assert: "?"
          min: 0
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: infix stopper
            i: 0
            min: 0
            nobind: 1
            r: 0
            s: 0
            text: " $+GOAL eq 'endargs' and @+MEMOS[$.pos]<endargs> "
infixstopper_01: *55
infixstopper_04: *78
integer: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &114 !!perl/hash:RE_any 
      a: 0
      altname: integer_01
      dba: integer
      i: 0
      min: 1
      name: integer_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: integer_01 0
          dba: integer
          i: 0
          min: 2
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: integer
              i: 0
              min: 1
              r: 1
              s: 0
              text: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: &42 !!perl/hash:RE_any 
                a: 0
                altname: integer_02
                dba: integer
                i: 0
                min: 1
                name: integer_02
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: integer_02 0
                    dba: integer
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: b
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_cclass 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "[01]"
                        min: 1
                        quant: 
                          - +
                          - ":"
                          - ''
                          - 1
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 2
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: integer
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: integer
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: _
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_cclass 
                                  a: 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "[01]"
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: integer_02 1
                    dba: integer
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: o
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_cclass 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "[0..7]"
                        min: 1
                        quant: 
                          - +
                          - ":"
                          - ''
                          - 1
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 2
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: integer
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: integer
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: _
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_cclass 
                                  a: 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "[0..7]"
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: integer_02 2
                    dba: integer
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: x
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_cclass 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "[0..9a..fA..F]"
                        min: 1
                        quant: 
                          - +
                          - ":"
                          - ''
                          - 1
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 2
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: integer
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: integer
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: _
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_cclass 
                                  a: 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "[0..9a..fA..F]"
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: integer_02 3
                    dba: integer
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: d
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_meta 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \d
                        min: 1
                        quant: 
                          - +
                          - ":"
                          - ''
                          - 1
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 2
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: integer
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: integer
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: _
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_meta 
                                  a: 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \d
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: integer_02 4
                    dba: integer
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_meta 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \d
                        min: 1
                        quant: 
                          - +
                          - ":"
                          - ''
                          - 1
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 2
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: integer
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: integer
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: _
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_meta 
                                  a: 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \d
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: integer
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $.worry(\"Leading 0 does not indicate octal in Perl 6\") "
        - !!perl/hash:RE_sequence 
          a: 0
          alt: integer_01 1
          dba: integer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: integer
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 2
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: integer
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: integer
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: _
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
integer_01: *114
integer_02: *42
label: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: label
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $label
  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: label
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: label
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: label
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: label
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: label
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: label
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: label
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: label
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $.is_type($label = $<identifier>.text) "
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Illegal redeclaration of '$label'")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: label
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.add_type($label); "
lambda: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &98 !!perl/hash:RE_any 
    a: 0
    altname: lambda_00
    dba: lambda
    i: 0
    min: 2
    name: lambda_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        alt: lambda_00 0
        dba: lambda
        i: 0
        min: 2
        r: 1
        s: 0
        text: ->
      - !!perl/hash:RE_string 
        a: 0
        alt: lambda_00 1
        dba: lambda
        i: 0
        min: 3
        r: 1
        s: 0
        text: <->
lambda_00: *98
longname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: longname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: longname
        i: 0
        min: 12345
        name: name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: longname
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
macro_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: macro_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: macro_def
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &74 !!perl/hash:RE_any 
            a: 0
            altname: macro_def_01
            dba: macro_def
            i: 0
            min: 1
            name: macro_def_01
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: macro_def_01 0
                dba: macro_def
                i: 0
                min: 1
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: "&"
                  - !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: macro_def
                      i: 0
                      min: 12345
                      name: deflongname
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: macro_def_01 1
                dba: macro_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 12345
                    name: deflongname
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &104 !!perl/hash:RE_any 
            a: 0
            altname: macro_def_02
            dba: macro_def
            i: 0
            min: 12345
            name: macro_def_02
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: macro_def_02 0
                dba: macro_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 12345
                    name: multisig
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: macro_def_02 1
                dba: macro_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: macro_def
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 1
          text: "\n        $ = $+PARSER.bless($);\n        $IN_DECL = 0;\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: macro_def
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
macro_def_01: *74
macro_def_02: *104
method_def: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: method_def
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &86 !!perl/hash:RE_any 
          a: 0
          altname: method_def_01
          dba: subscript signature
          i: 0
          min: 0
          name: method_def_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: method_def_01 0
              dba: method_def
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_cclass 
                    a: 0
                    dba: method_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: "[ ! ^ ]"
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: method_def
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &58 !!perl/hash:RE_any 
                      a: 0
                      altname: method_def_02
                      dba: method_def
                      i: 0
                      min: 12345
                      name: method_def_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: method_def_02 0
                          dba: method_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: method_def
                              i: 0
                              min: 12345
                              name: multisig
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: method_def_02 1
                          dba: method_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: method_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: method_def_01 1
              dba: method_def
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: method_def
                  i: 0
                  min: 12345
                  name: multisig
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: method_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: method_def_01 2
              dba: subscript signature
              i: 0
              min: 24691
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: method_def
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: method_def
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: .
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &1 !!perl/hash:RE_any 
                    a: 0
                    altname: method_def_03
                    dba: subscript signature
                    i: 0
                    min: 12345
                    name: method_def_03
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_03 0
                        dba: subscript signature
                        i: 0
                        min: 12347
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: (
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: subscript signature
                            extra: local $::GOAL = ')'
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "::"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 12345
                            name: signature
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: subscript signature
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: )
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: FAILGOAL
                                  nobind: 1
                                  rest: (')', 'subscript signature')
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_03 1
                        dba: subscript signature
                        i: 0
                        min: 12347
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "["
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: subscript signature
                            extra: local $::GOAL = ']'
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "::"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 12345
                            name: signature
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: subscript signature
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: "]"
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: FAILGOAL
                                  nobind: 1
                                  rest: (']', 'subscript signature')
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_03 2
                        dba: subscript signature
                        i: 0
                        min: 12347
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "{"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: subscript signature
                            extra: local $::GOAL = '}'
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "::"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 12345
                            name: signature
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: subscript signature
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: "}"
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: FAILGOAL
                                  nobind: 1
                                  rest: ('}', 'subscript signature')
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_03 3
                        dba: subscript signature
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: subscript signature
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: <
                              s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 12345
                            name: postcircumfix
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: subscript signature
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: method_def_01 3
              dba: subscript signature
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_noop 
                    a: 0
                    dba: subscript signature
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: method_def
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
method_def_01: *86
method_def_02: *58
method_def_03: *1
methodop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: method arguments
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &66 !!perl/hash:RE_any 
          a: 0
          altname: methodop_01
          dba: methodop
          i: 0
          min: 12345
          name: methodop_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: methodop_01 0
              dba: methodop
              i: 0
              min: 12345
              name: longname
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: methodop_01 1
              dba: methodop
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: &109 !!perl/hash:RE_any 
                        a: 0
                        altname: methodop_02
                        dba: methodop
                        i: 0
                        min: 1
                        name: methodop_02
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 0
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: $
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 1
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "@"
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: methodop
                  i: 0
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: methodop_01 2
              dba: methodop
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: methodop
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[ ' \" ]"
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: methodop
                  i: 0
                  min: 12345
                  name: quote
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: methodop
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<quote> ~~ /\\W/ or $.panic(\"Useless use of quotes\") "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: methodop
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &56 !!perl/hash:RE_any 
            a: 0
            altname: methodop_04
            dba: method arguments
            i: 0
            min: 12345
            name: methodop_04
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: methodop_04 0
                dba: method arguments
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_method_re 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE 
                        decl: []

                        min: 1
                        re: !!perl/hash:RE_meta 
                          a: 0
                          dba: method arguments
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                      s: 0
                  - !!perl/hash:RE_assertion 
                    assert: "!"
                    min: 0
                    re: !!perl/hash:RE_block 
                      a: 0
                      context: bool
                      dba: method arguments
                      i: 0
                      min: 0
                      nobind: 1
                      r: 1
                      s: 0
                      text: " $+inquote "
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 12345
                    name: arglist
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: methodop_04 1
                dba: method arguments
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_cclass 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 1
                      nobind: 1
                      r: 1
                      s: 0
                      text: "[.(]"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 12345
                    name: args
                    r: 1
                    rest: ''
                    s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
methodop_01: *66
methodop_02: *109
methodop_04: *56
modifier_expr: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: modifier_expr
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: modifier_expr
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
module_name__S_076normal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: module_name__S_076normal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: module_name__S_076normal
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: generic role
            i: 0
            min: 12347
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: generic role
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " ($+PKGDECL//'') eq 'role' "
              - !!perl/hash:RE_string 
                a: 0
                dba: generic role
                i: 0
                min: 1
                r: 1
                s: 0
                text: "["
              - !!perl/hash:RE_meta 
                a: 0
                dba: generic role
                extra: "local $::GOAL = ']' "
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: generic role
                i: 0
                min: 12345
                name: signature
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: generic role
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: generic role
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "]"
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (']' , 'generic role')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
module_name__S_077deprecated: !!perl/hash:RE 
  decl: []

  kind: token
  min: 8
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: module_name__S_077deprecated
    i: 0
    min: 8
    r: 1
    s: 0
    text: v6-alpha
morename: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: morename
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: morename
        i: 0
        min: 2
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: morename
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: morename
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &117 !!perl/hash:RE_any 
                      a: 0
                      altname: morename_02
                      dba: morename
                      i: 0
                      min: 1
                      name: morename_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: morename_02 0
                          dba: morename
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: (
                        - !!perl/hash:RE_method 
                          a: 0
                          alt: morename_02 1
                          dba: morename
                          i: 0
                          min: 12345
                          name: alpha
                          r: 1
                          rest: ''
                          s: 0
                  s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: &118 !!perl/hash:RE_any 
                  a: 0
                  altname: morename_03
                  dba: indirect name
                  i: 0
                  min: 12345
                  name: morename_03
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: morename_03 0
                      dba: morename
                      i: 0
                      min: 12345
                      name: identifier
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: morename_03 1
                      dba: indirect name
                      i: 0
                      min: 12347
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: indirect name
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: (
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: indirect name
                          extra: "local $::GOAL = ')' "
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "::"
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: indirect name
                          i: 0
                          min: 12345
                          name: EXPR
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: !!perl/hash:RE_first 
                            a: 0
                            dba: indirect name
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: indirect name
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: )
                              - !!perl/hash:RE_method 
                                min: 0
                                name: FAILGOAL
                                nobind: 1
                                rest: (')' , 'indirect name')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
morename_02: *117
morename_03: *118
multi_declarator__S_111multi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_111multi
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_111multi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: multi
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_111multi
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_111multi
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_111multi
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_111multi
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
multi_declarator__S_112proto: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_112proto
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_112proto
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: proto
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_112proto
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_112proto
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_112proto
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_112proto
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
multi_declarator__S_113only: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_113only
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_113only
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: only
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_113only
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_113only
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_113only
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_113only
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
multi_declarator__S_114null: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: multi_declarator__S_114null
    i: 0
    min: 12345
    name: declarator
    r: 1
    rest: ''
    s: 0
multisig: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multisig
    i: 0
    min: 12347
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: multisig
            i: 0
            min: 12347
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_string 
                  a: 0
                  dba: multisig
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ":"
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_string 
                a: 0
                dba: multisig
                i: 0
                min: 1
                r: 1
                s: 1
                text: (
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_meta 
                a: 0
                dba: multisig
                extra: local $::GOAL = ')'
                i: 0
                min: 0
                r: 1
                s: 1
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: multisig
                i: 0
                min: 12345
                name: signature
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: multisig
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: multisig
                      i: 0
                      min: 1
                      r: 1
                      s: 1
                      text: )
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (')', 'multisig')
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 12347
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: multisig
            i: 0
            min: 1
            r: 1
            s: 1
            text: "|"
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &69 !!perl/hash:RE_any 
      a: 0
      altname: name_01
      dba: name
      i: 0
      min: 12345
      name: name_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: name_01 0
          dba: name
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: name
              i: 0
              min: 12345
              name: identifier
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: name
                i: 0
                min: 12345
                name: morename
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_quantified_atom 
          alt: name_01 1
          atom: !!perl/hash:RE_method 
            a: 0
            dba: name
            i: 0
            min: 12345
            name: morename
            r: 1
            rest: ''
            s: 0
          min: 12345
          quant: 
            - +
            - ":"
            - ''
            - 1
name_01: *69
named_param: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: named_param
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = ')'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: named_param
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: named_param
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &25 !!perl/hash:RE_any 
          a: 0
          altname: named_param_01
          dba: named_param
          i: 0
          min: 12345
          name: named_param_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: named_param_01 0
              dba: named_param
              i: 0
              min: 37036
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: named_param
                    i: 0
                    min: 12345
                    name: identifier
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: name
                - !!perl/hash:RE_string 
                  a: 0
                  dba: named_param
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_method 
                  a: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &87 !!perl/hash:RE_any 
                    a: 0
                    altname: named_param_02
                    dba: named_param
                    i: 0
                    min: 12345
                    name: named_param_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: named_param_02 0
                        dba: named_param
                        i: 0
                        min: 12345
                        name: named_param
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: named_param_02 1
                        dba: named_param
                        i: 0
                        min: 24690
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: named_param
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: named_param
                            i: 0
                            min: 12345
                            name: ws
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: named_param
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: named_param
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unable to parse named parameter; couldn't find right parenthesis")
            - !!perl/hash:RE_method 
              a: 0
              alt: named_param_01 1
              dba: named_param
              i: 0
              min: 12345
              name: param_var
              r: 1
              rest: ''
              s: 0
named_param_01: *25
named_param_02: *87
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $text = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my @nibbles = ()
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $multiline = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $nibble
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: nibbler
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<firstpos> = self.pos; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: nibbler
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_method 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 12345
                      name: stopper
                      r: 1
                      rest: ''
                      s: 0
                  s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: starter
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: nibbler
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: stopper
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            my $n = $<nibbler>[*-1]<nibbles>;\n                            my @n = @$n;\n                            $text ~= $<starter>[*-1].text ~ shift(@n);\n                            $text = (@n ?? pop(@n) !! '') ~ $<stopper>[*-1].text;\n                            push @nibbles, @n;\n                        "
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: escape
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            push @nibbles, $text, $<escape>[*-1];\n                            $text = '';\n                        "
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            my $ch = substr($ORIG, $.pos-1, 1);\n                            $text ~= $ch;\n                            if $ch ~~ \"\\n\" {\n                                $multiline++;\n                            }\n                        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: nibbler
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        push @nibbles, $text; $<nibbles> = [@nibbles];\n        $<lastpos> = $.pos;\n        $<nibbler> :delete;\n        $<escape> :delete;\n        $COMPILING::LAST_NIBBLE = $;\n        $COMPILING::LAST_NIBBLE_MULTILINE = $ if $multiline;\n    "
nofun: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: nofun
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: &46 !!perl/hash:RE_any 
          a: 0
          altname: nofun_01
          dba: nofun
          i: 0
          min: 1
          name: nofun_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 0
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 1
              dba: nofun
              i: 0
              min: 2
              r: 1
              s: 0
              text: .(
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 2
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
      s: 0
nofun_01: *46
noun: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &64 !!perl/hash:RE_any 
      a: 0
      altname: noun_01
      dba: noun
      i: 0
      min: 12345
      name: noun_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 0
          dba: noun
          i: 0
          min: 12345
          name: fatarrow
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 1
          dba: noun
          i: 0
          min: 12345
          name: variable
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 2
          dba: noun
          i: 0
          min: 12345
          name: package_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 3
          dba: noun
          i: 0
          min: 12345
          name: scope_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: noun_01 4
          dba: noun
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: noun
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 4
                  re: &39 !!perl/hash:RE_any 
                    a: 0
                    altname: noun_02
                    dba: noun
                    i: 0
                    min: 4
                    name: noun_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: noun_02 0
                        dba: noun
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: multi
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: noun_02 1
                        dba: noun
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: proto
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: noun_02 2
                        dba: noun
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: only
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: noun
              i: 0
              min: 12345
              name: multi_declarator
              r: 1
              rest: ''
              s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 5
          dba: noun
          i: 0
          min: 12345
          name: routine_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 6
          dba: noun
          i: 0
          min: 12345
          name: regex_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 7
          dba: noun
          i: 0
          min: 12345
          name: type_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 8
          dba: noun
          i: 0
          min: 12345
          name: circumfix
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 9
          dba: noun
          i: 0
          min: 12345
          name: dotty
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 10
          dba: noun
          i: 0
          min: 12345
          name: value
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 11
          dba: noun
          i: 0
          min: 12345
          name: capterm
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 12
          dba: noun
          i: 0
          min: 12345
          name: sigterm
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 13
          dba: noun
          i: 0
          min: 12345
          name: term
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 14
          dba: noun
          i: 0
          min: 12345
          name: statement_prefix
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_quantified_atom 
          alt: noun_01 15
          atom: !!perl/hash:RE_bracket 
            decl: []

            min: 24690
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: noun
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: noun
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: noun
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
          min: 24690
          quant: 
            - +
            - ":"
            - ''
            - 1
noun_01: *64
noun_02: *39
nullterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: nullterm
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
nulltermish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &80 !!perl/hash:RE_any 
      a: 0
      altname: nulltermish_01
      dba: null term
      i: 0
      min: 0
      name: nulltermish_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_assertion 
          alt: nulltermish_01 0
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method 
            a: 0
            dba: null term
            i: 0
            min: 12345
            name: stdstopper
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_quantified_atom 
          alt: nulltermish_01 1
          atom: !!perl/hash:RE_method 
            a: 0
            dba: null term
            i: 0
            min: 12345
            name: termish
            r: 1
            rest: ''
            s: 0
          min: 0
          quant: 
            - "?"
            - ":"
            - ''
            - 0
nulltermish_01: *80
number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &4 !!perl/hash:RE_any 
      a: 0
      altname: number_01
      dba: number
      i: 0
      min: 12345
      name: number_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: number_01 0
          dba: number
          i: 0
          min: 12345
          name: dec_number
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: number_01 1
          dba: number
          i: 0
          min: 12345
          name: integer
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: number_01 2
          dba: number
          i: 0
          min: 12345
          name: rad_number
          r: 1
          rest: ''
          s: 0
number_01: *4
octint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: octint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: octint
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ 0..7 ]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: octint
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: octint
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_cclass 
                  a: 0
                  dba: octint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[ 0..7 ]"
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
old_rx_mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: old_rx_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_qw 
              a: 0
              dba: old_rx_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: < i g s m x c e >
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: old_rx_mods
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $0.text {\n            $_ ~~ /i/ and $.worryobs('/i',':i');\n            $_ ~~ /g/ and $.worryobs('/g',':g');\n            $_ ~~ /s/ and $.worryobs('/s','^^ and $$ anchors');\n            $_ ~~ /m/ and $.worryobs('/m','. or \\N');\n            $_ ~~ /x/ and $.worryobs('/x','normal default whitespace');\n            $_ ~~ /c/ and $.worryobs('/c',':c or :p');\n            $_ ~~ /e/ and $.worryobs('/e','interpolated {...} or s{} = ... form');\n            $.obs('suffix regex modifiers','prefix adverbs');\n        }\n    "
old_tr_mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: old_tr_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_qw 
              a: 0
              dba: old_tr_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: < c d s ] >
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: old_tr_mods
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $0.text {\n            $_ ~~ /c/ and $.worryobs('/c',':c');\n            $_ ~~ /d/ and $.worryobs('/g',':d');\n            $_ ~~ /s/ and $.worryobs('/s',':s');\n            $.obs('suffix transliteration modifiers','prefix adverbs');\n        }\n    "
opener: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass 
    a: 0
    dba: opener
    i: 0
    min: 1
    r: 1
    s: 0
    text: "[\\x{0028} \\x{003C} \\x{005B}\n    \\x{007B} \\x{00AB} \\x{0F3A}\n    \\x{0F3C} \\x{169B} \\x{2039}\n    \\x{2045} \\x{207D} \\x{208D}\n    \\x{2208} \\x{2209} \\x{220A}\n    \\x{2215} \\x{223C} \\x{2243}\n    \\x{2252} \\x{2254} \\x{2264}\n    \\x{2266} \\x{2268} \\x{226A}\n    \\x{226E} \\x{2270} \\x{2272}\n    \\x{2274} \\x{2276} \\x{2278}\n    \\x{227A} \\x{227C} \\x{227E}\n    \\x{2280} \\x{2282} \\x{2284}\n    \\x{2286} \\x{2288} \\x{228A}\n    \\x{228F} \\x{2291} \\x{2298}\n    \\x{22A2} \\x{22A6} \\x{22A8}\n    \\x{22A9} \\x{22AB} \\x{22B0}\n    \\x{22B2} \\x{22B4} \\x{22B6}\n    \\x{22C9} \\x{22CB} \\x{22D0}\n    \\x{22D6} \\x{22D8} \\x{22DA}\n    \\x{22DC} \\x{22DE} \\x{22E0}\n    \\x{22E2} \\x{22E4} \\x{22E6}\n    \\x{22E8} \\x{22EA} \\x{22EC}\n    \\x{22F0} \\x{22F2} \\x{22F3}\n    \\x{22F4} \\x{22F6} \\x{22F7}\n    \\x{2308} \\x{230A} \\x{2329}\n    \\x{23B4} \\x{2768} \\x{276A}\n    \\x{276C} \\x{276E} \\x{2770}\n    \\x{2772} \\x{2774} \\x{27C3}\n    \\x{27C5} \\x{27D5} \\x{27DD}\n    \\x{27E2} \\x{27E4} \\x{27E6}\n    \\x{27E8} \\x{27EA} \\x{2983}\n    \\x{2985} \\x{2987} \\x{2989}\n    \\x{298B} \\x{298D} \\x{298F}\n    \\x{2991} \\x{2993} \\x{2995}\n    \\x{2997} \\x{29C0} \\x{29C4}\n    \\x{29CF} \\x{29D1} \\x{29D4}\n    \\x{29D8} \\x{29DA} \\x{29F8}\n    \\x{29FC} \\x{2A2B} \\x{2A2D}\n    \\x{2A34} \\x{2A3C} \\x{2A64}\n    \\x{2A79} \\x{2A7D} \\x{2A7F}\n    \\x{2A81} \\x{2A83} \\x{2A8B}\n    \\x{2A91} \\x{2A93} \\x{2A95}\n    \\x{2A97} \\x{2A99} \\x{2A9B}\n    \\x{2AA1} \\x{2AA6} \\x{2AA8}\n    \\x{2AAA} \\x{2AAC} \\x{2AAF}\n    \\x{2AB3} \\x{2ABB} \\x{2ABD}\n    \\x{2ABF} \\x{2AC1} \\x{2AC3}\n    \\x{2AC5} \\x{2ACD} \\x{2ACF}\n    \\x{2AD1} \\x{2AD3} \\x{2AD5}\n    \\x{2AEC} \\x{2AF7} \\x{2AF9}\n    \\x{2E02} \\x{2E04} \\x{2E09}\n    \\x{2E0C} \\x{2E1C} \\x{3008}\n    \\x{300A} \\x{300C} \\x{300E}\n    \\x{3010} \\x{3014} \\x{3016}\n    \\x{3018} \\x{301A} \\x{301D}\n    \\x{FD3E} \\x{FE17} \\x{FE35}\n    \\x{FE37} \\x{FE39} \\x{FE3B}\n    \\x{FE3D} \\x{FE3F} \\x{FE41}\n    \\x{FE43} \\x{FE47} \\x{FE59}\n    \\x{FE5B} \\x{FE5D} \\x{FF08}\n    \\x{FF1C} \\x{FF3B} \\x{FF5B}\n    \\x{FF5F} \\x{FF62}]"
package_declarator__S_102class: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_102class
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'class'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_102class
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_102class
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: class
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_102class
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_103grammar: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_103grammar
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'grammar'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_103grammar
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_103grammar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: grammar
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_103grammar
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_104module: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_104module
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'module'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_104module
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_104module
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: module
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_104module
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_105package: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_105package
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'package'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_105package
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_105package
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: package
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_105package
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_106role: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_106role
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'role'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_106role
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_106role
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: role
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_106role
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_107knowhow: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_107knowhow
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'knowhow'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_107knowhow
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_107knowhow
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: knowhow
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_107knowhow
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_108require: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_108require
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_108require
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: require
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_108require
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: package_declarator__S_108require
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: package_declarator__S_108require
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: package_declarator__S_108require
                  i: 0
                  min: 12345
                  name: module_name
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: package_declarator__S_108require
                    i: 0
                    min: 12345
                    name: EXPR
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_method 
              a: 0
              dba: package_declarator__S_108require
              i: 0
              min: 12345
              name: EXPR
              r: 1
              rest: ''
              s: 0
package_declarator__S_109trusts: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_109trusts
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_109trusts
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: trusts
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_109trusts
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_109trusts
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 0
package_declarator__S_110does: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_110does
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_110does
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: does
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_110does
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_110does
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 0
package_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $longname
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: package_def
            i: 0
            min: 12345
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                a: 0
                dba: package_def
                i: 0
                min: 12345
                name: module_name
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: package_def
                i: 0
                min: 0
                r: 1
                s: 1
                text: "\n            $longname = $<module_name>[0]<longname>;\n            $.add_type($longname.text);\n        "
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: package_def
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: package_def
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: package_def
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: package_def
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: "{"
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: package_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "\n           # figure out the actual full package name (nested in outer package)\n            my $pkg = $+PKG // \"GLOBAL\";\n            push @PKGS, $pkg;\n            if $longname {\n                my $shortname = $longname.<name>.text;\n                $+PKG = $pkg ~ '::' ~ $shortname;\n            }\n            else {\n                $+PKG = $pkg ~ '::_anon_';\n            }\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: package_def
                  i: 0
                  min: 12345
                  name: block
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: package_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "\n            $+PKG = pop(@PKGS);\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'package_def_block'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: package_def
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: package_def
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 1
                    text: " $+begin_compunit "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: package_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: package_def
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: ;
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: package_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "\n            $longname orelse $.panic(\"Compilation unit cannot be anonymous\");\n            my $shortname = $longname.<name>.text;\n            $+PKG = $shortname;\n            $+begin_compunit = 0;\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'package_def_semi'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: package_def
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Unable to parse " ~ $+PKGDECL ~ " definition")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
param_sep: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: param_sep
    i: 0
    min: 1
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &50 !!perl/hash:RE_any 
          a: 0
          altname: param_sep_01
          dba: param_sep
          i: 0
          min: 1
          name: param_sep_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 0
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ","
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 1
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ":"
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 2
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ;
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 3
              dba: param_sep
              i: 0
              min: 2
              r: 1
              s: 1
              text: ;;
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
param_sep_01: *50
param_var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &108 !!perl/hash:RE_any 
      a: 0
      altname: param_var_01
      dba: param_var
      i: 0
      min: 12345
      name: param_var_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 0
          dba: param_var
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: param_var
              i: 0
              min: 1
              r: 1
              s: 0
              text: "["
            - !!perl/hash:RE_meta 
              a: 0
              dba: param_var
              extra: "local $::GOAL = ']' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: param_var
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: param_var
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (']' , 'param_var')
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 1
          dba: param_var
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: param_var
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_meta 
              a: 0
              dba: param_var
              extra: "local $::GOAL = ')' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: param_var
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: param_var
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (')' , 'param_var')
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 2
          dba: param_var
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: param_var
                i: 0
                min: 12345
                name: twigil
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: param_var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: param_var
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $<sigil>.text eq '&' "
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12345
                            name: ident
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: param_var
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: ''
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12345
                            name: sublongname
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: param_var
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: identifier
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: param_var
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $<sigil>.text eq '@' || $<sigil>.text eq '%' "
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12345
                            name: identifier
                            r: 1
                            rest: ''
                            s: 0
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_cclass 
                                a: 0
                                dba: param_var
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "[ \\< \\( \\[ \\{ ]"
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: param_var
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      name: identifier
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_cclass 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "[/!]"
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
param_var_01: *108
parameter: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $kind
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $quant = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $q
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parameter
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: parameter
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_bracket 
              decl: []

              min: 12345
              re: &54 !!perl/hash:RE_any 
                a: 0
                altname: parameter_02
                dba: parameter
                i: 0
                min: 12345
                name: parameter_02
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: parameter_02 0
                    dba: parameter
                    i: 0
                    min: 12345
                    name: type_constraint
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: parameter_02 1
                    dba: parameter
                    i: 0
                    min: 12345
                    name: param_var
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: parameter_02 2
                    dba: parameter
                    i: 0
                    min: 12346
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "*"
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: parameter
                        i: 0
                        min: 12345
                        name: param_var
                        r: 1
                        rest: ''
                        s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: parameter_02 3
                    dba: parameter
                    i: 0
                    min: 12346
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "|"
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: parameter
                        i: 0
                        min: 12345
                        name: param_var
                        r: 1
                        rest: ''
                        s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: parameter_02 4
                    dba: parameter
                    i: 0
                    min: 12346
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: parameter
                        i: 0
                        min: 12345
                        name: param_var
                        r: 1
                        rest: ''
                        s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: parameter_02 5
                    dba: parameter
                    i: 0
                    min: 12345
                    name: named_param
                    r: 1
                    rest: ''
                    s: 0
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: type_constraint
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &85 !!perl/hash:RE_any 
          a: 0
          altname: parameter_03
          dba: parameter
          i: 0
          min: 0
          name: parameter_03
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_03 0
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "*"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '*'; $kind = '*'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_03 1
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "|"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '|'; $kind = '*'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_03 2
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '\\\\'; $kind = '!'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_03 3
              dba: parameter
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &102 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_04
                    dba: parameter
                    i: 0
                    min: 12345
                    name: parameter_04
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_04 0
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '!'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_04 1
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: named_param
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '*'; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: &8 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_05
                    dba: parameter
                    i: 0
                    min: 0
                    name: parameter_05
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_05 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "?"
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '?'; $kind = '?' "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_05 1
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "!"
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '!'; $kind = '!' "
                      - !!perl/hash:RE_assertion 
                        alt: parameter_05 2
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_noop 
                          a: 0
                          dba: parameter
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_03 4
              dba: parameter
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_noop 
                    a: 0
                    dba: parameter
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = ''; $kind = '!'; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: post_constraint
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: parameter
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: parameter
                i: 0
                min: 12345
                name: default_value
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: parameter
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            given $quant {\n              when '!' { $.panic(\"Can't put a default on a required parameter\") }\n              when '*' { $.panic(\"Can't put a default on a slurpy parameter\") }\n              when '|' { $.panic(\"Can't put a default on an slurpy capture parameter\") }\n              when '\\\\' { $.panic(\"Can't put a default on a capture parameter\") }\n            }\n            $kind = '?';\n        "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        $<quant> = $quant;\n        $<kind> = $kind;\n    "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $kind {\n            when '!' {\n                given $+zone {\n                    when 'posopt' {\n$.panic(\"Can't put required parameter after optional parameters\");\n                    }\n                    when 'var' {\n$.panic(\"Can't put required parameter after variadic parameters\");\n                    }\n                }\n            }\n            when '?' {\n                given $+zone {\n                    when 'posreq' { $+zone = 'posopt' }\n                    when 'var' {\n$.panic(\"Can't put optional positional parameter after variadic parameters\");\n                    }\n                }\n            }\n            when '*' {\n                $+zone = 'var';\n            }\n        }\n    "
parameter_02: *54
parameter_03: *85
parameter_04: *102
parameter_05: *8
pblock: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parameterized block
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: parameterized block
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: parameterized block
                i: 0
                min: 12345
                name: lambda
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: parameterized block
                i: 0
                min: 12345
                name: signature
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: parameterized block
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 0
pod_comment: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: pod_comment
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: pod_comment
        i: 0
        min: 0
        r: 1
        s: 0
        text: "^^"
      - !!perl/hash:RE_string 
        a: 0
        dba: pod_comment
        i: 0
        min: 1
        r: 1
        s: 0
        text: =
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: pod_comment
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &22 !!perl/hash:RE_any 
          a: 0
          altname: pod_comment_01
          dba: pod_comment
          i: 0
          min: 0
          name: pod_comment_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 0
              dba: pod_comment
              i: 0
              min: 12352
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: begin
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_method 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 7
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_double 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: \n=
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 3
                            r: 1
                            s: 0
                            text: end
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_var 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            var: $<identifier>
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \N
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'pod_comment_tagged'
                            max: 0
                            min: 0
                            name: _REDUCE
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'pod_comment_end'
                            max: 0
                            min: 0
                            name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 1
              dba: pod_comment
              i: 0
              min: 5
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: begin
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $$
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "#"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unrecognized token after =begin")
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 6
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_double 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: \n=
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 3
                            r: 1
                            s: 0
                            text: end
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \N
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("=begin without =end")
                - !!perl/hash:RE_method_internal 
                  args: $S, 'pod_comment_anon'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 2
              dba: pod_comment
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 0
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: pod_comment
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 5
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: pod_comment
                                i: 0
                                min: 5
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: .*?
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 0
                                    r: 1
                                    s: 0
                                    text: "^^"
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 4
                                    r: 1
                                    s: 0
                                    text: =cut
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 0
                                    r: 1
                                    s: 0
                                    text: 
                            s: 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Obsolete pod format, please use =begin/=end instead")
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \N
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'pod_comment_misc'
                  max: 0
                  min: 0
                  name: _REDUCE
pod_comment_01: *22
post_constraint: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: post_constraint
    i: 0
    min: 5
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 5
        re: &76 !!perl/hash:RE_any 
          a: 0
          altname: post_constraint_01
          dba: post_constraint
          i: 0
          min: 5
          name: post_constraint_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 0
              dba: post_constraint
              i: 0
              min: 12347
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: "["
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: post_constraint
                  extra: local $::GOAL = ']'
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: post_constraint
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: post_constraint
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']', 'post_constraint')
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 1
              dba: post_constraint
              i: 0
              min: 12347
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: (
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: post_constraint
                  extra: local $::GOAL = ')'
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: post_constraint
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: post_constraint
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')', 'post_constraint')
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 2
              dba: post_constraint
              i: 0
              min: 5
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: where
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %chaining)
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
post_constraint_01: *76
postcircumfix__S_090Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: argument list
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: argument list
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: argument list
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: argument list
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: argument list
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: argument list
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'argument list')
postcircumfix__S_091Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: subscript
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_meta 
        a: 0
        dba: subscript
        extra: "local $::GOAL = ']' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: subscript
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: subscript
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'subscript')
postcircumfix__S_092Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: subscript
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: subscript
        extra: "local $::GOAL = '}' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: subscript
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: subscript
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: ('}' , 'subscript')
postcircumfix__S_093Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_093Lt_Gt
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_093Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_093Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_093Lt_Gt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right angle quote")
postcircumfix__S_094LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_094LtLt_GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_094LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_094LtLt_GtGt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_094LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right double-angle quote")
postcircumfix__S_095Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_095Fre_Nch
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_095Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_095Fre_Nch
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_095Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right double-angle quote")
postfix__S_273i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix__S_273i
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: postfix__S_273i
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: i
      - !!perl/hash:RE_meta 
        a: 0
        dba: postfix__S_273i
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
postfix__S_275MinusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix__S_275MinusGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postfix__S_275MinusGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: ->
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('-> to call a method', '.')
postfix__S_276PlusPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: postfix__S_276PlusPlus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ++
postfix__S_277MinusMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: postfix__S_277MinusMinus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: --
postfix_prefix_meta_operator__S_083Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &14 !!perl/hash:RE_any 
    a: 0
    altname: postfix_prefix_meta_operator__S_083Nch_00
    dba: postfix_prefix_meta_operator__S_083Nch
    i: 0
    min: 2
    name: postfix_prefix_meta_operator__S_083Nch_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        alt: postfix_prefix_meta_operator__S_083Nch_00 0
        dba: postfix_prefix_meta_operator__S_083Nch
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 
      - !!perl/hash:RE_string 
        a: 0
        alt: postfix_prefix_meta_operator__S_083Nch_00 1
        dba: postfix_prefix_meta_operator__S_083Nch
        i: 0
        min: 2
        r: 1
        s: 0
        text: ">>"
postfix_prefix_meta_operator__S_083Nch_00: *14
postop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: &9 !!perl/hash:RE_any 
    a: 0
    altname: postop_00
    dba: postop
    i: 0
    min: 12345
    name: postop_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        alt: postop_00 0
        dba: postop
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: postop
            i: 0
            min: 12345
            name: postfix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: postop
            i: 0
            min: 0
            r: 1
            s: 0
            text: " $<O> := $<postfix><O>; $<sym> := $<postfix><sym>; "
      - !!perl/hash:RE_sequence 
        a: 0
        alt: postop_00 1
        dba: postop
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: postop
            i: 0
            min: 12345
            name: postcircumfix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: postop
            i: 0
            min: 0
            r: 1
            s: 0
            text: " $<O> := $<postcircumfix><O>; $<sym> := $<postcircumfix><sym>; "
postop_00: *9
prefix__S_278PlusPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_278PlusPlus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ++
prefix__S_279MinusMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_279MinusMinus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: --
prefix__S_281Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_281Bang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!"
prefix__S_282Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_282Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
prefix__S_283Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_283Minus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "-"
prefix__S_284Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_284Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
prefix__S_285Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_285Question
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "?"
prefix__S_286Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_286Equal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =
prefix__S_287TildeCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_287TildeCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~^
prefix__S_288PlusCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_288PlusCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +^
prefix__S_289QuestionCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_289QuestionCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?^
prefix__S_290Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_290Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
prefix__S_291Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_291Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
prefix__S_321sleep: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_321sleep
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_321sleep
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: sleep
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_321sleep
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_321sleep
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_321sleep
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_322abs: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_322abs
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_322abs
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: abs
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_322abs
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_322abs
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_322abs
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_323int: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_323int
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_323int
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: int
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_323int
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_323int
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_323int
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_324let: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_324let
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_324let
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: let
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_324let
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_324let
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_324let
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_325temp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_325temp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_325temp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: temp
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_325temp
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_325temp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_325temp
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_376true: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_376true
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_376true
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 'true'
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_376true
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
prefix__S_377not: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_377not
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_377not
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: not
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_377not
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
prefix_circumfix_meta_operator__S_081reduce: !!perl/hash:RE 
  decl: []

  kind: regex
  min: 12347
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix_circumfix_meta_operator__S_081reduce
    i: 0
    min: 12347
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix_circumfix_meta_operator__S_081reduce
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 0
          re: !!perl/hash:RE 
            decl: []

            min: 3
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: prefix_circumfix_meta_operator__S_081reduce
              i: 0
              min: 3
              r: 0
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_081reduce
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: prefix_circumfix_meta_operator__S_081reduce
                    i: 0
                    min: 1
                    r: 0
                    s: 0
                    text: \S
                  min: 1
                  quant: 
                    - +
                    - "!"
                    - ''
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_081reduce
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: "]"
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 12347
          nobind: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: prefix_circumfix_meta_operator__S_081reduce
            i: 0
            min: 12347
            r: 0
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: prefix_circumfix_meta_operator__S_081reduce
                i: 0
                min: 1
                r: 0
                s: 0
                text: "["
              - !!perl/hash:RE_bracket 
                decl: []

                min: 12346
                re: &115 !!perl/hash:RE_any 
                  a: 0
                  altname: prefix_circumfix_meta_operator__S_081reduce_03
                  dba: prefix_circumfix_meta_operator__S_081reduce
                  i: 0
                  min: 12346
                  name: prefix_circumfix_meta_operator__S_081reduce_03
                  r: 0
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: prefix_circumfix_meta_operator__S_081reduce_03 0
                      dba: prefix_circumfix_meta_operator__S_081reduce
                      i: 0
                      min: 12346
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 12345
                            name: infixish
                            nobind: 1
                            r: 0
                            rest: ''
                            s: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 12345
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &82 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_081reduce_04
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_081reduce_04
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_081reduce_04 0
                                dba: prefix_circumfix_meta_operator__S_081reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_081reduce_04 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_081reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: prefix_circumfix_meta_operator__S_081reduce_03 1
                      dba: prefix_circumfix_meta_operator__S_081reduce
                      i: 0
                      min: 12347
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: \
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 12345
                            name: infixish
                            nobind: 1
                            r: 0
                            rest: ''
                            s: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 12345
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &83 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_081reduce_05
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_081reduce_05
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_081reduce_05 0
                                dba: prefix_circumfix_meta_operator__S_081reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_081reduce_05 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_081reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
        dba: prefix_circumfix_meta_operator__S_081reduce
        i: 0
        min: 12347
        r: 0
        s: 0
        var: s
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix_circumfix_meta_operator__S_081reduce
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 0
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: prefix_circumfix_meta_operator__S_081reduce
              i: 0
              min: 1
              r: 0
              s: 0
              text: "[ \\s ( ]"
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: prefix_circumfix_meta_operator__S_081reduce
        i: 0
        min: 0
        r: 0
        s: 0
        text: " $<O> = $<s><op><O>; $<sym> = $<s>.text; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: prefix_circumfix_meta_operator__S_081reduce
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: prefix_circumfix_meta_operator__S_081reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $<O><assoc> eq 'non' "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't reduce a non-associative operator")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: prefix_circumfix_meta_operator__S_081reduce
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: prefix_circumfix_meta_operator__S_081reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $<O><prec> eq %conditional<prec> "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't reduce a conditional operator")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: prefix_circumfix_meta_operator__S_081reduce
        i: 0
        min: 0
        r: 0
        s: 0
        text: " $<O><assoc> = 'unary'; $<O><uassoc> = 'left'; "
prefix_circumfix_meta_operator__S_081reduce_03: *115
prefix_circumfix_meta_operator__S_081reduce_04: *82
prefix_circumfix_meta_operator__S_081reduce_05: *83
prefix_postfix_meta_operator__S_082Fre: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &84 !!perl/hash:RE_any 
    a: 0
    altname: prefix_postfix_meta_operator__S_082Fre_00
    dba: prefix_postfix_meta_operator__S_082Fre
    i: 0
    min: 2
    name: prefix_postfix_meta_operator__S_082Fre_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        alt: prefix_postfix_meta_operator__S_082Fre_00 0
        dba: prefix_postfix_meta_operator__S_082Fre
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 
      - !!perl/hash:RE_string 
        a: 0
        alt: prefix_postfix_meta_operator__S_082Fre_00 1
        dba: prefix_postfix_meta_operator__S_082Fre
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
prefix_postfix_meta_operator__S_082Fre_00: *84
privop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: privop
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: privop
        i: 0
        min: 1
        r: 1
        s: 0
        text: "!"
      - !!perl/hash:RE_method 
        a: 0
        dba: privop
        i: 0
        min: 12345
        name: methodop
        r: 1
        rest: ''
        s: 0
quasiquibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quasiquibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quasiquibble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quasiquibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: quasiquibble
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: quasiquibble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: quasiquibble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start eq '{' "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: quasiquibble
                    i: 0
                    lang: ($lang)
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_decl 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        max: 0
                        min: 0
                        noquant: 1
                        r: 1
                        s: 0
                        text: "my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); "
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        min: 12345
                        name: block
                        r: 1
                        rest: ''
                        s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: quasiquibble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_var 
                  a: 0
                  dba: quasiquibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $start
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: quasiquibble
                    i: 0
                    lang: ($lang)
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_decl 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        max: 0
                        min: 0
                        noquant: 1
                        r: 1
                        s: 0
                        text: "my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); "
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        min: 12345
                        name: statementlist
                        r: 1
                        rest: ''
                        s: 0
                - !!perl/hash:RE_var 
                  a: 0
                  dba: quasiquibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
quibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($lang)
      - !!perl/hash:RE_var 
        a: 0
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        if $lang<_herelang> {\n            push @herestub_queue,\n                STD::Herestub.new(\n                    delim => $<nibble><nibbles>[0],\n                    orignode => $,\n                    lang => $lang<_herelang>,\n                );\n        }\n    "
quote__S_180Single_Single: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_180Single_Single
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_double 
        a: 0
        dba: quote__S_180Single_Single
        i: 0
        min: 1
        r: 1
        s: 0
        text: "'"
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).unbalanced("'"))
      - !!perl/hash:RE_double 
        a: 0
        dba: quote__S_180Single_Single
        i: 0
        min: 1
        r: 1
        s: 0
        text: "'"
quote__S_181Double_Double: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_181Double_Double
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_181Double_Double
        i: 0
        min: 1
        r: 1
        s: 0
        text: "\""
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).unbalanced('"'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_181Double_Double
        i: 0
        min: 1
        r: 1
        s: 0
        text: "\""
quote__S_182Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_182Fre_Nch
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_182Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_182Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
quote__S_183LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_183LtLt_GtGt
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_183LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_183LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: ">>"
quote__S_184Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_184Lt_Gt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_184Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_184Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: ">"
quote__S_185Slash_Slash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_185Slash_Slash
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_185Slash_Slash
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ( $.cursor_fresh( ::Regex ).unbalanced("/") )
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: quote__S_185Slash_Slash
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: quote__S_185Slash_Slash
              i: 0
              min: 1
              r: 1
              s: 0
              text: /
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find final '/'")
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_185Slash_Slash
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quote__S_186qq: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_186qq
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_186qq
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_186qq
        i: 0
        min: 2
        r: 1
        s: 0
        text: qq
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &68 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_186qq_01
          dba: quote__S_186qq
          i: 0
          min: 12345
          name: quote__S_186qq_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_186qq_01 0
              dba: quote__S_186qq
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_186qq
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_186qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_186qq
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_186qq
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_186qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.text "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_186qq
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_186qq_01 1
              dba: quote__S_186qq
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_186qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_186qq
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_186qq
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_186qq
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq))
quote__S_186qq_01: *68
quote__S_187q: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_187q
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_187q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_187q
        i: 0
        min: 1
        r: 1
        s: 0
        text: q
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &41 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_187q_01
          dba: quote__S_187q
          i: 0
          min: 12345
          name: quote__S_187q_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_187q_01 0
              dba: quote__S_187q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_187q
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_187q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_187q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_187q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_187q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.text "
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_187q_01 1
              dba: quote__S_187q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_187q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_187q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_187q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_187q
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:q))
quote__S_187q_01: *41
quote__S_188Q: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_188Q
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_188Q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_188Q
        i: 0
        min: 1
        r: 1
        s: 0
        text: Q
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &123 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_188Q_01
          dba: quote__S_188Q
          i: 0
          min: 12345
          name: quote__S_188Q_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_188Q_01 0
              dba: quote__S_188Q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_188Q
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_188Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_188Q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_188Q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_188Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.text "
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_188Q_01 1
              dba: quote__S_188Q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_188Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_188Q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_188Q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_188Q
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ))
quote__S_188Q_01: *123
quote__S_199rx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_199rx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_199rx
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rx
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_199rx
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_199rx
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_199rx
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( ::Regex ) )
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_199rx
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_200m: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_200m
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_200m
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: m
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_200m
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_200m
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_200m
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( ::Regex ) )
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_200m
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_201mm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_201mm
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_201mm
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: mm
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_201mm
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_201mm
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_201mm
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( ::Regex ).tweak(:s))
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_201mm
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_202s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_202s
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_202s
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: s
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_202s
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_202s
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_202s
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: sibble
          nobind: 1
          rest: ( $.cursor_fresh( ::Regex ), $.cursor_fresh( ::STD::Q ).tweak(:qq))
        dba: quote__S_202s
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_202s
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_203ss: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_203ss
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_203ss
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ss
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_203ss
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_203ss
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_203ss
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: sibble
          nobind: 1
          rest: ( $.cursor_fresh( ::Regex ).tweak(:s), $.cursor_fresh( ::STD::Q ).tweak(:qq))
        dba: quote__S_203ss
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_203ss
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_204tr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_204tr
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_204tr
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: tr
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_204tr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_204tr
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_204tr
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: tribble
          nobind: 1
          rest: ( $.cursor_fresh( ::STD::Q ).tweak(:q))
        dba: quote__S_204tr
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_204tr
          i: 0
          min: 12345
          name: old_tr_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_205quasi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_205quasi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_205quasi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: quasi
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_205quasi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_205quasi
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_205quasi
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quasiquibble
        rest: ($.cursor_fresh( ::STD::Quasi ))
quote_mod__S_189w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_189w
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
quote_mod__S_190ww: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_190ww
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ww
quote_mod__S_191x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_191x
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: x
quote_mod__S_192to: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_192to
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: to
quote_mod__S_193s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_193s
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
quote_mod__S_194a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_194a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
quote_mod__S_195h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_195h
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
quote_mod__S_196f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_196f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
quote_mod__S_197c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_197c
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: c
quote_mod__S_198b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_198b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
quotepair: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quotepair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $key
    - !!perl/hash:RE_decl 
      a: 0
      dba: quotepair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $value
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: colon pair (restricted)
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quotepair
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &33 !!perl/hash:RE_any 
          a: 0
          altname: quotepair_01
          dba: colon pair (restricted)
          i: 0
          min: 2
          name: quotepair_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 0
              dba: colon pair (restricted)
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.text; $value = 0; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair_false'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 1
              dba: colon pair (restricted)
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.text; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: colon pair (restricted)
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_string 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: .
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: colon pair (restricted)
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                              s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: colon pair (restricted)
                            i: 0
                            min: 12345
                            name: postcircumfix
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: colon pair (restricted)
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $value = $<postcircumfix>; "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: colon pair (restricted)
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $value = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair_value'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 2
              dba: colon pair (restricted)
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: 'n'
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_cclass 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[a..z]"
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: id
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<id>.text; $value = $<n>.text; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair_nth'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: colon pair (restricted)
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<k> = $key; $<v> = $value; "
quotepair_01: *33
rad_number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: number in radix notation
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: rad_number
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: rad_number
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        dba: rad_number
        i: 0
        min: 1
        r: 1
        s: 0
        var: radix
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: rad_number
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: rad_number
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 3
        re: !!perl/hash:RE_first 
          a: 0
          dba: number in radix notation
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: <
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_cclass 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "[ 0..9 a..z A..Z ]"
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: number in radix notation
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: number in radix notation
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_cclass 
                                    a: 0
                                    dba: number in radix notation
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "[ 0..9 a..z A..Z ]"
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: intpart
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_bracket 
                      decl: []

                      min: 2
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: number in radix notation
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[ 0..9 a..z A..Z ]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: number in radix notation
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: number in radix notation
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: number in radix notation
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[ 0..9 a..z A..Z ]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: number in radix notation
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: fracpart
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24693
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 24693
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: number in radix notation
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "*"
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 12345
                            name: radint
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: number in radix notation
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: base
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: number in radix notation
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: "**"
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 12345
                            name: radint
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: number in radix notation
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: exp
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "["
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
radint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &90 !!perl/hash:RE_any 
      a: 0
      altname: radint_01
      dba: radint
      i: 0
      min: 12345
      name: radint_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: radint_01 0
          dba: radint
          i: 0
          min: 12345
          name: integer
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: radint_01 1
          dba: radint
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: radint
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: radint
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: radint
              i: 0
              min: 12345
              name: rad_number
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: radint
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: "\n                        defined $<rad_number><intpart>\n                        and\n                        not defined $<rad_number><fracpart>\n                    "
radint_01: *90
regex_block: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $lang = ::Regex
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_block
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: regex_block
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: regex_block
                i: 0
                min: 12345
                name: quotepair
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: regex_block
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: regex_block
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            my $kv = $<quotepair>[*-1];\n            $lang = $lang.tweak($kv.<k>, $kv.<v>)\n                or self.panic(\"Unrecognized adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: regex_block
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ( $.cursor_fresh($lang).unbalanced('}') )
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: regex_block
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: regex_block
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right brace")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &21 !!perl/hash:RE_any 
          a: 0
          altname: regex_block_04
          dba: regex_block
          i: 0
          min: 0
          name: regex_block_04
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 0
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 0
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: regex_block
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: regex_block
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: regex_block
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_endstmt_simple_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 1
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: regex_block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[,:]"
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_normal_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 2
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_endstmt_complex'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 3
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endargs> = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_endargs'
                  max: 0
                  min: 0
                  name: _REDUCE
regex_block_04: *21
regex_declarator__S_119regex: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_119regex
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_119regex
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: regex
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_119regex
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_declarator__S_120token: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_120token
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_120token
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: token
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_120token
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_declarator__S_121rule: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_121rule
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_121rule
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rule
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_121rule
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_def
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &23 !!perl/hash:RE_any 
            a: 0
            altname: regex_def_01
            dba: regex_def
            i: 0
            min: 1
            name: regex_def_01
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: regex_def_01 0
                dba: regex_def
                i: 0
                min: 1
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: regex_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: "&"
                  - !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: regex_def
                      i: 0
                      min: 12345
                      name: deflongname
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: regex_def_01 1
                dba: regex_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: regex_def
                    i: 0
                    min: 12345
                    name: deflongname
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &77 !!perl/hash:RE_any 
            a: 0
            altname: regex_def_02
            dba: regex_def
            i: 0
            min: 12345
            name: regex_def_02
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: regex_def_02 0
                dba: regex_def
                i: 0
                min: 12347
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12347
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: regex_def
                      i: 0
                      min: 12347
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: regex_def
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: ":"
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: regex_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: regex_def
                          i: 0
                          min: 12345
                          name: signature
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: regex_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: regex_def_02 1
                dba: regex_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: regex_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: regex_def
        i: 0
        min: 0
        r: 1
        s: 1
        text: " $IN_DECL = 0; "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_def
        i: 0
        min: 12345
        name: regex_block
        r: 1
        rest: ''
        s: 1
regex_def_01: *23
regex_def_02: *77
routine_declarator__S_115sub: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_115sub
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_115sub
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: sub
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_115sub
        i: 0
        min: 12345
        name: routine_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_116method: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_116method
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_116method
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: method
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_116method
        i: 0
        min: 12345
        name: method_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_117submethod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_117submethod
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_117submethod
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: submethod
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_117submethod
        i: 0
        min: 12345
        name: method_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_118macro: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_118macro
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_118macro
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: macro
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_118macro
        i: 0
        min: 12345
        name: macro_def
        r: 1
        rest: ''
        s: 0
routine_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: routine_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_def
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &79 !!perl/hash:RE_any 
            a: 0
            altname: routine_def_01
            dba: routine_def
            i: 0
            min: 1
            name: routine_def_01
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: routine_def_01 0
                dba: routine_def
                i: 0
                min: 1
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: routine_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: "&"
                  - !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: routine_def
                      i: 0
                      min: 12345
                      name: deflongname
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: routine_def_01 1
                dba: routine_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: routine_def
                    i: 0
                    min: 12345
                    name: deflongname
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &106 !!perl/hash:RE_any 
            a: 0
            altname: routine_def_02
            dba: routine_def
            i: 0
            min: 12345
            name: routine_def_02
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: routine_def_02 0
                dba: routine_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: routine_def
                    i: 0
                    min: 12345
                    name: multisig
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: routine_def_02 1
                dba: routine_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: routine_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: routine_def
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 1
          text: "\n        $ = $+PARSER.bless($);\n        $IN_DECL = 0;\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_def
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
routine_def_01: *79
routine_def_02: *106
scope_declarator__S_097my: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_097my
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_097my
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: my
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_097my
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_097my
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_098our: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_098our
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_098our
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: our
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_098our
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_098our
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_099state: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_099state
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_099state
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: state
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_099state
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_099state
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_100constant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_100constant
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_100constant
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: constant
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_100constant
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_100constant
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_101has: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_101has
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_101has
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: has
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_101has
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_101has
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scoped: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scoped declarator
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &52 !!perl/hash:RE_any 
          a: 0
          altname: scoped_01
          dba: scoped declarator
          i: 0
          min: 12345
          name: scoped_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: scoped_01 0
              dba: scoped declarator
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  name: declarator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: scoped_01 1
              dba: scoped declarator
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  name: regex_declarator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: scoped_01 2
              dba: scoped declarator
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  name: package_declarator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: scoped_01 3
              dba: scoped declarator
              i: 0
              min: 24690
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: scoped declarator
                    i: 0
                    min: 12345
                    name: fulltypename
                    r: 1
                    rest: ''
                    s: 1
                  min: 12345
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  name: multi_declarator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: scoped_01 4
              dba: scoped declarator
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  name: multi_declarator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
scoped_01: *52
semiarglist: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: semiarglist
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: semiarglist
          i: 0
          min: 12345
          name: arglist
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: semiarglist
            i: 0
            min: 1
            r: 1
            s: 0
            text: ;
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: semiarglist
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
semilist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: semilist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 0
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: semicolon list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &44 !!perl/hash:RE_any 
          a: 0
          altname: semilist_01
          dba: semicolon list
          i: 0
          min: 0
          name: semilist_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: semilist_01 0
              dba: semicolon list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: semicolon list
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: semicolon list
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: semicolon list
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "[\\)\\]\\}]"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: semilist_01 1
              dba: semicolon list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: semicolon list
                      i: 0
                      min: 24690
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: semicolon list
                          i: 0
                          min: 12345
                          name: statement
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: semicolon list
                          i: 0
                          min: 12345
                          name: eat_terminator
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
semilist_01: *44
sibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: sibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: nibble
          nobind: 1
          rest: ($lang)
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: left
      - !!perl/hash:RE_var 
        a: 0
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: sibble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: sibble
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: sibble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start ne $stop "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: sibble
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: sibble
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Missing '='")
                - !!perl/hash:RE_method 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: EXPR
                    nobind: 1
                    rest: (item %item_assignment)
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
            - !!perl/hash:RE_sequence 
              a: 0
              dba: sibble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $lang = $lang2.unbalanced($stop); "
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: nibble
                    nobind: 1
                    rest: ($lang)
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
                - !!perl/hash:RE_var 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
sigil__S_166Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_166Dollar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $
sigil__S_167AtAt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_167AtAt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "@@"
sigil__S_168At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_168At
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "@"
sigil__S_169Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_169Percent
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "%"
sigil__S_170Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_170Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
signature: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $zone is context<rw> = 'posreq'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: signature
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &60 !!perl/hash:RE_any 
            a: 0
            altname: signature_01
            dba: signature
            i: 0
            min: 0
            name: signature_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                alt: signature_01 0
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: signature
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &6 !!perl/hash:RE_any 
                      a: 0
                      altname: signature_02
                      dba: signature
                      i: 0
                      min: 1
                      name: signature_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 0
                          dba: signature
                          i: 0
                          min: 3
                          r: 1
                          s: 0
                          text: -->
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 1
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 2
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 3
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "{"
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: signature_02 4
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: signature
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: ":"
                            - !!perl/hash:RE_assertion 
                              assert: "!"
                              min: 0
                              re: !!perl/hash:RE_method_re 
                                a: 0
                                dba: signature
                                i: 0
                                min: 0
                                name: before
                                nobind: 1
                                r: 1
                                re: !!perl/hash:RE 
                                  decl: []

                                  min: 1
                                  re: !!perl/hash:RE_string 
                                    a: 0
                                    dba: signature
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: ":"
                                s: 0
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                alt: signature_01 1
                dba: signature
                i: 0
                min: 12345
                name: parameter
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_method 
            a: 0
            dba: signature
            i: 0
            min: 12345
            name: param_sep
            r: 1
            rest: ''
            s: 0
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24693
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: signature
            i: 0
            min: 24693
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: signature
                i: 0
                min: 3
                r: 1
                s: 0
                text: -->
              - !!perl/hash:RE_method 
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: fulltypename
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: signature
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $IN_DECL = 0; $+SIGIL = '@' "
signature_01: *60
signature_02: *6
sigterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sigterm
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: sigterm
        i: 0
        min: 2
        r: 1
        s: 0
        text: :(
      - !!perl/hash:RE_meta 
        a: 0
        dba: sigterm
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: sigterm
        i: 0
        min: 12345
        name: signature
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: sigterm
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: sigterm
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'sigterm')
spacey: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: spacey
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: &63 !!perl/hash:RE_any 
          a: 0
          altname: spacey_01
          dba: spacey
          i: 0
          min: 1
          name: spacey_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_meta 
              a: 0
              alt: spacey_01 0
              dba: spacey
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string 
              a: 0
              alt: spacey_01 1
              dba: spacey
              i: 0
              min: 1
              r: 1
              s: 0
              text: "#"
      s: 0
spacey_01: *63
special_variable__S_122Dollar_a2_: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: special_variable__S_122Dollar_a2_
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $
special_variable__S_123DollarBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_123DollarBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_123DollarBang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $!
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_123DollarBang
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: special_variable__S_123DollarBang
              i: 0
              min: 1
              r: 1
              s: 0
              text: \w
          s: 0
special_variable__S_124DollarBangCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_124DollarBangCur_Ly
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 5
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_124DollarBangCur_Ly
            i: 0
            min: 5
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_124DollarBangCur_Ly
                i: 0
                min: 3
                r: 1
                s: 0
                text: $!{
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_124DollarBangCur_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_124DollarBangCur_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_124DollarBangCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 5
        var: 1
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ($0.text ~ " variable", 'smart match against $!')
special_variable__S_125DollarSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_125DollarSlash
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_125DollarSlash
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $/
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_125DollarSlash
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: special_variable__S_125DollarSlash
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: special_variable__S_125DollarSlash
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: special_variable__S_125DollarSlash
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: special_variable__S_125DollarSlash
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: =
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_cclass 
                            a: 0
                            dba: special_variable__S_125DollarSlash
                            i: 0
                            min: 1
                            nobind: 1
                            r: 1
                            s: 0
                            text: "[=]"
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: "('$/ variable as input record separator',\n             \"filehandle's :irs attribute\")"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
special_variable__S_126DollarTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_126DollarTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_126DollarTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $~
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_126DollarTilde
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_126DollarTilde
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &73 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_126DollarTilde_01
              dba: special_variable__S_126DollarTilde
              i: 0
              min: 1
              name: special_variable__S_126DollarTilde_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_126DollarTilde_01 0
                  dba: special_variable__S_126DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_126DollarTilde_01 1
                  dba: special_variable__S_126DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_126DollarTilde_01 2
                  dba: special_variable__S_126DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_126DollarTilde_01 3
                  dba: special_variable__S_126DollarTilde
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$~ variable', 'Form module')
special_variable__S_126DollarTilde_01: *73
special_variable__S_127DollarGrave: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_127DollarGrave
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_127DollarGrave
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $`
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_127DollarGrave
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_127DollarGrave
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &89 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_127DollarGrave_01
              dba: special_variable__S_127DollarGrave
              i: 0
              min: 1
              name: special_variable__S_127DollarGrave_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_127DollarGrave_01 0
                  dba: special_variable__S_127DollarGrave
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_127DollarGrave_01 1
                  dba: special_variable__S_127DollarGrave
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_127DollarGrave_01 2
                  dba: special_variable__S_127DollarGrave
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$` variable', 'explicit pattern before <(')
special_variable__S_127DollarGrave_01: *89
special_variable__S_128DollarAt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_128DollarAt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_128DollarAt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $@
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_128DollarAt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$@ variable as eval error', '$!')
special_variable__S_129DollarSharp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_129DollarSharp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_129DollarSharp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $#
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_129DollarSharp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: special_variable__S_129DollarSharp
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: special_variable__S_129DollarSharp
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: special_variable__S_129DollarSharp
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  min: 1
                  var: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: obs
                  nobind: 1
                  rest: ("\$#" ~ $0.text ~ " variable", "\@\{" ~ $0.text ~ "}.end")
            - !!perl/hash:RE_method 
              min: 0
              name: obs
              nobind: 1
              rest: ('$# variable', '.fmt')
special_variable__S_130DollarDollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_130DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_130DollarDollar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $$
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: special_variable__S_130DollarDollar
          i: 0
          min: 12345
          name: alpha
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_130DollarDollar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_130DollarDollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &65 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_130DollarDollar_01
              dba: special_variable__S_130DollarDollar
              i: 0
              min: 1
              name: special_variable__S_130DollarDollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_130DollarDollar_01 0
                  dba: special_variable__S_130DollarDollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_130DollarDollar_01 1
                  dba: special_variable__S_130DollarDollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_130DollarDollar_01 2
                  dba: special_variable__S_130DollarDollar
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$$ variable', '$*PID')
special_variable__S_130DollarDollar_01: *65
special_variable__S_131DollarPercent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_131DollarPercent
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_131DollarPercent
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $%
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_131DollarPercent
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$% variable', 'Form module')
special_variable__S_132DollarCaretX: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_132DollarCaretX
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_132DollarCaretX
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_132DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        text: "^"
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_cclass 
            a: 0
            dba: special_variable__S_132DollarCaretX
            i: 0
            min: 1
            r: 1
            s: 0
            text: "[A..Z]"
        dba: special_variable__S_132DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        var: letter
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_132DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
      - !!perl/hash:RE_method 
        min: 0
        name: obscaret
        nobind: 1
        rest: ($<sigil>.text ~ '^' ~ $<letter>.text, $<sigil>, $<letter>.text)
special_variable__S_133DollarCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_133DollarCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_133DollarCaret
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $^
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_133DollarCaret
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_133DollarCaret
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &40 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_133DollarCaret_01
              dba: special_variable__S_133DollarCaret
              i: 0
              min: 1
              name: special_variable__S_133DollarCaret_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_133DollarCaret_01 0
                  dba: special_variable__S_133DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_133DollarCaret_01 1
                  dba: special_variable__S_133DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_133DollarCaret_01 2
                  dba: special_variable__S_133DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_133DollarCaret_01 3
                  dba: special_variable__S_133DollarCaret
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$^ variable', 'Form module')
special_variable__S_133DollarCaret_01: *40
special_variable__S_134DollarAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_134DollarAmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_134DollarAmp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $&
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_134DollarAmp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_134DollarAmp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &107 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_134DollarAmp_01
              dba: special_variable__S_134DollarAmp
              i: 0
              min: 1
              name: special_variable__S_134DollarAmp_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_134DollarAmp_01 0
                  dba: special_variable__S_134DollarAmp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_134DollarAmp_01 1
                  dba: special_variable__S_134DollarAmp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_134DollarAmp_01 2
                  dba: special_variable__S_134DollarAmp
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$& variable', '$/ or $()')
special_variable__S_134DollarAmp_01: *107
special_variable__S_135DollarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_135DollarStar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_135DollarStar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $*
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_135DollarStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_135DollarStar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &15 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_135DollarStar_01
              dba: special_variable__S_135DollarStar
              i: 0
              min: 1
              name: special_variable__S_135DollarStar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_135DollarStar_01 0
                  dba: special_variable__S_135DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_135DollarStar_01 1
                  dba: special_variable__S_135DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_135DollarStar_01 2
                  dba: special_variable__S_135DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_135DollarStar_01 3
                  dba: special_variable__S_135DollarStar
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$* variable', '^^ and $$')
special_variable__S_135DollarStar_01: *15
special_variable__S_136DollarThesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_136DollarThesis
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_136DollarThesis
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $)
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_136DollarThesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_136DollarThesis
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &19 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_136DollarThesis_01
              dba: special_variable__S_136DollarThesis
              i: 0
              min: 1
              name: special_variable__S_136DollarThesis_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_136DollarThesis_01 0
                  dba: special_variable__S_136DollarThesis
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_136DollarThesis_01 1
                  dba: special_variable__S_136DollarThesis
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_136DollarThesis_01 2
                  dba: special_variable__S_136DollarThesis
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$) variable', '$*EGID')
special_variable__S_136DollarThesis_01: *19
special_variable__S_137DollarMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_137DollarMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_137DollarMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $-
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_137DollarMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_137DollarMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &67 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_137DollarMinus_01
              dba: special_variable__S_137DollarMinus
              i: 0
              min: 1
              name: special_variable__S_137DollarMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_137DollarMinus_01 0
                  dba: special_variable__S_137DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_137DollarMinus_01 1
                  dba: special_variable__S_137DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_137DollarMinus_01 2
                  dba: special_variable__S_137DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_137DollarMinus_01 3
                  dba: special_variable__S_137DollarMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$- variable', 'Form module')
special_variable__S_137DollarMinus_01: *67
special_variable__S_138DollarEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_138DollarEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_138DollarEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $=
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_138DollarEqual
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_138DollarEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &94 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_138DollarEqual_01
              dba: special_variable__S_138DollarEqual
              i: 0
              min: 1
              name: special_variable__S_138DollarEqual_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_138DollarEqual_01 0
                  dba: special_variable__S_138DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_138DollarEqual_01 1
                  dba: special_variable__S_138DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_138DollarEqual_01 2
                  dba: special_variable__S_138DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_138DollarEqual_01 3
                  dba: special_variable__S_138DollarEqual
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$= variable', 'Form module')
special_variable__S_138DollarEqual_01: *94
special_variable__S_139AtPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_139AtPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_139AtPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "@+"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_139AtPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_139AtPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &24 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_139AtPlus_01
              dba: special_variable__S_139AtPlus
              i: 0
              min: 1
              name: special_variable__S_139AtPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_139AtPlus_01 0
                  dba: special_variable__S_139AtPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_139AtPlus_01 1
                  dba: special_variable__S_139AtPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_139AtPlus_01 2
                  dba: special_variable__S_139AtPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_139AtPlus_01: *24
special_variable__S_140PercentPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_140PercentPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_140PercentPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%+"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_140PercentPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_140PercentPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &37 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_140PercentPlus_01
              dba: special_variable__S_140PercentPlus
              i: 0
              min: 1
              name: special_variable__S_140PercentPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_140PercentPlus_01 0
                  dba: special_variable__S_140PercentPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_140PercentPlus_01 1
                  dba: special_variable__S_140PercentPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_140PercentPlus_01 2
                  dba: special_variable__S_140PercentPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%+ variable', '.to method')
special_variable__S_140PercentPlus_01: *37
special_variable__S_141DollarPlusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_141DollarPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_141DollarPlusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: $+[
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_142AtPlusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_142AtPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_142AtPlusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@+["
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_143AtPlusCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_143AtPlusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_143AtPlusCur_Ly
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@+{"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%+ variable', '.to method')
special_variable__S_144AtMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_144AtMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_144AtMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "@-"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_144AtMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_144AtMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &51 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_144AtMinus_01
              dba: special_variable__S_144AtMinus
              i: 0
              min: 1
              name: special_variable__S_144AtMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_144AtMinus_01 0
                  dba: special_variable__S_144AtMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_144AtMinus_01 1
                  dba: special_variable__S_144AtMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_144AtMinus_01 2
                  dba: special_variable__S_144AtMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_144AtMinus_01: *51
special_variable__S_145PercentMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_145PercentMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_145PercentMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%-"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_145PercentMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_145PercentMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &18 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_145PercentMinus_01
              dba: special_variable__S_145PercentMinus
              i: 0
              min: 1
              name: special_variable__S_145PercentMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_145PercentMinus_01 0
                  dba: special_variable__S_145PercentMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_145PercentMinus_01 1
                  dba: special_variable__S_145PercentMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_145PercentMinus_01 2
                  dba: special_variable__S_145PercentMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%- variable', '.from method')
special_variable__S_145PercentMinus_01: *18
special_variable__S_146DollarMinusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_146DollarMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_146DollarMinusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: $-[
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_147AtMinusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_147AtMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_147AtMinusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@-["
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_148PercentMinusCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_148PercentMinusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_148PercentMinusCur_Ly
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@-{"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%- variable', '.from method')
special_variable__S_149DollarPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_149DollarPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_149DollarPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $+
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_149DollarPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_149DollarPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &100 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_149DollarPlus_01
              dba: special_variable__S_149DollarPlus
              i: 0
              min: 1
              name: special_variable__S_149DollarPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_149DollarPlus_01 0
                  dba: special_variable__S_149DollarPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_149DollarPlus_01 1
                  dba: special_variable__S_149DollarPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_149DollarPlus_01 2
                  dba: special_variable__S_149DollarPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$+ variable', 'Form module')
special_variable__S_149DollarPlus_01: *100
special_variable__S_150DollarCurCaret_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_150DollarCurCaret_Ly
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 12349
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_150DollarCurCaret_Ly
            i: 0
            min: 12349
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: special_variable__S_150DollarCurCaret_Ly
                i: 0
                min: 12345
                name: sigil
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_150DollarCurCaret_Ly
                i: 0
                min: 2
                r: 1
                s: 0
                text: "{^"
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_150DollarCurCaret_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_150DollarCurCaret_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_150DollarCurCaret_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 12349
        var: 1
      - !!perl/hash:RE_method 
        min: 0
        name: obscaret
        nobind: 1
        rest: ($0.text, $<sigil>, $0.{0}.text)
special_variable__S_151ColonColonCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_151ColonColonCur_Ly
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_151ColonColonCur_Ly
        i: 0
        min: 2
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_151ColonColonCur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: special_variable__S_151ColonColonCur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
special_variable__S_152DollarCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_152DollarCur_Ly
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 4
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_152DollarCur_Ly
            i: 0
            min: 4
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_cclass 
                a: 0
                dba: special_variable__S_152DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "[$@%]"
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_152DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "{"
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_152DollarCur_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_152DollarCur_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_152DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 4
        var: 1
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ("" ~ $0.text ~ " variable", "\{" ~ $<sigil>.text ~ "}(" ~ $0.{0}.text ~ ")")
special_variable__S_153DollarBra: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_153DollarBra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_153DollarBra
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $[
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_153DollarBra
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_153DollarBra
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &59 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_153DollarBra_01
              dba: special_variable__S_153DollarBra
              i: 0
              min: 1
              name: special_variable__S_153DollarBra_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_153DollarBra_01 0
                  dba: special_variable__S_153DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_153DollarBra_01 1
                  dba: special_variable__S_153DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_153DollarBra_01 2
                  dba: special_variable__S_153DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_153DollarBra_01 3
                  dba: special_variable__S_153DollarBra
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$[ variable', 'user-defined array indices')
special_variable__S_153DollarBra_01: *59
special_variable__S_154DollarKet: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_154DollarKet
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_154DollarKet
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $]
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_154DollarKet
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_154DollarKet
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &29 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_154DollarKet_01
              dba: special_variable__S_154DollarKet
              i: 0
              min: 1
              name: special_variable__S_154DollarKet_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_154DollarKet_01 0
                  dba: special_variable__S_154DollarKet
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_154DollarKet_01 1
                  dba: special_variable__S_154DollarKet
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_154DollarKet_01 2
                  dba: special_variable__S_154DollarKet
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$] variable', '$*PERL_VERSION')
special_variable__S_154DollarKet_01: *29
special_variable__S_155DollarBack: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_155DollarBack
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_155DollarBack
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $\
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_155DollarBack
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_155DollarBack
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &75 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_155DollarBack_01
              dba: special_variable__S_155DollarBack
              i: 0
              min: 1
              name: special_variable__S_155DollarBack_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_155DollarBack_01 0
                  dba: special_variable__S_155DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_155DollarBack_01 1
                  dba: special_variable__S_155DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_155DollarBack_01 2
                  dba: special_variable__S_155DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_155DollarBack_01 3
                  dba: special_variable__S_155DollarBack
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$\\ variable', "the filehandle's :ors attribute")
special_variable__S_155DollarBack_01: *75
special_variable__S_156DollarVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_156DollarVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_156DollarVert
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $|
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_156DollarVert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_156DollarVert
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &122 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_156DollarVert_01
              dba: special_variable__S_156DollarVert
              i: 0
              min: 1
              name: special_variable__S_156DollarVert_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_156DollarVert_01 0
                  dba: special_variable__S_156DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_156DollarVert_01 1
                  dba: special_variable__S_156DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_156DollarVert_01 2
                  dba: special_variable__S_156DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_156DollarVert_01 3
                  dba: special_variable__S_156DollarVert
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$| variable', 'Form module')
special_variable__S_156DollarVert_01: *122
special_variable__S_157DollarColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_157DollarColon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_157DollarColon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "$:"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_157DollarColon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: special_variable__S_157DollarColon
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[\\x20\\t\\n\\],=)}]"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: "('$: variable', 'Form module')"
special_variable__S_158DollarSemi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_158DollarSemi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_158DollarSemi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $;
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_158DollarSemi
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_158DollarSemi
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &93 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_158DollarSemi_01
              dba: special_variable__S_158DollarSemi
              i: 0
              min: 1
              name: special_variable__S_158DollarSemi_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_158DollarSemi_01 0
                  dba: special_variable__S_158DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_158DollarSemi_01 1
                  dba: special_variable__S_158DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_158DollarSemi_01 2
                  dba: special_variable__S_158DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_158DollarSemi_01 3
                  dba: special_variable__S_158DollarSemi
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$; variable', 'real multidimensional hashes')
special_variable__S_158DollarSemi_01: *93
special_variable__S_159DollarSingle: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_159DollarSingle
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_159DollarSingle
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $'
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_159DollarSingle
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_159DollarSingle
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &91 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_159DollarSingle_01
              dba: special_variable__S_159DollarSingle
              i: 0
              min: 1
              name: special_variable__S_159DollarSingle_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_159DollarSingle_01 0
                  dba: special_variable__S_159DollarSingle
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_159DollarSingle_01 1
                  dba: special_variable__S_159DollarSingle
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_159DollarSingle_01 2
                  dba: special_variable__S_159DollarSingle
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")
special_variable__S_159DollarSingle_01: *91
special_variable__S_160DollarDouble: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_160DollarDouble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_160DollarDouble
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_160DollarDouble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_160DollarDouble
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &103 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_160DollarDouble_01
              dba: special_variable__S_160DollarDouble
              i: 0
              min: 1
              name: special_variable__S_160DollarDouble_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_160DollarDouble_01 0
                  dba: special_variable__S_160DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_160DollarDouble_01 1
                  dba: special_variable__S_160DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_160DollarDouble_01 2
                  dba: special_variable__S_160DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_160DollarDouble_01 3
                  dba: special_variable__S_160DollarDouble
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$" variable', '.join() method')
special_variable__S_160DollarDouble_01: *103
special_variable__S_161DollarComma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_161DollarComma
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_161DollarComma
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $,
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_161DollarComma
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_161DollarComma
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &72 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_161DollarComma_01
              dba: special_variable__S_161DollarComma
              i: 0
              min: 1
              name: special_variable__S_161DollarComma_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_161DollarComma_01 0
                  dba: special_variable__S_161DollarComma
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_161DollarComma_01 1
                  dba: special_variable__S_161DollarComma
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_161DollarComma_01 2
                  dba: special_variable__S_161DollarComma
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$, variable', ".join() method")
special_variable__S_161DollarComma_01: *72
special_variable__S_162DollarLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_162DollarLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_162DollarLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "['$<']"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_162DollarLt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_162DollarLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: special_variable__S_162DollarLt
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_162DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_162DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \w
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_162DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: special_variable__S_162DollarLt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$< variable', '$*UID')
special_variable__S_163DollarGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_163DollarGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_163DollarGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $>
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_163DollarGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_163DollarGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &5 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_163DollarGt_01
              dba: special_variable__S_163DollarGt
              i: 0
              min: 1
              name: special_variable__S_163DollarGt_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_163DollarGt_01 0
                  dba: special_variable__S_163DollarGt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_163DollarGt_01 1
                  dba: special_variable__S_163DollarGt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_163DollarGt_01 2
                  dba: special_variable__S_163DollarGt
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ("$() variable", '$*EUID')
special_variable__S_163DollarGt_01: *5
special_variable__S_164DollarDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_164DollarDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_164DollarDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $.
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_164DollarDot
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_164DollarDot
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &7 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_164DollarDot_01
              dba: special_variable__S_164DollarDot
              i: 0
              min: 1
              name: special_variable__S_164DollarDot_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_164DollarDot_01 0
                  dba: special_variable__S_164DollarDot
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_164DollarDot_01 1
                  dba: special_variable__S_164DollarDot
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_164DollarDot_01 2
                  dba: special_variable__S_164DollarDot
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$. variable', "filehandle's .line method")
special_variable__S_164DollarDot_01: *7
special_variable__S_165DollarQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_165DollarQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_165DollarQuestion
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $?
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_165DollarQuestion
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_165DollarQuestion
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &43 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_165DollarQuestion_01
              dba: special_variable__S_165DollarQuestion
              i: 0
              min: 1
              name: special_variable__S_165DollarQuestion_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_165DollarQuestion_01 0
                  dba: special_variable__S_165DollarQuestion
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_165DollarQuestion_01 1
                  dba: special_variable__S_165DollarQuestion
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_165DollarQuestion_01 2
                  dba: special_variable__S_165DollarQuestion
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$? variable as child error', '$!')
special_variable__S_165DollarQuestion_01: *43
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
statement: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $endargs is context = -1
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: statement
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[\\)\\]\\}]"
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: statement
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: " $ = $+PARSER.bless($); "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &38 !!perl/hash:RE_any 
          a: 0
          altname: statement_02
          dba: statement end
          i: 0
          min: 0
          name: statement_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 0
              dba: statement
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: label
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: statement
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_label'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 1
              dba: statement
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: statement_control
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 2
              dba: statement end
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: EXPR
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_expr'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: statement modifier
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: statement end
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " (@+MEMOS[$.pos]<endstmt> // 0) == 2 "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement modifier
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: statement modifier
                            i: 0
                            min: 12345
                            name: ws
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 12345
                              re: &121 !!perl/hash:RE_any 
                                a: 0
                                altname: statement_05
                                dba: statement modifier loop
                                i: 0
                                min: 12345
                                name: statement_05
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: statement_05 0
                                    dba: statement modifier
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: statement modifier
                                        i: 0
                                        min: 12345
                                        name: statement_mod_loop
                                        r: 1
                                        rest: ''
                                        s: 0
                                      - !!perl/hash:RE_method_internal 
                                        args: $S, 'statement_mod_loop'
                                        max: 0
                                        min: 0
                                        name: _REDUCE
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: statement_05 1
                                    dba: statement modifier loop
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: statement modifier
                                        i: 0
                                        min: 12345
                                        name: statement_mod_cond
                                        r: 1
                                        rest: ''
                                        s: 0
                                      - !!perl/hash:RE_method_internal 
                                        args: $S, 'statement_mod_cond'
                                        max: 0
                                        min: 0
                                        name: _REDUCE
                                      - !!perl/hash:RE_bracket 
                                        decl: []

                                        min: 0
                                        re: !!perl/hash:RE_first 
                                          a: 0
                                          dba: statement modifier loop
                                          i: 0
                                          min: 0
                                          r: 1
                                          s: 0
                                          zyg: 
                                            - !!perl/hash:RE_assertion 
                                              assert: "?"
                                              min: 0
                                              re: !!perl/hash:RE_block 
                                                a: 0
                                                context: bool
                                                dba: statement modifier loop
                                                i: 0
                                                min: 0
                                                nobind: 1
                                                r: 1
                                                s: 0
                                                text: " (@+MEMOS[$.pos]<endstmt> // 0) == 2 "
                                            - !!perl/hash:RE_sequence 
                                              a: 0
                                              dba: statement modifier loop
                                              i: 0
                                              min: 12345
                                              r: 1
                                              s: 0
                                              zyg: 
                                                - !!perl/hash:RE_method 
                                                  a: 0
                                                  dba: statement modifier loop
                                                  i: 0
                                                  min: 12345
                                                  name: ws
                                                  nobind: 1
                                                  r: 1
                                                  rest: ''
                                                  s: 0
                                                - !!perl/hash:RE_quantified_atom 
                                                  atom: !!perl/hash:RE_method 
                                                    a: 0
                                                    dba: statement modifier loop
                                                    i: 0
                                                    min: 12345
                                                    name: statement_mod_loop
                                                    r: 1
                                                    rest: ''
                                                    s: 0
                                                  min: 0
                                                  quant: 
                                                    - "?"
                                                    - ":"
                                                    - ''
                                                    - 0
                                                - !!perl/hash:RE_method_internal 
                                                  args: $S, 'statement_mod_condloop'
                                                  max: 0
                                                  min: 0
                                                  name: _REDUCE
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_modexpr'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 3
              dba: statement end
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement end
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: statement end
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: ;
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_null'
                  max: 0
                  min: 0
                  name: _REDUCE
statement_02: *38
statement_05: *121
statement_control__S_034use: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_034use
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_034use
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: use
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_034use
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &27 !!perl/hash:RE_any 
          a: 0
          altname: statement_control__S_034use_01
          dba: statement_control__S_034use
          i: 0
          min: 12345
          name: statement_control__S_034use_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_034use_01 0
              dba: statement_control__S_034use
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_034use
                  i: 0
                  min: 12345
                  name: version
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_034use_01 1
              dba: statement_control__S_034use
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_034use
                  i: 0
                  min: 12345
                  name: module_name
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: statement_control__S_034use
                    i: 0
                    min: 12345
                    name: arglist
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: statement_control__S_034use
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "\n            my $longname = $<module_name><longname>;\n            $.add_type($longname.text);\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_034use_01: *27
statement_control__S_035no: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_035no
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_035no
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 'no'
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_035no
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_035no
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: statement_control__S_035no
          i: 0
          min: 12345
          name: arglist
          r: 1
          rest: ''
          s: 1
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_036if: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_036if
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_036if
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: if
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_036if
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_036if
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12350
          re: !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_paren 
              decl: []

              min: 12350
              nobind: 1
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: statement_control__S_036if
                i: 0
                min: 12350
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: statement_control__S_036if
                    i: 0
                    min: 5
                    r: 1
                    s: 1
                    text: elsif
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_036if
                      i: 0
                      min: 12345
                      name: spacey
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: statement_control__S_036if
                    i: 0
                    min: 12345
                    name: xblock
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'statement_control__S_036if_elsif'
                    max: 0
                    min: 0
                    name: _REDUCE
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
            dba: statement_control__S_036if
            i: 0
            min: 12350
            r: 1
            s: 1
            var: elsif
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12349
          re: !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_paren 
              decl: []

              min: 12349
              nobind: 1
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: statement_control__S_036if
                i: 0
                min: 12349
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: statement_control__S_036if
                    i: 0
                    min: 4
                    r: 1
                    s: 1
                    text: else
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_036if
                      i: 0
                      min: 12345
                      name: spacey
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: statement_control__S_036if
                    i: 0
                    min: 12345
                    name: pblock
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'statement_control__S_036if_else'
                    max: 0
                    min: 0
                    name: _REDUCE
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
            dba: statement_control__S_036if
            i: 0
            min: 12349
            r: 1
            s: 1
            var: else
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_037unless: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_037unless
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037unless
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: unless
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037unless
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037unless
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: statement_control__S_037unless
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_037unless
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement_control__S_037unless
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 4
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: statement_control__S_037unless
                        i: 0
                        min: 4
                        r: 1
                        s: 1
                        text: else
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_037unless
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("unless does not take \"else\" in Perl 6; please rewrite using \"if\"")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_038while: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_038while
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038while
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: while
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038while
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_038while
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_038while
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 5
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_038while
                      i: 0
                      min: 5
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_038while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 3
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: statement_control__S_038while
                              i: 0
                              min: 3
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_string 
                                    a: 0
                                    dba: statement_control__S_038while
                                    i: 0
                                    min: 2
                                    r: 1
                                    s: 1
                                    text: my
                                  min: 0
                                  quant: 
                                    - "?"
                                    - ":"
                                    - ''
                                    - 0
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: ws
                                  nobind: 1
                                  noquant: 1
                                  rest: ''
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: statement_control__S_038while
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: $
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: statement_control__S_038while
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 1
                                    text: \w
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: ws
                                  nobind: 1
                                  noquant: 1
                                  rest: ''
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: statement_control__S_038while
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: =
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_038while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: <
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: statement_control__S_038while
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: $
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: statement_control__S_038while
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \w
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_038while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ">"
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_038while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: )
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("This appears to be Perl 5 code")
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038while
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_039until: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_039until
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039until
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: until
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039until
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039until
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_040repeat: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37040
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_040repeat
    i: 0
    min: 37040
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040repeat
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: repeat
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040repeat
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12350
        re: &125 !!perl/hash:RE_any 
          a: 0
          altname: statement_control__S_040repeat_01
          dba: statement_control__S_040repeat
          i: 0
          min: 12350
          name: statement_control__S_040repeat_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_040repeat_01 0
              dba: statement_control__S_040repeat
              i: 0
              min: 12350
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 5
                    re: &12 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_control__S_040repeat_02
                      dba: statement_control__S_040repeat
                      i: 0
                      min: 5
                      name: statement_control__S_040repeat_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_040repeat_02 0
                          dba: statement_control__S_040repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: while
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_040repeat_02 1
                          dba: statement_control__S_040repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: until
                  min: 5
                  var: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_040repeat
                  i: 0
                  min: 12345
                  name: xblock
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_040repeat_01 1
              dba: statement_control__S_040repeat
              i: 0
              min: 24695
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_040repeat
                  i: 0
                  min: 12345
                  name: block
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_040repeat_block_wu'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 5
                    re: &13 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_control__S_040repeat_03
                      dba: statement_control__S_040repeat
                      i: 0
                      min: 5
                      name: statement_control__S_040repeat_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_040repeat_03 0
                          dba: statement_control__S_040repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: while
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_040repeat_03 1
                          dba: statement_control__S_040repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: until
                  min: 5
                  var: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_040repeat
                  i: 0
                  min: 12345
                  name: EXPR
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_040repeat_expr_wu'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_040repeat_01: *125
statement_control__S_040repeat_02: *12
statement_control__S_040repeat_03: *13
statement_control__S_041loop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_041loop
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041loop
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: loop
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041loop
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_paren 
            decl: []

            min: 4
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_041loop
              i: 0
              min: 4
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: (
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_041loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ;
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_041loop_e1'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_041loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e2
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ;
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_041loop_e2'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_041loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e3
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_041loop_e3'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: )
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_041loop_eee'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          min: 0
          nobind: 1
          quant: 
            - "?"
            - ":"
            - ''
            - 0
        dba: statement_control__S_041loop
        i: 0
        min: 0
        r: 1
        s: 1
        var: eee
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041loop
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_control__S_041loop_block'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_042for: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_042for
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042for
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: for
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042for
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_042for
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_042for
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 3
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_042for
                      i: 0
                      min: 3
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: statement_control__S_042for
                            i: 0
                            min: 2
                            r: 1
                            s: 1
                            text: my
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_042for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: $
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: statement_control__S_042for
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \w
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_042for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("This appears to be Perl 5 code")
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_042for
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_042for
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 4
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_042for
                      i: 0
                      min: 4
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_042for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_042for
                            i: 0
                            min: 12345
                            name: EXPR
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_042for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ;
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_042for
                            i: 0
                            min: 12345
                            name: EXPR
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_042for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ;
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_042for
                            i: 0
                            min: 12345
                            name: EXPR
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_042for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: )
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('C-style "for (;;)" loop', '"loop (;;)"')
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042for
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_043given: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_043given
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043given
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: given
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043given
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043given
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_044when: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_044when
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044when
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: when
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044when
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044when
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_045default: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_045default
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045default
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: default
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045default
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045default
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_046BEGIN: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_046BEGIN
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046BEGIN
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: BEGIN
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046BEGIN
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046BEGIN
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_047CHECK: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_047CHECK
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047CHECK
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CHECK
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047CHECK
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047CHECK
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_048INIT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_048INIT
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048INIT
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: INIT
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048INIT
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048INIT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_049END: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_049END
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049END
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: END
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049END
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049END
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_050START: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_050START
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050START
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: START
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050START
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050START
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_051ENTER: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_051ENTER
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051ENTER
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: ENTER
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051ENTER
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051ENTER
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_052LEAVE: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_052LEAVE
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052LEAVE
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: LEAVE
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052LEAVE
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052LEAVE
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_053KEEP: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_053KEEP
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053KEEP
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: KEEP
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053KEEP
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053KEEP
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_054UNDO: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_054UNDO
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054UNDO
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: UNDO
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054UNDO
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054UNDO
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_055FIRST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_055FIRST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055FIRST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: FIRST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055FIRST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055FIRST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_056NEXT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_056NEXT
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056NEXT
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: NEXT
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056NEXT
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056NEXT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_057LAST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_057LAST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057LAST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: LAST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057LAST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057LAST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_058PRE: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_058PRE
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058PRE
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: PRE
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058PRE
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058PRE
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_059POST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_059POST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059POST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: POST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059POST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059POST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_060CATCH: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_060CATCH
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060CATCH
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CATCH
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060CATCH
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060CATCH
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_061CONTROL: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_061CONTROL
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061CONTROL
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CONTROL
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061CONTROL
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061CONTROL
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_062TEMP: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_062TEMP
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062TEMP
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: TEMP
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062TEMP
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062TEMP
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_069if: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_069if
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_069if
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: if
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_069if
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_069if
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_cond__S_069if_if'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_070unless: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_070unless
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_070unless
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: unless
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_070unless
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_070unless
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_cond__S_070unless_unless'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_071when: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_071when
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_071when
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: when
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_071when
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_071when
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_cond__S_071when_when'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_072while: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_072while
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_072while
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: while
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_072while
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_072while
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_072while_while'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_073until: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_073until
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_073until
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: until
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_073until
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_073until
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_073until_until'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_074for: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_074for
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_074for
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: for
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_074for
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_074for
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_074for_for'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_075given: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_075given
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_075given
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: given
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_075given
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_075given
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_075given_given'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_prefix__S_250do: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_250do
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_250do
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: do
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_250do
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_250do
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_250do
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_250do
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_251try: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_251try
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_251try
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: try
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_251try
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_251try
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_251try
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_251try
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_252gather: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_252gather
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_252gather
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: gather
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_252gather
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_252gather
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_252gather
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_252gather
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_253contend: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_253contend
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_253contend
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: contend
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_253contend
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_253contend
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_253contend
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_253contend
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_254async: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_254async
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_254async
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: async
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_254async
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_254async
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_254async
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_254async
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_255maybe: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_255maybe
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_255maybe
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: maybe
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_255maybe
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_255maybe
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_255maybe
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_255maybe
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_256lazy: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_256lazy
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_256lazy
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: lazy
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_256lazy
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_256lazy
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_256lazy
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_256lazy
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statementlist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statementlist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PARSER is context<rw> = self
    - !!perl/hash:RE_decl 
      a: 0
      dba: statementlist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 0
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &35 !!perl/hash:RE_any 
          a: 0
          altname: statementlist_01
          dba: statement list
          i: 0
          min: 0
          name: statementlist_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 0
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: statement list
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: $
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 1
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement list
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement list
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: statement list
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "[\\)\\]\\}]"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 2
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement list
                      i: 0
                      min: 24690
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: statement list
                          i: 0
                          min: 12345
                          name: statement
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: statement list
                          i: 0
                          min: 12345
                          name: eat_terminator
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statementlist_01: *35
stdstopper: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: stdstopper
      i: 0
      max: 0
      min: 0
      r: 0
      s: 0
      text: my @stub = return self if @+MEMOS[self.pos]<endstmt> :exists
  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: standard stopper
    i: 0
    min: 0
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &48 !!perl/hash:RE_any 
          a: 0
          altname: stdstopper_01
          dba: standard stopper
          i: 0
          min: 0
          name: stdstopper_01
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: stdstopper_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: standard stopper
                i: 0
                min: 12345
                name: terminator
                nobind: 1
                r: 0
                rest: ''
                s: 0
            - !!perl/hash:RE_assertion 
              alt: stdstopper_01 1
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: standard stopper
                i: 0
                min: 12345
                name: unitstopper
                nobind: 1
                r: 0
                rest: ''
                s: 0
            - !!perl/hash:RE_meta 
              a: 0
              alt: stdstopper_01 2
              dba: standard stopper
              i: 0
              min: 0
              r: 0
              s: 0
              text: $
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: standard stopper
        i: 0
        min: 0
        r: 0
        s: 0
        text: " @+MEMOS[$.pos]<endstmt> ||= 1; "
stdstopper_01: *48
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: stopper
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
sublongname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sublongname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: sublongname
        i: 0
        min: 12345
        name: subshortname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: sublongname
          i: 0
          min: 12345
          name: sigterm
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
subshortname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &30 !!perl/hash:RE_any 
      a: 0
      altname: subshortname_01
      dba: subshortname
      i: 0
      min: 12345
      name: subshortname_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: subshortname_01 0
          dba: subshortname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: subshortname
              i: 0
              min: 12345
              name: category
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: subshortname
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_method 
                        a: 0
                        dba: subshortname
                        i: 0
                        min: 12345
                        name: colonpair
                        r: 1
                        rest: ''
                        s: 0
                      min: 12345
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_block 
                      a: 0
                      context: void
                      dba: subshortname
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: " $.add_macro($<category>) if $+IN_DECL; "
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: subshortname_01 1
          dba: subshortname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: subshortname
              i: 0
              min: 12345
              name: desigilname
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: subshortname
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $.add_routine($<desigilname>.text) if $+IN_DECL; "
subshortname_01: *30
term__S_063BEGIN: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_063BEGIN
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_063BEGIN
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: BEGIN
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_063BEGIN
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_064CHECK: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_064CHECK
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_064CHECK
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CHECK
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_064CHECK
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_065INIT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_065INIT
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_065INIT
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: INIT
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_065INIT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_066START: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_066START
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_066START
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: START
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_066START
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_067ENTER: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_067ENTER
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_067ENTER
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: ENTER
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_067ENTER
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_068FIRST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_068FIRST
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_068FIRST
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: FIRST
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_068FIRST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_257ColonColonQuestionIDENT: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_257ColonColonQuestionIDENT
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12348
          nobind: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_257ColonColonQuestionIDENT
            i: 0
            min: 12348
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: term__S_257ColonColonQuestionIDENT
                i: 0
                min: 3
                r: 1
                s: 0
                text: ::?
              - !!perl/hash:RE_method 
                a: 0
                dba: term__S_257ColonColonQuestionIDENT
                i: 0
                min: 12345
                name: identifier
                r: 1
                rest: ''
                s: 0
        dba: term__S_257ColonColonQuestionIDENT
        i: 0
        min: 12348
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_257ColonColonQuestionIDENT
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_258undef: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_258undef
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_258undef
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: undef
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_258undef
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_258undef
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_258undef
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_258undef
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_258undef
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: term__S_258undef
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: $/
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: "('$/ variable as input record separator',\n             \"the filehandle's .slurp method\")"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_258undef
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_258undef
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_258undef
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_258undef
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: term__S_258undef
                          i: 0
                          min: 12345
                          name: variable
                          r: 1
                          rest: ''
                          s: 0
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('undef as a verb', 'undefine function')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_259continue: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_259continue
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_259continue
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: continue
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_259continue
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_260self: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_260self
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_260self
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: self
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_260self
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_261defer: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_261defer
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_261defer
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: defer
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_261defer
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_262rand: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_262rand
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_262rand
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rand
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_262rand
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_262rand
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_262rand
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_262rand
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_262rand
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: &110 !!perl/hash:RE_any 
                            a: 0
                            altname: term__S_262rand_03
                            dba: term__S_262rand
                            i: 0
                            min: 1
                            name: term__S_262rand_03
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_meta 
                                a: 0
                                alt: term__S_262rand_03 0
                                dba: term__S_262rand
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: term__S_262rand_03 1
                                dba: term__S_262rand
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: $
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('rand(N)', 'N.rand or (1..N).pick')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_262rand_03: *110
term__S_263e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_263e
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_263e
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: e
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_263e
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_264i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_264i
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_264i
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: i
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_264i
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_265pi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_265pi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_265pi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: pi
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_265pi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_266Inf: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_266Inf
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_266Inf
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Inf
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_266Inf
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_267NaN: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_267NaN
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_267NaN
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: NaN
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_267NaN
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_268Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_method 
    a: 0
    dba: term__S_268Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
term__S_269StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_method 
    a: 0
    dba: term__S_269StarStar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "**"
term__S_384DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_384DotDotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_384DotDotDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ...
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_384DotDotDot
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_385QuestionQuestionQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_385QuestionQuestionQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_385QuestionQuestionQuestion
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ???
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_385QuestionQuestionQuestion
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_386BangBangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_386BangBangBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_386BangBangBang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!!!"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_386BangBangBang
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_387sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_387sigil
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_387sigil
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: term__S_387sigil
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: term__S_387sigil
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_387sigil
        i: 0
        min: 12345
        name: arglist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_387sigil
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $<sigil>.item; "
term__S_388identifier: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_388identifier
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $t
  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_388identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_388identifier
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: term__S_388identifier
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: term__S_388identifier
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_string 
                        a: 0
                        dba: term__S_388identifier
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      min: 0
                      quant: 
                        - "?"
                        - ":"
                        - ''
                        - 0
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: term__S_388identifier
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_388identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $t = $<identifier>.text; "
      - !!perl/hash:RE_method 
        min: 0
        name: args
        rest: ( $.is_type($t) )
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_388identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        %MYSTERY{$t} ~= $.lineof($.pos) ~ ' ' unless $<args><invocant> or $.is_known($t);\n    "
term__S_389opfunc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_389opfunc
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_389opfunc
        i: 0
        min: 12345
        name: category
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_389opfunc
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_389opfunc
        i: 0
        min: 12345
        name: args
        r: 1
        rest: ''
        s: 0
term__S_390name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_390name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_390name
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: type parameter
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: type parameter
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: term__S_390name
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: "\n            $.is_type($<longname>.text) or substr($<longname>.text,0,2) eq '::'\n        "
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: term__S_390name
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_390name
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: term__S_390name
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_string 
                                a: 0
                                dba: term__S_390name
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "["
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: term__S_390name
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12347
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: type parameter
                      i: 0
                      min: 12347
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: type parameter
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: "::"
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: type parameter
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_bracket 
                                decl: []

                                min: 1
                                re: &53 !!perl/hash:RE_any 
                                  a: 0
                                  altname: term__S_390name_06
                                  dba: type parameter
                                  i: 0
                                  min: 1
                                  name: term__S_390name_06
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_390name_06 0
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_390name_06 1
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: <
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_390name_06 2
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "{"
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_390name_06 3
                                      dba: type parameter
                                      i: 0
                                      min: 2
                                      r: 1
                                      s: 0
                                      text: <<
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: type parameter
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method_internal 
                          args: $S, 'term__S_390name_packagevar_'
                          max: 0
                          min: 0
                          name: _REDUCE
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'term__S_390name_typename'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: type parameter
                i: 0
                min: 12345
                name: args
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
term__S_390name_06: *53
terminator__S_400Semi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_400Semi
    i: 0
    min: 1
    r: 1
    s: 0
    text: ;
terminator__S_401if: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_401if
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_401if
        i: 0
        min: 2
        r: 1
        s: 0
        text: if
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_401if
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_401if
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_402unless: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12351
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_402unless
    i: 0
    min: 12351
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_402unless
        i: 0
        min: 6
        r: 1
        s: 0
        text: unless
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_402unless
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_402unless
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_403while: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_403while
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_403while
        i: 0
        min: 5
        r: 1
        s: 0
        text: while
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_403while
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_403while
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_404until: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_404until
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_404until
        i: 0
        min: 5
        r: 1
        s: 0
        text: until
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_404until
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_404until
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_405for: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_405for
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_405for
        i: 0
        min: 3
        r: 1
        s: 0
        text: for
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_405for
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_405for
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_406given: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_406given
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_406given
        i: 0
        min: 5
        r: 1
        s: 0
        text: given
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_406given
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_406given
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_407when: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_407when
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_407when
        i: 0
        min: 4
        r: 1
        s: 0
        text: when
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_407when
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_407when
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_408MinusMinusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_408MinusMinusGt
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_408MinusMinusGt
        i: 0
        min: 3
        r: 1
        s: 0
        text: -->
      - !!perl/hash:RE_method_internal 
        args: $S, 'terminator__S_408MinusMinusGt'
        max: 0
        min: 0
        name: _REDUCE
terminator__S_409Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Terminator
  re: !!perl/hash:RE_method 
    a: 0
    dba: terminator__S_409Thesis
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: )
terminator__S_410Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_410Ket
    i: 0
    min: 1
    r: 1
    s: 0
    text: "]"
terminator__S_411Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_411Ly
    i: 0
    min: 1
    r: 1
    s: 0
    text: "}"
terminator__S_412BangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_412BangBang
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_412BangBang
        i: 0
        min: 2
        r: 1
        s: 0
        text: "!!"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: terminator__S_412BangBang
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $+GOAL eq '!!' "
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &45 !!perl/hash:RE_any 
          a: 0
          altname: termish_01
          dba: prefix or noun
          i: 0
          min: 12345
          name: termish_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: termish_01 0
              dba: prefix or noun
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: prefix or noun
                    i: 0
                    min: 12345
                    name: PRE
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or noun
                  i: 0
                  min: 12345
                  name: noun
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: termish_01 1
              dba: prefix or noun
              i: 0
              min: 12345
              name: noun
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postfix
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: postfix
                i: 0
                min: 12345
                name: stdstopper
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: postfix
                i: 0
                min: 12345
                name: POST
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
termish_01: *45
trait: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &62 !!perl/hash:RE_any 
          a: 0
          altname: trait_01
          dba: trait
          i: 0
          min: 12345
          name: trait_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 0
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: trait_verb
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 1
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: trait_auxiliary
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 2
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_01: *62
trait_auxiliary__S_241is: !!perl/hash:RE 
  decl: []

  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_auxiliary__S_241is
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_241is
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: is
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_241is
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_241is
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_241is
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: trait_auxiliary__S_241is
          i: 0
          min: 12345
          name: postcircumfix
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
trait_auxiliary__S_242does: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: trait_auxiliary__S_242does
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'role'
  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_auxiliary__S_242does
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_242does
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: does
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_242does
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_242does
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_242does
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 0
trait_auxiliary__S_243will: !!perl/hash:RE 
  decl: []

  kind: token
  min: 74070
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_auxiliary__S_243will
    i: 0
    min: 74070
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_243will
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: will
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_243will
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_243will
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_243will
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_243will
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_243will
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 0
trait_verb__S_244of: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_244of
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_244of
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: of
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_244of
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_244of
        i: 0
        min: 12345
        name: fulltypename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_verb__S_245as: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_245as
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_245as
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: as
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_245as
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_245as
        i: 0
        min: 12345
        name: fulltypename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_verb__S_246returns: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_246returns
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_246returns
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: returns
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_246returns
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_246returns
        i: 0
        min: 12345
        name: fulltypename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_verb__S_247handles: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_247handles
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_247handles
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: handles
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_247handles
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_247handles
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
tribble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: tribble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: tribble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: nibble
          nobind: 1
          rest: ($lang)
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: left
      - !!perl/hash:RE_var 
        a: 0
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: tribble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: tribble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: tribble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start ne $stop "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: tribble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($lang2)
            - !!perl/hash:RE_sequence 
              a: 0
              dba: tribble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $lang = $lang2.unbalanced($stop); "
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: nibble
                    nobind: 1
                    rest: ($lang)
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
                - !!perl/hash:RE_var 
                  a: 0
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
twigil__S_171Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_171Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
twigil__S_172Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_172Bang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!"
twigil__S_173Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_173Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
twigil__S_174Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: twigil__S_174Colon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: twigil__S_174Colon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ":"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: twigil__S_174Colon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: twigil__S_174Colon
              i: 0
              min: 1
              r: 1
              s: 0
              text: ":"
          s: 0
twigil__S_175Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_175Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
twigil__S_176Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_176Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
twigil__S_177Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_177Question
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "?"
twigil__S_178Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_178Equal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =
type_constraint: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_constraint
    i: 0
    min: 5
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 5
        re: &10 !!perl/hash:RE_any 
          a: 0
          altname: type_constraint_01
          dba: type_constraint
          i: 0
          min: 5
          name: type_constraint_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: type_constraint_01 0
              dba: type_constraint
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 12345
                  name: value
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: type_constraint_01 1
              dba: type_constraint
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 12345
                  name: fulltypename
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: type_constraint_01 2
              dba: type_constraint
              i: 0
              min: 5
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: where
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %chaining)
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
type_constraint_01: *10
type_declarator__S_248subset: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_declarator__S_248subset
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_248subset
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: subset
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_248subset
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: type_declarator__S_248subset
        i: 0
        min: 0
        r: 1
        s: 1
        text: " $.add_type($<longname>.text); "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: type_declarator__S_248subset
            i: 0
            min: 12347
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_string 
                a: 0
                dba: type_declarator__S_248subset
                i: 0
                min: 2
                r: 1
                s: 1
                text: of
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                a: 0
                dba: type_declarator__S_248subset
                i: 0
                min: 12345
                name: fulltypename
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 5
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: type_declarator__S_248subset
            i: 0
            min: 5
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: type_declarator__S_248subset
                i: 0
                min: 5
                r: 1
                s: 1
                text: where
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: EXPR
                rest: (item %chaining)
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
type_declarator__S_249enum: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: type_declarator__S_249enum
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $l
  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_declarator__S_249enum
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_249enum
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: enum
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_249enum
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: type_declarator__S_249enum
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_bindvar 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: type_declarator__S_249enum
                  i: 0
                  min: 12345
                  name: longname
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                dba: type_declarator__S_249enum
                i: 0
                min: 12345
                r: 1
                s: 0
                var: $l
              - !!perl/hash:RE_meta 
                a: 0
                dba: type_declarator__S_249enum
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: type_declarator__S_249enum
                i: 0
                min: 0
                r: 1
                s: 0
                text: " $.add_type($l.text); "
              - !!perl/hash:RE_method 
                a: 0
                dba: type_declarator__S_249enum
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_249enum
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_249enum
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
typename: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: typename
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &112 !!perl/hash:RE_any 
          a: 0
          altname: typename_01
          dba: typename
          i: 0
          min: 12345
          name: typename_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: typename_01 0
              dba: typename
              i: 0
              min: 12348
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: typename
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: ::?
                - !!perl/hash:RE_method 
                  a: 0
                  dba: typename
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: typename_01 1
              dba: typename
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: typename
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: typename
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: "\n        my $longname = $<longname>.text;\n        if substr($longname, 0, 2) eq '::' {\n            $.add_type(substr($longname, 2));\n        }\n        else {\n            $.is_type($longname)\n        }\n      "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: typename
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: typename
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: typename
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: typename
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: typename
                i: 0
                min: 12345
                name: postcircumfix
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
typename_01: *112
unitstopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_meta 
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    text: $
unsp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: unspace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: unsp
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: unsp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: &36 !!perl/hash:RE_any 
                a: 0
                altname: unsp_02
                dba: unsp
                i: 0
                min: 1
                name: unsp_02
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_meta 
                    a: 0
                    alt: unsp_02 0
                    dba: unsp
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  - !!perl/hash:RE_string 
                    a: 0
                    alt: unsp_02 1
                    dba: unsp
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "#"
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &17 !!perl/hash:RE_any 
            a: 0
            altname: unsp_03
            dba: unspace
            i: 0
            min: 0
            name: unsp_03
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 0
                dba: unspace
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 12345
                    name: vws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'unsp_vwhite'
                    max: 0
                    min: 0
                    name: _REDUCE
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 1
                dba: unspace
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'unsp_unv'
                    max: 0
                    min: 0
                    name: _REDUCE
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 2
                dba: unspace
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_meta 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: $
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: unspace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: " $.moreinput "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
unsp_02: *36
unsp_03: *17
unspacey: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_method 
      a: 0
      dba: unspacey
      i: 0
      min: 12345
      name: unsp
      nobind: 1
      r: 1
      rest: ''
      s: 0
    min: 0
    quant: 
      - "?"
      - ":"
      - ''
      - 0
unv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &2 !!perl/hash:RE_any 
      a: 0
      altname: unv_01
      dba: horizontal whitespace
      i: 0
      min: 1
      name: unv_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 0
          dba: horizontal whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 1
                r: 1
                s: 0
                text: \h
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_method_internal 
              args: $S, 'unv_hwhite'
              max: 0
              min: 0
              name: _REDUCE
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 1
          dba: horizontal whitespace
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: horizontal whitespace
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                s: 0
            - !!perl/hash:RE_meta 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 0
              r: 1
              s: 0
              text: "^^"
            - !!perl/hash:RE_method 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 12345
              name: pod_comment
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method_internal 
              args: $S, 'unv_pod'
              max: 0
              min: 0
              name: _REDUCE
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 2
          dba: horizontal whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 1
                r: 1
                s: 0
                text: \h
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_string 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 1
              r: 1
              s: 0
              text: "#"
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &49 !!perl/hash:RE_any 
                a: 0
                altname: unv_03
                dba: horizontal whitespace
                i: 0
                min: 0
                name: unv_03
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: unv_03 0
                    dba: horizontal whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 12345
                          name: opener
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                      - !!perl/hash:RE_bracket 
                        decl: []

                        min: 0
                        re: !!perl/hash:RE_first 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_assertion 
                              assert: "!"
                              min: 0
                              re: !!perl/hash:RE_method_re 
                                a: 0
                                dba: horizontal whitespace
                                i: 0
                                min: 0
                                name: after
                                nobind: 1
                                r: 1
                                re: !!perl/hash:RE 
                                  decl: []

                                  min: 1
                                  re: !!perl/hash:RE_sequence 
                                    a: 0
                                    dba: horizontal whitespace
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_meta 
                                        a: 0
                                        dba: horizontal whitespace
                                        i: 0
                                        min: 0
                                        r: 1
                                        s: 0
                                        text: "^^"
                                      - !!perl/hash:RE_meta 
                                        a: 0
                                        dba: horizontal whitespace
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 0
                                        text: .
                                s: 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: panic
                              nobind: 1
                              rest: ("Can't use embedded comments in column 1")
                      - !!perl/hash:RE_method 
                        min: 0
                        name: quibble
                        nobind: 1
                        rest: ($.cursor_fresh( ::STD::Q ))
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'unv_embedded'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: unv_03 1
                    dba: horizontal whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: horizontal whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: ''
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_meta 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \N
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'unv_end'
                        max: 0
                        min: 0
                        name: _REDUCE
unv_01: *2
unv_03: *49
value: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &20 !!perl/hash:RE_any 
      a: 0
      altname: value_01
      dba: value
      i: 0
      min: 12345
      name: value_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: value_01 0
          dba: value
          i: 0
          min: 12345
          name: quote
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: value_01 1
          dba: value
          i: 0
          min: 12345
          name: number
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: value_01 2
          dba: value
          i: 0
          min: 12345
          name: version
          r: 1
          rest: ''
          s: 0
value_01: *20
variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: variable
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: variable
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: variable
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $+SIGIL ||= $<sigil>.text "
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: variable
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "&"
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &70 !!perl/hash:RE_any 
                    a: 0
                    altname: variable_03
                    dba: variable
                    i: 0
                    min: 12345
                    name: variable_03
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: variable_03 0
                        dba: variable
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: variable
                              i: 0
                              min: 12345
                              name: twigil
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: variable
                            i: 0
                            min: 12345
                            name: sublongname
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'variable_subnoun'
                            max: 0
                            min: 0
                            name: _REDUCE
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: variable_03 1
                        dba: variable
                        i: 0
                        min: 12347
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: variable
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "["
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: variable
                            extra: "local $::GOAL = ']' "
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: "::"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: variable
                            i: 0
                            min: 12345
                            name: infixish
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: variable
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "]"
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: FAILGOAL
                                  nobind: 1
                                  rest: (']' , 'variable')
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: variable
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 4
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: variable
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: $::(
                    s: 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: $
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: name
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: "$::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: name
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: "$:"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: name
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 12345
              re: &71 !!perl/hash:RE_any 
                a: 0
                altname: variable_09
                dba: variable
                i: 0
                min: 12345
                name: variable_09
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_09 0
                    dba: variable
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_method 
                          a: 0
                          dba: variable
                          i: 0
                          min: 12345
                          name: twigil
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: desigilname
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_desigilname'
                        max: 0
                        min: 0
                        name: _REDUCE
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 12345
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: variable
                            i: 0
                            min: 12345
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_assertion 
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_block 
                                  a: 0
                                  context: bool
                                  dba: variable
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 1
                                  s: 0
                                  text: " my $t = $<twigil>; @$t and $t.[0].text eq '.' "
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_method 
                                  a: 0
                                  dba: variable
                                  i: 0
                                  min: 12345
                                  name: unsp
                                  nobind: 1
                                  r: 1
                                  rest: ''
                                  s: 0
                                min: 0
                                quant: 
                                  - "?"
                                  - ":"
                                  - ''
                                  - 0
                              - !!perl/hash:RE_assertion 
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_method_re 
                                  a: 0
                                  dba: variable
                                  i: 0
                                  min: 0
                                  name: before
                                  nobind: 1
                                  r: 1
                                  re: !!perl/hash:RE 
                                    decl: []

                                    min: 1
                                    re: !!perl/hash:RE_string 
                                      a: 0
                                      dba: variable
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: (
                                  s: 0
                              - !!perl/hash:RE_method 
                                a: 0
                                dba: variable
                                i: 0
                                min: 12345
                                name: postcircumfix
                                r: 1
                                rest: ''
                                s: 0
                              - !!perl/hash:RE_method_internal 
                                args: $S, 'variable_methcall'
                                max: 0
                                min: 0
                                name: _REDUCE
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_09 1
                    dba: variable
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: special_variable
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_special'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_09 2
                    dba: variable
                    i: 0
                    min: 12346
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_bindnamed 
                        a: 0
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          nobind: 1
                          re: !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: variable
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                        dba: variable
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        var: index
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_$0'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_09 3
                    dba: variable
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: variable
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: &34 !!perl/hash:RE_any 
                              a: 0
                              altname: variable_13
                              dba: variable
                              i: 0
                              min: 1
                              name: variable_13
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_13 0
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: <
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_13 1
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                          s: 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: postcircumfix
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_$()'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_09 4
                    dba: variable
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: variable
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " $+IN_DECL "
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_anondecl'
                        max: 0
                        min: 0
                        name: _REDUCE
variable_03: *70
variable_09: *71
variable_13: *34
variable_declarator: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable_declarator
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: variable_declarator
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: variable_declarator
        i: 0
        min: 12345
        name: variable
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable_declarator
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $IN_DECL = 0; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: variable_declarator
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: variable_declarator
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &57 !!perl/hash:RE_any 
                      a: 0
                      altname: variable_declarator_02
                      dba: shape definition
                      i: 0
                      min: 12345
                      name: variable_declarator_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 0
                          dba: variable_declarator
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: variable_declarator
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: (
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: variable_declarator
                              extra: "local $::GOAL = ')' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: variable_declarator
                              i: 0
                              min: 12345
                              name: signature
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: variable_declarator
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: variable_declarator
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: )
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: (')' , 'variable_declarator')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 1
                          dba: shape definition
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "["
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: shape definition
                              extra: "local $::GOAL = ']' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: semilist
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "]"
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: (']' , 'shape definition')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 2
                          dba: shape definition
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "{"
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: shape definition
                              extra: "local $::GOAL = '}' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: semilist
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "}"
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: ('}' , 'shape definition')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 3
                          dba: shape definition
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_assertion 
                              assert: "?"
                              min: 0
                              re: !!perl/hash:RE_method_re 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 0
                                name: before
                                nobind: 1
                                r: 1
                                re: !!perl/hash:RE 
                                  decl: []

                                  min: 1
                                  re: !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: <
                                s: 0
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: postcircumfix
                              r: 1
                              rest: ''
                              s: 0
                  min: 0
                  nobind: 1
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                dba: variable_declarator
                i: 0
                min: 0
                r: 1
                s: 0
                var: shape
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: variable_declarator
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: variable_declarator
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: variable_declarator
          i: 0
          min: 12345
          name: post_constraint
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
variable_declarator_02: *57
version__S_078v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: version__S_078v
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: version__S_078v
        i: 0
        min: 1
        r: 1
        s: 0
        text: v
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: version__S_078v
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: version__S_078v
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
          s: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: version__S_078v
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: version__S_078v
          i: 0
          min: 12345
          name: vnum
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: version__S_078v
            i: 0
            min: 1
            r: 1
            s: 0
            text: .
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: version__S_078v
          i: 0
          min: 1
          r: 1
          s: 0
          text: +
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
vnum: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: &99 !!perl/hash:RE_any 
    a: 0
    altname: vnum_00
    dba: vnum
    i: 0
    min: 1
    name: vnum_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        alt: vnum_00 0
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: vnum
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_string 
        a: 0
        alt: vnum_00 1
        dba: vnum
        i: 0
        min: 1
        r: 1
        s: 0
        text: "*"
vnum_00: *99
vws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: vertical whitespace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: vertical whitespace
        i: 0
        min: 1
        r: 1
        s: 0
        text: \v
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 9
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: vertical whitespace
            i: 0
            min: 9
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: vertical whitespace
                i: 0
                min: 9
                r: 1
                s: 0
                text: "#DEBUG -1"
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: vertical whitespace
                i: 0
                min: 0
                r: 1
                s: 0
                text: " say \"DEBUG\"; $STD::DEBUG = $*DEBUG = -1; "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: ws
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my @stub = return self if @+MEMOS[self.pos]<ws> :exists
    - !!perl/hash:RE_decl 
      a: 0
      dba: ws
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $startpos = self.pos
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: whitespace
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &32 !!perl/hash:RE_any 
          a: 0
          altname: ws_01
          dba: whitespace
          i: 0
          min: 0
          name: ws_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: ws_01 0
              dba: whitespace
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_cclass 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 1
                    nobind: 1
                    r: 1
                    s: 0
                    text: "[#\\s\\\\]"
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<ws> = $startpos; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: ws_01 1
              dba: whitespace
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                    s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    name: after
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                    s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ":::"
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$startpos]<ws> = undef; "
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_noop 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
      - !!perl/hash:RE_sequence 
        a: 0
        dba: whitespace
        i: 0
        min: 0
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &120 !!perl/hash:RE_any 
                a: 0
                altname: ws_05
                dba: whitespace
                i: 0
                min: 0
                name: ws_05
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: ws_05 0
                    dba: whitespace
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: ws_05 1
                    dba: whitespace
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 12345
                        name: vws
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 12345
                        name: heredoc
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: ws_05 2
                    dba: whitespace
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: ws_05 3
                    dba: whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $.moreinput "
            min: 0
            quant: 
              - "*"
              - ":"
              - ''
              - 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: whitespace
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n        if ($.pos == $startpos) {\n            @+MEMOS[$.pos]<ws> = undef;\n        }\n        else {\n            @+MEMOS[$.pos]<ws> = $startpos;\n            @+MEMOS[$.pos]<endstmt> = @+MEMOS[$startpos]<endstmt>\n                if @+MEMOS[$startpos]<endstmt> :exists;\n        }\n    "
ws_01: *32
ws_05: *120
xblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: xblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '{'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: xblock
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: pblock
        r: 1
        rest: ''
        s: 0
RETREE_END
}

1;
# vim: sw=4 ft=perl
