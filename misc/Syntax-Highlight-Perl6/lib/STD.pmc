# Emulate context vars by localizing 'our' vars living in main
our $ACTIONS;
our $CORE;
our $CORESETTING;
our $CTX;
our $CURPAD;
our $CURPKG;
our $DELIM;
our $GLOBAL;
our $GOAL;
our $INTERPOLATION;
our $INVOCANT_IS;
our $INVOCANT_OK;
our $IN_DECL;
our $IN_META;
our $LANG;
our $ORIG;
our $PARSER;
our $PKGDECL;
our $PKGNAME;
our $QUASI_QUASH;
our $REALLYADD;
our $SCOPE;
our $SIGIL;
our $UNIT;
our $VAR;
our $VOID;
our $begin_compunit;
our $endargs;
our $endsym;
our $ignoreaccent;
our $ignorecase;
our $ratchet;
our $sigspace;
our $sym;
our $zone;
our %MYSTERY;
our @MEMOS;
our @PKGS;

our $moreinput;
our $DEBUG;

our %INSTANTIATED;
require 'mangle.pl';
use utf8;

package STD;
use strict;
use warnings;
no warnings 'qw', 'recursion';
use Cursor; # for base class as well as DEBUG constants
use Moose ':all' => { -prefix => "moose_" };
moose_extends('Cursor');
my $retree;
use feature 'state', 'say';
use utf8;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

sub BUILD {
my $self = shift;
$self->_AUTOLEXpeek('termish',$retree);
}

use YAML::Syck;


# should some of these be parser instance attributes?
local $::LANG;
local $::PKGDECL =  "";
local $::PKGNAME =  "";
local @::PKGS =  ();
local $::GOAL =  "(eof)";
local $::PARSER;
local $::ACTIONS;
local $::IN_DECL;
local $::INTERPOLATION =  '';
local $::IN_META =  0;
local $::QUASI_QUASH;
local $::SCOPE =  "";
local $::SIGIL;
local %::MYSTERY;
local $::ORIG;
local @::MEMOS;
local $::VOID;
local $::INVOCANT_OK;
local $::INVOCANT_IS;
local $::CURPAD;
local $::REALLYADD =  0;

local $::CORE;
local $::CORESETTING =  "CORE";
local $::GLOBAL;
local $::CURPKG;
local $::UNIT;

# random rule for debugging, please ignore
## token foo
##      token foo {
##         <?before [<ident>|<number>]> [<ident>|<number>]
##      }

sub foo__PEEK { $_[0]->_AUTOLEXpeek('foo',$retree) }
sub foo {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "foo", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'foo_02') {
$C->deb("Fate passed to foo_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'foo_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("foo_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['ident'], sub {
my $C = shift;
$C->ident
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'foo_03') {
$C->deb("Fate passed to foo_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'foo_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("foo_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['ident'], sub {
my $C = shift;
$C->ident
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

# =begin comment overview
# 
# This file is designed to be either preprocessed into a grammar with
# action statements or used as-is without any preprocessing.  The {*}
# notation is a no-op action block, but can be identified uniquely via a
# combination of the preceding token or rule name plus any additional text
# following a #= comment.  We put this into a comment rather than using
# a macro so that bootstrap compilers don't have to worry about macros
# yet, and to keep the main grammar relatively uncluttered by action
# statements.  Note that the preprocessor can certainly generate accesses
# to the match state within the action block, so we need not mention it
# explicitly.
# 
# Also, some rules are named by syntactic category plus an additonal symbol
# specified in adverbial form, either in bare :name form or in :sym<name>
# form.  (It does not matter which form you use for identifier symbols,
# except that to specify a symbol "sym" you must use the :sym<sym> form
# of adverb.)  If you use the <sym> rule within the rule, it will parse the
# symbol at that point.  At the final reduction point of a rule, if $sym
# has been set, that is used as the final symbol name for the rule.  This
# need not match the symbol specified as part the rule name; that is just
# for disambiguating the name.  However, if no $sym is set, the original
# symbol will be used by default.
# 
# Note that rules automatically get an implicit {*} at their return, so
# for the TOP rule the implicit action name is also simply "TOP".
# 
# Another nod toward preprocessing is that blocks that contain nested braces
# are delimited by double braces so that the preprocessor does not need to
# understand Perl 6 code.
# 
# This grammar relies on transitive longest-token semantics, though
# initially we made a feeble attempt to order rules so a procedural
# interpretation of alternation could usually produce a correct parse.
# (This is becoming less true over time.)
# 
# =end comment overview

## method TOP ($STOP = undef)
sub TOP {
my $self = shift;
my $STOP = shift() // undef;


if (defined $STOP) {
local $::GOAL =  $STOP;
$self->unitstop($STOP)->comp_unit;
}
else {
$self->comp_unit;
}
}

#  Absolute:
#    MY          # $stash = mypad()
#    OUR         # $stash = $?PACKAGE;
#    CORE        # $stash = $::CORE
#    GLOBAL      # $stash = CORE::<GLOBAL::>
#    PROCESS     # $stash = CORE::<PROCESS::>
#    COMPILING   # $stash = compiling($rest) # compiler's run time
#    CALLER      # ctx = ctx.caller # user's run time
#    CONTEXT     # ctx = ctx.context # user's run time
#
#  Relative:
#    OUTER       # $stash = $stash<OUTER::>
#    UNIT        # $stash = $stash.scanouter(:unit)
#    SETTING     # $stash = UNIT::<OUTER::>
#    PARENT      # $stash = $stash<PARENT::>
#
#    SUPER       # (give up, pass to dispatcher?)

## method newpad
sub newpad {
my $self = shift;


$::CURPAD = {
'OUTER::' => $::CURPAD,
};
$self;
}

## method finishpad($siggy = $*CURPAD.{'$?GOTSIG'}//0)
sub finishpad {
my $self = shift;
my $siggy = shift() // $CURPAD->{'$?GOTSIG'}//0;


my $line = $self->lineof($self->{_pos});
$CURPAD->{'$_'} //= { name => '$_', file => $COMPILING::FILE, line => $line };
$CURPAD->{'$/'} //= { name => '$/', file => $COMPILING::FILE, line => $line };
$CURPAD->{'$!'} //= { name => '$!', file => $COMPILING::FILE, line => $line };
if (not $siggy) {
$CURPAD->{'@_'} = { name => '@_', file => $COMPILING::FILE, line => $line };
$CURPAD->{'%_'} = { name => '%_', file => $COMPILING::FILE, line => $line };
$CURPAD->{'$?GOTSIG'} = '';
}
$self;
}

## method is_name ($name, $curpad = $*CURPAD)
sub is_name {
my $self = shift;
my $name = shift;
my $curpad = shift() // $::CURPAD;


# say "is_name $name";
$name = substr($name,2) while substr($name,0,2) eq '::';
# say "Looking for $name in $curpad";

my $curpkg = $::CURPKG;
if ($name =~ qr/::/) {
my @components = split(qr/\:\:/,$name);
return 1 if $components[0] eq 'COMPILING';
return 1 if $components[0] eq 'CALLER';
return 1 if $components[0] eq 'CONTEXT';
if ($curpkg = $self->find_top_pkg($components[0] . '::')) {
# say "Found lexical package " . $components[0];
shift @components;
}
else {
# say "Looking for GLOBAL::<$name>";
$curpkg = $::GLOBAL;
}
while (@components > 1) {
my $pkg = shift @components;
$curpkg = $curpkg->{$pkg . '::'};
return 0 unless $curpkg;
# say "Found $pkg okay, now in ";
}
$name = shift(@components)//'';
return 1 if $name eq '';
$name =~ s/^\<//;
$name =~ s/\>$//;
}
else {
my $pad = $curpad;
while ($pad) {
return 1 if $pad->{$name};
$pad = $pad->{'OUTER::'};
}
}
return 1 if $curpkg->{$name};
return 1 if $GLOBAL->{$name};
return 0;
}

## method find_stab ($name, $curpad = $*CURPAD)
sub find_stab {
my $self = shift;
my $name = shift;
my $curpad = shift() // $::CURPAD;


# say "is_name $name";
$name = substr($name,2) while substr($name,0,2) eq '::';
# say "Looking for $name in $curpad";

my $curpkg = $::CURPKG;
if ($name =~ qr/::/) {
$name = $self->canonicalize_name($name) unless $name =~ qr/^\w/;
my @components = split(qr/\:\:/,$name); 
if ($components[-1] eq '' or $name =~ qr/\:\:$/) {
pop(@components) if $components[-1] eq ''; # work around p5 problems
$components[-1] .= '::';
}
return () if $components[0] eq 'CALLER';
return () if $components[0] eq 'CONTEXT';
if ($curpkg = $self->find_top_pkg($components[0] . '::')) {
# say "Found lexical package " . $components[0];
shift @components;
}
else {
# say "Looking for GLOBAL::<$name>";
$curpkg = $::GLOBAL;
}
while (@components > 1) {
my $pkg = shift @components;
$curpkg = $curpkg->{$pkg . '::'};
return () unless $curpkg;
# say "Found $pkg okay, now in ";
}
$name = shift(@components)//'';
return () if $name eq '';
$name =~ s/^\<//;
$name =~ s/\>$//;
}
else {
my $pad = $curpad;
while ($pad) {
return $_ if $_ = $pad->{$name};
$pad = $pad->{'OUTER::'};
}
}
return $_ if $_ = $curpkg->{$name};
return $_ if $_ = $GLOBAL->{$name};
return ();
}

## method find_top_pkg ($name)
sub find_top_pkg {
my $self = shift;
my $name = shift;


# say "find_top_pkg $name";
if ($name eq 'OUR::') {
return $::CURPKG;
}
elsif ($name eq 'MY::') {
return $::CURPAD;
}
elsif ($name eq 'CORE::') {
return $::CORE;
}
elsif ($name eq 'UNIT::') {
return $::UNIT;
}
# everything is somewhere in lexical scope (we hope)
my $pad = $::CURPAD;
while ($pad) {
return $pad->{$name} if $pad->{$name};
$pad = $pad->{'OUTER::'} // 0;
}
return 0;
}

## method add_name ($name)
sub add_name {
my $self = shift;
my $name = shift;


# say "Adding $::SCOPE $name in $::PKGNAME";
if (($::SCOPE//'') eq 'our' or $name =~ qr/::/) {
$self->add_our_name($name);
}
else {
$self->add_my_name($name);
}
$self;
}

## method add_my_name ($name)
sub add_my_name {
my $self = shift;
my $name = shift;


# say "add_my_name $name";
$name = substr($name,2) while substr($name,0,2) eq '::';
$CURPAD->{$name} //= { name => $name };
$self;
}

## method add_our_name ($name)
sub add_our_name {
my $self = shift;
my $name = shift;


# say "add_our_name $name " . $::PKGNAME;
$name = substr($name,2) while substr($name,0,2) eq '::';
my $curpkg = $::CURPKG;
# say "curpkg $curpkg global $GLOBAL ", join ' ', %$::GLOBAL;
$name =~ s/\:ver\<.*?\>//;
$name =~ s/\:auth\<.*?\>//;
if ($name =~ qr/::/) {
my @components = split(qr/\:\:/,$name);
my $first = $components[0] . '::';
if ($curpkg = $self->find_top_pkg($first)) {
# say "Found $first package $curpkg";
shift @components;
}
else {
$curpkg = $::CURPKG;
# say "Assuming current package $curpkg ";
}
while (@components > 1) {
my $pkg = shift @components;
$curpkg->{$pkg} //= { name => $pkg, file => $COMPILING::FILE, line => $self->line };
$curpkg = $curpkg->{$pkg . '::'} //= { };
# say "Adding new package $pkg in $curpkg ";
}
$name = shift @components;
}
$name =~ s/^\<//;
$name =~ s/\>$//;
$curpkg->{$name} //= { name => $name, file => $COMPILING::FILE, line => $self->line };
$CURPAD->{$name} //= $curpkg->{$name};  # the lexical alias
my $n = $CURPAD->{$name . '::'} //= $curpkg->{$name . '::'} //= { name => $name . '::', file => $COMPILING::FILE, line => $self->line };
# say "Added package $name $n to $curpkg ";
$self;
}

## method add_mystery ($name,$pos)
sub add_mystery {
my $self = shift;
my $name = shift;
my $pos = shift;


if (not $self->is_known($name)) {
# say "add_mystery $name";
# say "Mystery $name $::CURPAD";
$::MYSTERY{$name}->{'pad'} = $::CURPAD;
$::MYSTERY{$name}->{'line'} .= $self->lineof($pos) . ' ';
}
else {
# say "$name is known";
}
$self;
}

## method load_setting ($setting)
sub load_setting {
my $self = shift;
my $setting = shift;


@PKGS = ();

# XXX CORE   == SETTING for now
$::CORE = $::CURPAD = $GLOBAL->{"CORE::"} = $GLOBAL->{"SETTING::"} = $self->load_pad($setting);
$::GLOBAL = $CORE->{'GLOBAL::'};
$::CURPKG = $::GLOBAL;
}

## method is_known ($name, $curpad = $*CURPAD)
sub is_known {
my $self = shift;
my $name = shift;
my $curpad = shift() // $::CURPAD;


# say "is_known $name";
return 1 if $::QUASI_QUASH;
return 1 if $CURPKG->{$name};
my $st;
($st,$name) = $name =~ qr/^(\W*)(.*)/;
$st =~ s/\:\://;
$st ||= '&';
# say "is_known sigiltwigil $st $name";
my $curpkg = $::CURPKG;
if ($name =~ qr/::/) {
$name = $self->canonicalize_name($name) unless $name =~ qr/^\w/;
my @components = split(qr/\:\:/,$name);
return 1 if $components[0] eq 'CALLER';
return 1 if $components[0] eq 'CONTEXT';
if ($curpkg = $self->find_top_pkg($components[0] . '::')) {
# say "Found lexical package " . $components[0];
shift @components;
}
else {
# say "Looking for GLOBAL::<$name>";
$curpkg = $::GLOBAL;
}
while (@components > 1) {
my $pkg = shift @components;
# say "Looking for $pkg in $curpkg " join ' ', keys(%$curpkg);
$curpkg = $curpkg->{$pkg . '::'};
return 0 unless $curpkg;
# say "Found $pkg okay, now in $curpkg ";
}
$name = shift(@components)//'';
# say "Final component is $name";
return 1 if $name eq '';
$name =~ s/^\<//;
$name =~ s/\>$//;
return 1 if $curpkg->{$name};
return 1 if $curpkg->{$st . $name};
}
else {
my $vname = $st . $name;
return 1 if $CURPKG->{$vname};
my $pad = $curpad;
while ($pad) {
return 1 if $pad->{$name};
return 1 if $pad->{$vname};
$pad = $pad->{'OUTER::'};
}
}
return 0;
}


## method add_routine ($name)
sub add_routine {
my $self = shift;
my $name = shift;


my $vname = '&' . $name;
if (($::SCOPE//'') eq 'our') {
$self->add_our_routine($vname);
if ($vname =~ s/\:\(.*//) {
$self->add_our_routine($vname);
}
}
else {
$self->add_my_routine($vname);
if ($vname =~ s/\:\(.*//) {
$self->add_my_routine($vname);
}
}
$self;
}

## method add_my_routine ($name)
sub add_my_routine {
my $self = shift;
my $name = shift;


# say "add_my_routine $name";
$CURPAD->{$name} //= { name => $name, file => $COMPILING::FILE, line => $self->line };
$self;
}

## method add_our_routine ($name)
sub add_our_routine {
my $self = shift;
my $name = shift;


# say "add_our_routine $name " . $::PKGNAME;
say "panic: unexpected package name $name" if $name =~ qr/\:\:/;
$CURPKG->{$name} //= { name => $name, file => $COMPILING::FILE, line => $self->line };
# say "CORE $::CORE adding name $name to CURPAD $::CURPAD in $::PKGNAME";
$CURPAD->{$name} //= $CURPKG->{$name};  # the lexical alias
$self;
}

## method add_variable ($name)
sub add_variable {
my $self = shift;
my $name = shift;


if (($::SCOPE//'') eq 'our') {
$self->add_our_variable($name);
}
else {
$self->add_my_variable($name);
}
$self;
}

## method add_my_variable ($name)
sub add_my_variable {
my $self = shift;
my $name = shift;


# say "add_my_variable $name";
if (substr($name, 0, 1) eq '&') {
$CURPAD->{$name} //= { name => $name, file => $COMPILING::FILE, line => $self->line };
if ($name =~ s/\:\(.*//) {
$CURPAD->{$name} //= { name => $name, file => $COMPILING::FILE, line => $self->line };
}
return $self;
}
if ($name eq '$_' or $name =~ s/\^|\://) {   # XXX hack
;
}
elsif (my $old = $CURPAD->{$name}) {
my $ofile = $old->{'file'} // '';
my $oline = $old->{'line'} // '???';
if ($ofile) {
if ($ofile ne $COMPILING::FILE) {
$self->worry("Redeclaration of $name (from $ofile line $oline)");
}
else {
$self->worry("Redeclaration of $name (from line $oline)");
}
}
else {
$self->worry("Redeclaration of $name");
}
}
$CURPAD->{$name} //= { name => $name, file => $COMPILING::FILE, line => $self->line };
$self;
}

## method add_our_variable ($name)
sub add_our_variable {
my $self = shift;
my $name = shift;


# say "add_our_variable $name " . $::PKGNAME;
say "panic: unexpected package name $name" if $name =~ qr/\:\:/;
$CURPKG->{$name} //= { name => $name, file => $COMPILING::FILE, line => $self->line };
# say "CORE $::CORE adding variable $name to CURPAD $::CURPAD in $::PKGNAME";
$CURPAD->{$name} //= $CURPKG->{$name};  # the lexical alias
$self;
}

## method check_variable ($variable)
sub check_variable {
my $self = shift;
my $variable = shift;


my $name = $variable->Str;
# say "check_variable $name";
my ($sigil, $twigil, $first) = $name =~ qr/(\W)(\W?)(.?)/;
do { my $_ = $twigil; if ((0)) {}
elsif ($_ eq '') {
my $ok = 0;
$ok = 1 if $name =~ qr/::/;
$ok ||= $::IN_DECL;
$ok ||= $sigil eq '&';
$ok ||= $first lt 'A';
$ok ||= $self->is_known($name);
if (not $ok) {
$variable->worry("Variable $name is not predeclared");
}
}
elsif ($_ eq '^') {
my $siggy = $CURPAD->{'$?GOTSIG'}//'';
if ($siggy) { $variable->panic("Placeholder variable $name cannot override existing signature $siggy"); }
$self->add_my_variable($name);
}
elsif ($_ eq ':') {
$self->add_my_variable($name);
}
elsif ($_ eq '?') {
if ($name =~ qr/\:\:/) {
$name = $self->canonicalize_name($name);
$variable->worry("Unrecognized variable: $name") unless $name =~ qr/^(CALLER|CONTEXT|OUTER|MY|SETTING|CORE)\:\:/;
}
else {
my $v;
do { my $_ = $name; if ((0)) {}
elsif ($_ eq '$?FILE') { $v = $COMPILING::FILE; }
elsif ($_ eq '$?LINE') { $v = $variable->lineof($variable->{_pos}); }
elsif ($_ eq '$?POSITION') { $v = $variable->{_pos}; }

elsif ($_ eq '$?PARSER') { $v = $::PARSER; }
elsif ($_ eq '$?LANG') { $v = $::LANG; }

elsif ($_ eq '$?SCOPE') { $v = $::CURPAD; }

elsif ($_ eq '$?PACKAGE') { $v = $::CURPKG; }
elsif ($_ eq '$?MODULE') { $v = $::CURPKG; } #  XXX should scan
elsif ($_ eq '$?CLASS') { $v = $::CURPKG; } #  XXX should scan
elsif ($_ eq '$?ROLE') { $v = $::CURPKG; } #  XXX should scan
elsif ($_ eq '$?GRAMMAR') { $v = $::CURPKG; } #  XXX should scan

elsif ($_ eq '$?PACKAGENAME') { $v = $::PKGNAME; }

elsif ($_ eq '$?OS') { $v = 'unimpl'; }
elsif ($_ eq '$?DISTRO') { $v = 'unimpl'; }
elsif ($_ eq '$?VM') { $v = 'unimpl'; }
elsif ($_ eq '$?XVM') { $v = 'unimpl'; }
elsif ($_ eq '$?PERL') { $v = 'unimpl'; }

elsif ($_ eq '$?USAGE') { $v = 'unimpl'; }

elsif ($_ eq '&?ROUTINE') { $v = 'unimpl'; }
elsif ($_ eq '&?BLOCK') { $v = 'unimpl'; }

elsif ($_ eq '%?CONFIG') { $v = 'unimpl'; }
elsif ($_ eq '%?DEEPMAGIC') { $v = 'unimpl'; }

else { $variable->worry("Unrecognized variable: $name"); }
};
$variable->{'value'} = $v if $v;
}
}
};
$self;
}

# The internal precedence levels are *not* part of the public interface.
# The current values are mere implementation; they may change at any time.
# Users should specify precedence only in relation to existing levels.

our %term            = ('dba' => ('term')            , 'prec' => 'z=');
our %methodcall      = ('dba' => ('methodcall')      , 'prec' => 'y=', 'assoc' => 'unary', 'uassoc' => 'left', 'fiddly' => 1);
our %autoincrement   = ('dba' => ('autoincrement')   , 'prec' => 'x=', 'assoc' => 'unary', 'uassoc' => 'non');
our %exponentiation  = ('dba' => ('exponentiation')  , 'prec' => 'w=', 'assoc' => 'right');
our %symbolic_unary  = ('dba' => ('symbolic unary')  , 'prec' => 'v=', 'assoc' => 'unary', 'uassoc' => 'left');
our %multiplicative  = ('dba' => ('multiplicative')  , 'prec' => 'u=', 'assoc' => 'left');
our %additive        = ('dba' => ('additive')        , 'prec' => 't=', 'assoc' => 'left');
our %replication     = ('dba' => ('replication')     , 'prec' => 's=', 'assoc' => 'left');
our %concatenation   = ('dba' => ('concatenation')   , 'prec' => 'r=', 'assoc' => 'list');
our %junctive_and    = ('dba' => ('junctive and')    , 'prec' => 'q=', 'assoc' => 'list');
our %junctive_or     = ('dba' => ('junctive or')     , 'prec' => 'p=', 'assoc' => 'list');
our %named_unary     = ('dba' => ('named unary')     , 'prec' => 'o=', 'assoc' => 'unary', 'uassoc' => 'left');
our %nonchaining     = ('dba' => ('nonchaining')     , 'prec' => 'n=', 'assoc' => 'non', 'diffy' => 1);
our %chaining        = ('dba' => ('chaining')        , 'prec' => 'm=', 'assoc' => 'chain', 'diffy' => 1, 'iffy' => 1);
our %tight_and       = ('dba' => ('tight and')       , 'prec' => 'l=', 'assoc' => 'list');
our %tight_or        = ('dba' => ('tight or')        , 'prec' => 'k=', 'assoc' => 'list');
our %conditional     = ('dba' => ('conditional')     , 'prec' => 'j=', 'assoc' => 'right', 'fiddly' => 1);
our %item_assignment = ('dba' => ('item assignment') , 'prec' => 'i=', 'assoc' => 'right', 'fiddly' => 1);
our %loose_unary     = ('dba' => ('loose unary')     , 'prec' => 'h=', 'assoc' => 'unary', 'uassoc' => 'left');
our %comma           = ('dba' => ('comma')           , 'prec' => 'g=', 'assoc' => 'list', 'nextterm' => 'nulltermish', 'fiddly' => 1);
our %list_infix      = ('dba' => ('list infix')      , 'prec' => 'f=', 'assoc' => 'list');
our %list_assignment = ('dba' => ('list assignment') , 'prec' => 'i=', 'assoc' => 'right', 'sub' => 'e=', 'fiddly' => 1);
our %list_prefix     = ('dba' => ('list prefix')     , 'prec' => 'e=', 'assoc' => 'unary', 'uassoc' => 'left');
our %loose_and       = ('dba' => ('loose and')       , 'prec' => 'd=', 'assoc' => 'list');
our %loose_or        = ('dba' => ('loose or')        , 'prec' => 'c=', 'assoc' => 'list');
our %sequencer       = ('dba' => ('sequencer')       , 'prec' => 'b=', 'assoc' => 'list', 'nextterm' => 'statement', 'fiddly' => 1);
our %LOOSEST         = ('dba' => ('LOOSEST')         , 'prec' => 'a=!');
our %terminator      = ('dba' => ('terminator')      , 'prec' => 'a=', 'assoc' => 'list');

# "epsilon" tighter than terminator
#constant $LOOSEST = %LOOSEST<prec>;
my $LOOSEST = "a=!"; # XXX preceding line is busted
my $item_assignment_prec = 'i=';


{ package STD::PrecOp;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;

# This is hopefully called on a match to mix in operator info by type.
##     method coerce (Match $m)
sub coerce {
my $self = shift;
my $m = shift;


# $m but= ::?CLASS;
my $var = (ref($self)||$self) . '::o';
my $d = do { no strict 'refs'; \%{$var}}; 
if (not $d->{transparent}) {
for (keys(%$d)) { $m->{O}{$_} //= $d->{$_} };
$m->deb("coercing to " . $self) if $::DEBUG & DEBUG::EXPR;
}
$m->{O}{kind} = (ref($self)||$self);
return $m;
}

} ## end role

{ package STD::Transparent;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp)); our %o = ('transparent' => 1);
} ## end class

{ package STD::Term;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %term;
} ## end class
{ package STD::Methodcall;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %methodcall;
} ## end class
{ package STD::Autoincrement;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %autoincrement;
} ## end class
{ package STD::Exponentiation;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %exponentiation;
} ## end class
{ package STD::Symbolic_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %symbolic_unary;
} ## end class
{ package STD::Multiplicative;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %multiplicative;
} ## end class
{ package STD::Additive;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %additive;
} ## end class
{ package STD::Replication;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %replication;
} ## end class
{ package STD::Concatenation;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %concatenation;
} ## end class
{ package STD::Junctive_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %junctive_and;
} ## end class
{ package STD::Junctive_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %junctive_or;
} ## end class
{ package STD::Named_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %named_unary;
} ## end class
{ package STD::Nonchaining;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %nonchaining;
} ## end class
{ package STD::Chaining;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %chaining;
} ## end class
{ package STD::Tight_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %tight_and;
} ## end class
{ package STD::Tight_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %tight_or;
} ## end class
{ package STD::Conditional;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %conditional;
} ## end class
{ package STD::Item_assignment;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %item_assignment;
} ## end class
{ package STD::Loose_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_unary;
} ## end class
{ package STD::Comma;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %comma;
} ## end class
{ package STD::List_infix;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_infix;
} ## end class
{ package STD::List_assignment;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_assignment;
} ## end class
{ package STD::List_prefix;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_prefix;
} ## end class
{ package STD::Loose_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_and;
} ## end class
{ package STD::Loose_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_or;
} ## end class
{ package STD::Sequencer;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %sequencer;
} ## end class
{ package STD::Terminator;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %terminator;
} ## end class

# Categories are designed to be easily extensible in derived grammars
# by merely adding more rules in the same category.  The rules within
# a given category start with the category name followed by a differentiating
# adverbial qualifier to serve (along with the category) as the longer name.

# The endsym context, if specified, says what to implicitly check for in each
# rule right after the initial <sym>.  Normally this is used to make sure
# there's appropriate whitespace.  # Note that endsym isn't called if <sym>
# isn't called.

local $::endsym =  "null";
local $::endargs =  -1;

#proto token category { <...> }
sub category__PEEK { $_[0]->_AUTOLEXpeek('category:*',$retree); }
sub category {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'category') {
$C->deb("Fate passed to category: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'category:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("category trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "category", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_000category (:$sym is context<rw> = 'category')
##      token category:category { <sym> }

sub category__S_000category__PEEK { $_[0]->_AUTOLEXpeek('category__S_000category',$retree) }
sub category__S_000category {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'category';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_000category", 
$C->_PATTERN(qr/\Gcategory/)
);
}

## token category__S_001sigil (:$sym is context<rw> = 'sigil')
##      token category:sigil { <sym> }

sub category__S_001sigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_001sigil',$retree) }
sub category__S_001sigil {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_001sigil", 
$C->_PATTERN(qr/\Gsigil/)
);
}
#proto token sigil { <...> }
sub sigil__PEEK { $_[0]->_AUTOLEXpeek('sigil:*',$retree); }
sub sigil {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'sigil') {
$C->deb("Fate passed to sigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'sigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "sigil", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_002twigil (:$sym is context<rw> = 'twigil')
##      token category:twigil { <sym> }

sub category__S_002twigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_002twigil',$retree) }
sub category__S_002twigil {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'twigil';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_002twigil", 
$C->_PATTERN(qr/\Gtwigil/)
);
}
#proto token twigil { <...> }
sub twigil__PEEK { $_[0]->_AUTOLEXpeek('twigil:*',$retree); }
sub twigil {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'twigil') {
$C->deb("Fate passed to twigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'twigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("twigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "twigil", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_003special_variable (:$sym is context<rw> = 'special_variable')
##      token category:special_variable { <sym> }

sub category__S_003special_variable__PEEK { $_[0]->_AUTOLEXpeek('category__S_003special_variable',$retree) }
sub category__S_003special_variable {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'special_variable';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_003special_variable", 
$C->_PATTERN(qr/\Gspecial_variable/)
);
}
#proto token special_variable { <...> }
sub special_variable__PEEK { $_[0]->_AUTOLEXpeek('special_variable:*',$retree); }
sub special_variable {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'special_variable') {
$C->deb("Fate passed to special_variable: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "special_variable", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_004version (:$sym is context<rw> = 'version')
##      token category:version { <sym> }

sub category__S_004version__PEEK { $_[0]->_AUTOLEXpeek('category__S_004version',$retree) }
sub category__S_004version {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'version';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_004version", 
$C->_PATTERN(qr/\Gversion/)
);
}
#proto token version { <...> }
sub version__PEEK { $_[0]->_AUTOLEXpeek('version:*',$retree); }
sub version {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'version') {
$C->deb("Fate passed to version: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'version:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("version trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "version", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_005module_name (:$sym is context<rw> = 'module_name')
##      token category:module_name { <sym> }

sub category__S_005module_name__PEEK { $_[0]->_AUTOLEXpeek('category__S_005module_name',$retree) }
sub category__S_005module_name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'module_name';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_005module_name", 
$C->_PATTERN(qr/\Gmodule_name/)
);
}
#proto token module_name { <...> }
sub module_name__PEEK { $_[0]->_AUTOLEXpeek('module_name:*',$retree); }
sub module_name {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'module_name') {
$C->deb("Fate passed to module_name: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'module_name:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("module_name trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "module_name", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_006noun (:$sym is context<rw> = 'noun')
##      token category:noun { <sym> }

sub category__S_006noun__PEEK { $_[0]->_AUTOLEXpeek('category__S_006noun',$retree) }
sub category__S_006noun {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'noun';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_006noun", 
$C->_PATTERN(qr/\Gnoun/)
);
}
#proto token noun { <...> }
sub noun__PEEK { $_[0]->_AUTOLEXpeek('noun:*',$retree); }
sub noun {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'noun') {
$C->deb("Fate passed to noun: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'noun:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("noun trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "noun", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_007value (:$sym is context<rw> = 'value')
##      token category:value { <sym> }

sub category__S_007value__PEEK { $_[0]->_AUTOLEXpeek('category__S_007value',$retree) }
sub category__S_007value {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'value';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_007value", 
$C->_PATTERN(qr/\Gvalue/)
);
}
#proto token value { <...> }
sub value__PEEK { $_[0]->_AUTOLEXpeek('value:*',$retree); }
sub value {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'value') {
$C->deb("Fate passed to value: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'value:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("value trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "value", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_008term (:$sym is context<rw> = 'term')
##      token category:term { <sym> }

sub category__S_008term__PEEK { $_[0]->_AUTOLEXpeek('category__S_008term',$retree) }
sub category__S_008term {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'term';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_008term", 
$C->_PATTERN(qr/\Gterm/)
);
}
#proto token term { <...> }
sub term__PEEK { $_[0]->_AUTOLEXpeek('term:*',$retree); }
sub term {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'term') {
$C->deb("Fate passed to term: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "term", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_009number (:$sym is context<rw> = 'number')
##      token category:number { <sym> }

sub category__S_009number__PEEK { $_[0]->_AUTOLEXpeek('category__S_009number',$retree) }
sub category__S_009number {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'number';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_009number", 
$C->_PATTERN(qr/\Gnumber/)
);
}
#proto token number { <...> }
sub number__PEEK { $_[0]->_AUTOLEXpeek('number:*',$retree); }
sub number {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'number') {
$C->deb("Fate passed to number: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'number:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("number trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "number", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_010quote (:$sym is context<rw> = 'quote')
##      token category:quote { <sym> }

sub category__S_010quote__PEEK { $_[0]->_AUTOLEXpeek('category__S_010quote',$retree) }
sub category__S_010quote {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_010quote", 
$C->_PATTERN(qr/\Gquote/)
);
}
#proto token quote () { <...> }
sub quote__PEEK { $_[0]->_AUTOLEXpeek('quote:*',$retree); }
sub quote {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quote') {
$C->deb("Fate passed to quote: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quote", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_011prefix (:$sym is context<rw> = 'prefix')
##      token category:prefix { <sym> }

sub category__S_011prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_011prefix',$retree) }
sub category__S_011prefix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_011prefix", 
$C->_PATTERN(qr/\Gprefix/)
);
}
#proto token prefix is unary is defequiv(%symbolic_unary) { <...> }
sub prefix__PEEK { $_[0]->_AUTOLEXpeek('prefix:*',$retree); }
sub prefix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'prefix') {
$C->deb("Fate passed to prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_012infix (:$sym is context<rw> = 'infix')
##      token category:infix { <sym> }

sub category__S_012infix__PEEK { $_[0]->_AUTOLEXpeek('category__S_012infix',$retree) }
sub category__S_012infix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_012infix", 
$C->_PATTERN(qr/\Ginfix/)
);
}
#proto token infix is binary is defequiv(%additive) { <...> }
sub infix__PEEK { $_[0]->_AUTOLEXpeek('infix:*',$retree); }
sub infix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix') {
$C->deb("Fate passed to infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_013postfix (:$sym is context<rw> = 'postfix')
##      token category:postfix { <sym> }

sub category__S_013postfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_013postfix',$retree) }
sub category__S_013postfix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postfix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_013postfix", 
$C->_PATTERN(qr/\Gpostfix/)
);
}
#proto token postfix is unary is defequiv(%autoincrement) { <...> }
sub postfix__PEEK { $_[0]->_AUTOLEXpeek('postfix:*',$retree); }
sub postfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'postfix') {
$C->deb("Fate passed to postfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_014dotty (:$sym is context<rw> = 'dotty')
##      token category:dotty { <sym> }

sub category__S_014dotty__PEEK { $_[0]->_AUTOLEXpeek('category__S_014dotty',$retree) }
sub category__S_014dotty {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'dotty';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_014dotty", 
$C->_PATTERN(qr/\Gdotty/)
);
}
#proto token dotty (:$endsym is context = 'unspacey') { <...> }
sub dotty__PEEK { $_[0]->_AUTOLEXpeek('dotty:*',$retree); }
sub dotty {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'dotty') {
$C->deb("Fate passed to dotty: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dotty:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "dotty", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_015circumfix (:$sym is context<rw> = 'circumfix')
##      token category:circumfix { <sym> }

sub category__S_015circumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_015circumfix',$retree) }
sub category__S_015circumfix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'circumfix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_015circumfix", 
$C->_PATTERN(qr/\Gcircumfix/)
);
}
#proto token circumfix { <...> }
sub circumfix__PEEK { $_[0]->_AUTOLEXpeek('circumfix:*',$retree); }
sub circumfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'circumfix') {
$C->deb("Fate passed to circumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'circumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("circumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "circumfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_016postcircumfix (:$sym is context<rw> = 'postcircumfix')
##      token category:postcircumfix { <sym> }

sub category__S_016postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_016postcircumfix',$retree) }
sub category__S_016postcircumfix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postcircumfix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_016postcircumfix", 
$C->_PATTERN(qr/\Gpostcircumfix/)
);
}
#proto token postcircumfix is unary { <...> }  # unary as far as EXPR knows...
sub postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix:*',$retree); }
sub postcircumfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'postcircumfix') {
$C->deb("Fate passed to postcircumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postcircumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postcircumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postcircumfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_017quote_mod (:$sym is context<rw> = 'quote_mod')
##      token category:quote_mod { <sym> }

sub category__S_017quote_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_017quote_mod',$retree) }
sub category__S_017quote_mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote_mod';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_017quote_mod", 
$C->_PATTERN(qr/\Gquote_mod/)
);
}
#proto token quote_mod { <...> }
sub quote_mod__PEEK { $_[0]->_AUTOLEXpeek('quote_mod:*',$retree); }
sub quote_mod {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quote_mod') {
$C->deb("Fate passed to quote_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote_mod:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quote_mod", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_018trait_verb (:$sym is context<rw> = 'trait_verb')
##      token category:trait_verb { <sym> }

sub category__S_018trait_verb__PEEK { $_[0]->_AUTOLEXpeek('category__S_018trait_verb',$retree) }
sub category__S_018trait_verb {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'trait_verb';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_018trait_verb", 
$C->_PATTERN(qr/\Gtrait_verb/)
);
}
#proto token trait_verb (:$endsym is context = 'spacey') { <...> }
sub trait_verb__PEEK { $_[0]->_AUTOLEXpeek('trait_verb:*',$retree); }
sub trait_verb {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'trait_verb') {
$C->deb("Fate passed to trait_verb: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_verb:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_verb trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "trait_verb", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_019trait_auxiliary (:$sym is context<rw> = 'trait_auxiliary')
##      token category:trait_auxiliary { <sym> }

sub category__S_019trait_auxiliary__PEEK { $_[0]->_AUTOLEXpeek('category__S_019trait_auxiliary',$retree) }
sub category__S_019trait_auxiliary {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'trait_auxiliary';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_019trait_auxiliary", 
$C->_PATTERN(qr/\Gtrait_auxiliary/)
);
}
#proto token trait_auxiliary (:$endsym is context = 'spacey') { <...> }
sub trait_auxiliary__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary:*',$retree); }
sub trait_auxiliary {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'trait_auxiliary') {
$C->deb("Fate passed to trait_auxiliary: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_auxiliary:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_auxiliary trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "trait_auxiliary", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_020type_declarator (:$sym is context<rw> = 'type_declarator')
##      token category:type_declarator { <sym> }

sub category__S_020type_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_020type_declarator',$retree) }
sub category__S_020type_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'type_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_020type_declarator", 
$C->_PATTERN(qr/\Gtype_declarator/)
);
}
#proto token type_declarator () { <...> }
sub type_declarator__PEEK { $_[0]->_AUTOLEXpeek('type_declarator:*',$retree); }
sub type_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'type_declarator') {
$C->deb("Fate passed to type_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'type_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "type_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_021scope_declarator (:$sym is context<rw> = 'scope_declarator')
##      token category:scope_declarator { <sym> }

sub category__S_021scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_021scope_declarator',$retree) }
sub category__S_021scope_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'scope_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_021scope_declarator", 
$C->_PATTERN(qr/\Gscope_declarator/)
);
}
#proto token scope_declarator (:$endsym is context = 'nofun') { <...> }
sub scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator:*',$retree); }
sub scope_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'scope_declarator') {
$C->deb("Fate passed to scope_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'scope_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scope_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "scope_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_022package_declarator (:$sym is context<rw> = 'package_declarator')
##      token category:package_declarator { <sym> }

sub category__S_022package_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_022package_declarator',$retree) }
sub category__S_022package_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'package_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_022package_declarator", 
$C->_PATTERN(qr/\Gpackage_declarator/)
);
}
#proto token package_declarator () { <...> }
sub package_declarator__PEEK { $_[0]->_AUTOLEXpeek('package_declarator:*',$retree); }
sub package_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'package_declarator') {
$C->deb("Fate passed to package_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'package_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("package_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "package_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_023multi_declarator (:$sym is context<rw> = 'multi_declarator')
##      token category:multi_declarator { <sym> }

sub category__S_023multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_023multi_declarator',$retree) }
sub category__S_023multi_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'multi_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_023multi_declarator", 
$C->_PATTERN(qr/\Gmulti_declarator/)
);
}
#proto token multi_declarator () { <...> }
sub multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator:*',$retree); }
sub multi_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'multi_declarator') {
$C->deb("Fate passed to multi_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'multi_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("multi_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "multi_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_024routine_declarator (:$sym is context<rw> = 'routine_declarator')
##      token category:routine_declarator { <sym> }

sub category__S_024routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_024routine_declarator',$retree) }
sub category__S_024routine_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'routine_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_024routine_declarator", 
$C->_PATTERN(qr/\Groutine_declarator/)
);
}
#proto token routine_declarator () { <...> }
sub routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator:*',$retree); }
sub routine_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'routine_declarator') {
$C->deb("Fate passed to routine_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "routine_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_025regex_declarator (:$sym is context<rw> = 'regex_declarator')
##      token category:regex_declarator { <sym> }

sub category__S_025regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_025regex_declarator',$retree) }
sub category__S_025regex_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'regex_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_025regex_declarator", 
$C->_PATTERN(qr/\Gregex_declarator/)
);
}
#proto token regex_declarator () { <...> }
sub regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator:*',$retree); }
sub regex_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'regex_declarator') {
$C->deb("Fate passed to regex_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "regex_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_026statement_prefix (:$sym is context<rw> = 'statement_prefix')
##      token category:statement_prefix { <sym> }

sub category__S_026statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_026statement_prefix',$retree) }
sub category__S_026statement_prefix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_prefix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_026statement_prefix", 
$C->_PATTERN(qr/\Gstatement_prefix/)
);
}
#proto rule  statement_prefix () { <...> }
sub statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix:*',$retree); }
sub statement_prefix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_prefix') {
$C->deb("Fate passed to statement_prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_prefix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_027statement_control (:$sym is context<rw> = 'statement_control')
##      token category:statement_control { <sym> }

sub category__S_027statement_control__PEEK { $_[0]->_AUTOLEXpeek('category__S_027statement_control',$retree) }
sub category__S_027statement_control {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_control';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_027statement_control", 
$C->_PATTERN(qr/\Gstatement_control/)
);
}
#proto rule  statement_control (:$endsym is context = 'spacey') { <...> }
sub statement_control__PEEK { $_[0]->_AUTOLEXpeek('statement_control:*',$retree); }
sub statement_control {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_control') {
$C->deb("Fate passed to statement_control: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_control", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_028statement_mod_cond (:$sym is context<rw> = 'statement_mod_cond')
##      token category:statement_mod_cond { <sym> }

sub category__S_028statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('category__S_028statement_mod_cond',$retree) }
sub category__S_028statement_mod_cond {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_mod_cond';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_028statement_mod_cond", 
$C->_PATTERN(qr/\Gstatement_mod_cond/)
);
}
#proto rule  statement_mod_cond (:$endsym is context = 'nofun') { <...> }
sub statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond:*',$retree); }
sub statement_mod_cond {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_mod_cond') {
$C->deb("Fate passed to statement_mod_cond: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_cond:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_cond trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_mod_cond", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_029statement_mod_loop (:$sym is context<rw> = 'statement_mod_loop')
##      token category:statement_mod_loop { <sym> }

sub category__S_029statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('category__S_029statement_mod_loop',$retree) }
sub category__S_029statement_mod_loop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_mod_loop';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_029statement_mod_loop", 
$C->_PATTERN(qr/\Gstatement_mod_loop/)
);
}
#proto rule  statement_mod_loop (:$endsym is context = 'nofun') { <...> }
sub statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop:*',$retree); }
sub statement_mod_loop {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_mod_loop') {
$C->deb("Fate passed to statement_mod_loop: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_loop:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_loop trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_mod_loop", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_030infix_prefix_meta_operator (:$sym is context<rw> = 'infix_prefix_meta_operator')
##      token category:infix_prefix_meta_operator { <sym> }

sub category__S_030infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_030infix_prefix_meta_operator',$retree) }
sub category__S_030infix_prefix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_prefix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_030infix_prefix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_prefix_meta_operator/)
);
}
#proto token infix_prefix_meta_operator is binary { <...> }
sub infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator:*',$retree); }
sub infix_prefix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix_prefix_meta_operator') {
$C->deb("Fate passed to infix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_prefix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_031infix_postfix_meta_operator (:$sym is context<rw> = 'infix_postfix_meta_operator')
##      token category:infix_postfix_meta_operator { <sym> }

sub category__S_031infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_031infix_postfix_meta_operator',$retree) }
sub category__S_031infix_postfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_postfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_031infix_postfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_postfix_meta_operator/)
);
}
#proto token infix_postfix_meta_operator ($op) is binary { <...> }
sub infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator:*',$retree); }
sub infix_postfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix_postfix_meta_operator') {
$C->deb("Fate passed to infix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_postfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_032infix_circumfix_meta_operator (:$sym is context<rw> = 'infix_circumfix_meta_operator')
##      token category:infix_circumfix_meta_operator { <sym> }

sub category__S_032infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_032infix_circumfix_meta_operator',$retree) }
sub category__S_032infix_circumfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_circumfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_032infix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_circumfix_meta_operator/)
);
}
#proto token infix_circumfix_meta_operator is binary { <...> }
sub infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator:*',$retree); }
sub infix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix_circumfix_meta_operator') {
$C->deb("Fate passed to infix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_circumfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_033postfix_prefix_meta_operator (:$sym is context<rw> = 'postfix_prefix_meta_operator')
##      token category:postfix_prefix_meta_operator { <sym> }

sub category__S_033postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_033postfix_prefix_meta_operator',$retree) }
sub category__S_033postfix_prefix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postfix_prefix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_033postfix_prefix_meta_operator", 
$C->_PATTERN(qr/\Gpostfix_prefix_meta_operator/)
);
}
#proto token postfix_prefix_meta_operator is unary { <...> }
sub postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator:*',$retree); }
sub postfix_prefix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'postfix_prefix_meta_operator') {
$C->deb("Fate passed to postfix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postfix_prefix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_034prefix_postfix_meta_operator (:$sym is context<rw> = 'prefix_postfix_meta_operator')
##      token category:prefix_postfix_meta_operator { <sym> }

sub category__S_034prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_034prefix_postfix_meta_operator',$retree) }
sub category__S_034prefix_postfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix_postfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_034prefix_postfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_postfix_meta_operator/)
);
}
#proto token prefix_postfix_meta_operator is unary { <...> }
sub prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator:*',$retree); }
sub prefix_postfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'prefix_postfix_meta_operator') {
$C->deb("Fate passed to prefix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix_postfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_035prefix_circumfix_meta_operator (:$sym is context<rw> = 'prefix_circumfix_meta_operator')
##      token category:prefix_circumfix_meta_operator { <sym> }

sub category__S_035prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_035prefix_circumfix_meta_operator',$retree) }
sub category__S_035prefix_circumfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix_circumfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_035prefix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_circumfix_meta_operator/)
);
}
#proto token prefix_circumfix_meta_operator is unary { <...> }
sub prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator:*',$retree); }
sub prefix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'prefix_circumfix_meta_operator') {
$C->deb("Fate passed to prefix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix_circumfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_036terminator (:$sym is context<rw> = 'terminator')
##      token category:terminator { <sym> }

sub category__S_036terminator__PEEK { $_[0]->_AUTOLEXpeek('category__S_036terminator',$retree) }
sub category__S_036terminator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'terminator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_036terminator", 
$C->_PATTERN(qr/\Gterminator/)
);
}
#proto token terminator { <...> }
sub terminator__PEEK { $_[0]->_AUTOLEXpeek('terminator:*',$retree); }
sub terminator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'terminator') {
$C->deb("Fate passed to terminator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'terminator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("terminator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "terminator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token unspacey
##      token unspacey { <.unsp>? }

sub unspacey__PEEK { $_[0]->_AUTOLEXpeek('unspacey',$retree) }
sub unspacey {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unspacey", 
$C->_OPTr(sub { my $C=shift;
$C->unsp
})
);
}
## token spacey
##      token spacey { <?before \s | '#'> }

sub spacey__PEEK { $_[0]->_AUTOLEXpeek('spacey',$retree) }
sub spacey {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "spacey", 
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'spacey_01') {
$C->deb("Fate passed to spacey_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'spacey_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("spacey_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}
## token nofun
##      token nofun { <!before '(' | '.(' | '\\' > }

sub nofun__PEEK { $_[0]->_AUTOLEXpeek('nofun',$retree) }
sub nofun {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nofun", 
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'nofun_01') {
$C->deb("Fate passed to nofun_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'nofun_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nofun_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_EXACT('.(')
},
sub { my $C=shift;
$C->_EXACT('\\')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
);
}

# Lexical routines

## token ws
##      token ws {
##          :my @stub = return self if @*MEMOS[self.pos]<ws> :exists;
##          :my $startpos = self.pos;
##      
##          :dba('whitespace')
##          [
##              | \h+ <![#\s\\]> { @*MEMOS[$.pos]<ws> = $startpos; }   # common case
##              | <?before \w> <?after \w> :::
##                  { @*MEMOS[$startpos]<ws> = undef; }
##                  <!>        # must \s+ between words
##          ]
##          ||
##          [
##          | <.unsp>
##          | <.vws> <.heredoc>
##          | <.unv>
##          | $ { $.moreinput }
##          ]*
##      
##          {{
##              if ($.pos == $startpos) {
##                  @*MEMOS[$.pos]<ws> = undef;
##              }
##              else {
##                  @*MEMOS[$.pos]<ws> = $startpos;
##                  @*MEMOS[$.pos]<endstmt> = @*MEMOS[$startpos]<endstmt>
##                      if @*MEMOS[$startpos]<endstmt> :exists;
##              }
##          }}
##      }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $::MEMOS[$self->{_pos}]{'ws'};
my $startpos = $self->{_pos};


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "ws", 
do { my @gather;
eval { push @gather, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'ws_01') {
$C->deb("Fate passed to ws_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[#\s\\]/)
}))) {
scalar(do {
$::MEMOS[$C->{_pos}]{'ws'} = $startpos; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
}, scalar(do {
$::MEMOS[$startpos]{'ws'} = undef; 
}, $C))
}, $C->_COMMITRULE())
}, $C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
scalar(do {

if (($C->{_pos} == $startpos)) {
$::MEMOS[$C->{_pos}]{'ws'} = undef;
}
else {
$::MEMOS[$C->{_pos}]{'ws'} = $startpos;
$::MEMOS[$C->{_pos}]{'endstmt'} = $::MEMOS[$startpos]{'endstmt'}
if exists $::MEMOS[$startpos]{'endstmt'};
}

}, $C)
}, $C->_STARr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'ws_05') {
$C->deb("Fate passed to ws_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->heredoc
}, $C->vws)
},
sub { my $C=shift;
$C->unv
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$C->moreinput 
}, $C)
}, $C->_PATTERN(qr/\G\z/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))} or do { die $@ if $@ };
@gather;
}
);
}

## token unsp
##      token unsp {
##          \\ <?before [\s|'#'] >
##          :dba('unspace')
##          [
##          | <.vws>                     {*}                             #= vwhite
##          | <.unv>                  {*}                                #= unv
##          | $ { $.moreinput }
##          ]*
##      }

sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp',$retree) }
sub unsp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unsp", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unsp_02') {
$C->deb("Fate passed to unsp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unsp_03') {
$C->deb("Fate passed to unsp_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->vws)) {
$C->_REDUCE($S, 'unsp_vwhite');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->unv)) {
$C->_REDUCE($S, 'unsp_unv');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token vws
##      token vws {
##          :dba('vertical whitespace')
##          \v
##          [ '#DEBUG -1' { say "DEBUG"; $STD::DEBUG = $*DEBUG = -1; } ]?
##      }

sub vws__PEEK { $_[0]->_AUTOLEXpeek('vws',$retree) }
sub vws {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "vws", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\n]/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('#DEBUG -1'))) {
scalar(do {
say "DEBUG"; $STD::DEBUG = $::DEBUG = -1; 
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# We provide two mechanisms here:
# 1) define $*moreinput, or
# 2) override moreinput method
## method moreinput ()
sub moreinput {
my $self = shift;


$::moreinput->() if $::moreinput;
}

## token unv
##      token unv {
##         :dba('horizontal whitespace')
##         [
##         | \h+                 {*}                                    #= hwhite
##         | <?before '='> ^^ <.pod_comment>  {*}                    #= pod
##         | \h* '#' [
##               |  <?opener>
##                  [ <!after ^^ . > || <.panic: "Can't use embedded comments in column 1"> ]
##                  <.quibble($.cursor_fresh( ::STD::Q ))>   {*}                               #= embedded
##               | {} \N*            {*}                                 #= end
##               ]
##          ]
##      }

sub unv__PEEK { $_[0]->_AUTOLEXpeek('unv',$retree) }
sub unv {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unv", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unv_01') {
$C->deb("Fate passed to unv_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
$C->_REDUCE($S, 'unv_hwhite');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:^)/))) {
do {
if (my ($C) = ($C->pod_comment)) {
$C->_REDUCE($S, 'unv_pod');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('#'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unv_03') {
$C->deb("Fate passed to unv_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->opener
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=(?s:.))(?m:^)/)
})
})} 
or
eval { push @gather, $C->panic("Can't use embedded comments in column 1")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->quibble($C->cursor_fresh( 'STD::Q' )))) {
$C->_REDUCE($S, 'unv_embedded');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))) {
$C->_REDUCE($S, 'unv_end');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token ident
##      token ident {
##          <.alpha> \w*
##      }

sub ident__PEEK { $_[0]->_AUTOLEXpeek('ident',$retree) }
sub ident {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "ident", 
$C->_PATTERN(qr/\G[_[:alpha:]]((?:\w)*+)/)
);
}

## token apostrophe
##      token apostrophe {
##          <[ ' \- ]>
##      }

sub apostrophe__PEEK { $_[0]->_AUTOLEXpeek('apostrophe',$retree) }
sub apostrophe {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "apostrophe", 
$C->_PATTERN(qr/\G['\-]/)
);
}

## token identifier
##      token identifier {
##          <.ident> [ <.apostrophe> <.ident> ]*
##      }

sub identifier__PEEK { $_[0]->_AUTOLEXpeek('identifier',$retree) }
sub identifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "identifier", 
do {
if (my ($C) = ($C->ident)) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->apostrophe)) {
$C->ident;
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# XXX We need to parse the pod eventually to support $= variables.

## token pod_comment
##      token pod_comment {
##          ^^ '=' <.unsp>?
##          [
##          | 'begin' \h+ <identifier> ::
##              [
##              ||  .*? "\n=" <.unsp>? 'end' \h+ $<identifier>  \N*          {*} #= tagged
##              ||  .*                                                        {*} #= end
##              ]
##          | 'begin'  :: \h* [ $$ || '#' || <.panic: "Unrecognized token after =begin"> ]
##              [ .*?  "\n=" <.unsp>? 'end'  \N* || <.panic: "=begin without =end"> ]   {*}       #= anon
##          | :: 
##              [ <?before .*? ^^ '=cut'  > <.panic: "Obsolete pod format, please use =begin/=end instead"> ]?
##              \N*                                           {*}       #= misc
##          ]
##      }

sub pod_comment__PEEK { $_[0]->_AUTOLEXpeek('pod_comment',$retree) }
sub pod_comment {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "pod_comment", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'pod_comment_01') {
$C->deb("Fate passed to pod_comment_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pod_comment_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pod_comment_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_tagged')
}, $C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}, $C->_PATTERN(qr/\G\b/))
}, $C->_BACKREFn('identifier'))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G\n=/))
}, $C->_SCANf())} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_end')
}, $C->_SCANg())} or do { die $@ if $@ };
@gather;
}
})
}, $C->_COMMITBRANCH())
}, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))
}, $C->_EXACT('begin'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_anon')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G\n=/))
}, $C->_SCANf())} 
or
eval { push @gather, $C->panic("=begin without =end")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?m:$)/)} 
or
eval { push @gather, $C->_EXACT('#')} 
or
eval { push @gather, $C->panic("Unrecognized token after =begin")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('begin'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_misc')
}, $C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Obsolete pod format, please use =begin/=end instead")
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G\b/)
}, $C->_EXACT('=cut'))
}, $C->_PATTERN(qr/\G(?m:^)/))
}, $C->_SCANf())
}))
})
}))
}, $C->_COMMITBRANCH())
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_EXACT('='))
}, $C->_PATTERN(qr/\G(?m:^)/))
);
}

# Top-level rules

# Note: we only check for the stopper.  We don't check for ^ because
# we might be embedded in something else.
## rule comp_unit
##      rule comp_unit {
##          :my $begin_compunit is context = 1;
##          :my $endargs        is context<rw> = -1;
##      
##          :my $LANG is context;
##          :my $PKGDECL is context = "";
##          :my $PKGNAME is context = "GLOBAL";
##          :my @PKGS is context<rw> = ();
##          :my $PARSER is context<rw>;
##          :my $IN_DECL is context<rw>;
##          :my $INTERPOLATION is context<rw> = '';
##          :my $IN_META is context<rw> = 0;
##          :my $QUASI_QUASH is context<rw>;
##          :my $SCOPE is context = "";
##          :my $SIGIL is context<rw>;
##          :my %MYSTERY is context<rw> = ();
##          :my @MEMOS is context;
##          :my $VOID is context<rw>;
##          :my $INVOCANT_OK is context<rw>;
##          :my $INVOCANT_IS is context<rw>;
##          :my $CURPAD is context<rw>;
##          :my $REALLYADD is context<rw> = 0;
##      
##          :my $CORE is context;
##          :my $CORESETTING is context = "CORE";
##          :my $GLOBAL is context;
##          :my $CURPKG is context;
##          :my $UNIT is context;
##          {{
##              @COMPILING::WORRIES = ();
##              self.load_setting($*CORESETTING);
##              $*UNIT = self.newpad;
##              self.finishpad(1);
##          }}
##          <statementlist>
##          [ <?unitstopper> || <.panic: "Can't understand next input--giving up"> ]
##          { $<CORE> = $*CORE; }
##          # "CHECK" time...
##          {{
##              if @COMPILING::WORRIES {
##                  warn "Potential difficulties:\n  " ~ join( "\n  ", @COMPILING::WORRIES) ~ "\n";
##              }
##      
##              my %post_types;
##              my %unk_types;
##              my %unk_routines;
##              for keys(%*MYSTERY) {
##                  my $p = %*MYSTERY{$_}.<pad>;
##                  if $.is_name($_, $p) {
##                      # types may not be post-declared
##                      %post_types{$_} = %*MYSTERY{$_};
##                      next;
##                  }
##      
##                  next if $.is_known($_, $p);
##      
##                  # just a guess, but good enough to improve error reporting
##                  if $_ lt 'a' {
##                      %unk_types{$_} = %*MYSTERY{$_};
##                  }
##                  else {
##                      %unk_routines{$_} = %*MYSTERY{$_};
##                  }
##              }
##              if %post_types {
##                  my @tmp = sort keys(%post_types);
##                  warn "Illegally post-declared type" ~ ('s' x (@tmp != 1)) ~ ":\n";
##                  for @tmp {
##                      warn "\t$_ used at ", %post_types{$_}.<line>, "\n";
##                  }
##              }
##              if %unk_types {
##                  my @tmp = sort keys(%unk_types);
##                  warn "Undeclared name" ~ ('s' x (@tmp != 1)) ~ ":\n";
##                  for @tmp {
##                      warn "\t$_ used at ", %unk_types{$_}.<line>, "\n";
##                  }
##              }
##              if %unk_routines {
##                  my @tmp = sort keys(%unk_routines);
##                  warn "Undeclared routine" ~ ('s' x (@tmp != 1)) ~ ":\n";
##                  for @tmp {
##                      warn "\t$_ used at ", %unk_routines{$_}.<line>, "\n";
##                  }
##              }
##          }}
##      }

sub comp_unit__PEEK { $_[0]->_AUTOLEXpeek('comp_unit',$retree) }
sub comp_unit {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::begin_compunit =  1;
local $::endargs =  -1;
local $::LANG;
local $::PKGDECL =  "";
local $::PKGNAME =  "GLOBAL";
local @::PKGS =  ();
local $::PARSER;
local $::IN_DECL;
local $::INTERPOLATION =  '';
local $::IN_META =  0;
local $::QUASI_QUASH;
local $::SCOPE =  "";
local $::SIGIL;
local %::MYSTERY =  ();
local @::MEMOS;
local $::VOID;
local $::INVOCANT_OK;
local $::INVOCANT_IS;
local $::CURPAD;
local $::REALLYADD =  0;
local $::CORE;
local $::CORESETTING =  "CORE";
local $::GLOBAL;
local $::CURPKG;
local $::UNIT;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "comp_unit", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

@COMPILING::WORRIES = ();
$self->load_setting($::CORESETTING);
$::UNIT = $self->newpad;
$self->finishpad(1);

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->unitstopper
}))) {
$C->ws;
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Can't understand next input--giving up"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{CORE} = $::CORE; ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

if (@COMPILING::WORRIES) {
warn "Potential difficulties:\n  " . join( "\n  ", @COMPILING::WORRIES) . "\n";
}

my %post_types;
my %unk_types;
my %unk_routines;
for (keys(%::MYSTERY)) {
my $p = $::MYSTERY{$_}->{'pad'};
if ($C->is_name($_, $p)) {
# types may not be post-declared
$post_types{$_} = $::MYSTERY{$_};
next;
}

next if $C->is_known($_, $p);

# just a guess, but good enough to improve error reporting
if ($_ lt 'a') {
$unk_types{$_} = $::MYSTERY{$_};
}
else {
$unk_routines{$_} = $::MYSTERY{$_};
}
}
if (%post_types) {
my @tmp = sort keys(%post_types);
warn "Illegally post-declared type" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
warn "\t$_ used at ", $post_types{$_}->{'line'}, "\n";
}
}
if (%unk_types) {
my @tmp = sort keys(%unk_types);
warn "Undeclared name" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
warn "\t$_ used at ", $unk_types{$_}->{'line'}, "\n";
}
}
if (%unk_routines) {
my @tmp = sort keys(%unk_routines);
warn "Undeclared routine" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
warn "\t$_ used at ", $unk_routines{$_}->{'line'}, "\n";
}
}

}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# Note: because of the possibility of placeholders we can't determine arity of
# the block syntactically, so this must be determined via semantic analysis.
# Also, pblocks used in an if/unless statement do not treat $_ as a placeholder,
# while most other blocks treat $_ as equivalent to $^x.  Therefore the first
# possible place to check arity is not here but in the rule that calls this
# rule.  (Could also be done in a later pass.)

## token pblock ($CURPAD is context<rw> = $*CURPAD)
##      token pblock ($CURPAD is context<rw> = $*CURPAD) {
##          :dba('parameterized block')
##          <?before <.lambda> | '{' >
##          [
##          | <lambda>
##              <.newpad>
##              <signature>
##              <blockoid>
##          | <?before '{'>
##              <.newpad>
##              <blockoid>
##          ] || <.panic: "Malformed block">
##      }

sub pblock__PEEK { $_[0]->_AUTOLEXpeek('pblock',$retree) }
sub pblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "pblock", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'pblock_01') {
$C->deb("Fate passed to pblock_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pblock_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pblock_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->lambda
},
sub { my $C=shift;
$C->_EXACT('{')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'pblock_02') {
$C->deb("Fate passed to pblock_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pblock_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pblock_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['lambda'], sub {
my $C = shift;
$C->lambda
}))) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->newpad)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}} 
or
eval { push @gather, $C->panic("Malformed block")} or do { die $@ if $@ };
@gather;
}
);
}

## token lambda
##      token lambda { '->' | '<->' }

sub lambda__PEEK { $_[0]->_AUTOLEXpeek('lambda',$retree) }
sub lambda {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "lambda", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'lambda_00') {
$C->deb("Fate passed to lambda_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'lambda_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("lambda_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('->')
},
sub { my $C=shift;
$C->_EXACT('<->')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

# Look for an expression followed by a required lambda.
## token xblock
##      token xblock {
##          :my $GOAL is context = '{';
##          <EXPR>
##          <.ws>
##          <pblock>
##      }

sub xblock__PEEK { $_[0]->_AUTOLEXpeek('xblock',$retree) }
sub xblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL =  '{';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "xblock", 
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token block ($CURPAD is context<rw> = $*CURPAD)
##      token block ($CURPAD is context<rw> = $*CURPAD) {
##          :dba('scoped block')
##          <?before '{' >
##          <.newpad>
##          <blockoid>
##      }

sub block__PEEK { $_[0]->_AUTOLEXpeek('block',$retree) }
sub block {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "block", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->newpad)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token blockoid
##      token blockoid {
##          <.finishpad>
##          [
##          | '{' ~ '}' <statementlist>
##          | <?terminator> <.panic: 'Missing {...}'>
##          ]
##      
##          [
##          | <?before \h* $$>  # (usual case without comments)
##              { @*MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt simple 
##          | \h* <.unsp>? <?before <[,:]>> {*}                         #= normal 
##          | <.unv>? $$
##              { @*MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt complex
##          | <.unsp>? { @*MEMOS[$.pos]<endargs> = 1; } {*}             #= endargs
##          ]
##      }

sub blockoid__PEEK { $_[0]->_AUTOLEXpeek('blockoid',$retree) }
sub blockoid {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "blockoid", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'blockoid_02') {
$C->deb("Fate passed to blockoid_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'blockoid_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("blockoid_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid_endstmt_simple_')
}, scalar(do {
$::MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?m:$)/)
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid_normal_')
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[,:]/)
}))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid_endstmt_complex')
}, scalar(do {
$::MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))
}, $C->_PATTERN(qr/\G(?m:$)/))
}, $C->_OPTr(sub { my $C=shift;
$C->unv
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid_endargs')
}, scalar(do {
$::MEMOS[$C->{_pos}]{'endargs'} = 1; 
}, $C))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'blockoid_01') {
$C->deb("Fate passed to blockoid_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'blockoid_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("blockoid_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}' , 'blockoid')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic('Missing {...}')
}, $C->before( sub { my $C=shift;
$C->terminator
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->finishpad)
);
}

## token regex_block
##      token regex_block {
##          :my $lang = ::Regex;
##          :my $GOAL is context = '}';
##      
##          [ <quotepair> <.ws>
##              {
##                  my $kv = $<quotepair>[*-1];
##                  $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                      or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##              }
##          ]*
##      
##          '{'
##          <nibble( $.cursor_fresh($lang).unbalanced('}') )>
##          [ '}' || <.panic: "Unable to parse regex; couldn't find right brace"> ]
##      
##          [
##          | <?before \h* $$>  # (usual case without comments)
##              { @*MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt simple 
##          | \h* <.unsp>? <?before <[,:]>> {*}                         #= normal 
##          | <.unv>? $$
##              { @*MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt complex
##          | <.unsp>? { @*MEMOS[$.pos]<endargs> = 1; }   {*}           #= endargs
##          ]
##      }

sub regex_block__PEEK { $_[0]->_AUTOLEXpeek('regex_block',$retree) }
sub regex_block {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $lang = 'STD::Regex';
local $::GOAL =  '}';


my $C = $self;
my $S = $C->{_pos};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "regex_block", 
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{quotepair}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh($lang)->unbalanced('}') )
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'regex_block_04') {
$C->deb("Fate passed to regex_block_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_block_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_block_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[\x20\t\r])*+)(?m:$)/)
}))) {
do {
if (my ($C) = (scalar(do {
$::MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))) {
$C->_REDUCE($S, 'regex_block_endstmt_simple_');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[,:]/)
}))) {
$C->_REDUCE($S, 'regex_block_normal_');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unv
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:$)/))) {
do {
if (my ($C) = (scalar(do {
$::MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))) {
$C->_REDUCE($S, 'regex_block_endstmt_complex');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = (scalar(do {
$::MEMOS[$C->{_pos}]{'endargs'} = 1; 
}, $C))) {
$C->_REDUCE($S, 'regex_block_endargs');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# statement semantics
## rule statementlist
##      rule statementlist {
##          :my $PARSER is context<rw> = self;
##          :my $INVOCANT_OK is context<rw> = 0;
##          :dba('statement list')
##          [
##          | $
##          | <?before <[\)\]\}]> >
##          | [<statement><eat_terminator> ]*
##          ]
##      }

sub statementlist__PEEK { $_[0]->_AUTOLEXpeek('statementlist',$retree) }
sub statementlist {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::PARSER =  $self;
local $::INVOCANT_OK =  0;


my $C = $self;
my $S = $C->{_pos};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "statementlist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statementlist_01') {
$C->deb("Fate passed to statementlist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statementlist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statementlist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\)\]\}]/))) {
$C->ws;
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# embedded semis, context-dependent semantics
## rule semilist
##      rule semilist {
##          :my $INVOCANT_OK is context<rw> = 0;
##          :dba('semicolon list')
##          [
##          | <?before <[\)\]\}]> >
##          | [<statement><eat_terminator> ]*
##          ]
##      }

sub semilist__PEEK { $_[0]->_AUTOLEXpeek('semilist',$retree) }
sub semilist {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK =  0;


my $C = $self;
my $S = $C->{_pos};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "semilist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'semilist_01') {
$C->deb("Fate passed to semilist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'semilist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("semilist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\)\]\}]/))) {
$C->ws;
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token label
##      token label {
##          :my $label;
##          <identifier> ':' <?before \s> <.ws>
##      
##          [ <?{ $.is_name($label = $<identifier>.Str) }>
##            <.panic("Illegal redeclaration of '$label'")>
##          ]?
##      
##          # add label as a pseudo type
##          {{ $.add_my_name($label); }}
##      
##      }

sub label__PEEK { $_[0]->_AUTOLEXpeek('label',$retree) }
sub label {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $label;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "label", 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $C->is_name($label = $M->{identifier}->Str) ;
})
}))) {
$C->panic("Illegal redeclaration of '$label'");
}
else {
();
}
}
})
}))) {
scalar(do {
$C->add_my_name($label); 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement
##      token statement {
##          :my $endargs is context = -1;
##          <!before <[\)\]\}]> >
##      
##          # this could either be a statement that follows a declaration
##          # or a statement that is within the block of a code declaration
##          <!!{ $ = $*PARSER.bless($); }>
##      
##          [
##          | <label> <statement>                        {*}            #= label
##          | <statement_control>                        {*}            #= control
##          | <EXPR> {*}                                                #= expr
##              :dba('statement end')
##              [
##              || <?{ (@*MEMOS[$.pos]<endstmt> // 0) == 2 }>   # no mod after end-line curly
##              ||
##                  :dba('statement modifier')
##                  <.ws>
##                  [
##                  | <statement_mod_loop> {*}                              #= mod loop
##                  | <statement_mod_cond> {*}                              #= mod cond
##                      :dba('statement modifier loop')
##                      [
##                      || <?{ (@*MEMOS[$.pos]<endstmt> // 0) == 2 }>
##                      || <.ws> <statement_mod_loop>? {*}                  #= mod condloop
##                      ]
##                  ]?
##              ]
##              {*}                                                     #= modexpr
##          | <?before ';'> {*}                                         #= null
##          ]
##      
##          # Is there more on same line after a block?
##          [ <?{ (@*MEMOS[@*MEMOS[$.pos]<ws>//$.pos]<endargs>//0) == 1 }>
##              \h*
##              <!before ';' | ')' | ']' | '}' >
##              <!infixstopper>
##              <.panic: "Statements must be separated with semicolon">
##          ]?
##      }

sub statement__PEEK { $_[0]->_AUTOLEXpeek('statement',$retree) }
sub statement {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::endargs =  -1;


my $C = $self;
my $S = $C->{_pos};
$C->{'statement_mod_loop'} = [];
$C->{'statement_mod_cond'} = [];

$self->_MATCHIFYr($S, "statement", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$C = $::PARSER->bless($C); 
})
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_02') {
$C->deb("Fate passed to statement_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['label'], sub {
my $C = shift;
$C->label
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_REDUCE($S, 'statement_label');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
}))) {
$C->_REDUCE($S, 'statement_control');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_expr'))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{_pos}]{'endstmt'} // 0) == 2 
})
})} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_05') {
$C->deb("Fate passed to statement_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
}))) {
$C->_REDUCE($S, 'statement_mod_loop');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_cond'], sub {
my $C = shift;
$C->statement_mod_cond
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond'))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{_pos}]{'endstmt'} // 0) == 2 
})
})} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
})
}))) {
$C->_REDUCE($S, 'statement_mod_condloop');
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'statement_modexpr');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(';')
}))) {
$C->_REDUCE($S, 'statement_null');
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$::MEMOS[$C->{_pos}]{'ws'}//$C->{_pos}]{'endargs'}//0) == 1 
})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_10') {
$C->deb("Fate passed to statement_10: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_10', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_10 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(';')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('}')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
$C->panic("Statements must be separated with semicolon");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token eat_terminator
##      token eat_terminator {
##          [
##          || ';'
##          || <?{ @*MEMOS[$.pos]<endstmt> }> <.ws>
##          || <?terminator>
##          || $
##          || {{ if @*MEMOS[$.pos]<ws> { $.pos = @*MEMOS[$.pos]<ws>; } }}   # undo any line transition
##              <.panic: "Syntax error">
##          ]
##      }

sub eat_terminator__PEEK { $_[0]->_AUTOLEXpeek('eat_terminator',$retree) }
sub eat_terminator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "eat_terminator", 
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(';')} 
or
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{_pos}]{'endstmt'} 
})
}))) {
$C->ws;
}
else {
();
}
}} 
or
eval { push @gather, $C->before( sub { my $C=shift;
$C->terminator
})} 
or
eval { push @gather, $C->_PATTERN(qr/\G\z/)} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
if ($::MEMOS[$C->{_pos}]{'ws'}) { $C->{_pos} = $::MEMOS[$C->{_pos}]{'ws'}; } 
}, $C))) {
$C->panic("Syntax error");
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
})
);
}

## token statement_control__S_037use (:$endsym is context = 'spacey', :$sym is context<rw> = 'use')
##      token statement_control:use {
##          <sym> :s
##          [
##          | <version>
##          | <module_name><arglist>?
##              {{
##                  my $longname = $<module_name><longname>.Str;
##                  $.add_our_name($longname);
##                  # XXX cheat on import list for now
##                  $.do_imports($longname, $<arglist>[0]);
##              }}
##          ]
##      }

sub statement_control__S_037use__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_037use',$retree) }
sub statement_control__S_037use {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'use';


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_037use", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guse/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_037use_01') {
$C->deb("Fate passed to statement_control__S_037use_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_037use_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_037use_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $longname = $M->{module_name}{longname}->Str;
$C->add_our_name($longname);
# XXX cheat on import list for now
$C->do_imports($longname, $M->{arglist}[0]);
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_038no (:$endsym is context = 'spacey', :$sym is context<rw> = 'no')
##      token statement_control:no {
##          <sym> :s
##          <module_name><arglist>?
##      }

sub statement_control__S_038no__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_038no',$retree) }
sub statement_control__S_038no {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'no';


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_038no", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gno/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_039if (:$endsym is context = 'spacey', :$sym is context<rw> = 'if')
##      token statement_control:if {
##          <sym> :s
##          <xblock>
##          [
##              'elsif'<?spacey> <elsif=xblock>       {*}                #= elsif
##          ]*
##          [
##              'else'<?spacey> <else=pblock>       {*}             #= else
##          ]?
##      }

sub statement_control__S_039if__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_039if',$retree) }
sub statement_control__S_039if {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'if';


my $C = $self;
my $S = $C->{_pos};
$C->{'else'} = [];
$C->{'elsif'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_039if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('elsif'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['elsif'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_039if_elsif'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('else'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['else'], sub {
my $C = shift;
$C->pblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_039if_else'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_040unless (:$endsym is context = 'spacey', :$sym is context<rw> = 'unless')
##      token statement_control:unless {
##          <sym> :s
##          <xblock>
##          [ <!before 'else'> || <.panic: "unless does not take \"else\" in Perl 6; please rewrite using \"if\""> ]
##      }

sub statement_control__S_040unless__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_040unless',$retree) }
sub statement_control__S_040unless {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'unless';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_040unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('else')
})
}))) {
$C->ws;
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("unless does not take \"else\" in Perl 6; please rewrite using \"if\""))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_041while (:$endsym is context = 'spacey', :$sym is context<rw> = 'while')
##      token statement_control:while {
##          <sym> :s
##          [ <?before '(' ['my'? '$'\w+ '=']? '<' '$'?\w+ '>' ')'>   #'
##              <.panic: "This appears to be Perl 5 code"> ]?
##          <xblock>
##      }

sub statement_control__S_041while__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_041while',$retree) }
sub statement_control__S_041while {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'while';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_041while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT('=');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('$')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_042until (:$endsym is context = 'spacey', :$sym is context<rw> = 'until')
##      token statement_control:until {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_042until__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_042until',$retree) }
sub statement_control__S_042until {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'until';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_042until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_043repeat (:$endsym is context = 'spacey', :$sym is context<rw> = 'repeat')
##      token statement_control:repeat {
##          <sym> :s
##          [
##              | ('while'|'until')
##                <xblock>
##              | <block>                      {*}                      #= block wu
##                ('while'|'until') <EXPR>         {*}                      #= expr wu
##          ]
##      }

sub statement_control__S_043repeat__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_043repeat',$retree) }
sub statement_control__S_043repeat {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'repeat';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_043repeat", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grepeat/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_043repeat_01') {
$C->deb("Fate passed to statement_control__S_043repeat_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_043repeat_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_043repeat_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_043repeat_02') {
$C->deb("Fate passed to statement_control__S_043repeat_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_043repeat_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_043repeat_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_043repeat_block_wu'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_043repeat_03') {
$C->deb("Fate passed to statement_control__S_043repeat_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_043repeat_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_043repeat_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_043repeat_expr_wu'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_control__S_044loop (:$endsym is context = 'spacey', :$sym is context<rw> = 'loop')
##      token statement_control:loop {
##          <sym> :s
##          $<eee> = (
##              '('
##                  <e1=EXPR>? ';'   {*}                            #= e1
##                  <e2=EXPR>? ';'   {*}                            #= e2
##                  <e3=EXPR>?       {*}                            #= e3
##              ')'                      {*}                            #= eee
##          )?
##          <block>                     {*}                             #= block
##      }

sub statement_control__S_044loop__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_044loop',$retree) }
sub statement_control__S_044loop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'loop';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_044loop", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gloop/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['eee'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e1','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop_e1'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e2','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop_e2'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e3','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop_e3'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(')'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop_eee'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop_block'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_045for (:$endsym is context = 'spacey', :$sym is context<rw> = 'for')
##      token statement_control:for {
##          <sym> :s
##          [ <?before 'my'? '$'\w+ '(' >
##              <.panic: "This appears to be Perl 5 code"> ]?
##          [ <?before '(' <.EXPR>? ';' <.EXPR>? ';' <.EXPR>? ')' >
##              <.obs('C-style "for (;;)" loop', '"loop (;;)"')> ]?
##          <xblock>
##      }

sub statement_control__S_045for__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_045for',$retree) }
sub statement_control__S_045for {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'for';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_045for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(')'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->obs('C-style "for (;;)" loop', '"loop (;;)"'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_control__S_046given (:$endsym is context = 'spacey', :$sym is context<rw> = 'given')
##      token statement_control:given {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_046given__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_046given',$retree) }
sub statement_control__S_046given {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'given';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_046given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_control__S_047when (:$endsym is context = 'spacey', :$sym is context<rw> = 'when')
##      token statement_control:when {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_047when__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_047when',$retree) }
sub statement_control__S_047when {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'when';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_047when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_048default (:$endsym is context = 'spacey', :$sym is context<rw> = 'default')
##      rule statement_control:default {<sym> <block> }

sub statement_control__S_048default__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_048default',$retree) }
sub statement_control__S_048default {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'default';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_048default", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdefault/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_control__S_049BEGIN (:$endsym is context = 'spacey', :$sym is context<rw> = 'BEGIN')
##      rule statement_control:BEGIN   {<sym> <block> }

sub statement_control__S_049BEGIN__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_049BEGIN',$retree) }
sub statement_control__S_049BEGIN {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'BEGIN';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_049BEGIN", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GBEGIN/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_050CHECK (:$endsym is context = 'spacey', :$sym is context<rw> = 'CHECK')
##      rule statement_control:CHECK   {<sym> <block> }

sub statement_control__S_050CHECK__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_050CHECK',$retree) }
sub statement_control__S_050CHECK {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CHECK';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_050CHECK", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCHECK/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_051INIT (:$endsym is context = 'spacey', :$sym is context<rw> = 'INIT')
##      rule statement_control:INIT    {<sym> <block> }

sub statement_control__S_051INIT__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_051INIT',$retree) }
sub statement_control__S_051INIT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'INIT';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_051INIT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GINIT/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_052END (:$endsym is context = 'spacey', :$sym is context<rw> = 'END')
##      rule statement_control:END     {<sym> <block> }

sub statement_control__S_052END__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_052END',$retree) }
sub statement_control__S_052END {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'END';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_052END", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GEND/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_053START (:$endsym is context = 'spacey', :$sym is context<rw> = 'START')
##      rule statement_control:START   {<sym> <block> }

sub statement_control__S_053START__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_053START',$retree) }
sub statement_control__S_053START {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'START';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_053START", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GSTART/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_054ENTER (:$endsym is context = 'spacey', :$sym is context<rw> = 'ENTER')
##      rule statement_control:ENTER   {<sym> <block> }

sub statement_control__S_054ENTER__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_054ENTER',$retree) }
sub statement_control__S_054ENTER {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'ENTER';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_054ENTER", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GENTER/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_055LEAVE (:$endsym is context = 'spacey', :$sym is context<rw> = 'LEAVE')
##      rule statement_control:LEAVE   {<sym> <block> }

sub statement_control__S_055LEAVE__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_055LEAVE',$retree) }
sub statement_control__S_055LEAVE {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'LEAVE';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_055LEAVE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLEAVE/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_056KEEP (:$endsym is context = 'spacey', :$sym is context<rw> = 'KEEP')
##      rule statement_control:KEEP    {<sym> <block> }

sub statement_control__S_056KEEP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_056KEEP',$retree) }
sub statement_control__S_056KEEP {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'KEEP';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_056KEEP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GKEEP/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_057UNDO (:$endsym is context = 'spacey', :$sym is context<rw> = 'UNDO')
##      rule statement_control:UNDO    {<sym> <block> }

sub statement_control__S_057UNDO__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_057UNDO',$retree) }
sub statement_control__S_057UNDO {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'UNDO';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_057UNDO", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GUNDO/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_058FIRST (:$endsym is context = 'spacey', :$sym is context<rw> = 'FIRST')
##      rule statement_control:FIRST   {<sym> <block> }

sub statement_control__S_058FIRST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_058FIRST',$retree) }
sub statement_control__S_058FIRST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'FIRST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_058FIRST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GFIRST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_059NEXT (:$endsym is context = 'spacey', :$sym is context<rw> = 'NEXT')
##      rule statement_control:NEXT    {<sym> <block> }

sub statement_control__S_059NEXT__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_059NEXT',$retree) }
sub statement_control__S_059NEXT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'NEXT';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_059NEXT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GNEXT/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_060LAST (:$endsym is context = 'spacey', :$sym is context<rw> = 'LAST')
##      rule statement_control:LAST    {<sym> <block> }

sub statement_control__S_060LAST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_060LAST',$retree) }
sub statement_control__S_060LAST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'LAST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_060LAST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLAST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_061PRE (:$endsym is context = 'spacey', :$sym is context<rw> = 'PRE')
##      rule statement_control:PRE     {<sym> <block> }

sub statement_control__S_061PRE__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_061PRE',$retree) }
sub statement_control__S_061PRE {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'PRE';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_061PRE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPRE/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_062POST (:$endsym is context = 'spacey', :$sym is context<rw> = 'POST')
##      rule statement_control:POST    {<sym> <block> }

sub statement_control__S_062POST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_062POST',$retree) }
sub statement_control__S_062POST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'POST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_062POST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPOST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_063CATCH (:$endsym is context = 'spacey', :$sym is context<rw> = 'CATCH')
##      rule statement_control:CATCH   {<sym> <block> }

sub statement_control__S_063CATCH__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_063CATCH',$retree) }
sub statement_control__S_063CATCH {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CATCH';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_063CATCH", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCATCH/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_064CONTROL (:$endsym is context = 'spacey', :$sym is context<rw> = 'CONTROL')
##      rule statement_control:CONTROL {<sym> <block> }

sub statement_control__S_064CONTROL__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_064CONTROL',$retree) }
sub statement_control__S_064CONTROL {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CONTROL';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_064CONTROL", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCONTROL/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_065TEMP (:$endsym is context = 'spacey', :$sym is context<rw> = 'TEMP')
##      rule statement_control:TEMP    {<sym> <block> }

sub statement_control__S_065TEMP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_065TEMP',$retree) }
sub statement_control__S_065TEMP {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'TEMP';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_065TEMP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GTEMP/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule term__S_066BEGIN (:$sym is context<rw> = 'BEGIN')
##      rule term:BEGIN   {<sym> <block> }

sub term__S_066BEGIN__PEEK { $_[0]->_AUTOLEXpeek('term__S_066BEGIN',$retree) }
sub term__S_066BEGIN {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'BEGIN';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_066BEGIN", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GBEGIN/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_067CHECK (:$sym is context<rw> = 'CHECK')
##      rule term:CHECK   {<sym> <block> }

sub term__S_067CHECK__PEEK { $_[0]->_AUTOLEXpeek('term__S_067CHECK',$retree) }
sub term__S_067CHECK {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'CHECK';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_067CHECK", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCHECK/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_068INIT (:$sym is context<rw> = 'INIT')
##      rule term:INIT    {<sym> <block> }

sub term__S_068INIT__PEEK { $_[0]->_AUTOLEXpeek('term__S_068INIT',$retree) }
sub term__S_068INIT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'INIT';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_068INIT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GINIT/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_069START (:$sym is context<rw> = 'START')
##      rule term:START   {<sym> <block> }

sub term__S_069START__PEEK { $_[0]->_AUTOLEXpeek('term__S_069START',$retree) }
sub term__S_069START {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'START';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_069START", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GSTART/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_070ENTER (:$sym is context<rw> = 'ENTER')
##      rule term:ENTER   {<sym> <block> }

sub term__S_070ENTER__PEEK { $_[0]->_AUTOLEXpeek('term__S_070ENTER',$retree) }
sub term__S_070ENTER {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ENTER';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_070ENTER", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GENTER/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_071FIRST (:$sym is context<rw> = 'FIRST')
##      rule term:FIRST   {<sym> <block> }

sub term__S_071FIRST__PEEK { $_[0]->_AUTOLEXpeek('term__S_071FIRST',$retree) }
sub term__S_071FIRST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'FIRST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_071FIRST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GFIRST/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule modifier_expr
##      rule modifier_expr { <EXPR> }

sub modifier_expr__PEEK { $_[0]->_AUTOLEXpeek('modifier_expr',$retree) }
sub modifier_expr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "modifier_expr", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_cond__S_072if (:$endsym is context = 'nofun', :$sym is context<rw> = 'if')
##      rule statement_mod_cond:if     {<sym> <modifier_expr> {*} }     #= if

sub statement_mod_cond__S_072if__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_072if',$retree) }
sub statement_mod_cond__S_072if {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'if';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_072if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond__S_072if_if'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_cond__S_073unless (:$endsym is context = 'nofun', :$sym is context<rw> = 'unless')
##      rule statement_mod_cond:unless {<sym> <modifier_expr> {*} }     #= unless

sub statement_mod_cond__S_073unless__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_073unless',$retree) }
sub statement_mod_cond__S_073unless {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'unless';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_073unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond__S_073unless_unless'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_cond__S_074when (:$endsym is context = 'nofun', :$sym is context<rw> = 'when')
##      rule statement_mod_cond:when   {<sym> <modifier_expr> {*} }     #= when

sub statement_mod_cond__S_074when__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_074when',$retree) }
sub statement_mod_cond__S_074when {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'when';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_074when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond__S_074when_when'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_loop__S_075while (:$endsym is context = 'nofun', :$sym is context<rw> = 'while')
##      rule statement_mod_loop:while {<sym> <modifier_expr> {*} }      #= while

sub statement_mod_loop__S_075while__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_075while',$retree) }
sub statement_mod_loop__S_075while {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'while';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_075while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_075while_while'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_loop__S_076until (:$endsym is context = 'nofun', :$sym is context<rw> = 'until')
##      rule statement_mod_loop:until {<sym> <modifier_expr> {*} }      #= until

sub statement_mod_loop__S_076until__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_076until',$retree) }
sub statement_mod_loop__S_076until {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'until';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_076until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_076until_until'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_loop__S_077for (:$endsym is context = 'nofun', :$sym is context<rw> = 'for')
##      rule statement_mod_loop:for   {<sym> <modifier_expr> {*} }      #= for

sub statement_mod_loop__S_077for__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_077for',$retree) }
sub statement_mod_loop__S_077for {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'for';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_077for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_077for_for'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_loop__S_078given (:$endsym is context = 'nofun', :$sym is context<rw> = 'given')
##      rule statement_mod_loop:given {<sym> <modifier_expr> {*} }      #= given

sub statement_mod_loop__S_078given__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_078given',$retree) }
sub statement_mod_loop__S_078given {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'given';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_078given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_078given_given'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token def_module_name
##      token def_module_name {
##          <longname>
##          [ :dba('generic role') <?{ ($*PKGDECL//'') eq 'role' }> '[' ~ ']' <signature> ]?
##      }

sub def_module_name__PEEK { $_[0]->_AUTOLEXpeek('def_module_name',$retree) }
sub def_module_name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'signature'} = [];

$self->_MATCHIFY($S, "def_module_name", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'generic role')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
($::PKGDECL//'') eq 'role' 
})
}))
})
})
}, $C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
);
}

## token module_name__S_079normal (:$sym is context<rw> = 'normal')
##      token module_name:normal {
##          <longname>
##          [ <?before '['> :dba('generic role') '[' ~ ']' <arglist> ]?
##      }

sub module_name__S_079normal__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_079normal',$retree) }
sub module_name__S_079normal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'normal';


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "module_name__S_079normal", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'generic role')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['arglist'], sub {
my $C = shift;
$C->arglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
}, $C->before(sub { my $C=shift;
$C->_EXACT('[')
}))
})
})
}, $C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
);
}

## token module_name__S_080deprecated (:$sym is context<rw> = 'deprecated')
##      token module_name:deprecated { 'v6-alpha' }

sub module_name__S_080deprecated__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_080deprecated',$retree) }
sub module_name__S_080deprecated {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'deprecated';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "module_name__S_080deprecated", 
$C->_EXACT('v6-alpha')
);
}

## token vnum
##      token vnum {
##          \d+ | '*'
##      }

sub vnum__PEEK { $_[0]->_AUTOLEXpeek('vnum',$retree) }
sub vnum {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "vnum", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'vnum_00') {
$C->deb("Fate passed to vnum_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'vnum_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("vnum_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token version__S_081v (:$sym is context<rw> = <v>)
##      token version:sym<v> {
##          'v' <?before \d+'.'> :: <vnum> ** '.' '+'?
##      }

sub version__S_081v__PEEK { $_[0]->_AUTOLEXpeek('version__S_081v',$retree) }
sub version__S_081v {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(v);


my $C = $self;
my $S = $C->{_pos};
$C->{'vnum'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "version__S_081v", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('+')
})
}, $C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('.')
}, sub { my $C=shift;
$C->_SUBSUME(['vnum'], sub {
my $C = shift;
$C->vnum
})
}))
}, $C->_COMMITBRANCH())
}, $C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_EXACT('.');
}
else {
();
}
}
}))
}, $C->_EXACT('v'))
);
}

###################################################

## token PRE
##      token PRE {
##          :dba('prefix or meta-prefix')
##          [
##          | <prefix>
##              { $<O> = $<prefix><O>; $<sym> = $<prefix><sym> }
##                                                          {*}         #= prefix
##          | <prefix_circumfix_meta_operator>
##              { $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.Str }
##                                                          {*}         #= precircum
##          ]
##          # XXX assuming no precedence change
##          
##          <prefix_postfix_meta_operator>*                 {*}         #= prepost
##          <.ws>
##      }

sub PRE__PEEK { $_[0]->_AUTOLEXpeek('PRE',$retree) }
sub PRE {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'prefix_postfix_meta_operator'} = [];

$self->_MATCHIFYr($S, "PRE", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'PRE_01') {
$C->deb("Fate passed to PRE_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'PRE_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("PRE_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix'], sub {
my $C = shift;
$C->prefix
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{O} = $M->{prefix}{O}; $M->{sym} = $M->{prefix}{sym} ;
}, $C))) {
$C->_REDUCE($S, 'PRE_prefix');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix_circumfix_meta_operator'], sub {
my $C = shift;
$C->prefix_circumfix_meta_operator
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{O} = $M->{prefix_circumfix_meta_operator}{O}; $M->{sym} = $M->{prefix_circumfix_meta_operator}->Str ;
}, $C))) {
$C->_REDUCE($S, 'PRE_precircum');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['prefix_postfix_meta_operator'], sub {
my $C = shift;
$C->prefix_postfix_meta_operator
})
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'PRE_prepost'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# (for when you want to tell EXPR that infix already parsed the term)
## token nullterm
##      token nullterm {
##          <?>
##      }

sub nullterm__PEEK { $_[0]->_AUTOLEXpeek('nullterm',$retree) }
sub nullterm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nullterm", 
$C->before( sub { my $C=shift;
$C
})
);
}

## token nulltermish
##      token nulltermish {
##          :dba('null term')
##          [
##          | <?stdstopper>
##          | <noun=termish>
##              {
##                  $<PRE>  = $<noun><PRE>:delete;
##                  $<POST> = $<noun><POST>:delete;
##              }
##          | <?>
##          ]
##      }

sub nulltermish__PEEK { $_[0]->_AUTOLEXpeek('nulltermish',$retree) }
sub nulltermish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nulltermish", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'nulltermish_01') {
$C->deb("Fate passed to nulltermish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'nulltermish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nulltermish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->termish
}))) {
scalar(do {
my $M = $C; 
$M->{PRE}  = delete $M->{noun}{PRE};
$M->{POST} = delete $M->{noun}{POST};
;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token termish
##      token termish {
##          :my $SCOPE is context<rw> = "our";
##          :my $VAR is context<rw>;
##          :dba('prefix or noun')
##          [
##          | <PRE>+ <noun>
##          | <noun>
##          ]
##      
##          # also queue up any postfixes
##          :dba('postfix')
##          [
##          || <?{ $*INTERPOLATION }>
##              [
##              || <?{ $*INTERPOLATION eq '$' }> [ <POST>+! <?after <[ \] } > ) ]> > ]?
##              ||                                 <POST>+! <?after <[ \] } > ) ]> > 
##              || { $VAR = 0; }
##              ]
##          || <!{ $*INTERPOLATION }>
##              [
##              || <?stdstopper>
##              || <POST>*
##              ]
##          ]
##          { self.check_variable($VAR) if $VAR; }
##          { $.<~CAPS> = $<noun><~CAPS> }
##      }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::SCOPE =  "our";
local $::VAR;


my $C = $self;
my $S = $C->{_pos};
$C->{'PRE'} = [];
$C->{'POST'} = [];

$self->_MATCHIFY($S, "termish", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $C->{'~CAPS'} = $M->{noun}{'~CAPS'} ;
}, $C)
}, scalar(do {
$self->check_variable($VAR) if $VAR; 
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
})
})
}, $C->_PLUSg(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
}))
})
})
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::INTERPOLATION eq '$' 
})
}))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
})
})
}, $C->_PLUSg(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
}))} 
or
eval { push @gather, scalar(do {
$VAR = 0; 
}, $C)} or do { die $@ if $@ };
@gather;
}
})
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::INTERPOLATION 
})
}))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
$C->stdstopper
})} 
or
eval { push @gather, $C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
})} or do { die $@ if $@ };
@gather;
}
})
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::INTERPOLATION 
})
}))} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'termish_01') {
$C->deb("Fate passed to termish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'termish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("termish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['noun'], sub {
my $C = shift;
$C->noun
})
}, $C->_PLUSr(sub { my $C=shift;
$C->_SUBSUME(['PRE'], sub {
my $C = shift;
$C->PRE
})
}))
},
sub { my $C=shift;
$C->_SUBSUME(['noun'], sub {
my $C = shift;
$C->noun
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

## token noun__S_082fatarrow (:$sym is context<rw> = 'fatarrow')
##      token noun:fatarrow           { <fatarrow> }

sub noun__S_082fatarrow__PEEK { $_[0]->_AUTOLEXpeek('noun__S_082fatarrow',$retree) }
sub noun__S_082fatarrow {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'fatarrow';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_082fatarrow", 
$C->_SUBSUMEr(['fatarrow'], sub {
my $C = shift;
$C->fatarrow
})
);
}
## token noun__S_083variable (:$sym is context<rw> = 'variable')
##      token noun:variable           { <variable> { $*VAR = $<variable> } }

sub noun__S_083variable__PEEK { $_[0]->_AUTOLEXpeek('noun__S_083variable',$retree) }
sub noun__S_083variable {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'variable';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_083variable", 
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;  $::VAR = $M->{variable} ;
}, $C);
}
else {
();
}
}
);
}
## token noun__S_084package_declarator (:$sym is context<rw> = 'package_declarator')
##      token noun:package_declarator { <package_declarator> }

sub noun__S_084package_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_084package_declarator',$retree) }
sub noun__S_084package_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'package_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_084package_declarator", 
$C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
})
);
}
## token noun__S_085scope_declarator (:$sym is context<rw> = 'scope_declarator')
##      token noun:scope_declarator   { <scope_declarator> }

sub noun__S_085scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_085scope_declarator',$retree) }
sub noun__S_085scope_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'scope_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_085scope_declarator", 
$C->_SUBSUMEr(['scope_declarator'], sub {
my $C = shift;
$C->scope_declarator
})
);
}
## token noun__S_086multi_declarator (:$sym is context<rw> = 'multi_declarator')
##      token noun:multi_declarator   { <?before 'multi'|'proto'|'only'> <multi_declarator> }

sub noun__S_086multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_086multi_declarator',$retree) }
sub noun__S_086multi_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'multi_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_086multi_declarator", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'noun__S_086multi_declarator_01') {
$C->deb("Fate passed to noun__S_086multi_declarator_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'noun__S_086multi_declarator_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("noun__S_086multi_declarator_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('multi')
},
sub { my $C=shift;
$C->_EXACT('proto')
},
sub { my $C=shift;
$C->_EXACT('only')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
});
}
else {
();
}
}
);
}
## token noun__S_087routine_declarator (:$sym is context<rw> = 'routine_declarator')
##      token noun:routine_declarator { <routine_declarator> }

sub noun__S_087routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_087routine_declarator',$retree) }
sub noun__S_087routine_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'routine_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_087routine_declarator", 
$C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
);
}
## token noun__S_088regex_declarator (:$sym is context<rw> = 'regex_declarator')
##      token noun:regex_declarator   { <regex_declarator> }

sub noun__S_088regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_088regex_declarator',$retree) }
sub noun__S_088regex_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'regex_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_088regex_declarator", 
$C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
);
}
## token noun__S_089type_declarator (:$sym is context<rw> = 'type_declarator')
##      token noun:type_declarator    { <type_declarator> }

sub noun__S_089type_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_089type_declarator',$retree) }
sub noun__S_089type_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'type_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_089type_declarator", 
$C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
);
}
## token noun__S_090circumfix (:$sym is context<rw> = 'circumfix')
##      token noun:circumfix          { <circumfix> }

sub noun__S_090circumfix__PEEK { $_[0]->_AUTOLEXpeek('noun__S_090circumfix',$retree) }
sub noun__S_090circumfix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'circumfix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_090circumfix", 
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
);
}
## token noun__S_091dotty (:$sym is context<rw> = 'dotty')
##      token noun:dotty              { <dotty> }

sub noun__S_091dotty__PEEK { $_[0]->_AUTOLEXpeek('noun__S_091dotty',$retree) }
sub noun__S_091dotty {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'dotty';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_091dotty", 
$C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
})
);
}
## token noun__S_092value (:$sym is context<rw> = 'value')
##      token noun:value              { <value> }

sub noun__S_092value__PEEK { $_[0]->_AUTOLEXpeek('noun__S_092value',$retree) }
sub noun__S_092value {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'value';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_092value", 
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
);
}
## token noun__S_093capterm (:$sym is context<rw> = 'capterm')
##      token noun:capterm            { <capterm> }

sub noun__S_093capterm__PEEK { $_[0]->_AUTOLEXpeek('noun__S_093capterm',$retree) }
sub noun__S_093capterm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'capterm';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_093capterm", 
$C->_SUBSUMEr(['capterm'], sub {
my $C = shift;
$C->capterm
})
);
}
## token noun__S_094sigterm (:$sym is context<rw> = 'sigterm')
##      token noun:sigterm            { <sigterm> }

sub noun__S_094sigterm__PEEK { $_[0]->_AUTOLEXpeek('noun__S_094sigterm',$retree) }
sub noun__S_094sigterm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigterm';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_094sigterm", 
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
);
}
## token noun__S_095term (:$sym is context<rw> = 'term')
##      token noun:term               { <term> }

sub noun__S_095term__PEEK { $_[0]->_AUTOLEXpeek('noun__S_095term',$retree) }
sub noun__S_095term {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'term';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_095term", 
$C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
})
);
}
## token noun__S_096statement_prefix (:$sym is context<rw> = 'statement_prefix')
##      token noun:statement_prefix   { <statement_prefix> }

sub noun__S_096statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('noun__S_096statement_prefix',$retree) }
sub noun__S_096statement_prefix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_prefix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_096statement_prefix", 
$C->_SUBSUMEr(['statement_prefix'], sub {
my $C = shift;
$C->statement_prefix
})
);
}
## token noun__S_097colonpair (:$sym is context<rw> = 'colonpair')
##      token noun:colonpair          { [ <colonpair> <.ws> ]+ }

sub noun__S_097colonpair__PEEK { $_[0]->_AUTOLEXpeek('noun__S_097colonpair',$retree) }
sub noun__S_097colonpair {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'colonpair';


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_097colonpair", 
$C->_PLUSr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
})
})
);
}


## token fatarrow
##      token fatarrow {
##          <key=identifier> \h* '=>' <.ws> <val=EXPR(item %item_assignment)>
##      }

sub fatarrow__PEEK { $_[0]->_AUTOLEXpeek('fatarrow',$retree) }
sub fatarrow {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "fatarrow", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['key'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('=>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['val'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token colonpair
##      token colonpair {
##          :my $key;
##          :my $value;
##      
##          ':'
##          :dba('colon pair')
##          [
##          | '!' <identifier>
##              { $key = $<identifier>.Str; $value = 0; }
##              {*}                                                     #= false
##          | $<num> = [\d+] <identifier>
##          | <identifier>
##              { $key = $<identifier>.Str; }
##              [
##              || <.unsp>? <postcircumfix> { $value = $<postcircumfix>; }
##              || { $value = 1; }
##              ]
##              {*}                                                     #= value
##          | :dba('signature') '(' ~ ')' <signature>
##          | <postcircumfix>
##              { $key = ""; $value = $<postcircumfix>; }
##              {*}                                                     #= structural
##          | $<var> = (<sigil> {} <twigil>? <desigilname>)
##              { $key = $<var><desigilname>.Str; $value = $<var>; }
##              {*}                                                     #= varname
##          ]
##          { $<k> = $key; $<v> = $value; }
##      }

sub colonpair__PEEK { $_[0]->_AUTOLEXpeek('colonpair',$retree) }
sub colonpair {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "colonpair", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{k} = $key; $M->{v} = $value; ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'colonpair_01') {
$C->deb("Fate passed to colonpair_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'colonpair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("colonpair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->Str; $value = 0; ;
}, $C))) {
$C->_REDUCE($S, 'colonpair_false');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['num'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->Str; ;
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{postcircumfix}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, scalar(do {
$value = 1; 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'colonpair_value');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'signature')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'colonpair_structural')
}, scalar(do {
my $M = $C;  $key = ""; $value = $M->{postcircumfix}; ;
}, $C))
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'colonpair_varname')
}, scalar(do {
my $M = $C;  $key = $M->{var}{desigilname}->Str; $value = $M->{var}; ;
}, $C))
},     $C->_SUBSUME(['var'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
}, scalar(do {

}, $C))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
})}
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_EXACT(':'))
);
}

## token quotepair
##      token quotepair {
##          :my $key;
##          :my $value;
##      
##          ':'
##          :dba('colon pair (restricted)')
##          [
##          | '!' <identifier>
##              { $key = $<identifier>.Str; $value = 0; }
##              {*}                                                     #= false
##          | <identifier>
##              { $key = $<identifier>.Str; }
##              [
##              || <.unsp>? <?before '('> <postcircumfix> { $value = $<postcircumfix>; }
##              || { $value = 1; }
##              ]
##              {*}                                                     #= value
##          | $<n>=(\d+) $<id>=(<[a..z]>+)
##              { $key = $<id>.Str; $value = $<n>.Str; }
##              {*}                                                     #= nth
##          ]
##          { $<k> = $key; $<v> = $value; }
##      }

sub quotepair__PEEK { $_[0]->_AUTOLEXpeek('quotepair',$retree) }
sub quotepair {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quotepair", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quotepair_01') {
$C->deb("Fate passed to quotepair_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quotepair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quotepair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->Str; $value = 0; ;
}, $C))) {
$C->_REDUCE($S, 'quotepair_false');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->Str; ;
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{postcircumfix}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, scalar(do {
$value = 1; 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'quotepair_value');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['n'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['id'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[a-z])++)/)
})}
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{id}->Str; $value = $M->{n}->Str; ;
}, $C))) {
$C->_REDUCE($S, 'quotepair_nth');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
my $M = $C;  $M->{k} = $key; $M->{v} = $value; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infixish ($in_meta = $*IN_META)
##      token infixish ($in_meta = $*IN_META) {
##          :my $infix;
##          :my $IN_META is context<rw> = $in_meta;
##          <!stdstopper>
##          <!infixstopper>
##          :dba('infix or meta-infix')
##          [
##          | <colonpair> {
##                  $<fake> = 1;
##                  $<sym> = ':';
##                  %<O><prec> = %comma<prec>;  # actual test is non-inclusive of comma!
##                  %<O><assoc> = 'unary';
##                  %<O><uassoc> = 'left';
##              }
##          | '[' ~ ']' <infixish(1)> { $<O> = $<infixish><O>; $<sym> = $<infixish><sym>; }
##          | <infix_circumfix_meta_operator>
##              { $<O> = $<infix_circumfix_meta_operator><O>;
##                $<sym> = $<infix_circumfix_meta_operator><sym>; }
##          | <infix_prefix_meta_operator>
##              { $<O> = $<infix_prefix_meta_operator><O>;
##                $<sym> = $<infix_prefix_meta_operator><sym>; }
##          | <infix> <!before '='>
##                 { $<O> = $<infix>.<O>; $<sym> = $<infix>.<sym>; }
##          | <infix> <?before '='> <?{ $infix = $<infix>; }> <infix_postfix_meta_operator($infix)>
##                 { $<O> = $<infix_postfix_meta_operator>.<O>; $<sym> = $<infix_postfix_meta_operator>.<sym>; }
##          ]
##      }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $in_meta = shift() // $::IN_META;
my $infix;
local $::IN_META =  $in_meta;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "infixish", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infixish_01') {
$C->deb("Fate passed to infixish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
scalar(do {
my $M = $C; 
$M->{fake} = 1;
$M->{sym} = ':';
$M->{O}{prec} = $comma{prec};  # actual test is non-inclusive of comma!
$M->{O}{assoc} = 'unary';
$M->{O}{uassoc} = 'left';
;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O} = $M->{infixish}{O}; $M->{sym} = $M->{infixish}{sym}; ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'infix or meta-infix')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O} = $M->{infix_circumfix_meta_operator}{O};
$M->{sym} = $M->{infix_circumfix_meta_operator}{sym}; ;
}, $C)
}, $C->_SUBSUME(['infix_circumfix_meta_operator'], sub {
my $C = shift;
$C->infix_circumfix_meta_operator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O} = $M->{infix_prefix_meta_operator}{O};
$M->{sym} = $M->{infix_prefix_meta_operator}{sym}; ;
}, $C)
}, $C->_SUBSUME(['infix_prefix_meta_operator'], sub {
my $C = shift;
$C->infix_prefix_meta_operator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O} = $M->{infix}->{'O'}; $M->{sym} = $M->{infix}->{'sym'}; ;
}, $C)
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('=')
})
}))
}, $C->_SUBSUME(['infix'], sub {
my $C = shift;
$C->infix
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O} = $M->{infix_postfix_meta_operator}->{'O'}; $M->{sym} = $M->{infix_postfix_meta_operator}->{'sym'}; ;
}, $C)
}, $C->_SUBSUME(['infix_postfix_meta_operator'], sub {
my $C = shift;
$C->infix_postfix_meta_operator($infix)
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $infix = $M->{infix}; ;
})
}))
}, $C->before(sub { my $C=shift;
$C->_EXACT('=')
}))
}, $C->_SUBSUME(['infix'], sub {
my $C = shift;
$C->infix
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))
);
}

# doing fancy as one rule simplifies LTM
## token dotty__S_098DotStar (:$endsym is context = 'unspacey'  , :$sym is context<rw> = <.*> --> Methodcall)
##      token dotty:sym<.*> ( --> Methodcall) {
##          ('.' [ <[+*?=]> | '^' '!'? ]) :: <.unspacey> <dottyop>
##          { $<sym> = $0.Str; }
##      }

sub dotty__S_098DotStar__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_098DotStar',$retree) }
sub dotty__S_098DotStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'unspacey'  ;
local $sym = $args{sym} // q(.*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "dotty__S_098DotStar",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{sym} = $$C{0}->Str; ;
}, $C)
}, $C->_SUBSUME(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))
}, $C->unspacey)
}, $C->_COMMITBRANCH())
},     $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'dotty__S_098DotStar_02') {
$C->deb("Fate passed to dotty__S_098DotStar_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dotty__S_098DotStar_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty__S_098DotStar_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G[+*?=]/)
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('^'))) {
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('!')
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
})}
}))
);
}

## token dotty__S_099Dot (:$endsym is context = 'unspacey'  , :$sym is context<rw> = <.> --> Methodcall)
##      token dotty:sym<.> ( --> Methodcall) {
##          <sym> <dottyop>
##      }

sub dotty__S_099Dot__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_099Dot',$retree) }
sub dotty__S_099Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'unspacey'  ;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "dotty__S_099Dot",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\./))) {
do {
if (my ($C) = ($C->unspacey)) {
$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token privop ( --> Methodcall)
##      token privop ( --> Methodcall) {
##          '!' <methodop>
##      }

sub privop__PEEK { $_[0]->_AUTOLEXpeek('privop',$retree) }
sub privop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "privop",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('!'))) {
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
});
}
else {
();
}
}
);
}

## token dottyopish
##      token dottyopish {
##          <noun=dottyop>
##      }

sub dottyopish__PEEK { $_[0]->_AUTOLEXpeek('dottyopish',$retree) }
sub dottyopish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "dottyopish", 
$C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->dottyop
})
);
}

## token dottyop
##      token dottyop {
##          :dba('dotty method or postfix')
##          [
##          | <methodop>
##          | <colonpair>
##          | <!alpha> <postop> { $<O> = $<postop><O>; $<sym> = $<postop><sym>; }  # only non-alpha postfixes have dotty form
##          ]
##      }

sub dottyop__PEEK { $_[0]->_AUTOLEXpeek('dottyop',$retree) }
sub dottyop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "dottyop", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'dottyop_01') {
$C->deb("Fate passed to dottyop_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dottyop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dottyop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{postop}{O}; $M->{sym} = $M->{postop}{sym}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# Note, this rule mustn't do anything irreversible because it's used
# as a lookahead by the quote interpolator.

## token POST
##      token POST {
##          <!stdstopper>
##      
##          # last whitespace didn't end here
##          <!{ @*MEMOS[$.pos]<ws> }>
##      
##          [ <.unsp> | '\\' ]?
##      
##          [ ['.' <.unsp>?]? <postfix_prefix_meta_operator> <.unsp>? ]*
##      
##          :dba('postfix')
##          [
##          | <dotty>  { $<O> = $<dotty><O>;  $<sym> = $<dotty><sym>;  $<~CAPS> = $<dotty><~CAPS>; }
##          | <privop> { $<O> = $<privop><O>; $<sym> = $<privop><sym>; $<~CAPS> = $<privop><~CAPS>; }
##          | <postop> { $<O> = $<postop><O>; $<sym> = $<postop><sym>; $<~CAPS> = $<postop><~CAPS>; }
##          ]
##          { $*SIGIL = '@'; }
##      }

sub POST__PEEK { $_[0]->_AUTOLEXpeek('POST',$retree) }
sub POST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'postfix_prefix_meta_operator'} = [];

$self->_MATCHIFYr($S, "POST", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{_pos}]{'ws'} 
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'POST_01') {
$C->deb("Fate passed to POST_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'POST_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
$C->_EXACT('\\')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix_prefix_meta_operator'], sub {
my $C = shift;
$C->postfix_prefix_meta_operator
}))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'POST_04') {
$C->deb("Fate passed to POST_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'POST_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{dotty}{O};  $M->{sym} = $M->{dotty}{sym};  $M->{'~CAPS'} = $M->{dotty}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['privop'], sub {
my $C = shift;
$C->privop
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{privop}{O}; $M->{sym} = $M->{privop}{sym}; $M->{'~CAPS'} = $M->{privop}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{postop}{O}; $M->{sym} = $M->{postop}{sym}; $M->{'~CAPS'} = $M->{postop}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::SIGIL = '@'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## method can_meta ($op, $meta)
sub can_meta {
my $self = shift;
my $op = shift;
my $meta = shift;


!$op->{O}{fiddly} || $self->panic("Can't " . $meta . " a " . $op->{O}{dba} . " because it's too fiddly");
$self;
}

## regex prefix_circumfix_meta_operator__S_100reduce ( :$sym is context<rw> = 'reduce' --> List_prefix)
##      regex prefix_circumfix_meta_operator:reduce (--> List_prefix) {
##          <?before '['\S+']'>
##          $<s> = (
##              '['
##              [
##              || <op=infixish(1)> ']' [''|<?>]
##              || \\<op=infixish(1)> ']' [''|<?>]
##              || <!>
##              ]
##          ) <?before <[ \s ( ]> >
##      
##          <.can_meta($<s><op>, "reduce")>
##      
##          [
##          || <!{ $<s><op><O><diffy> }>
##          || <?{ $<s><op><O><assoc> eq 'chain' }>
##          || <.panic("Can't reduce a " ~ $<s><op><O><dba> ~ " operator because it's diffy and not chaining")>
##          ]
##      
##          { $<O> = $<s><op><O>; $<O><prec>:delete; $<O><assoc> = 'unary'; $<O><uassoc> = 'left'; }
##          { $<sym> = $<s>.Str; }
##      
##      }

sub prefix_circumfix_meta_operator__S_100reduce__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator__S_100reduce',$retree) }
sub prefix_circumfix_meta_operator__S_100reduce {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'reduce';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "prefix_circumfix_meta_operator__S_100reduce",  Cursor::lazymap sub { STD::List_prefix->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{sym} = $M->{s}->Str; ;
}, $C)
}, scalar(do {
my $M = $C;  $M->{O} = $M->{s}{op}{O}; delete $M->{O}{prec}; $M->{O}{assoc} = 'unary'; $M->{O}{uassoc} = 'left'; ;
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{s}{op}{O}{diffy} ;
})
})} 
or
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{s}{op}{O}{assoc} eq 'chain' ;
})
})} 
or
eval { push @gather, do { my $M = $C;
$C->panic("Can't reduce a " . $M->{s}{op}{O}{dba} . " operator because it's diffy and not chaining")
; }} or do { die $@ if $@ };
@gather;
}
}))
}, do { my $M = $C;
$C->can_meta($M->{s}{op}, "reduce")
; })
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\s(]/)
}))
},     $C->_SUBSUME(['s'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_100reduce_04') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_100reduce_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_100reduce_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_100reduce_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish(1)
}))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_100reduce_06') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_100reduce_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_100reduce_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_100reduce_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish(1)
}))
}, $C->_EXACT('\\'))} 
or
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C
})} or do { die $@ if $@ };
@gather;
}
})
}, $C->_EXACT('['))
})}
}))
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT(']')
}, $C->_PLUSg(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))
}, $C->_EXACT('['))
}))
);
}

## token prefix_postfix_meta_operator__S_101Fre (:$sym is context<rw> = <  >)
##      token prefix_postfix_meta_operator:sym<  >    { <sym> | '<<' }

sub prefix_postfix_meta_operator__S_101Fre__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator__S_101Fre',$retree) }
sub prefix_postfix_meta_operator__S_101Fre {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix_postfix_meta_operator__S_101Fre", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_postfix_meta_operator__S_101Fre_00') {
$C->deb("Fate passed to prefix_postfix_meta_operator__S_101Fre_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator__S_101Fre_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator__S_101Fre_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G/)
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token postfix_prefix_meta_operator__S_102Nch (:$sym is context<rw> = <  >)
##      token postfix_prefix_meta_operator:sym<  >    { <sym> | '>>' }

sub postfix_prefix_meta_operator__S_102Nch__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator__S_102Nch',$retree) }
sub postfix_prefix_meta_operator__S_102Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix_prefix_meta_operator__S_102Nch", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'postfix_prefix_meta_operator__S_102Nch_00') {
$C->deb("Fate passed to postfix_prefix_meta_operator__S_102Nch_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator__S_102Nch_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator__S_102Nch_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G/)
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token infix_prefix_meta_operator__S_103Bang (  :$sym is context<rw> = <!> --> Transparent)
##      token infix_prefix_meta_operator:sym<!> ( --> Transparent) {
##          <sym> <!before '!'> {} <infixish(1)>
##      
##          [
##          || <?{ $<infixish>.Str eq '=' }>
##             { $ = ::Chaining.coerce($); }
##             
##          || <.can_meta($<infixish>, "negate")>    
##             <?{ $<infixish><O><iffy> }>
##             <?{ $<O> = $<infixish><O>; }>
##              
##          || <.panic("Can't negate a " ~ $<infixish><O><dba> ~ " operator because it's not iffy enough")>
##          ]
##      }

sub infix_prefix_meta_operator__S_103Bang__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_103Bang',$retree) }
sub infix_prefix_meta_operator__S_103Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_103Bang",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('!')
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{infixish}->Str eq '=' ;
})
}))) {
scalar(do {
$C = 'STD::Chaining'->coerce($C); 
}, $C);
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{infixish}, "negate")
; })) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{infixish}{O}{iffy} ;
})
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infixish}{O}; ;
})
});
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do { my $M = $C;
$C->panic("Can't negate a " . $M->{infixish}{O}{dba} . " operator because it's not iffy enough")
; }} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_prefix_meta_operator__S_104R (  :$sym is context<rw> = <R> --> Transparent)
##      token infix_prefix_meta_operator:sym<R> ( --> Transparent) {
##          <sym> {} <infixish(1)>
##          <.can_meta($<infixish>, "reverse")>
##          <?{ $<O> = $<infixish><O>; }>
##      }

sub infix_prefix_meta_operator__S_104R__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_104R',$retree) }
sub infix_prefix_meta_operator__S_104R {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(R);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_104R",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\GR/))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{infixish}, "reverse")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infixish}{O}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

#method lex1 (Str $s) {
#    self.<O>{$s}++ and self.panic("Nested $s metaoperators not allowed");
#    self;
#}

## token infix_prefix_meta_operator__S_105X (  :$sym is context<rw> = <X> --> List_infix)
##      token infix_prefix_meta_operator:sym<X> ( --> List_infix) {
##          <sym> {}
##          [ <infixish(1)>
##              [X <.panic: "Old form of XopX found">]?
##              <.can_meta($<infixish>[0], "cross")>
##              <?{ $<O> = $<infixish>[0]<O>; $<O><prec>:delete; $<sym> ~= $<infixish>[0].Str }>
##          ]?
##      }

sub infix_prefix_meta_operator__S_105X__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_105X',$retree) }
sub infix_prefix_meta_operator__S_105X {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(X);


my $C = $self;
my $S = $C->{_pos};
$C->{'infixish'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_105X",  map { STD::List_infix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\GX/))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('X'))) {
$C->panic("Old form of XopX found");
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{infixish}[0], "cross")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infixish}[0]{'O'}; delete $M->{O}{prec}; $M->{sym} .= $M->{infixish}[0]->Str ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_circumfix_meta_operator__S_106Fre_Nch (  :$sym is context<rw> = < > --> Transparent)
##      token infix_circumfix_meta_operator:sym< > ( --> Transparent) {
##          [
##          | ''
##          | ''
##          ]
##          {} <infixish(1)> [ '' | '' ]
##          <.can_meta($<infixish>, "hyper")>
##          <?{ $<O> := $<infixish><O>; }>
##      }

sub infix_circumfix_meta_operator__S_106Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_106Fre_Nch',$retree) }
sub infix_circumfix_meta_operator__S_106Fre_Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_106Fre_Nch",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_106Fre_Nch_01') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_106Fre_Nch_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_106Fre_Nch_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_106Fre_Nch_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_106Fre_Nch_02') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_106Fre_Nch_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_106Fre_Nch_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_106Fre_Nch_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{infixish}, "hyper")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infixish}{O}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_circumfix_meta_operator__S_107LtLt_GtGt (  :$sym is context<rw> = << >> --> Transparent)
##      token infix_circumfix_meta_operator:sym<< >> ( --> Transparent) {
##          [
##          | '<<'
##          | '>>'
##          ]
##          {} <infixish(1)> [ '<<' | '>>' ]
##          <.can_meta($<infixish>, "hyper")>
##          <?{ $<O> := $<infixish><O>; }>
##      }

sub infix_circumfix_meta_operator__S_107LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_107LtLt_GtGt',$retree) }
sub infix_circumfix_meta_operator__S_107LtLt_GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_107LtLt_GtGt",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_107LtLt_GtGt_01') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_107LtLt_GtGt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_107LtLt_GtGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_107LtLt_GtGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_107LtLt_GtGt_02') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_107LtLt_GtGt_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_107LtLt_GtGt_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_107LtLt_GtGt_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{infixish}, "hyper")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infixish}{O}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_postfix_meta_operator__S_108Equal ($op  , :$sym is context<rw> = <=> --> Item_assignment)
##      token infix_postfix_meta_operator:sym<=> ($op --> Item_assignment) {
##          '='
##          <.can_meta($op, "make assignment out of")>
##          [ <!{ $op<O><diffy> }> || <.panic("Can't make assignment out of a " ~ $op<O><dba> ~ " operator because it's diffy")> ]
##          { $<O> = $op<O>; $<O><prec>:delete; $<O><fiddly> = 1; }
##      }

sub infix_postfix_meta_operator__S_108Equal__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator__S_108Equal',$retree) }
sub infix_postfix_meta_operator__S_108Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $op = shift;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_postfix_meta_operator__S_108Equal",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->can_meta($op, "make assignment out of"))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$op->{O}{diffy} 
})
})} 
or
eval { push @gather, $C->panic("Can't make assignment out of a " . $op->{O}{dba} . " operator because it's diffy")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{O} = $op->{O}; delete $M->{O}{prec}; $M->{O}{fiddly} = 1; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_109Paren_Thesis (  :$sym is context<rw> = <( )> --> Methodcall)
##      token postcircumfix:sym<( )> ( --> Methodcall)
##          { :dba('argument list') '(' ~ ')' <semiarglist> }

sub postcircumfix__S_109Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_109Paren_Thesis',$retree) }
sub postcircumfix__S_109Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_109Paren_Thesis",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

## token postcircumfix__S_110Bra_Ket (  :$sym is context<rw> = <[ ]> --> Methodcall)
##      token postcircumfix:sym<[ ]> ( --> Methodcall)
##          { :dba('subscript') '[' ~ ']' <semilist> { $<semilist>.Str eq '-1' and $.obs("[-1] subscript to access final element","[*-1]") } }

sub postcircumfix__S_110Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_110Bra_Ket',$retree) }
sub postcircumfix__S_110Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_110Bra_Ket",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{semilist}->Str eq '-1' and $C->obs("[-1] subscript to access final element","[*-1]") ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'subscript')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
);
}

## token postcircumfix__S_111Cur_Ly (  :$sym is context<rw> = <{ }> --> Methodcall)
##      token postcircumfix:sym<{ }> ( --> Methodcall)
##          { :dba('subscript') '{' ~ '}' <semilist> }

sub postcircumfix__S_111Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_111Cur_Ly',$retree) }
sub postcircumfix__S_111Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_111Cur_Ly",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}' , 'subscript')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
);
}

## token postcircumfix__S_112Lt_Gt (  :$sym is context<rw> = < > --> Methodcall)
##      token postcircumfix:sym< > ( --> Methodcall)
##          { '<' <nibble($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))> [ '>' || <.panic: "Unable to parse quote-words subscript; couldn't find right angle quote"> ] }

sub postcircumfix__S_112Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_112Lt_Gt',$retree) }
sub postcircumfix__S_112Lt_Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_112Lt_Gt",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>')} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_113LtLt_GtGt (  :$sym is context<rw> = << >> --> Methodcall)
##      token postcircumfix:sym<< >> ( --> Methodcall)
##          { '<<' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> [ '>>' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] }

sub postcircumfix__S_113LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_113LtLt_GtGt',$retree) }
sub postcircumfix__S_113LtLt_GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_113LtLt_GtGt",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>>')} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_114Fre_Nch (  :$sym is context<rw> = < > --> Methodcall)
##      token postcircumfix:sym< > ( --> Methodcall)
##          { '' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))> [ '' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] }

sub postcircumfix__S_114Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_114Fre_Nch',$retree) }
sub postcircumfix__S_114Fre_Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_114Fre_Nch",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('',''))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('')} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postop
##      token postop {
##          | <postfix>         { $<O> := $<postfix><O>; $<sym> := $<postfix><sym>; }
##          | <postcircumfix>   { $<O> := $<postcircumfix><O>; $<sym> := $<postcircumfix><sym>; }
##      }

sub postop__PEEK { $_[0]->_AUTOLEXpeek('postop',$retree) }
sub postop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "postop", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'postop_00') {
$C->deb("Fate passed to postop_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postop_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postop_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix'], sub {
my $C = shift;
$C->postfix
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{postfix}{O}; $M->{sym} = $M->{postfix}{sym}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{postcircumfix}{O}; $M->{sym} = $M->{postcircumfix}{sym}; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token methodop
##      token methodop {
##          [
##          | <longname>
##          | <?before '$' | '@' > <variable> { $*VAR = $<variable> }
##          | <?before <[ ' " ]> > <quote>
##              { $<quote> ~~ /\W/ or $.panic("Useless use of quotes") }
##          ] <.unsp>? 
##      
##          :dba('method arguments')
##          [
##          | ':' <?before \s> <!{ $*INTERPOLATION }> <arglist>
##          | <?[\\(]> <args>
##          ]?
##      }

sub methodop__PEEK { $_[0]->_AUTOLEXpeek('methodop',$retree) }
sub methodop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'args'} = [];

$self->_MATCHIFYr($S, "methodop", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'methodop_01') {
$C->deb("Fate passed to methodop_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'methodop_02') {
$C->deb("Fate passed to methodop_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('$')
},
sub { my $C=shift;
$C->_EXACT('@')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;  $::VAR = $M->{variable} ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G['"]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
}))) {
scalar(do {
my $M = $C;  $M->{quote} =~ qr/\W/ or $C->panic("Useless use of quotes") ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'methodop_04') {
$C->deb("Fate passed to methodop_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::INTERPOLATION 
})
}))) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->_PATTERN(qr/\G[\\(]/)
}))) {
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token semiarglist
##      token semiarglist {
##          <arglist> ** ';'
##          <.ws>
##      }

sub semiarglist__PEEK { $_[0]->_AUTOLEXpeek('semiarglist',$retree) }
sub semiarglist {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];

$self->_MATCHIFYr($S, "semiarglist", 
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(';')
}, sub { my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->ws;
}
else {
();
}
}
);
}

## token arglist
##      token arglist {
##          :my $inv_ok = $*INVOCANT_OK;
##          :my StrPos $endargs is context<rw> = 0;
##          :my $GOAL is context = 'endargs';
##          <.ws>
##          :dba('argument list')
##          [
##          | <?stdstopper>
##          | <EXPR(item %list_infix)> {{
##                  my $delims = $<EXPR><delims>;
##                  for @$delims {
##                      if ($_.<sym> // '') eq ':' {
##                          if $inv_ok {
##                              $*INVOCANT_IS = $<EXPR><list>[0];
##                          }
##                      }
##                  }
##              }}
##          ]
##      }

sub arglist__PEEK { $_[0]->_AUTOLEXpeek('arglist',$retree) }
sub arglist {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $inv_ok = $::INVOCANT_OK;
local $::endargs =  0;
local $::GOAL =  'endargs';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "arglist", 
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'arglist_01') {
$C->deb("Fate passed to arglist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'arglist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("arglist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%list_infix)
}))) {
scalar(do {
my $M = $C; 
my $delims = $M->{EXPR}{delims};
for (@$delims) {
if (($_->{'sym'} // '') eq ':') {
if ($inv_ok) {
$::INVOCANT_IS = $M->{EXPR}{list}[0];
}
}
}
;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token circumfix__S_115Cur_Ly (  :$sym is context<rw> = <{ }> --> Term)
##      token circumfix:sym<{ }> ( --> Term) {
##          <?before '{' | <.lambda> > <pblock>
##      }

sub circumfix__S_115Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_115Cur_Ly',$retree) }
sub circumfix__S_115Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "circumfix__S_115Cur_Ly",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'circumfix__S_115Cur_Ly_01') {
$C->deb("Fate passed to circumfix__S_115Cur_Ly_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'circumfix__S_115Cur_Ly_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("circumfix__S_115Cur_Ly_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->lambda
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
});
}
else {
();
}
}
);
}

## token constant_declarator
##      token constant_declarator {
##          :my $IN_DECL is context<rw> = 1;
##          <identifier>
##          <?{ $*SCOPE eq 'constant' }>
##          <!{ $.is_name($<identifier>.Str) }>
##          { $*IN_DECL = 0; self.add_name($<identifier>.Str) }
##          <.ws>
##      
##          <trait>*
##      }

sub constant_declarator__PEEK { $_[0]->_AUTOLEXpeek('constant_declarator',$retree) }
sub constant_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "constant_declarator", 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::SCOPE eq 'constant' 
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $C->is_name($M->{identifier}->Str) ;
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::IN_DECL = 0; $self->add_name($M->{identifier}->Str) ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token variable_declarator
##      token variable_declarator {
##          :my $IN_DECL is context<rw> = 1;
##          <variable>
##          { $*IN_DECL = 0; self.add_variable($<variable>.Str) }
##          [   # Is it a shaped array or hash declaration?
##            #  <?{ $<sigil> eq '@' | '%' }>
##              <.unsp>?
##              $<shape> = [
##              | '(' ~ ')' <signature>
##              | :dba('shape definition') '[' ~ ']' <semilist>
##              | :dba('shape definition') '{' ~ '}' <semilist>
##              | <?before '<'> <postcircumfix>
##              ]*
##          ]?
##          <.ws>
##      
##          <trait>*
##      }

sub variable_declarator__PEEK { $_[0]->_AUTOLEXpeek('variable_declarator',$retree) }
sub variable_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];
$C->{'signature'} = [];
$C->{'shape'} = [];
$C->{'postcircumfix'} = [];
$C->{'semilist'} = [];

$self->_MATCHIFY($S, "variable_declarator", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
})
}, $C->ws)
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['shape'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_declarator_02') {
$C->deb("Fate passed to variable_declarator_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_declarator_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_declarator_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'variable_declarator')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'shape definition')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}' , 'shape definition')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
}, $C->before(sub { my $C=shift;
$C->_EXACT('<')
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
})
}))
}, scalar(do {
my $M = $C;  $::IN_DECL = 0; $self->add_variable($M->{variable}->Str) ;
}, $C))
}, $C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))
);
}

## rule scoped
##      rule scoped {
##          :dba('scoped declarator')
##          [
##          | <declarator>
##          | <regex_declarator>
##          | <package_declarator>
##          | <fulltypename>+
##              {
##                  my $t = $<fulltypename>;
##                  @$t > 1 and $.panic("Multiple prefix constraints not yet supported")
##              }
##              <multi_declarator>
##          | <multi_declarator>
##          ]
##          || <?before <[A..Z]> > <longname> {{
##                  my $t = $<longname>.Str;
##                  if not $.is_known($t) {
##                      $.panic("In \"$*SCOPE\" declaration, typename $t must be predeclared (or marked as declarative with :: prefix)");
##                  }
##              }}
##              <!> # drop through
##          || <.panic: "Malformed $*SCOPE">
##      }

sub scoped__PEEK { $_[0]->_AUTOLEXpeek('scoped',$retree) }
sub scoped {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'fulltypename'} = [];

$self->_MATCHIFYr($S, "scoped", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'scoped_01') {
$C->deb("Fate passed to scoped_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'scoped_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scoped_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{fulltypename};
@$t > 1 and $C->panic("Multiple prefix constraints not yet supported")
;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[A-Z]/))) {
$C->ws;
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{longname}->Str;
if (not $C->is_known($t)) {
$C->panic("In \"$::SCOPE\" declaration, typename $t must be predeclared (or marked as declarative with :: prefix)");
}
;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed $::SCOPE"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}


## token scope_declarator__S_116my (:$endsym is context = 'nofun', :$sym is context<rw> = 'my')
##      token scope_declarator:my        { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_116my__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_116my',$retree) }
sub scope_declarator__S_116my {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'my';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_116my", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmy/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{sym} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_117our (:$endsym is context = 'nofun', :$sym is context<rw> = 'our')
##      token scope_declarator:our       { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_117our__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_117our',$retree) }
sub scope_declarator__S_117our {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'our';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_117our", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gour/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{sym} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_118state (:$endsym is context = 'nofun', :$sym is context<rw> = 'state')
##      token scope_declarator:state     { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_118state__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_118state',$retree) }
sub scope_declarator__S_118state {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'state';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_118state", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gstate/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{sym} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_119constant (:$endsym is context = 'nofun', :$sym is context<rw> = 'constant')
##      token scope_declarator:constant  { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_119constant__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_119constant',$retree) }
sub scope_declarator__S_119constant {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'constant';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_119constant", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gconstant/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{sym} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_120has (:$endsym is context = 'nofun', :$sym is context<rw> = 'has')
##      token scope_declarator:has       { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_120has__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_120has',$retree) }
sub scope_declarator__S_120has {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'has';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_120has", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghas/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{sym} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_121augment (:$endsym is context = 'nofun', :$sym is context<rw> = 'augment')
##      token scope_declarator:augment   { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_121augment__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_121augment',$retree) }
sub scope_declarator__S_121augment {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'augment';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_121augment", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gaugment/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{sym} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_122supersede (:$endsym is context = 'nofun', :$sym is context<rw> = 'supersede')
##      token scope_declarator:supersede { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_122supersede__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_122supersede',$retree) }
sub scope_declarator__S_122supersede {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'supersede';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_122supersede", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsupersede/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{sym} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token package_declarator__S_123class (:$sym is context<rw> = 'class')
##      token package_declarator:class {
##          :my $PKGDECL is context = 'class';
##          <sym> <package_def>
##      }

sub package_declarator__S_123class__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_123class',$retree) }
sub package_declarator__S_123class {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'class';
local $::PKGDECL =  'class';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_123class", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gclass/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_124grammar (:$sym is context<rw> = 'grammar')
##      token package_declarator:grammar {
##          :my $PKGDECL is context = 'grammar';
##          <sym> <package_def>
##      }

sub package_declarator__S_124grammar__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_124grammar',$retree) }
sub package_declarator__S_124grammar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'grammar';
local $::PKGDECL =  'grammar';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_124grammar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggrammar/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_125module (:$sym is context<rw> = 'module')
##      token package_declarator:module {
##          :my $PKGDECL is context = 'module';
##          <sym> <package_def>
##      }

sub package_declarator__S_125module__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_125module',$retree) }
sub package_declarator__S_125module {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'module';
local $::PKGDECL =  'module';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_125module", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmodule/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_126package (:$sym is context<rw> = 'package')
##      token package_declarator:package {
##          :my $PKGDECL is context = 'package';
##          <sym> <package_def>
##      }

sub package_declarator__S_126package__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_126package',$retree) }
sub package_declarator__S_126package {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'package';
local $::PKGDECL =  'package';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_126package", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gpackage/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_127role (:$sym is context<rw> = 'role')
##      token package_declarator:role {
##          :my $PKGDECL is context = 'role';
##          <sym> <package_def>
##      }

sub package_declarator__S_127role__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_127role',$retree) }
sub package_declarator__S_127role {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'role';
local $::PKGDECL =  'role';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_127role", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grole/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_128knowhow (:$sym is context<rw> = 'knowhow')
##      token package_declarator:knowhow {
##          :my $PKGDECL is context = 'knowhow';
##          <sym> <package_def>
##      }

sub package_declarator__S_128knowhow__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_128knowhow',$retree) }
sub package_declarator__S_128knowhow {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'knowhow';
local $::PKGDECL =  'knowhow';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_128knowhow", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gknowhow/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_129require (:$sym is context<rw> = 'require')
##      token package_declarator:require {   # here because of declarational aspects
##          <sym> <.ws>
##          [
##          || <module_name> <EXPR>?
##          || <EXPR>
##          ]
##      }

sub package_declarator__S_129require__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_129require',$retree) }
sub package_declarator__S_129require {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'require';


my $C = $self;
my $S = $C->{_pos};
$C->{'EXPR'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_129require", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grequire/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
});
}
else {
();
}
}} 
or
eval { push @gather, $C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_130trusts (:$sym is context<rw> = 'trusts')
##      token package_declarator:trusts {
##          <sym> <.ws>
##          <module_name>
##      }

sub package_declarator__S_130trusts__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_130trusts',$retree) }
sub package_declarator__S_130trusts {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'trusts';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_130trusts", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtrusts/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_131does (:$sym is context<rw> = 'does')
##      token package_declarator:does {
##          <sym> <.ws>
##          <typename>
##      }

sub package_declarator__S_131does__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_131does',$retree) }
sub package_declarator__S_131does {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'does';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_131does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule package_def
##      rule package_def {
##          :my $longname;
##          [
##              [
##                  <def_module_name>{
##                      $longname = $<def_module_name>[0]<longname>;
##                      $.add_name($longname.Str);
##                  }
##              ]?
##              <trait>*
##              [
##              <?before '{'>
##              {{
##                  # figure out the actual full package name (nested in outer package)
##                      my $pkg = $*PKGNAME || "GLOBAL";
##                      my $shortname;
##                      if $longname {
##                           $shortname = $longname.<name>.Str;
##                      }
##                      else {
##                          $shortname = '_anon_';
##                      }
##                      $*PKGNAME = $pkg ~ '::' ~ $shortname;
##                      my $newpkg = $*CURPKG.{$shortname ~ '::'} //= {};
##                      $newpkg.<PARENT::> = $*CURPKG;
##                      $*CURPKG = $newpkg;
##                      push @PKGS, $pkg;
##                      # say "adding $newpkg " ~ $*PKGNAME;
##                  }}
##                  <block>
##                  {{
##                      $*PKGNAME = pop(@PKGS);
##                      $*CURPKG = $*CURPKG.{'PARENT::'};
##                  }}
##                  {*}                                                     #= block
##              || <?{ $*begin_compunit }> {} <?before ';'>
##                  {{
##                      $longname orelse $.panic("Compilation unit cannot be anonymous");
##                      my $shortname = $longname.<name>.Str;
##                      $*PKGNAME = $shortname;
##                      my $newpkg = $*CURPKG.{$shortname ~ '::'} //= {};
##                      $newpkg.<PARENT::> = $*CURPKG;
##                      $*CURPKG = $newpkg;
##                      $*begin_compunit = 0;
##                  }}
##                  {*}                                                     #= semi
##              || <.panic: "Unable to parse " ~ $*PKGDECL ~ " definition">
##              ]
##          ] || <.panic: "Malformed $*PKGDECL">
##      }

sub package_def__PEEK { $_[0]->_AUTOLEXpeek('package_def',$retree) }
sub package_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $longname;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];
$C->{'def_module_name'} = [];

$self->_MATCHIFYr($S, "package_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['def_module_name'], sub {
my $C = shift;
$C->def_module_name
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$longname = $M->{def_module_name}[0]{'longname'};
$C->add_name($longname->Str);
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

# figure out the actual full package name (nested in outer package)
my $pkg = $::PKGNAME || "GLOBAL";
my $shortname;
if ($longname) {
$shortname = $longname->{'name'}->Str;
}
else {
$shortname = '_anon_';
}
$::PKGNAME = $pkg . '::' . $shortname;
my $newpkg = $CURPKG->{$shortname . '::'} //= {};
$newpkg->{'PARENT::'} = $::CURPKG;
$::CURPKG = $newpkg;
push @PKGS, $pkg;
# say "adding $newpkg " . $::PKGNAME;

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

$::PKGNAME = pop(@PKGS);
$::CURPKG = $CURPKG->{'PARENT::'};

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'package_def_block'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::begin_compunit 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(';')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

$longname or $C->panic("Compilation unit cannot be anonymous");
my $shortname = $longname->{'name'}->Str;
$::PKGNAME = $shortname;
my $newpkg = $CURPKG->{$shortname . '::'} //= {};
$newpkg->{'PARENT::'} = $::CURPKG;
$::CURPKG = $newpkg;
$::begin_compunit = 0;

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'package_def_semi'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Unable to parse " . $::PKGDECL . " definition"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed $::PKGDECL"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## token declarator
##      token declarator {
##          [
##          | <constant_declarator>
##          | <variable_declarator>
##          | '(' ~ ')' <signature> <trait>*
##          | <routine_declarator>
##          | <regex_declarator>
##          | <type_declarator>
##          ]
##      }

sub declarator__PEEK { $_[0]->_AUTOLEXpeek('declarator',$retree) }
sub declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];

$self->_MATCHIFY($S, "declarator", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'declarator_01') {
$C->deb("Fate passed to declarator_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'declarator_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("declarator_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['constant_declarator'], sub {
my $C = shift;
$C->constant_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['variable_declarator'], sub {
my $C = shift;
$C->variable_declarator
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
})
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'declarator')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
$C->_SUBSUME(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
},
sub { my $C=shift;
$C->_SUBSUME(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub { my $C=shift;
$C->_SUBSUME(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token multi_declarator__S_132multi (:$sym is context<rw> = 'multi')
##      token multi_declarator:multi { <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed multi'> ] }

sub multi_declarator__S_132multi__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_132multi',$retree) }
sub multi_declarator__S_132multi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'multi';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_132multi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmulti/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} 
or
eval { push @gather, $C->panic('Malformed multi')} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_133proto (:$sym is context<rw> = 'proto')
##      token multi_declarator:proto { <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed proto'> ] }

sub multi_declarator__S_133proto__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_133proto',$retree) }
sub multi_declarator__S_133proto {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'proto';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_133proto", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gproto/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} 
or
eval { push @gather, $C->panic('Malformed proto')} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_134only (:$sym is context<rw> = 'only')
##      token multi_declarator:only  { <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed only'> ] }

sub multi_declarator__S_134only__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_134only',$retree) }
sub multi_declarator__S_134only {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'only';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_134only", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gonly/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} 
or
eval { push @gather, $C->panic('Malformed only')} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_135null (:$sym is context<rw> = 'null')
##      token multi_declarator:null  { <declarator> }

sub multi_declarator__S_135null__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_135null',$retree) }
sub multi_declarator__S_135null {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'null';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_135null", 
$C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
);
}

## token routine_declarator__S_136sub (:$sym is context<rw> = 'sub')
##      token routine_declarator:sub       { <sym> <routine_def> }

sub routine_declarator__S_136sub__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_136sub',$retree) }
sub routine_declarator__S_136sub {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sub';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_136sub", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsub/))) {
$C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
});
}
else {
();
}
}
);
}
## token routine_declarator__S_137method (:$sym is context<rw> = 'method')
##      token routine_declarator:method    { <sym> <method_def> }

sub routine_declarator__S_137method__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_137method',$retree) }
sub routine_declarator__S_137method {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'method';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_137method", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmethod/))) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
}
);
}
## token routine_declarator__S_138submethod (:$sym is context<rw> = 'submethod')
##      token routine_declarator:submethod { <sym> <method_def> }

sub routine_declarator__S_138submethod__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_138submethod',$retree) }
sub routine_declarator__S_138submethod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'submethod';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_138submethod", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubmethod/))) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
}
);
}
## token routine_declarator__S_139macro (:$sym is context<rw> = 'macro')
##      token routine_declarator:macro     { <sym> <macro_def> }

sub routine_declarator__S_139macro__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_139macro',$retree) }
sub routine_declarator__S_139macro {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'macro';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_139macro", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmacro/))) {
$C->_SUBSUMEr(['macro_def'], sub {
my $C = shift;
$C->macro_def
});
}
else {
();
}
}
);
}

## token regex_declarator__S_140regex (:$sym is context<rw> = 'regex')
##      token regex_declarator:regex { <sym>       <regex_def> }

sub regex_declarator__S_140regex__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_140regex',$retree) }
sub regex_declarator__S_140regex {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'regex';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_140regex", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gregex/))) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
}
);
}
## token regex_declarator__S_141token (:$sym is context<rw> = 'token')
##      token regex_declarator:token { <sym>       <regex_def> }

sub regex_declarator__S_141token__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_141token',$retree) }
sub regex_declarator__S_141token {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'token';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_141token", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtoken/))) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
}
);
}
## token regex_declarator__S_142rule (:$sym is context<rw> = 'rule')
##      token regex_declarator:rule  { <sym>       <regex_def> }

sub regex_declarator__S_142rule__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_142rule',$retree) }
sub regex_declarator__S_142rule {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rule';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_142rule", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grule/))) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
}
);
}

# Most of these special variable rules are there simply to catch old p5 brainos

## token special_variable__S_143Dollar_a2_ (:$sym is context<rw> = <$>)
##      token special_variable:sym<$> { <sym> }

sub special_variable__S_143Dollar_a2___PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_143Dollar_a2_',$retree) }
sub special_variable__S_143Dollar_a2_ {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_143Dollar_a2_", 
$C->_PATTERN(qr/\G\$/)
);
}

## token special_variable__S_144DollarBang (:$sym is context<rw> = <$!>)
##      token special_variable:sym<$!> { <sym> <!before \w> }

sub special_variable__S_144DollarBang__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_144DollarBang',$retree) }
sub special_variable__S_144DollarBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_144DollarBang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\!/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
});
}
else {
();
}
}
);
}

## token special_variable__S_145DollarBangCur_Ly (:$sym is context<rw> = <$!{ }>)
##      token special_variable:sym<$!{ }> {
##          # XXX the backslashes are necessary here for bootstrapping, not for P6...
##          ( '$!{' :: (.*?) '}' )
##          <.obs($0.Str ~ " variable", 'smart match against $!')>
##      }

sub special_variable__S_145DollarBangCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_145DollarBangCur_Ly',$retree) }
sub special_variable__S_145DollarBangCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($!{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_145DollarBangCur_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
$C->obs($$C{0}->Str . " variable", 'smart match against $!')
},     $C->_SUBSUME(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('$!{'))
})}
}))
);
}

## token special_variable__S_146DollarSlash (:$sym is context<rw> = <$/>)
##      token special_variable:sym<$/> {
##          <sym>
##          # XXX assuming nobody ever wants to assign $/ directly anymore...
##          [ <?before \h* '=' <![=]> >
##              <.obs('$/ variable as input record separator',
##                   "filehandle's :irs attribute")>
##          ]?
##      }

sub special_variable__S_146DollarSlash__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_146DollarSlash',$retree) }
sub special_variable__S_146DollarSlash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($/);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_146DollarSlash", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\//))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[=]/)
});
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->obs('$/ variable as input record separator',
"filehandle's :irs attribute");
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token special_variable__S_147DollarTilde (:$sym is context<rw> = <$~>)
##      token special_variable:sym<$~> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$~ variable', 'Form module')>
##      }

sub special_variable__S_147DollarTilde__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_147DollarTilde',$retree) }
sub special_variable__S_147DollarTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_147DollarTilde", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$~ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_147DollarTilde_01') {
$C->deb("Fate passed to special_variable__S_147DollarTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_147DollarTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_147DollarTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\~/))
);
}

## token special_variable__S_148DollarGrave (:$sym is context<rw> = <$`>)
##      token special_variable:sym<$`> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$` variable', 'explicit pattern before <(')>
##      }

sub special_variable__S_148DollarGrave__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_148DollarGrave',$retree) }
sub special_variable__S_148DollarGrave {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($`);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_148DollarGrave", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$` variable', 'explicit pattern before <(')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_148DollarGrave_01') {
$C->deb("Fate passed to special_variable__S_148DollarGrave_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_148DollarGrave_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_148DollarGrave_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\`/))
);
}

## token special_variable__S_149DollarAt (:$sym is context<rw> = <$@>)
##      token special_variable:sym<$@> {
##          <sym> ::
##          <.obs('$@ variable as eval error', '$!')>
##      }

sub special_variable__S_149DollarAt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_149DollarAt',$retree) }
sub special_variable__S_149DollarAt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_149DollarAt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$@ variable as eval error', '$!')
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\@/))
);
}

## token special_variable__S_150DollarSharp (:$sym is context<rw> = <$#>)
##      token special_variable:sym<$#> {
##          <sym> ::
##          [
##          || (\w+) <.obs("\$#" ~ $0.Str ~ " variable", "\@\{" ~ $0.Str ~ "}.end")>
##          || <.obs('$# variable', '.fmt')>
##          ]
##      }

sub special_variable__S_150DollarSharp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_150DollarSharp',$retree) }
sub special_variable__S_150DollarSharp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($#);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_150DollarSharp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->obs("\$#" . $$C{0}->Str . " variable", "\@\{" . $$C{0}->Str . "}.end")
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))} 
or
eval { push @gather, $C->obs('$# variable', '.fmt')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\#/))
);
}
## token special_variable__S_151DollarDollar (:$sym is context<rw> = <$$>)
##      token special_variable:sym<$$> {
##          <sym> <!alpha> :: <?before \s | ',' | <terminator> >
##          <.obs('$$ variable', '$*PID')>
##      }

sub special_variable__S_151DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_151DollarDollar',$retree) }
sub special_variable__S_151DollarDollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($$);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_151DollarDollar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$$ variable', '$::PID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_151DollarDollar_01') {
$C->deb("Fate passed to special_variable__S_151DollarDollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_151DollarDollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_151DollarDollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))
}, $C->_PATTERN(qr/\G\$\$/))
);
}
## token special_variable__S_152DollarPercent (:$sym is context<rw> = <$%>)
##      token special_variable:sym<$%> {
##          <sym> ::
##          <.obs('$% variable', 'Form module')>
##      }

sub special_variable__S_152DollarPercent__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_152DollarPercent',$retree) }
sub special_variable__S_152DollarPercent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_152DollarPercent", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$% variable', 'Form module')
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\%/))
);
}

# Note: this works because placeholders are restricted to lowercase
## token special_variable__S_153DollarCaretX (:$sym is context<rw> = <$^X>)
##      token special_variable:sym<$^X> {
##          <sigil> '^' $<letter> = [<[A..Z]>] \W
##          <.obscaret($<sigil>.Str ~ '^' ~ $<letter>.Str, $<sigil>, $<letter>.Str)>
##      }

sub special_variable__S_153DollarCaretX__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_153DollarCaretX',$retree) }
sub special_variable__S_153DollarCaretX {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($^X);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_153DollarCaretX", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_EXACT('^'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['letter'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) {
do { my $M = $C;
$C->obscaret($M->{sigil}->Str . '^' . $M->{letter}->Str, $M->{sigil}, $M->{letter}->Str)
; };
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token special_variable__S_154DollarCaret (:$sym is context<rw> = <$^>)
##      token special_variable:sym<$^> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$^ variable', 'Form module')>
##      }

sub special_variable__S_154DollarCaret__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_154DollarCaret',$retree) }
sub special_variable__S_154DollarCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_154DollarCaret", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$^ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_154DollarCaret_01') {
$C->deb("Fate passed to special_variable__S_154DollarCaret_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_154DollarCaret_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_154DollarCaret_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\^/))
);
}

## token special_variable__S_155DollarAmp (:$sym is context<rw> = <$&>)
##      token special_variable:sym<$&> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$& variable', '$/ or $()')>
##      }

sub special_variable__S_155DollarAmp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_155DollarAmp',$retree) }
sub special_variable__S_155DollarAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_155DollarAmp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$& variable', '$/ or $()')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_155DollarAmp_01') {
$C->deb("Fate passed to special_variable__S_155DollarAmp_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_155DollarAmp_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_155DollarAmp_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\&/))
);
}

## token special_variable__S_156DollarStar (:$sym is context<rw> = <$*>)
##      token special_variable:sym<$*> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$* variable', '^^ and $$')>
##      }

sub special_variable__S_156DollarStar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_156DollarStar',$retree) }
sub special_variable__S_156DollarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_156DollarStar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$* variable', '^^ and $$')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_156DollarStar_01') {
$C->deb("Fate passed to special_variable__S_156DollarStar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_156DollarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_156DollarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\*/))
);
}

## token special_variable__S_157DollarThesis (:$sym is context<rw> = <$)>)
##      token special_variable:sym<$)> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$) variable', '$*EGID')>
##      }

sub special_variable__S_157DollarThesis__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_157DollarThesis',$retree) }
sub special_variable__S_157DollarThesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[$)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_157DollarThesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$) variable', '$::EGID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_157DollarThesis_01') {
$C->deb("Fate passed to special_variable__S_157DollarThesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_157DollarThesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_157DollarThesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\)/))
);
}

## token special_variable__S_158DollarMinus (:$sym is context<rw> = <$->)
##      token special_variable:sym<$-> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$- variable', 'Form module')>
##      }

sub special_variable__S_158DollarMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_158DollarMinus',$retree) }
sub special_variable__S_158DollarMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_158DollarMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$- variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_158DollarMinus_01') {
$C->deb("Fate passed to special_variable__S_158DollarMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_158DollarMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_158DollarMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\-/))
);
}

## token special_variable__S_159DollarEqual (:$sym is context<rw> = <$=>)
##      token special_variable:sym<$=> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$= variable', 'Form module')>
##      }

sub special_variable__S_159DollarEqual__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_159DollarEqual',$retree) }
sub special_variable__S_159DollarEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_159DollarEqual", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$= variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_159DollarEqual_01') {
$C->deb("Fate passed to special_variable__S_159DollarEqual_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_159DollarEqual_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_159DollarEqual_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\=/))
);
}

## token special_variable__S_160AtPlus (:$sym is context<rw> = <@+>)
##      token special_variable:sym<@+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_160AtPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_160AtPlus',$retree) }
sub special_variable__S_160AtPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_160AtPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('@+ variable', '.to method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_160AtPlus_01') {
$C->deb("Fate passed to special_variable__S_160AtPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_160AtPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_160AtPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\@\+/))
);
}

## token special_variable__S_161PercentPlus (:$sym is context<rw> = <%+>)
##      token special_variable:sym<%+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('%+ variable', '.to method')>
##      }

sub special_variable__S_161PercentPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_161PercentPlus',$retree) }
sub special_variable__S_161PercentPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_161PercentPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('%+ variable', '.to method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_161PercentPlus_01') {
$C->deb("Fate passed to special_variable__S_161PercentPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_161PercentPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_161PercentPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\%\+/))
);
}

## token special_variable__S_162DollarPlusBra_Ket (:$sym is context<rw> = <$+[ ]>)
##      token special_variable:sym<$+[ ]> {
##          '$+['
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_162DollarPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_162DollarPlusBra_Ket',$retree) }
sub special_variable__S_162DollarPlusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($+[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_162DollarPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$+['))) {
$C->obs('@+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_163AtPlusBra_Ket (:$sym is context<rw> = <@+[ ]>)
##      token special_variable:sym<@+[ ]> {
##          '@+['
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_163AtPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_163AtPlusBra_Ket',$retree) }
sub special_variable__S_163AtPlusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@+[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_163AtPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@+['))) {
$C->obs('@+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_164AtPlusCur_Ly (:$sym is context<rw> = <@+{ }>)
##      token special_variable:sym<@+{ }> {
##          '@+{'
##          <.obs('%+ variable', '.to method')>
##      }

sub special_variable__S_164AtPlusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_164AtPlusCur_Ly',$retree) }
sub special_variable__S_164AtPlusCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@+{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_164AtPlusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@+{'))) {
$C->obs('%+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_165AtMinus (:$sym is context<rw> = <@->)
##      token special_variable:sym<@-> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_165AtMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_165AtMinus',$retree) }
sub special_variable__S_165AtMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_165AtMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('@- variable', '.from method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_165AtMinus_01') {
$C->deb("Fate passed to special_variable__S_165AtMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_165AtMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_165AtMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\@\-/))
);
}

## token special_variable__S_166PercentMinus (:$sym is context<rw> = <%->)
##      token special_variable:sym<%-> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('%- variable', '.from method')>
##      }

sub special_variable__S_166PercentMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_166PercentMinus',$retree) }
sub special_variable__S_166PercentMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_166PercentMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('%- variable', '.from method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_166PercentMinus_01') {
$C->deb("Fate passed to special_variable__S_166PercentMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_166PercentMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_166PercentMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\%\-/))
);
}

## token special_variable__S_167DollarMinusBra_Ket (:$sym is context<rw> = <$-[ ]>)
##      token special_variable:sym<$-[ ]> {
##          '$-['
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_167DollarMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_167DollarMinusBra_Ket',$retree) }
sub special_variable__S_167DollarMinusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($-[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_167DollarMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$-['))) {
$C->obs('@- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_168AtMinusBra_Ket (:$sym is context<rw> = <@-[ ]>)
##      token special_variable:sym<@-[ ]> {
##          '@-['
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_168AtMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_168AtMinusBra_Ket',$retree) }
sub special_variable__S_168AtMinusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@-[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_168AtMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@-['))) {
$C->obs('@- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_169PercentMinusCur_Ly (:$sym is context<rw> = <%-{ }>)
##      token special_variable:sym<%-{ }> {
##          '@-{'
##          <.obs('%- variable', '.from method')>
##      }

sub special_variable__S_169PercentMinusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_169PercentMinusCur_Ly',$retree) }
sub special_variable__S_169PercentMinusCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(%-{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_169PercentMinusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@-{'))) {
$C->obs('%- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_170DollarPlus (:$sym is context<rw> = <$+>)
##      token special_variable:sym<$+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$+ variable', 'Form module')>
##      }

sub special_variable__S_170DollarPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_170DollarPlus',$retree) }
sub special_variable__S_170DollarPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_170DollarPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$+ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_170DollarPlus_01') {
$C->deb("Fate passed to special_variable__S_170DollarPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_170DollarPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_170DollarPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\+/))
);
}

## token special_variable__S_171DollarCurCaret_Ly (:$sym is context<rw> = <${^ }>)
##      token special_variable:sym<${^ }> {
##          ( <sigil> '{^' :: (.*?) '}' )
##          <.obscaret($0.Str, $<sigil>, $0.{0}.Str)>
##      }

sub special_variable__S_171DollarCurCaret_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_171DollarCurCaret_Ly',$retree) }
sub special_variable__S_171DollarCurCaret_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(${^ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_171DollarCurCaret_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
do { my $M = $C;
$C->obscaret($$C{0}->Str, $M->{sigil}, $$C{0}.{0}->Str)
; }
},     $C->_SUBSUME(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{^'))
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
})}
}))
);
}

# XXX should eventually rely on multi instead of nested cases here...
## method obscaret (Str $var, Str $sigil, Str $name)
sub obscaret {
my $self = shift;
my $var = shift;
my $sigil = shift;
my $name = shift;


my $repl = do { do { my $_ = $sigil; if ((0)) {}
elsif ($_ eq '$') {
do { my $_ = $name; if ((0)) {}
elsif ($_ eq 'MATCH') { '$/' }
elsif ($_ eq 'PREMATCH') { 'an explicit pattern before <(' }
elsif ($_ eq 'POSTMATCH') { 'an explicit pattern after )>' }
elsif ($_ eq 'ENCODING') { '$?ENCODING' }
elsif ($_ eq 'UNICODE') { '$?UNICODE' }  # XXX ???
elsif ($_ eq 'TAINT') { '$::TAINT' }
elsif ($_ eq 'OPEN') { 'filehandle introspection' }
elsif ($_ eq 'N') { '$-1' } # XXX ???
elsif ($_ eq 'L') { 'Form module' }
elsif ($_ eq 'A') { 'Form module' }
elsif ($_ eq 'E') { '$!.extended_os_error' }
elsif ($_ eq 'C') { 'COMPILING namespace' }
elsif ($_ eq 'D') { '$::DEBUGGING' }
elsif ($_ eq 'F') { '$::SYSTEM_FD_MAX' }
elsif ($_ eq 'H') { '$?FOO variables' }
elsif ($_ eq 'I') { '$::INPLACE' } # XXX ???
elsif ($_ eq 'O') { '$?OS or $::OS' }
elsif ($_ eq 'P') { 'whatever debugger Perl 6 comes with' }
elsif ($_ eq 'R') { 'an explicit result variable' }
elsif ($_ eq 'S') { 'the context function' } # XXX ???
elsif ($_ eq 'T') { '$::BASETIME' }
elsif ($_ eq 'V') { '$::PERL_VERSION' }
elsif ($_ eq 'W') { '$::WARNING' }
elsif ($_ eq 'X') { '$::EXECUTABLE_NAME' }
else { "a global form such as $sigil*$name" }
};
}
elsif ($_ eq '%') {
do { my $_ = $name; if ((0)) {}
elsif ($_ eq 'H') { '$?FOO variables' }
else { "a global form such as $sigil*$name" }
};
}
else { "a global form such as $sigil*$name" }
};
};
return $self->obs("$var variable", $repl);
}

## token special_variable__S_172ColonColonCur_Ly (:$sym is context<rw> = <::{ }>)
##      token special_variable:sym<::{ }> {
##          '::' <?before '{'>
##      }

sub special_variable__S_172ColonColonCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_172ColonColonCur_Ly',$retree) }
sub special_variable__S_172ColonColonCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(::{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_172ColonColonCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('::'))) {
$C->before(sub { my $C=shift;
$C->_EXACT('{')
});
}
else {
();
}
}
);
}

## token special_variable__S_173DollarCur_Ly (:$sym is context<rw> = <${ }>)
##      token special_variable:sym<${ }> {
##          ( <[$@%]> '{' :: (.*?) '}' )
##          <.obs("" ~ $0.Str ~ " variable", "\{" ~ $<sigil>.Str ~ "}(" ~ $0.{0}.Str ~ ")")>
##      }

sub special_variable__S_173DollarCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_173DollarCur_Ly',$retree) }
sub special_variable__S_173DollarCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(${ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_173DollarCur_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
do { my $M = $C;
$C->obs("" . $$C{0}->Str . " variable", "\{" . $M->{sigil}->Str . "}(" . $$C{0}.{0}->Str . ")")
; }
},     $C->_SUBSUME(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
}, $C->_PATTERN(qr/\G[$@%]/))
})}
}))
);
}

## token special_variable__S_174DollarBra (:$sym is context<rw> = <$[>)
##      token special_variable:sym<$[> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$[ variable', 'user-defined array indices')>
##      }

sub special_variable__S_174DollarBra__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_174DollarBra',$retree) }
sub special_variable__S_174DollarBra {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($[);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_174DollarBra", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$[ variable', 'user-defined array indices')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_174DollarBra_01') {
$C->deb("Fate passed to special_variable__S_174DollarBra_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_174DollarBra_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_174DollarBra_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\[/))
);
}

## token special_variable__S_175DollarKet (:$sym is context<rw> = <$]>)
##      token special_variable:sym<$]> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$] variable', '$*PERL_VERSION')>
##      }

sub special_variable__S_175DollarKet__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_175DollarKet',$retree) }
sub special_variable__S_175DollarKet {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($]);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_175DollarKet", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$] variable', '$::PERL_VERSION')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_175DollarKet_01') {
$C->deb("Fate passed to special_variable__S_175DollarKet_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_175DollarKet_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_175DollarKet_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\]/))
);
}

## token special_variable__S_176DollarBack (:$sym is context<rw> = <$\\>)
##      token special_variable:sym<$\\> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$\\ variable', "the filehandle's :ors attribute")>
##      }

sub special_variable__S_176DollarBack__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_176DollarBack',$retree) }
sub special_variable__S_176DollarBack {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_176DollarBack", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$\\ variable', "the filehandle's :ors attribute")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_176DollarBack_01') {
$C->deb("Fate passed to special_variable__S_176DollarBack_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_176DollarBack_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_176DollarBack_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\\/))
);
}

## token special_variable__S_177DollarVert (:$sym is context<rw> = <$|>)
##      token special_variable:sym<$|> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$| variable', 'Form module')>
##      }

sub special_variable__S_177DollarVert__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_177DollarVert',$retree) }
sub special_variable__S_177DollarVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_177DollarVert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$| variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_177DollarVert_01') {
$C->deb("Fate passed to special_variable__S_177DollarVert_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_177DollarVert_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_177DollarVert_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\|/))
);
}

## token special_variable__S_178DollarColon (:$sym is context<rw> = <$:>)
##      token special_variable:sym<$:> {
##          <sym> <?before <[\x20\t\n\],=)}]> >
##          <.obs('$: variable', 'Form module')>
##      }

sub special_variable__S_178DollarColon__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_178DollarColon',$retree) }
sub special_variable__S_178DollarColon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_178DollarColon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\:/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\n\],=)}]/)
}))) {
$C->obs('$: variable', 'Form module');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token special_variable__S_179DollarSemi (:$sym is context<rw> = <$;>)
##      token special_variable:sym<$;> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$; variable', 'real multidimensional hashes')>
##      }

sub special_variable__S_179DollarSemi__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_179DollarSemi',$retree) }
sub special_variable__S_179DollarSemi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($;);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_179DollarSemi", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$; variable', 'real multidimensional hashes')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_179DollarSemi_01') {
$C->deb("Fate passed to special_variable__S_179DollarSemi_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_179DollarSemi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_179DollarSemi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\;/))
);
}

## token special_variable__S_180DollarSingle (:$sym is context<rw> = <$'>)
##      token special_variable:sym<$'> { #'
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")>
##      }

sub special_variable__S_180DollarSingle__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_180DollarSingle',$retree) }
sub special_variable__S_180DollarSingle {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($');


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_180DollarSingle", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$' . "'" . 'variable', "explicit pattern after )\x3E")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_180DollarSingle_01') {
$C->deb("Fate passed to special_variable__S_180DollarSingle_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_180DollarSingle_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_180DollarSingle_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\'/))
);
}

## token special_variable__S_181DollarDouble (:$sym is context<rw> = <$">)
##      token special_variable:sym<$"> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$" variable', '.join() method')>
##      }

sub special_variable__S_181DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_181DollarDouble',$retree) }
sub special_variable__S_181DollarDouble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($");


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_181DollarDouble", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$" variable', '.join() method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_181DollarDouble_01') {
$C->deb("Fate passed to special_variable__S_181DollarDouble_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_181DollarDouble_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_181DollarDouble_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\"/))
);
}

## token special_variable__S_182DollarComma (:$sym is context<rw> = <$,>)
##      token special_variable:sym<$,> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$, variable', ".join() method")>
##      }

sub special_variable__S_182DollarComma__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_182DollarComma',$retree) }
sub special_variable__S_182DollarComma {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[$,];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_182DollarComma", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$, variable', ".join() method")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_182DollarComma_01') {
$C->deb("Fate passed to special_variable__S_182DollarComma_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_182DollarComma_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_182DollarComma_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\,/))
);
}

## token special_variable__S_183DollarLt (:$sym is context<rw> = ['$<'])
##      token special_variable:sym['$<'] {
##          <sym> :: <!before \s* \w+ \s* '>' >
##          <.obs('$< variable', '$*UID')>
##      }

sub special_variable__S_183DollarLt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_183DollarLt',$retree) }
sub special_variable__S_183DollarLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // ['$<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_183DollarLt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$< variable', '$::UID')
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('>')
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
}, $C->_PATTERN(qr/\G((?:\w)++)/))
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
})
}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\[\'\$\<\'\]/))
);
}

## token special_variable__S_184DollarGt (:$sym is context<rw> = \$>)
##      token special_variable:sym\$> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs("$() variable", '$*EUID')>
##      }

sub special_variable__S_184DollarGt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_184DollarGt',$retree) }
sub special_variable__S_184DollarGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['\$>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_184DollarGt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs("$() variable", '$::EUID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_184DollarGt_01') {
$C->deb("Fate passed to special_variable__S_184DollarGt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_184DollarGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_184DollarGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\>/))
);
}

## token special_variable__S_185DollarDot (:$sym is context<rw> = <$.>)
##      token special_variable:sym<$.> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$. variable', "filehandle's .line method")>
##      }

sub special_variable__S_185DollarDot__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_185DollarDot',$retree) }
sub special_variable__S_185DollarDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_185DollarDot", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$. variable', "filehandle's .line method")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_185DollarDot_01') {
$C->deb("Fate passed to special_variable__S_185DollarDot_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_185DollarDot_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_185DollarDot_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\./))
);
}

## token special_variable__S_186DollarQuestion (:$sym is context<rw> = <$?>)
##      token special_variable:sym<$?> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$? variable as child error', '$!')>
##      }

sub special_variable__S_186DollarQuestion__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_186DollarQuestion',$retree) }
sub special_variable__S_186DollarQuestion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_186DollarQuestion", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$? variable as child error', '$!')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_186DollarQuestion_01') {
$C->deb("Fate passed to special_variable__S_186DollarQuestion_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_186DollarQuestion_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_186DollarQuestion_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\?/))
);
}

# desigilname should only follow a sigil/twigil

## token desigilname
##      token desigilname {
##          [
##          | <?before '$' > <variable> { $*VAR = $<variable> }
##          | <longname>
##          ]
##      }

sub desigilname__PEEK { $_[0]->_AUTOLEXpeek('desigilname',$retree) }
sub desigilname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "desigilname", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'desigilname_01') {
$C->deb("Fate passed to desigilname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'desigilname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("desigilname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;  $::VAR = $M->{variable} ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token variable
##      token variable {
##          :my $IN_META is context<rw> = 0;
##          :my $sigil = '';
##          :my $twigil = '';
##          :my $name;
##          <?before <sigil> {
##              $sigil = $<sigil>.Str;
##              $*SIGIL ||= $sigil;
##          }> {}
##          [
##          || '&'
##              [
##              | <twigil>?  <sublongname> { $name = $<sublongname>.Str } {*}                                   #= subnoun
##              | '[' ~ ']' <infixish(1)>
##              ]
##          || <?before '$::('> '$' <name>?
##          || '$::' <name>? # XXX
##          || '$:' <name>? # XXX
##          || [
##              | <sigil> <twigil>? <desigilname> { $name = $<desigilname>.Str } {*}                                    #= desigilname
##              | <special_variable> {*}                                    #= special
##              | <sigil> $<index>=[\d+] {*}                                #= $0
##              # Note: $() can also parse as contextualizer in an expression; should have same effect
##              | <sigil> <?before '<' | '('> <postcircumfix> {*}           #= $()
##              | <sigil> <?{ $*IN_DECL }> {*}                              #= anondecl
##              | <.panic: "Anonymous variable requires declarator">
##              ]
##          ]
##      
##          { my $t = $<twigil>; $twigil = $t.[0].Str if @$t; }
##          [ <?{ $twigil eq '.' }>
##              [<.unsp> | '\\' | <?> ] <?before '('> <postcircumfix> {*}          #= methcall
##          ]?
##      }

sub variable__PEEK { $_[0]->_AUTOLEXpeek('variable',$retree) }
sub variable {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_META =  0;
my $sigil = '';
my $twigil = '';
my $name;


my $C = $self;
my $S = $C->{_pos};
$C->{'name'} = [];
$C->{'postcircumfix'} = [];
$C->{'twigil'} = [];

$self->_MATCHIFY($S, "variable", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable_methcall')
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->before(sub { my $C=shift;
$C->_EXACT('(')
}))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_13') {
$C->deb("Fate passed to variable_13: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_13', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_13 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
$C->_EXACT('\\')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$twigil eq '.' 
})
}))
})
})
}, scalar(do {
my $M = $C;  my $t = $M->{twigil}; $twigil = $t->[0]->Str if @$t; ;
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_03') {
$C->deb("Fate passed to variable_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['sublongname'], sub {
my $C = shift;
$C->sublongname
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $name = $M->{sublongname}->Str ;
}, $C))) {
$C->_REDUCE($S, 'variable_subnoun');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'variable')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('&'))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->name
})
})
}, $C->_EXACT('$'))
}, $C->before(sub { my $C=shift;
$C->_EXACT('$::(')
}))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->name
})
})
}, $C->_EXACT('$::'))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->name
})
})
}, $C->_EXACT('$:'))} 
or
eval { push @gather, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_09') {
$C->deb("Fate passed to variable_09: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_09', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_09 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable_desigilname')
}, scalar(do {
my $M = $C;  $name = $M->{desigilname}->Str ;
}, $C))
}, $C->_SUBSUME(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable_special')
}, $C->_SUBSUME(['special_variable'], sub {
my $C = shift;
$C->special_variable
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable_$$C{0}')
},     $C->_SUBSUME(['index'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable_$()')
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_11') {
$C->deb("Fate passed to variable_11: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_11', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_11 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable_anondecl')
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::IN_DECL 
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
$C->panic("Anonymous variable requires declarator")
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} or do { die $@ if $@ };
@gather;
}
}))
}, scalar(do {

}, $C))
}, $C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
scalar(do {
my $M = $C; 
$sigil = $M->{sigil}->Str;
$::SIGIL ||= $sigil;
;
}, $C);
}
else {
();
}
}
}))
);
}



# Note, don't reduce on a bare sigil unless you don't want a twigil or
# you otherwise don't care what the longest token is.

## token sigil__S_187Dollar (:$sym is context<rw> = <$>)
##      token sigil:sym<$>  { <sym> }

sub sigil__S_187Dollar__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_187Dollar',$retree) }
sub sigil__S_187Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_187Dollar", 
$C->_PATTERN(qr/\G\$/)
);
}
## token sigil__S_188AtAt (:$sym is context<rw> = <@@>)
##      token sigil:sym<@@> { <sym> }

sub sigil__S_188AtAt__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_188AtAt',$retree) }
sub sigil__S_188AtAt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_188AtAt", 
$C->_PATTERN(qr/\G\@\@/)
);
}
## token sigil__S_189At (:$sym is context<rw> = <@>)
##      token sigil:sym<@>  { <sym> }

sub sigil__S_189At__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_189At',$retree) }
sub sigil__S_189At {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_189At", 
$C->_PATTERN(qr/\G\@/)
);
}
## token sigil__S_190Percent (:$sym is context<rw> = <%>)
##      token sigil:sym<%>  { <sym> }

sub sigil__S_190Percent__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_190Percent',$retree) }
sub sigil__S_190Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_190Percent", 
$C->_PATTERN(qr/\G\%/)
);
}
## token sigil__S_191Amp (:$sym is context<rw> = <&>)
##      token sigil:sym<&>  { <sym> }

sub sigil__S_191Amp__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_191Amp',$retree) }
sub sigil__S_191Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_191Amp", 
$C->_PATTERN(qr/\G\&/)
);
}

## token twigil__S_192Dot (:$sym is context<rw> = <.>)
##      token twigil:sym<.> { <sym> }

sub twigil__S_192Dot__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_192Dot',$retree) }
sub twigil__S_192Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_192Dot", 
$C->_PATTERN(qr/\G\./)
);
}
## token twigil__S_193Bang (:$sym is context<rw> = <!>)
##      token twigil:sym<!> { <sym> }

sub twigil__S_193Bang__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_193Bang',$retree) }
sub twigil__S_193Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_193Bang", 
$C->_PATTERN(qr/\G\!/)
);
}
## token twigil__S_194Caret (:$sym is context<rw> = <^>)
##      token twigil:sym<^> { <sym> }

sub twigil__S_194Caret__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_194Caret',$retree) }
sub twigil__S_194Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_194Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
## token twigil__S_195Colon (:$sym is context<rw> = <:>)
##      token twigil:sym<:> { <sym> <!before ':'> }

sub twigil__S_195Colon__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_195Colon',$retree) }
sub twigil__S_195Colon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_195Colon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(':')
})
});
}
else {
();
}
}
);
}
## token twigil__S_196Star (:$sym is context<rw> = <*>)
##      token twigil:sym<*> { <sym> }

sub twigil__S_196Star__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_196Star',$retree) }
sub twigil__S_196Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_196Star", 
$C->_PATTERN(qr/\G\*/)
);
}
## token twigil__S_197Plus (:$sym is context<rw> = <+>)
##      token twigil:sym<+> { <sym> <!!worry: "The + twigil is deprecated, use the * twigil instead"> }

sub twigil__S_197Plus__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_197Plus',$retree) }
sub twigil__S_197Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_197Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->worry("The + twigil is deprecated, use the * twigil instead")
})
});
}
else {
();
}
}
);
}
## token twigil__S_198Question (:$sym is context<rw> = <?>)
##      token twigil:sym<?> { <sym> }

sub twigil__S_198Question__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_198Question',$retree) }
sub twigil__S_198Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_198Question", 
$C->_PATTERN(qr/\G\?/)
);
}
## token twigil__S_199Equal (:$sym is context<rw> = <=>)
##      token twigil:sym<=> { <sym> }

sub twigil__S_199Equal__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_199Equal',$retree) }
sub twigil__S_199Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_199Equal", 
$C->_PATTERN(qr/\G\=/)
);
}

## token deflongname
##      token deflongname {
##          :dba('name to be defined')
##          <name>
##          # XXX too soon
##          [ <colonpair>+ { $.add_macro($<name>) if $*IN_DECL; } ]?
##          { $.add_routine($<name>.Str) if $*IN_DECL; }
##      }

sub deflongname__PEEK { $_[0]->_AUTOLEXpeek('deflongname',$retree) }
sub deflongname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "deflongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{name}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C;  $C->add_routine($M->{name}->Str) if $::IN_DECL; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token longname
##      token longname {
##          <name> <colonpair>*
##      }

sub longname__PEEK { $_[0]->_AUTOLEXpeek('longname',$retree) }
sub longname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "longname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
});
}
else {
();
}
}
);
}

## token name
##      token name {
##          [
##          | <identifier> <morename>*
##          | <morename>+
##          ]
##      }

sub name__PEEK { $_[0]->_AUTOLEXpeek('name',$retree) }
sub name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'morename'} = [];

$self->_MATCHIFYr($S, "name", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'name_01') {
$C->deb("Fate passed to name_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'name_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("name_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token morename
##      token morename {
##          '::'
##          [
##              <?before '(' | <alpha> >
##              [
##              | <identifier>
##              | :dba('indirect name') '(' ~ ')' <EXPR>
##              ]
##          ]?
##      }

sub morename__PEEK { $_[0]->_AUTOLEXpeek('morename',$retree) }
sub morename {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'identifier'} = [];
$C->{'EXPR'} = [];

$self->_MATCHIFY($S, "morename", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'morename_03') {
$C->deb("Fate passed to morename_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'indirect name')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'morename_02') {
$C->deb("Fate passed to morename_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
})
})
}, $C->_EXACT('::'))
);
}

## token subshortname
##      token subshortname {
##          [
##          | <category>
##              [ <colonpair>+ { $.add_macro($<category>) if $*IN_DECL; } ]?
##          | <desigilname> { $.add_routine($<desigilname>.Str) if $*IN_DECL; }
##          ]
##      }

sub subshortname__PEEK { $_[0]->_AUTOLEXpeek('subshortname',$retree) }
sub subshortname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "subshortname", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'subshortname_01') {
$C->deb("Fate passed to subshortname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'subshortname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("subshortname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{category}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))) {
scalar(do {
my $M = $C;  $C->add_routine($M->{desigilname}->Str) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token sublongname
##      token sublongname {
##          <subshortname> <sigterm>?
##      }

sub sublongname__PEEK { $_[0]->_AUTOLEXpeek('sublongname',$retree) }
sub sublongname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'sigterm'} = [];

$self->_MATCHIFYr($S, "sublongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['subshortname'], sub {
my $C = shift;
$C->subshortname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
});
}
else {
();
}
}
);
}

## token value__S_200quote (:$sym is context<rw> = 'quote')
##      token value:quote   { <quote> }

sub value__S_200quote__PEEK { $_[0]->_AUTOLEXpeek('value__S_200quote',$retree) }
sub value__S_200quote {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "value__S_200quote", 
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
);
}
## token value__S_201number (:$sym is context<rw> = 'number')
##      token value:number  { <number> }

sub value__S_201number__PEEK { $_[0]->_AUTOLEXpeek('value__S_201number',$retree) }
sub value__S_201number {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'number';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "value__S_201number", 
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
);
}
## token value__S_202version (:$sym is context<rw> = 'version')
##      token value:version { <version> }

sub value__S_202version__PEEK { $_[0]->_AUTOLEXpeek('value__S_202version',$retree) }
sub value__S_202version {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'version';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "value__S_202version", 
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
);
}

## token typename
##      token typename {
##          [
##          | '::?'<identifier>                 # parse ::?CLASS as special case
##          | <longname>
##            <?{{
##              my $longname = $<longname>.Str;
##              if substr($longname, 0, 2) eq '::' {
##                  $.add_my_name(substr($longname, 2));
##              }
##              else {
##                  $.is_name($longname)
##              }
##            }}>
##          ]
##          # parametric type?
##          <.unsp>? [ <?before '['> <postcircumfix> ]?
##      }

sub typename__PEEK { $_[0]->_AUTOLEXpeek('typename',$retree) }
sub typename {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'postcircumfix'} = [];

$self->_MATCHIFYr($S, "typename", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'typename_01') {
$C->deb("Fate passed to typename_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'typename_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("typename_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
my $longname = $M->{longname}->Str;
if (substr($longname, 0, 2) eq '::') {
$C->add_my_name(substr($longname, 2));
}
else {
$C->is_name($longname)
}
;
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule fulltypename
##      rule fulltypename {<typename>['|'<typename>]*
##          [ of <.ws> <fulltypename> ]?
##      }

sub fulltypename__PEEK { $_[0]->_AUTOLEXpeek('fulltypename',$retree) }
sub fulltypename {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'typename'} = [];
$C->{'fulltypename'} = [];

$self->_MATCHIFYr($S, "fulltypename", 
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('of'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token numish
##      token numish {
##          [
##          | <integer>
##          | <dec_number>
##          | <rad_number>
##          | 'NaN' 
##          | 'Inf' 
##          | '+Inf' 
##          | '-Inf' 
##          ]
##      }

sub numish__PEEK { $_[0]->_AUTOLEXpeek('numish',$retree) }
sub numish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "numish", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'numish_01') {
$C->deb("Fate passed to numish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'numish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("numish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['dec_number'], sub {
my $C = shift;
$C->dec_number
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('NaN'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('Inf'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('+Inf'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-Inf'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token number__S_203rational (:$sym is context<rw> = 'rational')
##      token number:rational { <nu=integer>'/'<de=integer> }

sub number__S_203rational__PEEK { $_[0]->_AUTOLEXpeek('number__S_203rational',$retree) }
sub number__S_203rational {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rational';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "number__S_203rational", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['nu'], sub {
my $C = shift;
$C->integer
}))) {
do {
if (my ($C) = ($C->_EXACT('/'))) {
$C->_SUBSUMEr(['de'], sub {
my $C = shift;
$C->integer
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token number__S_204complex (:$sym is context<rw> = 'complex')
##      token number:complex { <re=numish>'+'<im=numish>'\\'?'i' | <im=numish>'\\'?'i' }

sub number__S_204complex__PEEK { $_[0]->_AUTOLEXpeek('number__S_204complex',$retree) }
sub number__S_204complex {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'complex';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "number__S_204complex", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'number__S_204complex_00') {
$C->deb("Fate passed to number__S_204complex_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'number__S_204complex_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("number__S_204complex_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['re'], sub {
my $C = shift;
$C->numish
}))) {
do {
if (my ($C) = ($C->_EXACT('+'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['im'], sub {
my $C = shift;
$C->numish
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('\\')
}))) {
$C->_EXACT('i');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['im'], sub {
my $C = shift;
$C->numish
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('\\')
}))) {
$C->_EXACT('i');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}
## token number__S_205numish (:$sym is context<rw> = 'numish')
##      token number:numish { <numish> }

sub number__S_205numish__PEEK { $_[0]->_AUTOLEXpeek('number__S_205numish',$retree) }
sub number__S_205numish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'numish';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "number__S_205numish", 
$C->_SUBSUMEr(['numish'], sub {
my $C = shift;
$C->numish
})
);
}

## token integer
##      token integer {
##          [
##          | 0 [ b <[01]>+           [ _ <[01]>+ ]*
##              | o <[0..7]>+         [ _ <[0..7]>+ ]*
##              | x <[0..9a..fA..F]>+ [ _ <[0..9a..fA..F]>+ ]*
##              | d \d+               [ _ \d+]*
##              | \d+[_\d+]*
##                  <!!{ $.worry("Leading 0 does not indicate octal in Perl 6") }>
##              ]
##          | \d+[_\d+]*
##          ]
##          <!!before ['.' <?before \s | ',' | '=' | <terminator> > <.panic: "Decimal point must be followed by digit">]? >
##      }

sub integer__PEEK { $_[0]->_AUTOLEXpeek('integer',$retree) }
sub integer {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "integer", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'integer_01') {
$C->deb("Fate passed to integer_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'integer_02') {
$C->deb("Fate passed to integer_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('b'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[01])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[01])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('o'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-7])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-7])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('x'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('d'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$C->worry("Leading 0 does not indicate octal in Perl 6") 
})
})
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'integer_11') {
$C->deb("Fate passed to integer_11: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_11', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_11 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->panic("Decimal point must be followed by digit");
}
else {
();
}
};
}
else {
();
}
}
})
})
})
})
});
}
else {
();
}
}
);
}

## token radint
##      token radint {
##          [
##          | <integer>
##          | <?before ':'> <rad_number> <?{
##                              defined $<rad_number><intpart>
##                              and
##                              not defined $<rad_number><fracpart>
##                          }>
##          ]
##      }

sub radint__PEEK { $_[0]->_AUTOLEXpeek('radint',$retree) }
sub radint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "radint", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'radint_01') {
$C->deb("Fate passed to radint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'radint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("radint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
defined $M->{rad_number}{intpart}
and
not defined $M->{rad_number}{fracpart}
;
})
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token escale
##      token escale {
##          <[Ee]> <[+\-]>? \d+[_\d+]*
##      }

sub escale__PEEK { $_[0]->_AUTOLEXpeek('escale',$retree) }
sub escale {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "escale", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[Ee]/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[+\-])?+)/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# careful to distinguish from both integer and 42.method
## token dec_number
##      token dec_number {
##          :dba('decimal number')
##          [
##          | $<coeff> = [           '.' \d+[_\d+]* ] <escale>?
##          | $<coeff> = [\d+[_\d+]* '.' \d+[_\d+]* ] <escale>?
##          | $<coeff> = [\d+[_\d+]*                ] <escale>
##          ]
##          <!!before [ '.' <?before \d> <.panic: "Number contains two decimal points (missing 'v' for version number?)">]? >
##      }

sub dec_number__PEEK { $_[0]->_AUTOLEXpeek('dec_number',$retree) }
sub dec_number {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'escale'} = [];

$self->_MATCHIFYr($S, "dec_number", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'dec_number_01') {
$C->deb("Fate passed to dec_number_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dec_number_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dec_number_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
})
}))) {
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
}))) {
$C->panic("Number contains two decimal points (missing 'v' for version number?)");
}
else {
();
}
};
}
else {
();
}
}
})
})
})
})
});
}
else {
();
}
}
);
}

## token rad_number
##      token rad_number {
##          ':' $<radix> = [\d+] <.unsp>?      # XXX optional dot here?
##          {}           # don't recurse in lexer
##          :dba('number in radix notation')
##          [
##          || '<'
##                  $<intpart> = [ <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]
##                  $<fracpart> = [ '.' <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]?
##                  [ '*' <base=radint> '**' <exp=radint> ]?
##             '>'
##      #      { make radcalc($<radix>, $<intpart>, $<fracpart>, $<base>, $<exp>) }
##          || <?before '['> <postcircumfix>
##          || <?before '('> <postcircumfix>
##          ]
##      }

sub rad_number__PEEK { $_[0]->_AUTOLEXpeek('rad_number',$retree) }
sub rad_number {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'exp'} = [];
$C->{'base'} = [];

$self->_MATCHIFYr($S, "rad_number", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['radix'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['intpart'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['fracpart'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
})
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['base'], sub {
my $C = shift;
$C->radint
}))) {
do {
if (my ($C) = ($C->_EXACT('**'))) {
$C->_SUBSUMEr(['exp'], sub {
my $C = shift;
$C->radint
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token octint
##      token octint {
##          <[ 0..7 ]>+ [ _ <[ 0..7 ]>+ ]*
##      }

sub octint__PEEK { $_[0]->_AUTOLEXpeek('octint',$retree) }
sub octint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "octint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-7])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-7])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token hexint
##      token hexint {
##          <[ 0..9 a..f A..F ]>+ [ _ <[ 0..9 a..f A..F ]>+ ]*
##      }

sub hexint__PEEK { $_[0]->_AUTOLEXpeek('hexint',$retree) }
sub hexint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "hexint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

our @herestub_queue;

{ package STD::Herestub;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_has 'delim' => (is => 'rw');    moose_has 'orignode' => (is => 'rw');    moose_has 'lang' => (is => 'rw');} ## end class

{ package STD::herestop;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##     token stopper
##          token stopper { ^^ {*} $<ws>=(\h*?) $*DELIM \h* <.unv>?? $$ \v? }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "stopper", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G((?:[\n])?+)/)
}, $C->_PATTERN(qr/\G(?m:$)/))
}, $C->_OPTf(sub { my $C=shift;
$C->unv
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_EXACT($::DELIM))
},     $C->_SUBSUME(['ws'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
})
})}
}))
}, $C->_REDUCE($S, 'stopper'))
}, $C->_PATTERN(qr/\G(?m:^)/))
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        text: "^^"
      - !!perl/hash:RE_method_internal 
        args: $S, 'stopper'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 0
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: stopper
              i: 0
              min: 1
              r: 1
              s: 0
              text: \h
            min: 0
            quant: 
              - "*"
              - "?"
              - ''
              - 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        var: ws
      - !!perl/hash:RE_var 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        var: $*DELIM
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: stopper
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: stopper
          i: 0
          min: 12345
          name: unv
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - "?"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        text: $$
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: stopper
          i: 0
          min: 1
          r: 1
          s: 0
          text: \v
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
RETREE_END
}
} ## end role

# XXX be sure to temporize @herestub_queue on reentry to new line of heredocs

## method heredoc ()
sub heredoc {
my $self = shift;


local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
return if $self->peek;
my $here = $self;
while (my $herestub = shift @herestub_queue) {
local $::DELIM =  $herestub->delim;
my $lang = $herestub->lang->mixin( 'STD::herestop' );
my $doc;
if (($doc) = $here->nibble($lang)) {
$here = $doc->trim_heredoc();
$herestub->orignode->{doc} = $doc;
}
else {
$self->panic("Ending delimiter $::DELIM not found");
}
}
return $self->cursor($here->{_pos});  # return to initial type
}

#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}

#proto token escape { <...> }
sub escape__PEEK { $_[0]->_AUTOLEXpeek('escape:*',$retree); }
sub escape {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'escape') {
$C->deb("Fate passed to escape: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'escape:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "escape", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}

## token starter
##      token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
## token escape__S_206none (:$sym is context<rw> = 'none')
##      token escape:none { <!> }

sub escape__S_206none__PEEK { $_[0]->_AUTOLEXpeek('escape__S_206none',$retree) }
sub escape__S_206none {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'none';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_206none", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

## token babble ($l)
##      token babble ($l) {
##          :my $lang = $l;
##          :my $start;
##          :my $stop;
##      
##          <.ws>
##          [ <quotepair> <.ws>
##              {
##                  my $kv = $<quotepair>[*-1];
##                  $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                      or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##              }
##          ]*
##      
##          {
##              ($start,$stop) = $.peek_delimiters();
##              $lang = $start ne $stop ?? $lang.balanced($start,$stop)
##                                      !! $lang.unbalanced($stop);
##              $<B> = [$lang,$start,$stop];
##          }
##      }

sub babble__PEEK { $_[0]->_AUTOLEXpeek('babble',$retree) }
sub babble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang = $l;
my $start;
my $stop;


my $C = $self;
my $S = $C->{_pos};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "babble", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{quotepair}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
($start,$stop) = $C->peek_delimiters();
$lang = $start ne $stop ? $lang->balanced($start,$stop)
: $lang->unbalanced($stop);
$M->{B} = [$lang,$start,$stop];
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quibble ($l)
##      token quibble ($l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <nibble($lang)> $stop
##      
##          {{
##              if $lang<_herelang> {
##                  push @herestub_queue,
##                      ::Herestub.new(
##                          delim => $<nibble><nibbles>[0]<TEXT>,
##                          orignode => $,
##                          lang => $lang<_herelang>,
##                      );
##              }
##          }}
##      }

sub quibble__PEEK { $_[0]->_AUTOLEXpeek('quibble',$retree) }
sub quibble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
scalar(do {
my $M = $C; 
if ($lang->{_herelang}) {
push @herestub_queue,
'STD::Herestub'->new(
delim => $M->{nibble}{nibbles}[0]{'TEXT'},
orignode => $C,
lang => $lang->{_herelang},
);
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token sibble ($l, $lang2)
##      token sibble ($l, $lang2) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <left=nibble($lang)> $stop 
##          [ <?{ $start ne $stop }>
##              <.ws>
##              [ '=' || <.panic: "Missing '='"> ]
##              <.ws>
##              <right=EXPR(item %item_assignment)>
##          || 
##              { $lang = $lang2.unbalanced($stop); }
##              <right=nibble($lang)> $stop
##          ]
##      }

sub sibble__PEEK { $_[0]->_AUTOLEXpeek('sibble',$retree) }
sub sibble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "sibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('=')} 
or
eval { push @gather, $C->panic("Missing '='")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token tribble ($l, $lang2 = $l)
##      token tribble ($l, $lang2 = $l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <left=nibble($lang)> $stop 
##          [ <?{ $start ne $stop }>
##              <.ws> <quibble($lang2)>
##          || 
##              { $lang = $lang2.unbalanced($stop); }
##              <right=nibble($lang)> $stop
##          ]
##      }

sub tribble__PEEK { $_[0]->_AUTOLEXpeek('tribble',$retree) }
sub tribble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift() // $l;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "tribble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($lang2)
});
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quasiquibble ($l)
##      token quasiquibble ($l) {
##          :my ($lang, $start, $stop);
##          :my $QUASI_QUASH is context = 0; # :COMPILING sets true
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          [
##          || <?{ $start eq '{' }> [ :lang($lang) <block> ]
##          || $start [ :lang($lang) <statementlist> ] $stop
##          ]
##      }

sub quasiquibble__PEEK { $_[0]->_AUTOLEXpeek('quasiquibble',$retree) }
sub quasiquibble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my ($lang, $start, $stop);
local $::QUASI_QUASH =  0;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quasiquibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start eq '{' 
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
});
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# note: polymorphic over many quote languages, we hope
## token nibbler
##      token nibbler {
##          :my $text = '';
##          :my $from = self.pos;
##          :my $to = $from;
##          :my @nibbles = ();
##          :my $multiline = 0;
##          :my $nibble;
##          { $<_from> = self.pos; }
##          [ <!before <stopper> >
##              [
##              || <starter> <nibbler> <stopper>
##                              {{
##                                  push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );
##      
##                                  my $n = $<nibbler>[*-1]<nibbles>;
##                                  my @n = @$n;
##      
##                                  push @nibbles, $<starter>;
##                                  push @nibbles, @n;
##                                  push @nibbles, $<stopper>;
##      
##                                  $text = '';
##                                  $to = $from = $.pos;
##                              }}
##              || <escape>     {{
##                                  push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to ), $<escape>[*-1];
##                                  $text = '';
##                                  $to = $from = $.pos;
##                              }}
##              || .
##                              {{
##                                  my $ch = substr($*ORIG, $.pos-1, 1);
##                                  $text ~= $ch;
##                                  $to = $.pos;
##                                  if $ch ~~ "\n" {
##                                      $multiline++;
##                                  }
##                              }}
##              ]
##          ]*
##          {{
##              push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );
##              $<nibbles> = \@nibbles;
##              $<_pos> = $.pos;
##              $<nibbler> :delete;
##              $<escape> :delete;
##              $<starter> :delete;
##              $<stopper> :delete;
##              $COMPILING::LAST_NIBBLE = $;
##              $COMPILING::LAST_NIBBLE_MULTILINE = $ if $multiline;
##          }}
##      }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $text = '';
my $from = $self->{_pos};
my $to = $from;
my @nibbles = ();
my $multiline = 0;
my $nibble;


my $C = $self;
my $S = $C->{_pos};
$C->{'nibbler'} = [];
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'escape'} = [];

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{_from} = $self->{_pos}; ;
}, $C))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->cursor_singleton(TEXT => $text, _from => $from, _pos => $to );

my $n = $M->{nibbler}[-1]{'nibbles'};
my @n = @$n;

push @nibbles, $M->{starter};
push @nibbles, @n;
push @nibbles, $M->{stopper};

$text = '';
$to = $from = $C->{_pos};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['escape'], sub {
my $C = shift;
$C->escape
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->cursor_singleton(TEXT => $text, _from => $from, _pos => $to ), $M->{escape}[-1];
$text = '';
$to = $from = $C->{_pos};
;
}, $C);
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_PATTERN(qr/\G(?s:.)/))) {
scalar(do {

my $ch = substr($::ORIG, $C->{_pos}-1, 1);
$text .= $ch;
$to = $C->{_pos};
if ($ch =~ "\n") {
$multiline++;
}

}, $C);
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->cursor_singleton(TEXT => $text, _from => $from, _pos => $to );
$M->{nibbles} = \@nibbles;
$M->{_pos} = $C->{_pos};
delete $M->{nibbler};
delete $M->{escape};
delete $M->{starter};
delete $M->{stopper};
$COMPILING::LAST_NIBBLE = $C;
$COMPILING::LAST_NIBBLE_MULTILINE = $C if $multiline;
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

# and this is what makes nibbler polymorphic...
## method nibble ($lang)
sub nibble {
my $self = shift;
my $lang = shift;


my $outerlang = (ref($self)||$self);
local $::LANG =  $outerlang;
$self->cursor_fresh($lang)->nibbler;
}


## token quote__S_207Single_Single (:$sym is context<rw> = <' '>)
##      token quote:sym<' '>   { "'" <nibble($.cursor_fresh( ::STD::Q ).tweak(:q).unbalanced("'"))> "'" }

sub quote__S_207Single_Single__PEEK { $_[0]->_AUTOLEXpeek('quote__S_207Single_Single',$retree) }
sub quote__S_207Single_Single {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(' ')];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_207Single_Single", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G'/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->unbalanced("'"))
}))) {
$C->_PATTERN(qr/\G'/);
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_208Double_Double (:$sym is context<rw> = <" ">)
##      token quote:sym<" ">   { '"' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).unbalanced('"'))> '"' }

sub quote__S_208Double_Double__PEEK { $_[0]->_AUTOLEXpeek('quote__S_208Double_Double',$retree) }
sub quote__S_208Double_Double {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(" ")];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_208Double_Double", 
do {
if (my ($C) = ($C->_EXACT('"'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->unbalanced('"'))
}))) {
$C->_EXACT('"');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_209Fre_Nch (:$sym is context<rw> = < >)
##      token quote:sym< >   { '' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))> '' }

sub quote__S_209Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('quote__S_209Fre_Nch',$retree) }
sub quote__S_209Fre_Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_209Fre_Nch", 
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('',''))
}))) {
$C->_EXACT('');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_210LtLt_GtGt (:$sym is context<rw> = << >>)
##      token quote:sym<< >> { '<<' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> '>>' }

sub quote__S_210LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('quote__S_210LtLt_GtGt',$retree) }
sub quote__S_210LtLt_GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_210LtLt_GtGt", 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
$C->_EXACT('>>');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_211Lt_Gt (:$sym is context<rw> = < >)
##      token quote:sym< >   { '<'
##                                    [ <?before 'STDIN>' > <.obs('<STDIN>', '$' ~ '*IN.lines')> ]?  # XXX fake out gimme5
##                                    [ <?before '>' > <.obs('<>', 'lines() or ()')> ]?
##                                    <nibble($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))> '>' }

sub quote__S_211Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('quote__S_211Lt_Gt',$retree) }
sub quote__S_211Lt_Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_211Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('STDIN>')
}))) {
$C->obs('<STDIN>', '$' . '*IN.lines');
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('>')
}))) {
$C->obs('<>', 'lines() or ()');
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_212Slash_Slash (:$sym is context<rw> = </ />)
##      token quote:sym</ />   {
##          '/' <nibble( $.cursor_fresh( ::Regex ).unbalanced("/") )> [ '/' || <.panic: "Unable to parse regex; couldn't find final '/'"> ]
##          <.old_rx_mods>?
##      }

sub quote__S_212Slash_Slash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_212Slash_Slash',$retree) }
sub quote__S_212Slash_Slash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(/ /)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_212Slash_Slash", 
do {
if (my ($C) = ($C->_EXACT('/'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh( 'STD::Regex' )->unbalanced("/") )
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('/')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find final '/'")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_OPTr(sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# handle composite forms like qww
## token quote__S_213qq (:$sym is context<rw> = 'qq')
##      token quote:qq {
##          :my $qm;
##          'qq'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.Str } <.ws> <quibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( ::STD::Q ).tweak(:qq))>
##          ]
##      }

sub quote__S_213qq__PEEK { $_[0]->_AUTOLEXpeek('quote__S_213qq',$retree) }
sub quote__S_213qq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';
my $qm;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_213qq", 
do {
if (my ($C) = ($C->_EXACT('qq'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quote__S_213qq_01') {
$C->deb("Fate passed to quote__S_213qq_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_213qq_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_213qq_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{quote_mod}->Str ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
## token quote__S_214q (:$sym is context<rw> = 'q')
##      token quote:q {
##          :my $qm;
##          'q'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.Str } <quibble($.cursor_fresh( ::STD::Q ).tweak(:q).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( ::STD::Q ).tweak(:q))>
##          ]
##      }

sub quote__S_214q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_214q',$retree) }
sub quote__S_214q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'q';
my $qm;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_214q", 
do {
if (my ($C) = ($C->_EXACT('q'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quote__S_214q_01') {
$C->deb("Fate passed to quote__S_214q_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_214q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_214q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{quote_mod}->Str ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token quote__S_215Q (:$sym is context<rw> = 'Q')
##      token quote:Q {
##          :my $qm;
##          'Q'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.Str } <quibble($.cursor_fresh( ::STD::Q ).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( ::STD::Q ))>
##          ]
##      }

sub quote__S_215Q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_215Q',$retree) }
sub quote__S_215Q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';
my $qm;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_215Q", 
do {
if (my ($C) = ($C->_EXACT('Q'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quote__S_215Q_01') {
$C->deb("Fate passed to quote__S_215Q_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_215Q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_215Q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{quote_mod}->Str ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token quote_mod__S_216w (:$sym is context<rw> = 'w')
##      token quote_mod:w  { <sym> }

sub quote_mod__S_216w__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_216w',$retree) }
sub quote_mod__S_216w {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_216w", 
$C->_PATTERN(qr/\Gw/)
);
}
## token quote_mod__S_217ww (:$sym is context<rw> = 'ww')
##      token quote_mod:ww { <sym> }

sub quote_mod__S_217ww__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_217ww',$retree) }
sub quote_mod__S_217ww {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ww';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_217ww", 
$C->_PATTERN(qr/\Gww/)
);
}
## token quote_mod__S_218x (:$sym is context<rw> = 'x')
##      token quote_mod:x  { <sym> }

sub quote_mod__S_218x__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_218x',$retree) }
sub quote_mod__S_218x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_218x", 
$C->_PATTERN(qr/\Gx/)
);
}
## token quote_mod__S_219to (:$sym is context<rw> = 'to')
##      token quote_mod:to { <sym> }

sub quote_mod__S_219to__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_219to',$retree) }
sub quote_mod__S_219to {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'to';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_219to", 
$C->_PATTERN(qr/\Gto/)
);
}
## token quote_mod__S_220s (:$sym is context<rw> = 's')
##      token quote_mod:s  { <sym> }

sub quote_mod__S_220s__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_220s',$retree) }
sub quote_mod__S_220s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_220s", 
$C->_PATTERN(qr/\Gs/)
);
}
## token quote_mod__S_221a (:$sym is context<rw> = 'a')
##      token quote_mod:a  { <sym> }

sub quote_mod__S_221a__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_221a',$retree) }
sub quote_mod__S_221a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_221a", 
$C->_PATTERN(qr/\Ga/)
);
}
## token quote_mod__S_222h (:$sym is context<rw> = 'h')
##      token quote_mod:h  { <sym> }

sub quote_mod__S_222h__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_222h',$retree) }
sub quote_mod__S_222h {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_222h", 
$C->_PATTERN(qr/\Gh/)
);
}
## token quote_mod__S_223f (:$sym is context<rw> = 'f')
##      token quote_mod:f  { <sym> }

sub quote_mod__S_223f__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_223f',$retree) }
sub quote_mod__S_223f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_223f", 
$C->_PATTERN(qr/\Gf/)
);
}
## token quote_mod__S_224c (:$sym is context<rw> = 'c')
##      token quote_mod:c  { <sym> }

sub quote_mod__S_224c__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_224c',$retree) }
sub quote_mod__S_224c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_224c", 
$C->_PATTERN(qr/\Gc/)
);
}
## token quote_mod__S_225b (:$sym is context<rw> = 'b')
##      token quote_mod:b  { <sym> }

sub quote_mod__S_225b__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_225b',$retree) }
sub quote_mod__S_225b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_225b", 
$C->_PATTERN(qr/\Gb/)
);
}

## token quote__S_226rx (:$sym is context<rw> = 'rx')
##      token quote:rx {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( ::Regex ) )>
##          <!old_rx_mods>
##      }

sub quote__S_226rx__PEEK { $_[0]->_AUTOLEXpeek('quote__S_226rx',$retree) }
sub quote__S_226rx {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rx';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_226rx", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grx/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( 'STD::Regex' ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_227m (:$sym is context<rw> = 'm')
##      token quote:m  {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( ::Regex ) )>
##          <!old_rx_mods>
##      }

sub quote__S_227m__PEEK { $_[0]->_AUTOLEXpeek('quote__S_227m',$retree) }
sub quote__S_227m {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'm';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_227m", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( 'STD::Regex' ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_228mm (:$sym is context<rw> = 'mm')
##      token quote:mm {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( ::Regex ).tweak(:s))>
##          <!old_rx_mods>
##      }

sub quote__S_228mm__PEEK { $_[0]->_AUTOLEXpeek('quote__S_228mm',$retree) }
sub quote__S_228mm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mm';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_228mm", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( 'STD::Regex' )->tweak('s' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_229s (:$sym is context<rw> = 's')
##      token quote:s {
##          <sym>  <!before '('>
##          <pat=sibble( $.cursor_fresh( ::Regex ), $.cursor_fresh( ::STD::Q ).tweak(:qq))>
##          <!old_rx_mods>
##      }

sub quote__S_229s__PEEK { $_[0]->_AUTOLEXpeek('quote__S_229s',$retree) }
sub quote__S_229s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_229s", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( 'STD::Regex' ), $C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_230ss (:$sym is context<rw> = 'ss')
##      token quote:ss {
##          <sym>  <!before '('>
##          <pat=sibble( $.cursor_fresh( ::Regex ).tweak(:s), $.cursor_fresh( ::STD::Q ).tweak(:qq))>
##          <!old_rx_mods>
##      }

sub quote__S_230ss__PEEK { $_[0]->_AUTOLEXpeek('quote__S_230ss',$retree) }
sub quote__S_230ss {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ss';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_230ss", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gss/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( 'STD::Regex' )->tweak('s' => 1), $C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_231tr (:$sym is context<rw> = 'tr')
##      token quote:tr {
##          <sym>  <!before '('> <pat=tribble( $.cursor_fresh( ::STD::Q ).tweak(:q))>
##          <!old_tr_mods>
##      }

sub quote__S_231tr__PEEK { $_[0]->_AUTOLEXpeek('quote__S_231tr',$retree) }
sub quote__S_231tr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'tr';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_231tr", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtr/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->tribble( $C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_tr_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token old_rx_mods
##      token old_rx_mods {
##          (< i g s m x c e >+) 
##          {{
##              given $0.Str {
##                  $_ ~~ /i/ and $.worryobs('/i',':i');
##                  $_ ~~ /g/ and $.worryobs('/g',':g');
##                  $_ ~~ /s/ and $.worryobs('/s','^^ and $$ anchors');
##                  $_ ~~ /m/ and $.worryobs('/m','. or \N');
##                  $_ ~~ /x/ and $.worryobs('/x','normal default whitespace');
##                  $_ ~~ /c/ and $.worryobs('/c',':c or :p');
##                  $_ ~~ /e/ and $.worryobs('/e','interpolated {...} or s{} = ... form');
##                  $.obs('suffix regex modifiers','prefix adverbs');
##              }
##          }}
##      }

sub old_rx_mods__PEEK { $_[0]->_AUTOLEXpeek('old_rx_mods',$retree) }
sub old_rx_mods {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "old_rx_mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< i g s m x c e > )
})
})}
}))) {
scalar(do {

do { my $_ = $$C{0}->Str; if ((0)) {}
$_ =~ qr/i/ and $C->worryobs('/i',':i');
$_ =~ qr/g/ and $C->worryobs('/g',':g');
$_ =~ qr/s/ and $C->worryobs('/s','^^ and $$ anchors');
$_ =~ qr/m/ and $C->worryobs('/m','. or \N');
$_ =~ qr/x/ and $C->worryobs('/x','normal default whitespace');
$_ =~ qr/c/ and $C->worryobs('/c',':c or :p');
$_ =~ qr/e/ and $C->worryobs('/e','interpolated {...} or s{} = ... form');
$C->obs('suffix regex modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
}
);
}

## token old_tr_mods
##      token old_tr_mods {
##          (< c d s ] >+) 
##          {{
##              given $0.Str {
##                  $_ ~~ /c/ and $.worryobs('/c',':c');
##                  $_ ~~ /d/ and $.worryobs('/g',':d');
##                  $_ ~~ /s/ and $.worryobs('/s',':s');
##                  $.obs('suffix transliteration modifiers','prefix adverbs');
##              }
##          }}
##      }

sub old_tr_mods__PEEK { $_[0]->_AUTOLEXpeek('old_tr_mods',$retree) }
sub old_tr_mods {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "old_tr_mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< c d s ] > )
})
})}
}))) {
scalar(do {

do { my $_ = $$C{0}->Str; if ((0)) {}
$_ =~ qr/c/ and $C->worryobs('/c',':c');
$_ =~ qr/d/ and $C->worryobs('/g',':d');
$_ =~ qr/s/ and $C->worryobs('/s',':s');
$C->obs('suffix transliteration modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
}
);
}


## token quote__S_232quasi (:$sym is context<rw> = 'quasi')
##      token quote:quasi {
##          <sym>  <!before '('> <quasiquibble($.cursor_fresh( ::STD::Quasi ))>
##      }

sub quote__S_232quasi__PEEK { $_[0]->_AUTOLEXpeek('quote__S_232quasi',$retree) }
sub quote__S_232quasi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quasi';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_232quasi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gquasi/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
$C->_SUBSUMEr(['quasiquibble'], sub {
my $C = shift;
$C->quasiquibble($C->cursor_fresh( 'STD::Quasi' ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX should eventually be derived from current Unicode tables.
our %open2close = (
"\x{0028}" => "\x{0029}", "\x{003C}" => "\x{003E}", "\x{005B}" => "\x{005D}",
"\x{007B}" => "\x{007D}", "\x{00AB}" => "\x{00BB}", "\x{0F3A}" => "\x{0F3B}",
"\x{0F3C}" => "\x{0F3D}", "\x{169B}" => "\x{169C}", "\x{2039}" => "\x{203A}",
"\x{2045}" => "\x{2046}", "\x{207D}" => "\x{207E}", "\x{208D}" => "\x{208E}",
"\x{2208}" => "\x{220B}", "\x{2209}" => "\x{220C}", "\x{220A}" => "\x{220D}",
"\x{2215}" => "\x{29F5}", "\x{223C}" => "\x{223D}", "\x{2243}" => "\x{22CD}",
"\x{2252}" => "\x{2253}", "\x{2254}" => "\x{2255}", "\x{2264}" => "\x{2265}",
"\x{2266}" => "\x{2267}", "\x{2268}" => "\x{2269}", "\x{226A}" => "\x{226B}",
"\x{226E}" => "\x{226F}", "\x{2270}" => "\x{2271}", "\x{2272}" => "\x{2273}",
"\x{2274}" => "\x{2275}", "\x{2276}" => "\x{2277}", "\x{2278}" => "\x{2279}",
"\x{227A}" => "\x{227B}", "\x{227C}" => "\x{227D}", "\x{227E}" => "\x{227F}",
"\x{2280}" => "\x{2281}", "\x{2282}" => "\x{2283}", "\x{2284}" => "\x{2285}",
"\x{2286}" => "\x{2287}", "\x{2288}" => "\x{2289}", "\x{228A}" => "\x{228B}",
"\x{228F}" => "\x{2290}", "\x{2291}" => "\x{2292}", "\x{2298}" => "\x{29B8}",
"\x{22A2}" => "\x{22A3}", "\x{22A6}" => "\x{2ADE}", "\x{22A8}" => "\x{2AE4}",
"\x{22A9}" => "\x{2AE3}", "\x{22AB}" => "\x{2AE5}", "\x{22B0}" => "\x{22B1}",
"\x{22B2}" => "\x{22B3}", "\x{22B4}" => "\x{22B5}", "\x{22B6}" => "\x{22B7}",
"\x{22C9}" => "\x{22CA}", "\x{22CB}" => "\x{22CC}", "\x{22D0}" => "\x{22D1}",
"\x{22D6}" => "\x{22D7}", "\x{22D8}" => "\x{22D9}", "\x{22DA}" => "\x{22DB}",
"\x{22DC}" => "\x{22DD}", "\x{22DE}" => "\x{22DF}", "\x{22E0}" => "\x{22E1}",
"\x{22E2}" => "\x{22E3}", "\x{22E4}" => "\x{22E5}", "\x{22E6}" => "\x{22E7}",
"\x{22E8}" => "\x{22E9}", "\x{22EA}" => "\x{22EB}", "\x{22EC}" => "\x{22ED}",
"\x{22F0}" => "\x{22F1}", "\x{22F2}" => "\x{22FA}", "\x{22F3}" => "\x{22FB}",
"\x{22F4}" => "\x{22FC}", "\x{22F6}" => "\x{22FD}", "\x{22F7}" => "\x{22FE}",
"\x{2308}" => "\x{2309}", "\x{230A}" => "\x{230B}", "\x{2329}" => "\x{232A}",
"\x{23B4}" => "\x{23B5}", "\x{2768}" => "\x{2769}", "\x{276A}" => "\x{276B}",
"\x{276C}" => "\x{276D}", "\x{276E}" => "\x{276F}", "\x{2770}" => "\x{2771}",
"\x{2772}" => "\x{2773}", "\x{2774}" => "\x{2775}", "\x{27C3}" => "\x{27C4}",
"\x{27C5}" => "\x{27C6}", "\x{27D5}" => "\x{27D6}", "\x{27DD}" => "\x{27DE}",
"\x{27E2}" => "\x{27E3}", "\x{27E4}" => "\x{27E5}", "\x{27E6}" => "\x{27E7}",
"\x{27E8}" => "\x{27E9}", "\x{27EA}" => "\x{27EB}", "\x{2983}" => "\x{2984}",
"\x{2985}" => "\x{2986}", "\x{2987}" => "\x{2988}", "\x{2989}" => "\x{298A}",
"\x{298B}" => "\x{298C}", "\x{298D}" => "\x{298E}", "\x{298F}" => "\x{2990}",
"\x{2991}" => "\x{2992}", "\x{2993}" => "\x{2994}", "\x{2995}" => "\x{2996}",
"\x{2997}" => "\x{2998}", "\x{29C0}" => "\x{29C1}", "\x{29C4}" => "\x{29C5}",
"\x{29CF}" => "\x{29D0}", "\x{29D1}" => "\x{29D2}", "\x{29D4}" => "\x{29D5}",
"\x{29D8}" => "\x{29D9}", "\x{29DA}" => "\x{29DB}", "\x{29F8}" => "\x{29F9}",
"\x{29FC}" => "\x{29FD}", "\x{2A2B}" => "\x{2A2C}", "\x{2A2D}" => "\x{2A2E}",
"\x{2A34}" => "\x{2A35}", "\x{2A3C}" => "\x{2A3D}", "\x{2A64}" => "\x{2A65}",
"\x{2A79}" => "\x{2A7A}", "\x{2A7D}" => "\x{2A7E}", "\x{2A7F}" => "\x{2A80}",
"\x{2A81}" => "\x{2A82}", "\x{2A83}" => "\x{2A84}", "\x{2A8B}" => "\x{2A8C}",
"\x{2A91}" => "\x{2A92}", "\x{2A93}" => "\x{2A94}", "\x{2A95}" => "\x{2A96}",
"\x{2A97}" => "\x{2A98}", "\x{2A99}" => "\x{2A9A}", "\x{2A9B}" => "\x{2A9C}",
"\x{2AA1}" => "\x{2AA2}", "\x{2AA6}" => "\x{2AA7}", "\x{2AA8}" => "\x{2AA9}",
"\x{2AAA}" => "\x{2AAB}", "\x{2AAC}" => "\x{2AAD}", "\x{2AAF}" => "\x{2AB0}",
"\x{2AB3}" => "\x{2AB4}", "\x{2ABB}" => "\x{2ABC}", "\x{2ABD}" => "\x{2ABE}",
"\x{2ABF}" => "\x{2AC0}", "\x{2AC1}" => "\x{2AC2}", "\x{2AC3}" => "\x{2AC4}",
"\x{2AC5}" => "\x{2AC6}", "\x{2ACD}" => "\x{2ACE}", "\x{2ACF}" => "\x{2AD0}",
"\x{2AD1}" => "\x{2AD2}", "\x{2AD3}" => "\x{2AD4}", "\x{2AD5}" => "\x{2AD6}",
"\x{2AEC}" => "\x{2AED}", "\x{2AF7}" => "\x{2AF8}", "\x{2AF9}" => "\x{2AFA}",
"\x{2E02}" => "\x{2E03}", "\x{2E04}" => "\x{2E05}", "\x{2E09}" => "\x{2E0A}",
"\x{2E0C}" => "\x{2E0D}", "\x{2E1C}" => "\x{2E1D}", "\x{3008}" => "\x{3009}",
"\x{300A}" => "\x{300B}", "\x{300C}" => "\x{300D}", "\x{300E}" => "\x{300F}",
"\x{3010}" => "\x{3011}", "\x{3014}" => "\x{3015}", "\x{3016}" => "\x{3017}",
"\x{3018}" => "\x{3019}", "\x{301A}" => "\x{301B}", "\x{301D}" => "\x{301E}",
"\x{FD3E}" => "\x{FD3F}", "\x{FE17}" => "\x{FE18}", "\x{FE35}" => "\x{FE36}",
"\x{FE37}" => "\x{FE38}", "\x{FE39}" => "\x{FE3A}", "\x{FE3B}" => "\x{FE3C}",
"\x{FE3D}" => "\x{FE3E}", "\x{FE3F}" => "\x{FE40}", "\x{FE41}" => "\x{FE42}",
"\x{FE43}" => "\x{FE44}", "\x{FE47}" => "\x{FE48}", "\x{FE59}" => "\x{FE5A}",
"\x{FE5B}" => "\x{FE5C}", "\x{FE5D}" => "\x{FE5E}", "\x{FF08}" => "\x{FF09}",
"\x{FF1C}" => "\x{FF1E}", "\x{FF3B}" => "\x{FF3D}", "\x{FF5B}" => "\x{FF5D}",
"\x{FF5F}" => "\x{FF60}", "\x{FF62}" => "\x{FF63}",
);

## token opener
##      token opener {
##        <[\x0028 \x003C \x005B
##          \x007B \x00AB \x0F3A
##          \x0F3C \x169B \x2039
##          \x2045 \x207D \x208D
##          \x2208 \x2209 \x220A
##          \x2215 \x223C \x2243
##          \x2252 \x2254 \x2264
##          \x2266 \x2268 \x226A
##          \x226E \x2270 \x2272
##          \x2274 \x2276 \x2278
##          \x227A \x227C \x227E
##          \x2280 \x2282 \x2284
##          \x2286 \x2288 \x228A
##          \x228F \x2291 \x2298
##          \x22A2 \x22A6 \x22A8
##          \x22A9 \x22AB \x22B0
##          \x22B2 \x22B4 \x22B6
##          \x22C9 \x22CB \x22D0
##          \x22D6 \x22D8 \x22DA
##          \x22DC \x22DE \x22E0
##          \x22E2 \x22E4 \x22E6
##          \x22E8 \x22EA \x22EC
##          \x22F0 \x22F2 \x22F3
##          \x22F4 \x22F6 \x22F7
##          \x2308 \x230A \x2329
##          \x23B4 \x2768 \x276A
##          \x276C \x276E \x2770
##          \x2772 \x2774 \x27C3
##          \x27C5 \x27D5 \x27DD
##          \x27E2 \x27E4 \x27E6
##          \x27E8 \x27EA \x2983
##          \x2985 \x2987 \x2989
##          \x298B \x298D \x298F
##          \x2991 \x2993 \x2995
##          \x2997 \x29C0 \x29C4
##          \x29CF \x29D1 \x29D4
##          \x29D8 \x29DA \x29F8
##          \x29FC \x2A2B \x2A2D
##          \x2A34 \x2A3C \x2A64
##          \x2A79 \x2A7D \x2A7F
##          \x2A81 \x2A83 \x2A8B
##          \x2A91 \x2A93 \x2A95
##          \x2A97 \x2A99 \x2A9B
##          \x2AA1 \x2AA6 \x2AA8
##          \x2AAA \x2AAC \x2AAF
##          \x2AB3 \x2ABB \x2ABD
##          \x2ABF \x2AC1 \x2AC3
##          \x2AC5 \x2ACD \x2ACF
##          \x2AD1 \x2AD3 \x2AD5
##          \x2AEC \x2AF7 \x2AF9
##          \x2E02 \x2E04 \x2E09
##          \x2E0C \x2E1C \x3008
##          \x300A \x300C \x300E
##          \x3010 \x3014 \x3016
##          \x3018 \x301A \x301D
##          \xFD3E \xFE17 \xFE35
##          \xFE37 \xFE39 \xFE3B
##          \xFE3D \xFE3F \xFE41
##          \xFE43 \xFE47 \xFE59
##          \xFE5B \xFE5D \xFF08
##          \xFF1C \xFF3B \xFF5B
##          \xFF5F \xFF62]>
##      }

sub opener__PEEK { $_[0]->_AUTOLEXpeek('opener',$retree) }
sub opener {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "opener", 
$C->_PATTERN(qr/\G[\x{0028}\x{003C}\x{005B}\x{007B}\x{00AB}\x{0F3A}\x{0F3C}\x{169B}\x{2039}\x{2045}\x{207D}\x{208D}\x{2208}\x{2209}\x{220A}\x{2215}\x{223C}\x{2243}\x{2252}\x{2254}\x{2264}\x{2266}\x{2268}\x{226A}\x{226E}\x{2270}\x{2272}\x{2274}\x{2276}\x{2278}\x{227A}\x{227C}\x{227E}\x{2280}\x{2282}\x{2284}\x{2286}\x{2288}\x{228A}\x{228F}\x{2291}\x{2298}\x{22A2}\x{22A6}\x{22A8}\x{22A9}\x{22AB}\x{22B0}\x{22B2}\x{22B4}\x{22B6}\x{22C9}\x{22CB}\x{22D0}\x{22D6}\x{22D8}\x{22DA}\x{22DC}\x{22DE}\x{22E0}\x{22E2}\x{22E4}\x{22E6}\x{22E8}\x{22EA}\x{22EC}\x{22F0}\x{22F2}\x{22F3}\x{22F4}\x{22F6}\x{22F7}\x{2308}\x{230A}\x{2329}\x{23B4}\x{2768}\x{276A}\x{276C}\x{276E}\x{2770}\x{2772}\x{2774}\x{27C3}\x{27C5}\x{27D5}\x{27DD}\x{27E2}\x{27E4}\x{27E6}\x{27E8}\x{27EA}\x{2983}\x{2985}\x{2987}\x{2989}\x{298B}\x{298D}\x{298F}\x{2991}\x{2993}\x{2995}\x{2997}\x{29C0}\x{29C4}\x{29CF}\x{29D1}\x{29D4}\x{29D8}\x{29DA}\x{29F8}\x{29FC}\x{2A2B}\x{2A2D}\x{2A34}\x{2A3C}\x{2A64}\x{2A79}\x{2A7D}\x{2A7F}\x{2A81}\x{2A83}\x{2A8B}\x{2A91}\x{2A93}\x{2A95}\x{2A97}\x{2A99}\x{2A9B}\x{2AA1}\x{2AA6}\x{2AA8}\x{2AAA}\x{2AAC}\x{2AAF}\x{2AB3}\x{2ABB}\x{2ABD}\x{2ABF}\x{2AC1}\x{2AC3}\x{2AC5}\x{2ACD}\x{2ACF}\x{2AD1}\x{2AD3}\x{2AD5}\x{2AEC}\x{2AF7}\x{2AF9}\x{2E02}\x{2E04}\x{2E09}\x{2E0C}\x{2E1C}\x{3008}\x{300A}\x{300C}\x{300E}\x{3010}\x{3014}\x{3016}\x{3018}\x{301A}\x{301D}\x{FD3E}\x{FE17}\x{FE35}\x{FE37}\x{FE39}\x{FE3B}\x{FE3D}\x{FE3F}\x{FE41}\x{FE43}\x{FE47}\x{FE59}\x{FE5B}\x{FE5D}\x{FF08}\x{FF1C}\x{FF3B}\x{FF5B}\x{FF5F}\x{FF62}]/)
);
}

# assumes whitespace is eaten already

## method peek_delimiters
sub peek_delimiters {
my $self = shift;


my $pos = $self->{_pos};
my $startpos = $pos;
my $char = substr($::ORIG,$pos++,1);
if ($char =~ qr/^\s$/) {
$self->panic("Whitespace not allowed as delimiter");
}

# XXX not defined yet
#    <?before <+isPe> > {
#        self.panic("Use a closing delimiter for an opener is reserved");
#    }

my $rightbrack = $open2close{$char};
if (not defined $rightbrack) {
return $char, $char;
}
while (substr($::ORIG,$pos,1) eq $char) {
$pos++;
}
my $len = $pos - $startpos;
my $start = $char x $len;
my $stop = $rightbrack x $len;
return $start, $stop;
}

{ package STD::startstop;
sub __instantiate__ { my $self = shift;
my ($start,$stop) = @_;
my $mangle = ::mangle($start,$stop);
my $mixin = "STD::startstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$start' => $start,'$stop' => $stop } }
##     token starter
##          token starter { $start }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "starter", 
$C->_EXACT($start)
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: starter
    i: 0
    min: 0
    r: 1
    s: 0
    var: $start
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::stop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::stop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token starter
##          token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::unitstop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::unitstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token unitstopper
##          token unitstopper { $stop }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
unitstopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role
## token unitstopper
##      } # end role
##      
##      token unitstopper { $ }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_PATTERN(qr/\G\z/)
);
}

## method balanced ($start,$stop)
sub balanced {
my $self = shift;
my $start = shift;
my $stop = shift;

$self->mixin( 'STD::startstop'->__instantiate__($start,$stop) ); }
## method unbalanced ($stop)
sub unbalanced {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::stop'->__instantiate__($stop) ); }
## method unitstop ($stop)
sub unitstop {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::unitstop'->__instantiate__($stop) ); }

## token codepoint
##      token codepoint {
##          '[' {} ( [<!before ']'> .]*? ) ']'
##      }

sub codepoint__PEEK { $_[0]->_AUTOLEXpeek('codepoint',$retree) }
sub codepoint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "codepoint", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT(']')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_STARf(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?s:.)/)
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(']')
})
}))
})
})
})}
}))
}, scalar(do {

}, $C))
}, $C->_EXACT('['))
);
}

## method truly ($bool,$opt)
sub truly {
my $self = shift;
my $bool = shift;
my $opt = shift;


return $self if $bool;
$self->panic("Can't negate $opt adverb");
}

{ package STD::Q;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
{ package STD::Q::b1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_233Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <sym> <item=backslash> }

sub escape__S_233Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_233Back',$retree) }
sub escape__S_233Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_233Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##         token backslash__S_234qq (:$sym is context<rw> = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $.cursor_fresh($*LANG).quote(); } }

sub backslash__S_234qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_234qq',$retree) }
sub backslash__S_234qq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_234qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{quote} = $C->cursor_fresh($::LANG)->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_235Back (:$sym is context<rw> = <\\>)
##              token backslash:sym<\\> { <text=sym> }

sub backslash__S_235Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_235Back',$retree) }
sub backslash__S_235Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_235Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_236stopper (:$sym is context<rw> = 'stopper')
##              token backslash:stopper { <text=stopper> }

sub backslash__S_236stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_236stopper',$retree) }
sub backslash__S_236stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'stopper';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_236stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}
##         token backslash__S_237a (:$sym is context<rw> = 'a')
##              token backslash:a { <sym> }

sub backslash__S_237a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_237a',$retree) }
sub backslash__S_237a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_237a", 
$C->_PATTERN(qr/\Ga/)
);
}
##         token backslash__S_238b (:$sym is context<rw> = 'b')
##              token backslash:b { <sym> }

sub backslash__S_238b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_238b',$retree) }
sub backslash__S_238b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_238b", 
$C->_PATTERN(qr/\Gb/)
);
}
##         token backslash__S_239c (:$sym is context<rw> = 'c')
##              token backslash:c { <sym>
##                  [
##                  | <codepoint>
##                  | \d+
##                  | [ <[ ?.._ ]> || <.panic: "Unrecognized \\c character"> ]
##                  ]
##              }

sub backslash__S_239c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_239c',$retree) }
sub backslash__S_239c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_239c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gc/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_239c_01') {
$C->deb("Fate passed to backslash__S_239c_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_239c_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_239c_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['codepoint'], sub {
my $C = shift;
$C->codepoint
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G[?-_]/)} 
or
eval { push @gather, $C->panic("Unrecognized \\c character")} or do { die $@ if $@ };
@gather;
}
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##         token backslash__S_240e (:$sym is context<rw> = 'e')
##              token backslash:e { <sym> }

sub backslash__S_240e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_240e',$retree) }
sub backslash__S_240e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_240e", 
$C->_PATTERN(qr/\Ge/)
);
}
##         token backslash__S_241f (:$sym is context<rw> = 'f')
##              token backslash:f { <sym> }

sub backslash__S_241f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_241f',$retree) }
sub backslash__S_241f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_241f", 
$C->_PATTERN(qr/\Gf/)
);
}
##         token backslash__S_242n (:$sym is context<rw> = 'n')
##              token backslash:n { <sym> }

sub backslash__S_242n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_242n',$retree) }
sub backslash__S_242n {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_242n", 
$C->_PATTERN(qr/\Gn/)
);
}
##         token backslash__S_243o (:$sym is context<rw> = 'o')
##              token backslash:o { <sym> [ <octint> | '[' <octint>**',' ']' ] }

sub backslash__S_243o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_243o',$retree) }
sub backslash__S_243o {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{_pos};
$C->{'octint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_243o", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Go/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_243o_01') {
$C->deb("Fate passed to backslash__S_243o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_243o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_243o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
}))) {
$C->_EXACT(']');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##         token backslash__S_244r (:$sym is context<rw> = 'r')
##              token backslash:r { <sym> }

sub backslash__S_244r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_244r',$retree) }
sub backslash__S_244r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_244r", 
$C->_PATTERN(qr/\Gr/)
);
}
##         token backslash__S_245t (:$sym is context<rw> = 't')
##              token backslash:t { <sym> }

sub backslash__S_245t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_245t',$retree) }
sub backslash__S_245t {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_245t", 
$C->_PATTERN(qr/\Gt/)
);
}
##         token backslash__S_246x (:$sym is context<rw> = 'x')
##              token backslash:x { <sym> [ <hexint> | '[' [<.ws><hexint><.ws> ] ** ',' ']' ] }

sub backslash__S_246x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_246x',$retree) }
sub backslash__S_246x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'hexint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_246x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gx/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_246x_01') {
$C->deb("Fate passed to backslash__S_246x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_246x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_246x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_EXACT(']');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##         token backslash__S_2470 (:$sym is context<rw> = <0>)
##              token backslash:sym<0> { <sym> }

sub backslash__S_2470__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_2470',$retree) }
sub backslash__S_2470 {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(0);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "backslash__S_2470", 
$C->_PATTERN(qr/\G0/)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_234qq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_234qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_234qq
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: backslash__S_234qq
              i: 0
              min: 1
              r: 1
              s: 0
              text: q
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_234qq
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<quote> = $.cursor_fresh($*LANG).quote(); "
backslash__S_235Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_235Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_235Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_236stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_236stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_236stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_237a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_237a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
backslash__S_238b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_238b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_239c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_239c
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_239c
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: c
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_239c_01
          dba: backslash__S_239c
          i: 0
          min: 0
          name: backslash__S_239c_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_239c_01 0
              dba: backslash__S_239c
              i: 0
              min: 12345
              name: codepoint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              alt: backslash__S_239c_01 1
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: backslash__S_239c
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_bracket 
              alt: backslash__S_239c_01 2
              decl: []

              min: 0
              re: !!perl/hash:RE_first 
                a: 0
                dba: backslash__S_239c
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_cclass 
                    a: 0
                    dba: backslash__S_239c
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "[ ?.._ ]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Unrecognized \\c character")
backslash__S_239c_01: *1
backslash__S_240e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_240e
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_241f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_241f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_242n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_242n
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_243o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_243o
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_243o
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: o
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &2 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_243o_01
          dba: backslash__S_243o
          i: 0
          min: 12345
          name: backslash__S_243o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_243o_01 0
              dba: backslash__S_243o
              i: 0
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_243o_01 1
              dba: backslash__S_243o
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_243o
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: backslash__S_243o
                    i: 0
                    min: 12345
                    name: octint
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_243o
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_243o
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_243o_01: *2
backslash__S_244r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_244r
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_245t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_245t
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_246x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_246x
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_246x
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &3 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_246x_01
          dba: backslash__S_246x
          i: 0
          min: 12345
          name: backslash__S_246x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_246x_01 0
              dba: backslash__S_246x
              i: 0
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_246x_01 1
              dba: backslash__S_246x
              i: 0
              min: 37037
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_246x
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 37035
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_246x
                      i: 0
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_246x
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_246x
                          i: 0
                          min: 12345
                          name: hexint
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_246x
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                  min: 37035
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_246x
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_246x
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_246x_01: *3
backslash__S_2470: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_2470
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 0
escape__S_233Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_233Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: escape__S_233Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: escape__S_233Back
          i: 0
          min: 12345
          name: backslash
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: escape__S_233Back
        i: 0
        min: 12345
        r: 1
        s: 0
        var: item
RETREE_END
}
} ## end role

{ package STD::Q::b0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_248Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <!> }

sub escape__S_248Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_248Back',$retree) }
sub escape__S_248Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_248Back", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_248Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_248Back
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_249Cur_Ly (:$sym is context<rw> = <{ }>)
##              token escape:sym<{ }> { <?before '{'> [ :lang($*LANG) <block> ] }

sub escape__S_249Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_249Cur_Ly',$retree) }
sub escape__S_249Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_249Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_249Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_249Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_249Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_249Cur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: escape__S_249Cur_Ly
          i: 0
          lang: ($::LANG)
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: escape__S_249Cur_Ly
              i: 0
              lang: ($::LANG)
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: escape__S_249Cur_Ly
              i: 0
              lang: ($::LANG)
              min: 12345
              name: block
              r: 1
              rest: ''
              s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_250Cur_Ly (:$sym is context<rw> = <{ }>)
##              token escape:sym<{ }> { <!> }

sub escape__S_250Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_250Cur_Ly',$retree) }
sub escape__S_250Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_250Cur_Ly", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_250Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_250Cur_Ly
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::s1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_251Dollar (:$sym is context<rw> = <$>)
##              token escape:sym<$> {
##                  :my $INTERPOLATION is context = '$';
##                  <?before '$'>
##                  [ :lang($*LANG) <EXPR(item %methodcall)> ] || <.panic: "Non-variable \$ must be backslashed">
##              }

sub escape__S_251Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_251Dollar',$retree) }
sub escape__S_251Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);
local $::INTERPOLATION =  '$';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_251Dollar", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
});
}
else {
();
}
}} 
or
eval { push @gather, $C->panic("Non-variable \$ must be backslashed")} or do { die $@ if $@ };
@gather;
}
);
}
##         token special_variable__S_252DollarDouble (:$sym is context<rw> = <$">)
##              token special_variable:sym<$"> {
##                  '$' <stopper>
##                  <.panic: "Can't use a \$ in the last position of an interpolating string">
##              }

sub special_variable__S_252DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_252DollarDouble',$retree) }
sub special_variable__S_252DollarDouble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($");


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_252DollarDouble", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->panic("Can't use a \$ in the last position of an interpolating string");
}
else {
();
}
};
}
else {
();
}
}
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_251Dollar: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_251Dollar
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INTERPOLATION is context = '$'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: escape__S_251Dollar
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: escape__S_251Dollar
        i: 0
        min: 0
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_assertion 
            assert: "?"
            min: 0
            re: !!perl/hash:RE_method_re 
              a: 0
              dba: escape__S_251Dollar
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE 
                decl: []

                min: 1
                re: !!perl/hash:RE_string 
                  a: 0
                  dba: escape__S_251Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: $
              s: 0
          - !!perl/hash:RE_bracket 
            decl: []

            min: 0
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: escape__S_251Dollar
              i: 0
              lang: ($::LANG)
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_251Dollar
                  i: 0
                  lang: ($::LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Non-variable \$ must be backslashed")
special_variable__S_252DollarDouble: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_252DollarDouble
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_252DollarDouble
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_252DollarDouble
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Can't use a \$ in the last position of an interpolating string")
RETREE_END
}
} ## end role

{ package STD::Q::s0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_253Dollar (:$sym is context<rw> = <$>)
##              token escape:sym<$> { <!> }

sub escape__S_253Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_253Dollar',$retree) }
sub escape__S_253Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_253Dollar", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
##         token special_variable__S_254DollarDouble (:$sym is context<rw> = <$">)
##              token special_variable:sym<$"> { <!> }

sub special_variable__S_254DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_254DollarDouble',$retree) }
sub special_variable__S_254DollarDouble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($");


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_254DollarDouble", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_253Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_253Dollar
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
special_variable__S_254DollarDouble: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: special_variable__S_254DollarDouble
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::a1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_255At (:$sym is context<rw> = <@>)
##              token escape:sym<@> {
##                  :my $INTERPOLATION is context<rw> = '@';
##                  <?before '@'>
##                  [ :lang($*LANG) <EXPR(item %methodcall)> | <!> ] # trap ABORTBRANCH from variable's ::
##              }

sub escape__S_255At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_255At',$retree) }
sub escape__S_255At {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);
local $::INTERPOLATION =  '@';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_255At", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('@')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'escape__S_255At_02') {
$C->deb("Fate passed to escape__S_255At_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::a1', 'escape__S_255At_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_255At_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_255At: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_255At
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INTERPOLATION is context<rw> = '@'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_255At
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_255At
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_255At
              i: 0
              min: 1
              r: 1
              s: 0
              text: "@"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_255At_02
          dba: escape__S_255At
          i: 0
          lang: ($::LANG)
          min: 0
          name: escape__S_255At_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_255At_02 0
              dba: escape__S_255At
              i: 0
              lang: ($::LANG)
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_255At
                  i: 0
                  lang: ($::LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
            - !!perl/hash:RE_assertion 
              alt: escape__S_255At_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_255At
                i: 0
                lang: ($::LANG)
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_255At_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::a0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_256At (:$sym is context<rw> = <@>)
##              token escape:sym<@> { <!> }

sub escape__S_256At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_256At',$retree) }
sub escape__S_256At {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_256At", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_256At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_256At
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::h1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_257Percent (:$sym is context<rw> = <%>)
##              token escape:sym<%> {
##                  :my $INTERPOLATION is context<rw> = '%';
##                  <?before '%'>
##                  [ :lang($*LANG) <EXPR(item %methodcall)> | <!> ]
##              }

sub escape__S_257Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_257Percent',$retree) }
sub escape__S_257Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);
local $::INTERPOLATION =  '%';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_257Percent", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('%')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'escape__S_257Percent_02') {
$C->deb("Fate passed to escape__S_257Percent_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::h1', 'escape__S_257Percent_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_257Percent_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_257Percent: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_257Percent
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INTERPOLATION is context<rw> = '%'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_257Percent
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_257Percent
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_257Percent
              i: 0
              min: 1
              r: 1
              s: 0
              text: "%"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_257Percent_02
          dba: escape__S_257Percent
          i: 0
          lang: ($::LANG)
          min: 0
          name: escape__S_257Percent_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_257Percent_02 0
              dba: escape__S_257Percent
              i: 0
              lang: ($::LANG)
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_257Percent
                  i: 0
                  lang: ($::LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
            - !!perl/hash:RE_assertion 
              alt: escape__S_257Percent_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_257Percent
                i: 0
                lang: ($::LANG)
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_257Percent_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::h0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_258Percent (:$sym is context<rw> = <%>)
##              token escape:sym<%> { <!> }

sub escape__S_258Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_258Percent',$retree) }
sub escape__S_258Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_258Percent", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_258Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_258Percent
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::f1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_259Amp (:$sym is context<rw> = <&>)
##              token escape:sym<&> {
##                  :my $INTERPOLATION is context<rw> = '&';
##                  <?before '&'>
##                  [ :lang($*LANG) <EXPR(item %methodcall)> | <!> ]
##              }

sub escape__S_259Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_259Amp',$retree) }
sub escape__S_259Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);
local $::INTERPOLATION =  '&';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_259Amp", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('&')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'escape__S_259Amp_02') {
$C->deb("Fate passed to escape__S_259Amp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::f1', 'escape__S_259Amp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_259Amp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_259Amp: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_259Amp
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INTERPOLATION is context<rw> = '&'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_259Amp
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_259Amp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_259Amp
              i: 0
              min: 1
              r: 1
              s: 0
              text: "&"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_259Amp_02
          dba: escape__S_259Amp
          i: 0
          lang: ($::LANG)
          min: 0
          name: escape__S_259Amp_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_259Amp_02 0
              dba: escape__S_259Amp
              i: 0
              lang: ($::LANG)
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_259Amp
                  i: 0
                  lang: ($::LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
            - !!perl/hash:RE_assertion 
              alt: escape__S_259Amp_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_259Amp
                i: 0
                lang: ($::LANG)
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_259Amp_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::f0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_260Amp (:$sym is context<rw> = <&>)
##              token escape:sym<&> { <!> }

sub escape__S_260Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_260Amp',$retree) }
sub escape__S_260Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_260Amp", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_260Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_260Amp
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::w1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->comb }
} ## end role

{ package STD::Q::w0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::ww1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->comb }
} ## end role

{ package STD::Q::ww0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::x1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->run }
} ## end role

{ package STD::Q::x0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::q;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token stopper
##              token stopper { \' }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('\'')
);
}

##         token escape__S_261Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <sym> <item=backslash> }

sub escape__S_261Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_261Back',$retree) }
sub escape__S_261Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_261Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}

##         token backslash__S_262qq (:$sym is context<rw> = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $.cursor_fresh($*LANG).quote(); } }

sub backslash__S_262qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_262qq',$retree) }
sub backslash__S_262qq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_262qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{quote} = $C->cursor_fresh($::LANG)->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_263Back (:$sym is context<rw> = <\\>)
##              token backslash:sym<\\> { <text=sym> }

sub backslash__S_263Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_263Back',$retree) }
sub backslash__S_263Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_263Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_264stopper (:$sym is context<rw> = 'stopper')
##              token backslash:stopper { <text=stopper> }

sub backslash__S_264stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_264stopper',$retree) }
sub backslash__S_264stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'stopper';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_264stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}

# in single quotes, keep backslash on random character by default
##         token backslash__S_265misc (:$sym is context<rw> = 'misc')
##              token backslash:misc { {} (.) { $<text> = "\\" ~ $0.Str; } }

sub backslash__S_265misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_265misc',$retree) }
sub backslash__S_265misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_265misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G(?s:.)/)
})}
}))) {
scalar(do {
my $M = $C;  $M->{text} = "\\" . $$C{0}->Str; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_262qq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_262qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_262qq
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: backslash__S_262qq
              i: 0
              min: 1
              r: 1
              s: 0
              text: q
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_262qq
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<quote> = $.cursor_fresh($*LANG).quote(); "
backslash__S_263Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_263Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_263Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_264stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_264stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_264stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_265misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_265misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_265misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_meta 
            a: 0
            dba: backslash__S_265misc
            i: 0
            min: 1
            r: 1
            s: 0
            text: .
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_265misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<text> = \"\\\\\" ~ $0.Str; "
escape__S_261Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_261Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: escape__S_261Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: escape__S_261Back
          i: 0
          min: 12345
          name: backslash
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: escape__S_261Back
        i: 0
        min: 12345
        r: 1
        s: 0
        var: item
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: "'"
RETREE_END
}
} ## end role

{ package STD::Q::qq;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::Q::b1 STD::Q::c1 STD::Q::s1 STD::Q::a1 STD::Q::h1 STD::Q::f1));
##         token stopper
##              token stopper { \" }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('"')
);
}
# in double quotes, omit backslash on random \W backslash by default
##         token backslash__S_266misc (:$sym is context<rw> = 'misc')
##              token backslash:misc { {} [ (\W) { $<text> = $0.Str; } | $<x>=(\w) <.panic("Unrecognized backslash sequence: '\\" ~ $<x>.Str ~ "'")> ] }

sub backslash__S_266misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_266misc',$retree) }
sub backslash__S_266misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_266misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_266misc_01') {
$C->deb("Fate passed to backslash__S_266misc_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::qq', 'backslash__S_266misc_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_266misc_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
}))) {
scalar(do {
my $M = $C;  $M->{text} = $$C{0}->Str; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['x'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})}
}))) {
do { my $M = $C;
$C->panic("Unrecognized backslash sequence: '\\" . $M->{x}->Str . "'")
; };
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_266misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_266misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_266misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_266misc_01
          dba: backslash__S_266misc
          i: 0
          min: 1
          name: backslash__S_266misc_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_266misc_01 0
              dba: backslash__S_266misc
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_meta 
                      a: 0
                      dba: backslash__S_266misc
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \W
                  min: 1
                  var: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: backslash__S_266misc
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<text> = $0.Str; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_266misc_01 1
              dba: backslash__S_266misc
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_meta 
                      a: 0
                      dba: backslash__S_266misc
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \w
                  dba: backslash__S_266misc
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: x
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: "(\"Unrecognized backslash sequence: '\\\\\" ~ $<x>.Str ~ \"'\")"
backslash__S_266misc_01: *1
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: "\""
RETREE_END
}
} ## end role

{ package STD::Q::p5;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'i') {
my $i = $v;  $self }
elsif ($k eq 'm') {
my $m = $v;  $self }
elsif ($k eq 's') {
my $s = $v;  $self }
elsif ($k eq 'x') {
my $x = $v;  $self }
elsif ($k eq 'p') {
my $p = $v;  $self }
elsif ($k eq 'c') {
my $c = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks
} ## end role

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}

elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->truly($q,':q'); $self->mixin( 'STD::Q::q' ); }

elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->truly($qq, ':qq'); $self->mixin( 'STD::Q::qq' ); }

elsif ($k eq 'backslash' or $k eq 'b') {
my $b = $v;  $self->mixin($b ? 'STD::Q::b1' : 'STD::Q::b0') }
elsif ($k eq 'scalar' or $k eq 's') {
my $s = $v;  $self->mixin($s ? 'STD::Q::s1' : 'STD::Q::s0') }
elsif ($k eq 'array' or $k eq 'a') {
my $a = $v;  $self->mixin($a ? 'STD::Q::a1' : 'STD::Q::a0') }
elsif ($k eq 'hash' or $k eq 'h') {
my $h = $v;  $self->mixin($h ? 'STD::Q::h1' : 'STD::Q::h0') }
elsif ($k eq 'function' or $k eq 'f') {
my $f = $v;  $self->mixin($f ? 'STD::Q::f1' : 'STD::Q::f0') }
elsif ($k eq 'closure' or $k eq 'c') {
my $c = $v;  $self->mixin($c ? 'STD::Q::c1' : 'STD::Q::c0') }

elsif ($k eq 'exec' or $k eq 'x') {
my $x = $v;  $self->mixin($x ? 'STD::Q::x1' : 'STD::Q::x0') }
elsif ($k eq 'words' or $k eq 'w') {
my $w = $v;  $self->mixin($w ? 'STD::Q::w1' : 'STD::Q::w0') }
elsif ($k eq 'quotewords' or $k eq 'ww') {
my $ww = $v;  $self->mixin($ww ? 'STD::Q::ww1' : 'STD::Q::ww0') }

elsif ($k eq 'heredoc' or $k eq 'to') {
my $to = $v;  $self->truly($to, ':to'); $self->cursor_herelang; }

elsif ($k eq 'regex') {
my $regex = $v; 
return 'STD::Q::Regex';
}

elsif ($k eq 'trans') {
my $trans = $v; 
return 'STD::Q::Trans';
}

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quote modifier: " . join('',@k));
}
else { die 'NOMATCH' }
} # end tweaks


} ## end grammar

{ package STD::Quasi;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));##     token term__S_267unquote (:$sym is context<rw> = 'unquote')
##          token term:unquote {
##              :my $QUASI_QUASH is context = 0;
##              <starter><starter><starter> <EXPR> <stopper><stopper><stopper>
##          }

sub term__S_267unquote__PEEK { $_[0]->_AUTOLEXpeek('term__S_267unquote',$retree) }
sub term__S_267unquote {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unquote';
local $::QUASI_QUASH =  0;


my $C = $self;
my $S = $C->{_pos};
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_267unquote", 
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'ast') {
my $ast = $v;  $self; } # XXX some transformer operating on the normal AST?
elsif ($k eq 'lang') {
my $lang = $v;  $self->cursor_fresh( $lang ); }
elsif ($k eq 'unquote') {
my $unquote = $v;  $self; } # XXX needs to override unquote
elsif ($k eq 'COMPILING') {
my $COMPILING = $v;  $::QUASI_QUASH = 1; $self; } # XXX needs to lazify the lexical lookups somehow

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quasiquote modifier: " . join('',@k));
}
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
term__S_267unquote: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_267unquote
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QUASI_QUASH is context = 0
  kind: token
  min: 86415
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_267unquote
    i: 0
    min: 86415
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_267unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_267unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_267unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_267unquote
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_267unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_267unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_267unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
RETREE_END
}
} ## end grammar
## rule multisig
##      } # end grammar
##      
##      rule multisig {
##          [
##              ':'?'(' ~ ')' <signature>
##          ]
##          ** '|'
##      }

sub multisig__PEEK { $_[0]->_AUTOLEXpeek('multisig',$retree) }
sub multisig {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'signature'} = [];

$self->_MATCHIFY($S, "multisig", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('|')
}, sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')', 'multisig')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
}, $C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))
}, $C->ws)
})
}))
}, $C->ws)
);
}

## rule routine_def ($CURPAD is context<rw> = $*CURPAD)
##      rule routine_def ($CURPAD is context<rw> = $*CURPAD) {
##          :my $IN_DECL is context<rw> = 1;
##          [
##              [ '&'<deflongname>? | <deflongname> ]?
##              <.newpad>
##              [ <multisig> | <trait> ]*
##              <!{
##                  $ = $*PARSER.bless($);
##                  $*IN_DECL = 0;
##              }>
##              <blockoid>:!s
##          ] || <.panic: "Malformed routine">
##      }

sub routine_def__PEEK { $_[0]->_AUTOLEXpeek('routine_def',$retree) }
sub routine_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;
local $::IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "routine_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'routine_def_02') {
$C->deb("Fate passed to routine_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'routine_def_03') {
$C->deb("Fate passed to routine_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$C = $::PARSER->bless($C);
$::IN_DECL = 0;

})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed routine"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## rule method_def ($CURPAD is context<rw> = $*CURPAD)
##      rule method_def ($CURPAD is context<rw> = $*CURPAD) {
##          <.newpad>
##          [
##              [
##              | <[ ! ^ ]>?<longname> [ <multisig> | <trait> ]*
##              | <multisig> <trait>*
##              | <sigil> '.'
##                  :dba('subscript signature')
##                  [
##                  | '(' ~ ')' <signature>
##                  | '[' ~ ']' <signature>
##                  | '{' ~ '}' <signature>
##                  | <?before '<'> <postcircumfix>
##                  ]
##                  <trait>*
##              | <?>
##              ]
##              <blockoid>:!s
##          ] || <.panic: "Malformed method">
##      }

sub method_def__PEEK { $_[0]->_AUTOLEXpeek('method_def',$retree) }
sub method_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;


my $C = $self;
my $S = $C->{_pos};
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFY($S, "method_def", 
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['blockoid'], sub {
my $C = shift;
$C->blockoid
})
}, $C->ws)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'method_def_02') {
$C->deb("Fate passed to method_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[!^])?+)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'method_def_03') {
$C->deb("Fate passed to method_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
}))
}, $C->ws)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'method_def_04') {
$C->deb("Fate passed to method_def_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']'))
}, $C->ws)
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}'))
}, $C->ws)
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->ws)
}, $C->before(sub { my $C=shift;
$C->_EXACT('<')
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
}, $C->ws)
}, $C->_EXACT('.'))
}, $C->ws)
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->before( sub { my $C=shift;
$C
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}))
}, $C->ws)
}, $C->newpad)
}, $C->ws)} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->panic("Malformed method"))
}, $C->ws)} or do { die $@ if $@ };
@gather;
}
);
}

## rule regex_def ($CURPAD is context<rw> = $*CURPAD)
##      rule regex_def ($CURPAD is context<rw> = $*CURPAD) {
##          :my $IN_DECL is context<rw> = 1;
##          [
##              [ '&'<deflongname>? | <deflongname> ]?
##              <.newpad>
##              [ [ ':'?'(' <signature> ')'] | <trait> ]*
##              { $*IN_DECL = 0; }
##              <.finishpad>
##              <regex_block>:!s
##          ] || <.panic: "Malformed regex">
##      }

sub regex_def__PEEK { $_[0]->_AUTOLEXpeek('regex_def',$retree) }
sub regex_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;
local $::IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'deflongname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "regex_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'regex_def_02') {
$C->deb("Fate passed to regex_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'regex_def_03') {
$C->deb("Fate passed to regex_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$::IN_DECL = 0; 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->finishpad)) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['regex_block'], sub {
my $C = shift;
$C->regex_block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed regex"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## rule macro_def ($CURPAD is context<rw> = $*CURPAD)
##      rule macro_def ($CURPAD is context<rw> = $*CURPAD) {
##          :my $IN_DECL is context<rw> = 1;
##          [
##              [ '&'<deflongname>? | <deflongname> ]?
##              <.newpad>
##              [ <multisig> | <trait> ]*
##              <!{
##                  $ = $*PARSER.bless($);
##                  $*IN_DECL = 0;
##              }>
##              <blockoid>:!s
##          ] || <.panic: "Malformed macro">
##      }

sub macro_def__PEEK { $_[0]->_AUTOLEXpeek('macro_def',$retree) }
sub macro_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;
local $::IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "macro_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'macro_def_02') {
$C->deb("Fate passed to macro_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'macro_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'macro_def_03') {
$C->deb("Fate passed to macro_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'macro_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$C = $::PARSER->bless($C);
$::IN_DECL = 0;

})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed macro"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## rule trait
##      rule trait {
##          :my $IN_DECL is context<rw> = 0;
##          [
##          | <trait_verb>
##          | <trait_auxiliary>
##          | <colonpair>
##          ]
##      }

sub trait__PEEK { $_[0]->_AUTOLEXpeek('trait',$retree) }
sub trait {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL =  0;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "trait", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'trait_01') {
$C->deb("Fate passed to trait_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['trait_verb'], sub {
my $C = shift;
$C->trait_verb
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['trait_auxiliary'], sub {
my $C = shift;
$C->trait_auxiliary
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token trait_auxiliary__S_268is (:$endsym is context = 'spacey', :$sym is context<rw> = 'is')
##      token trait_auxiliary:is {
##          <sym> <.ws> <longname><postcircumfix>?
##      }

sub trait_auxiliary__S_268is__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary__S_268is',$retree) }
sub trait_auxiliary__S_268is {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'is';


my $C = $self;
my $S = $C->{_pos};
$C->{'postcircumfix'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_auxiliary__S_268is", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gis/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_auxiliary__S_269does (:$endsym is context = 'spacey', :$sym is context<rw> = 'does')
##      token trait_auxiliary:does {
##          :my $PKGDECL is context = 'role';
##          <sym> <.ws> <module_name>
##      }

sub trait_auxiliary__S_269does__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary__S_269does',$retree) }
sub trait_auxiliary__S_269does {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'does';
local $::PKGDECL =  'role';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_auxiliary__S_269does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_auxiliary__S_270will (:$endsym is context = 'spacey', :$sym is context<rw> = 'will')
##      token trait_auxiliary:will {
##          <sym> <.ws> <identifier> <.ws> <block>
##      }

sub trait_auxiliary__S_270will__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary__S_270will',$retree) }
sub trait_auxiliary__S_270will {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'will';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_auxiliary__S_270will", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwill/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule trait_verb__S_271of (:$endsym is context = 'spacey', :$sym is context<rw> = 'of')
##      rule trait_verb:of      {<sym> <fulltypename> }

sub trait_verb__S_271of__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_271of',$retree) }
sub trait_verb__S_271of {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'of';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_271of", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gof/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule trait_verb__S_272as (:$endsym is context = 'spacey', :$sym is context<rw> = 'as')
##      rule trait_verb:as      {<sym> <fulltypename> }

sub trait_verb__S_272as__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_272as',$retree) }
sub trait_verb__S_272as {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'as';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_272as", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gas/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule trait_verb__S_273returns (:$endsym is context = 'spacey', :$sym is context<rw> = 'returns')
##      rule trait_verb:returns {<sym> <fulltypename> }

sub trait_verb__S_273returns__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_273returns',$retree) }
sub trait_verb__S_273returns {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'returns';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_273returns", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Greturns/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule trait_verb__S_274handles (:$endsym is context = 'spacey', :$sym is context<rw> = 'handles')
##      rule trait_verb:handles {<sym> <noun> }

sub trait_verb__S_274handles__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_274handles',$retree) }
sub trait_verb__S_274handles {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'handles';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_274handles", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghandles/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->noun
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token capterm
##      token capterm {
##          '\\'
##          [
##          | '(' <capture>? ')'
##          | <?before \S> <termish>
##          ]
##      }

sub capterm__PEEK { $_[0]->_AUTOLEXpeek('capterm',$retree) }
sub capterm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'capture'} = [];

$self->_MATCHIFYr($S, "capterm", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'capterm_01') {
$C->deb("Fate passed to capterm_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'capterm_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("capterm_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['capture'], sub {
my $C = shift;
$C->capture
})
}))) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## rule capture
##      rule capture {
##          :my $INVOCANT_OK is context<rw> = 1;
##          <EXPR>
##      }

sub capture__PEEK { $_[0]->_AUTOLEXpeek('capture',$retree) }
sub capture {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK =  1;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "capture", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token sigterm
##      token sigterm {
##          ':(' ~ ')' <signature>
##      }

sub sigterm__PEEK { $_[0]->_AUTOLEXpeek('sigterm',$retree) }
sub sigterm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "sigterm", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'sigterm')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT(':('))
);
}

## rule param_sep
##      rule param_sep { [','|':'|';'|';;'] }

sub param_sep__PEEK { $_[0]->_AUTOLEXpeek('param_sep',$retree) }
sub param_sep {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "param_sep", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'param_sep_01') {
$C->deb("Fate passed to param_sep_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'param_sep_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_sep_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT(':')
},
sub { my $C=shift;
$C->_EXACT(';')
},
sub { my $C=shift;
$C->_EXACT(';;')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token signature
##      token signature {
##          # XXX incorrectly scopes &infix:<x> parameters to outside following block
##          :my $IN_DECL is context<rw> = 1;
##          :my $zone is context<rw> = 'posreq';
##          :my $startpos = self.pos;
##          <.ws>
##          [
##          | <?before '-->' | ')' | ']' | '{' | ':'\s >
##          | <parameter>
##          ] ** <param_sep>
##          <.ws>
##          [ '-->' <.ws> <fulltypename> ]?
##          {{ $*IN_DECL = 0; $*SIGIL = '@'; $*CURPAD.{'$?GOTSIG'} ~= '(' ~ substr($*ORIG, $startpos, $.pos - $startpos) ~ ')'; }}
##      }

sub signature__PEEK { $_[0]->_AUTOLEXpeek('signature',$retree) }
sub signature {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL =  1;
local $::zone =  'posreq';
my $startpos = $self->{_pos};


my $C = $self;
my $S = $C->{_pos};
$C->{'parameter'} = [];
$C->{'param_sep'} = [];
$C->{'fulltypename'} = [];

$self->_MATCHIFYr($S, "signature", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_SUBSUMEr(['param_sep'], sub {
my $C = shift;
$C->param_sep
})
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'signature_01') {
$C->deb("Fate passed to signature_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'signature_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'signature_02') {
$C->deb("Fate passed to signature_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'signature_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('-->')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
},
sub { my $C=shift;
$C->_SUBSUMEr(['parameter'], sub {
my $C = shift;
$C->parameter
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-->'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {
$::IN_DECL = 0; $::SIGIL = '@'; $CURPAD->{'$?GOTSIG'} .= '(' . substr($::ORIG, $startpos, $C->{_pos} - $startpos) . ')'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token type_declarator__S_275subset (:$sym is context<rw> = 'subset')
##      token type_declarator:subset {
##          <sym> :s
##          [
##              <longname> { $.add_name($<longname>.Str); }
##              [ of <.ws> <fulltypename> ]?
##              [where <EXPR(item %chaining)> ]?    # (EXPR can parse multiple where clauses)
##          ] || <.panic: "Malformed subset">
##      }

sub type_declarator__S_275subset__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_275subset',$retree) }
sub type_declarator__S_275subset {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'subset';


my $C = $self;
my $S = $C->{_pos};
$C->{'fulltypename'} = [];
$C->{'EXPR'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "type_declarator__S_275subset", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubset/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $C->add_name($M->{longname}->Str); ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('of'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed subset"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## token type_declarator__S_276enum (:$sym is context<rw> = 'enum')
##      token type_declarator:enum {
##          :my $l;
##          <sym> <.ws>
##          [
##          || $l = <longname>  <.ws> <arglist> <.ws>
##              { $.add_name($l.Str); $.add_enum($l.Str, $<arglist>.Str); }
##          || <arglist> <.ws>
##          ]
##      }

sub type_declarator__S_276enum__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_276enum',$retree) }
sub type_declarator__S_276enum {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'enum';
my $l;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "type_declarator__S_276enum", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Genum/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = (($l = $C->longname))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C;  $C->add_name($l->Str); $C->add_enum($l->Str, $M->{arglist}->Str); ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token type_constraint
##      token type_constraint {
##          [
##          | <value>
##          | <fulltypename>
##          | where <.ws> <EXPR(item %chaining)>
##          ]
##          <.ws>
##      }

sub type_constraint__PEEK { $_[0]->_AUTOLEXpeek('type_constraint',$retree) }
sub type_constraint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "type_constraint", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'type_constraint_01') {
$C->deb("Fate passed to type_constraint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'type_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
}
);
}

## rule post_constraint
##      rule post_constraint {
##          [
##          | '[' ~ ']' <signature>
##          | '(' ~ ')' <signature>
##          | where <EXPR(item %chaining)>
##          ]
##      }

sub post_constraint__PEEK { $_[0]->_AUTOLEXpeek('post_constraint',$retree) }
sub post_constraint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "post_constraint", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'post_constraint_01') {
$C->deb("Fate passed to post_constraint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'post_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("post_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']', 'post_constraint')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']'))
}, $C->ws)
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')', 'post_constraint')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))
}, $C->ws)
}, $C->_EXACT('where'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
);
}

## token named_param
##      token named_param {
##          :my $GOAL is context = ')';
##          ':'
##          [
##          | <name=identifier> '(' <.ws>
##              [ <named_param> | <param_var> <.ws> ]
##              [ ')' || <.panic: "Unable to parse named parameter; couldn't find right parenthesis"> ]
##          | <param_var>
##          ]
##      }

sub named_param__PEEK { $_[0]->_AUTOLEXpeek('named_param',$retree) }
sub named_param {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL =  ')';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "named_param", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'named_param_01') {
$C->deb("Fate passed to named_param_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'named_param_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'named_param_02') {
$C->deb("Fate passed to named_param_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'named_param_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Unable to parse named parameter; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token param_var
##      token param_var {
##          [
##          | '[' ~ ']' <signature>
##          | '(' ~ ')' <signature>
##          | <sigil> [<?before <.twigil>\w> <twigil>]?
##              [
##                  # Is it a longname declaration?
##              || <?{ $<sigil>.Str eq '&' }> <?ident> {}
##                  <name=sublongname> {{ $*REALLYADD = 0 }} # sublongname adds symbol
##      
##              ||  # Is it a shaped array or hash declaration?
##                  <?{ $<sigil>.Str eq '@' || $<sigil>.Str eq '%' }>
##                  <name=identifier>?
##                  <?before <[ \< \( \[ \{ ]> >
##                  <postcircumfix>
##      
##                  # ordinary parameter name
##              || <name=identifier>
##              || $<name> = [<[/!]>]
##      
##                  # bare sigil?
##              ]?
##              {{
##                  my $vname = $<sigil>.Str;
##                  my $t = $<twigil>;
##                  my $twigil = '';
##                  $twigil = $t.[0].Str if @$t;
##                  $vname ~= $twigil;
##                  my $n = try { $<name>[0].Str } // '';
##                  $vname ~= $n;
##                  if $*REALLYADD {
##                      given $twigil {
##                          when '' {
##                              self.add_variable($vname) if $n ne '';
##                          }
##                          when '.' {
##                          }
##                          when '!' {
##                          }
##                          default {
##                              self.worry("Illegal to use $twigil twigil in signature");
##                          }
##                      }
##                  }
##              }}
##          ]
##      }

sub param_var__PEEK { $_[0]->_AUTOLEXpeek('param_var',$retree) }
sub param_var {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'identifier'} = [];
$C->{'name'} = [];
$C->{'twigil'} = [];
$C->{'postcircumfix'} = [];

$self->_MATCHIFY($S, "param_var", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'param_var_01') {
$C->deb("Fate passed to param_var_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'param_var_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_var_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'param_var')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'param_var')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C; 
my $vname = $M->{sigil}->Str;
my $t = $M->{twigil};
my $twigil = '';
$twigil = $t->[0]->Str if @$t;
$vname .= $twigil;
my $n = eval { $M->{name}[0]->Str } // '';
$vname .= $n;
if ($::REALLYADD) {
do { my $_ = $twigil; if ((0)) {}
elsif ($_ eq '') {
$self->add_variable($vname) if $n ne '';
}
elsif ($_ eq '.') {
}
elsif ($_ eq '!') {
}
else {
$self->worry("Illegal to use $twigil twigil in signature");
}
};
}
;
}, $C)
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$::REALLYADD = 0 
}, $C)
},     $C->_SUBSUME(['name'], sub {
my $C = shift;
$C->sublongname
}))
}, scalar(do {

}, $C))
}, $C->before( sub { my $C=shift;
$C->ident
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{sigil}->Str eq '&' ;
})
}))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\<\(\[\{]/)
}))
},     $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['name','identifier'], sub {
my $C = shift;
$C->identifier
})
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{sigil}->Str eq '@' || $M->{sigil}->Str eq '%' ;
})
}))} 
or
eval { push @gather,     $C->_SUBSUME(['name'], sub {
my $C = shift;
$C->identifier
})} 
or
eval { push @gather,     $C->_SUBSUME(['name'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
$C->_PATTERN(qr/\G[\/!]/)
})
})} or do { die $@ if $@ };
@gather;
}
})
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G\w/)
}, $C->twigil)
}))
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token parameter
##      token parameter {
##          :my $kind;
##          :my $quant = '';
##          :my $q;
##          :my $REALLYADD is context<rw> = 0;
##      
##          {{ $*REALLYADD = 1 }}
##      
##          [
##          | <type_constraint>+
##              {
##                  my $t = $<type_constraint>;
##                  @$t > 1 and $.panic("Multiple prefix constraints not yet supported")
##              }
##              [
##              | '*' <param_var>   { $quant = '*'; $kind = '*'; }
##              | '|' <param_var>   { $quant = '|'; $kind = '*'; }
##              | '\\' <param_var>  { $quant = '\\'; $kind = '!'; }
##              |   [
##                  | <param_var>   { $quant = ''; $kind = '!'; }
##                  | <named_param> { $quant = ''; $kind = '*'; }
##                  ]
##                  [
##                  | '?'           { $quant = '?'; $kind = '?' }
##                  | '!'           { $quant = '!'; $kind //= '!' }
##                  | <?>
##                  ]
##              | <?> { $quant = ''; $kind = '!' }
##              ]
##      
##          | '*' <param_var>   { $quant = '*'; $kind = '*'; }
##          | '|' <param_var>   { $quant = '|'; $kind = '*'; }
##          | '\\' <param_var>  { $quant = '\\'; $kind = '!'; }
##          |   [
##              | <param_var>   { $quant = ''; $kind = '!'; }
##              | <named_param> { $quant = ''; $kind = '*'; }
##              ]
##              [
##              | '?'           { $quant = '?'; $kind = '?' }
##              | '!'           { $quant = '!'; $kind //= '!' }
##              | <?>
##              ]
##          ]
##      
##          <trait>*
##      
##          <post_constraint>*
##      
##          [
##              <default_value> {{
##                  given $quant {
##                    when '!' { $.panic("Can't put a default on a required parameter") }
##                    when '*' { $.panic("Can't put a default on a slurpy parameter") }
##                    when '|' { $.panic("Can't put a default on an slurpy capture parameter") }
##                    when '\\' { $.panic("Can't put a default on a capture parameter") }
##                  }
##                  $kind = '?';
##              }}
##          ]?
##      
##          {
##              $<quant> = $quant;
##              $<kind> = $kind;
##          }
##      
##          # enforce zone constraints
##          {{
##              given $kind {
##                  when '!' {
##                      given $*zone {
##                          when 'posopt' {
##      $.panic("Can't put required parameter after optional parameters");
##                          }
##                          when 'var' {
##      $.panic("Can't put required parameter after variadic parameters");
##                          }
##                      }
##                  }
##                  when '?' {
##                      given $*zone {
##                          when 'posreq' { $*zone = 'posopt' }
##                          when 'var' {
##      $.panic("Can't put optional positional parameter after variadic parameters");
##                          }
##                      }
##                  }
##                  when '*' {
##                      $*zone = 'var';
##                  }
##              }
##          }}
##      }

sub parameter__PEEK { $_[0]->_AUTOLEXpeek('parameter',$retree) }
sub parameter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $kind;
my $quant = '';
my $q;
local $::REALLYADD =  0;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];
$C->{'default_value'} = [];
$C->{'post_constraint'} = [];
$C->{'type_constraint'} = [];

$self->_MATCHIFYr($S, "parameter", 
do {
if (my ($C) = (scalar(do {
$::REALLYADD = 1 
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_01') {
$C->deb("Fate passed to parameter_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{type_constraint};
@$t > 1 and $C->panic("Multiple prefix constraints not yet supported")
;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_02') {
$C->deb("Fate passed to parameter_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\'; $kind = '!'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_03') {
$C->deb("Fate passed to parameter_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = ''; $kind = '*'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_04') {
$C->deb("Fate passed to parameter_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('?'))) {
scalar(do {
$quant = '?'; $kind = '?' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
scalar(do {
$quant = '!'; $kind //= '!' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C
}))) {
scalar(do {
$quant = ''; $kind = '!' 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\'; $kind = '!'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_05') {
$C->deb("Fate passed to parameter_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = ''; $kind = '*'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_06') {
$C->deb("Fate passed to parameter_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('?'))) {
scalar(do {
$quant = '?'; $kind = '?' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
scalar(do {
$quant = '!'; $kind //= '!' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['default_value'], sub {
my $C = shift;
$C->default_value
}))) {
scalar(do {

do { my $_ = $quant; if ((0)) {}
elsif ($_ eq '!') { $C->panic("Can't put a default on a required parameter") }
elsif ($_ eq '*') { $C->panic("Can't put a default on a slurpy parameter") }
elsif ($_ eq '|') { $C->panic("Can't put a default on an slurpy capture parameter") }
elsif ($_ eq '\\') { $C->panic("Can't put a default on a capture parameter") }
};
$kind = '?';

}, $C);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$M->{quant} = $quant;
$M->{kind} = $kind;
;
}, $C))) {
scalar(do {

do { my $_ = $kind; if ((0)) {}
elsif ($_ eq '!') {
do { my $_ = $::zone; if ((0)) {}
elsif ($_ eq 'posopt') {
$C->panic("Can't put required parameter after optional parameters");
}
elsif ($_ eq 'var') {
$C->panic("Can't put required parameter after variadic parameters");
}
};
}
elsif ($_ eq '?') {
do { my $_ = $::zone; if ((0)) {}
elsif ($_ eq 'posreq') { $::zone = 'posopt' }
elsif ($_ eq 'var') {
$C->panic("Can't put optional positional parameter after variadic parameters");
}
};
}
elsif ($_ eq '*') {
$::zone = 'var';
}
};

}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule default_value
##      rule default_value {
##          '=' <EXPR(item %item_assignment)>
##      }

sub default_value__PEEK { $_[0]->_AUTOLEXpeek('default_value',$retree) }
sub default_value {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "default_value", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_prefix__S_277try (:$sym is context<rw> = 'try')
##      token statement_prefix:try     { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_277try__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_277try',$retree) }
sub statement_prefix__S_277try {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'try';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_277try", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtry/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_278gather (:$sym is context<rw> = 'gather')
##      token statement_prefix:gather  { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_278gather__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_278gather',$retree) }
sub statement_prefix__S_278gather {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'gather';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_278gather", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggather/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_279contend (:$sym is context<rw> = 'contend')
##      token statement_prefix:contend { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_279contend__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_279contend',$retree) }
sub statement_prefix__S_279contend {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'contend';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_279contend", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gcontend/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_280async (:$sym is context<rw> = 'async')
##      token statement_prefix:async   { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_280async__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_280async',$retree) }
sub statement_prefix__S_280async {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'async';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_280async", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gasync/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_281maybe (:$sym is context<rw> = 'maybe')
##      token statement_prefix:maybe   { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_281maybe__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_281maybe',$retree) }
sub statement_prefix__S_281maybe {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'maybe';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_281maybe", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmaybe/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_282lazy (:$sym is context<rw> = 'lazy')
##      token statement_prefix:lazy    { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_282lazy__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_282lazy',$retree) }
sub statement_prefix__S_282lazy {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lazy';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_282lazy", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glazy/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_283do (:$sym is context<rw> = 'do')
##      token statement_prefix:do      { <sym> <?before \s> <.ws> <statement> {{
##              my $loop = $<statement><statement_mod_loop>;
##              if $loop and @$loop and (my $s = $loop.[0].<sym>) ~~ /while|until/ {
##                  $.obs("do...$s" ,"repeat...$s");
##              }
##          }}
##      }

sub statement_prefix__S_283do__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_283do',$retree) }
sub statement_prefix__S_283do {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'do';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_283do", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdo/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
scalar(do {
my $M = $C; 
my $loop = $M->{statement}{statement_mod_loop};
if ($loop and @$loop and (my $s = $loop->[0]->{'sym'}) =~ qr/while|until/) {
$C->obs("do...$s" ,"repeat...$s");
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_284lift (:$sym is context<rw> = 'lift')
##      token statement_prefix:lift    {
##          :my $QUASI_QUASH is context = 1;
##          <sym> <?before \s> <.ws> <statement>
##      }

sub statement_prefix__S_284lift__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_284lift',$retree) }
sub statement_prefix__S_284lift {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lift';
local $::QUASI_QUASH =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_284lift", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glift/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## term

## token term__S_285new (  :$sym is context<rw> = 'new' --> Term)
##      token term:new ( --> Term) {
##          'new' \h+ <longname> \h* <!before ':'> <.obs("C++ constructor syntax", "method call syntax")>
##      }

sub term__S_285new__PEEK { $_[0]->_AUTOLEXpeek('term__S_285new',$retree) }
sub term__S_285new {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'new';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_285new",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('new'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(':')
})
}))) {
$C->obs("C++ constructor syntax", "method call syntax");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_286ColonColonQuestionIDENT (  :$sym is context<rw> = <::?IDENT> --> Term)
##      token term:sym<::?IDENT> ( --> Term) {
##          $<sym> = [ '::?' <identifier> ] 
##      }

sub term__S_286ColonColonQuestionIDENT__PEEK { $_[0]->_AUTOLEXpeek('term__S_286ColonColonQuestionIDENT',$retree) }
sub term__S_286ColonColonQuestionIDENT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::?IDENT);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_286ColonColonQuestionIDENT",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token term__S_287undef (  :$sym is context<rw> = <undef> --> Term)
##      token term:sym<undef> ( --> Term) {
##          <sym> 
##          [ <?before \h*'$/' >
##              <.obs('$/ variable as input record separator',
##                   "the filehandle's .slurp method")>
##          ]?
##          [ <?before \h*<sigil><twigil>?\w >
##              <.obs('undef as a verb', 'undefine function')>
##          ]?
##      }

sub term__S_287undef__PEEK { $_[0]->_AUTOLEXpeek('term__S_287undef',$retree) }
sub term__S_287undef {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(undef);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_287undef",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gundef/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_EXACT('$/');
}
else {
();
}
}
}))) {
$C->obs('$/ variable as input record separator',
"the filehandle's .slurp method");
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
$C->_PATTERN(qr/\G\w/);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->obs('undef as a verb', 'undefine function');
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_288continue (  :$sym is context<rw> = <continue> --> Term)
##      token term:sym<continue> ( --> Term)
##          { <sym>  }

sub term__S_288continue__PEEK { $_[0]->_AUTOLEXpeek('term__S_288continue',$retree) }
sub term__S_288continue {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(continue);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_288continue",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gcontinue\b/)
);
}

## token term__S_289self (  :$sym is context<rw> = <self> --> Term)
##      token term:sym<self> ( --> Term)
##          { <sym>  }

sub term__S_289self__PEEK { $_[0]->_AUTOLEXpeek('term__S_289self',$retree) }
sub term__S_289self {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(self);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_289self",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gself\b/)
);
}

## token term__S_290defer (  :$sym is context<rw> = <defer> --> Term)
##      token term:sym<defer> ( --> Term)
##          { <sym>  }

sub term__S_290defer__PEEK { $_[0]->_AUTOLEXpeek('term__S_290defer',$retree) }
sub term__S_290defer {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(defer);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_290defer",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gdefer\b/)
);
}

## token term__S_291rand (  :$sym is context<rw> = 'rand' --> Term)
##      token term:rand ( --> Term)
##          { <sym>  [ <?before \h+ [\d|'$']> <.obs('rand(N)', 'N.rand or (1..N).pick')> ]? }

sub term__S_291rand__PEEK { $_[0]->_AUTOLEXpeek('term__S_291rand',$retree) }
sub term__S_291rand {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rand';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_291rand",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grand/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'term__S_291rand_03') {
$C->deb("Fate passed to term__S_291rand_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_291rand_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_291rand_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub { my $C=shift;
$C->_EXACT('$')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
}))) {
$C->obs('rand(N)', 'N.rand or (1..N).pick');
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_292e (  :$sym is context<rw> = 'e' --> Term)
##      token term:e ( --> Term)
##          { <sym>  }

sub term__S_292e__PEEK { $_[0]->_AUTOLEXpeek('term__S_292e',$retree) }
sub term__S_292e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_292e",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Ge\b/)
);
}

## token term__S_293i (  :$sym is context<rw> = 'i' --> Term)
##      token term:i ( --> Term)
##          { <sym>  }

sub term__S_293i__PEEK { $_[0]->_AUTOLEXpeek('term__S_293i',$retree) }
sub term__S_293i {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'i';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_293i",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gi\b/)
);
}

## token term__S_294pi (  :$sym is context<rw> = 'pi' --> Term)
##      token term:pi ( --> Term)
##          { <sym>  }

sub term__S_294pi__PEEK { $_[0]->_AUTOLEXpeek('term__S_294pi',$retree) }
sub term__S_294pi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'pi';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_294pi",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gpi\b/)
);
}

## token term__S_295Inf (  :$sym is context<rw> = 'Inf' --> Term)
##      token term:Inf ( --> Term)
##          { <sym>  }

sub term__S_295Inf__PEEK { $_[0]->_AUTOLEXpeek('term__S_295Inf',$retree) }
sub term__S_295Inf {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Inf';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_295Inf",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\GInf\b/)
);
}

## token term__S_296NaN (  :$sym is context<rw> = 'NaN' --> Term)
##      token term:NaN ( --> Term)
##          { <sym>  }

sub term__S_296NaN__PEEK { $_[0]->_AUTOLEXpeek('term__S_296NaN',$retree) }
sub term__S_296NaN {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'NaN';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_296NaN",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\GNaN\b/)
);
}

## token term__S_297Star (  :$sym is context<rw> = <*> --> Term)
##      token term:sym<*> ( --> Term)
##          { <sym> }

sub term__S_297Star__PEEK { $_[0]->_AUTOLEXpeek('term__S_297Star',$retree) }
sub term__S_297Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_297Star",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\G\*/)
);
}

## token term__S_298StarStar (  :$sym is context<rw> = <**> --> Term)
##      token term:sym<**> ( --> Term)
##          { <sym> }

sub term__S_298StarStar__PEEK { $_[0]->_AUTOLEXpeek('term__S_298StarStar',$retree) }
sub term__S_298StarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_298StarStar",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\G\*\*/)
);
}

## token infix__S_299lambda (  :$sym is context<rw> = 'lambda' --> Term)
##      token infix:lambda ( --> Term) {
##          <?before '{' | '->' > {{
##              my $line = $.lineof($.pos);
##              for 'if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when' {
##                  my $m = %*MYSTERY{$_};
##                  next unless $m;
##                  if $line - ($m.<line>//-123) < 5 {
##                      $.panic("$_() interpreted as function call at line " ~ $m.<line> ~
##                      "; please use whitespace instead of parens\nUnexpected block in infix position (two terms in a row)");
##                  }
##              }
##              $.panic("Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)");
##          }}
##      }

sub infix__S_299lambda__PEEK { $_[0]->_AUTOLEXpeek('infix__S_299lambda',$retree) }
sub infix__S_299lambda {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lambda';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_299lambda",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix__S_299lambda_01') {
$C->deb("Fate passed to infix__S_299lambda_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_299lambda_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_299lambda_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('->')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {

my $line = $C->lineof($C->{_pos});
for ('if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when') {
my $m = $::MYSTERY{$_};
next unless $m;
if ($line - ($m->{'line'}//-123) < 5) {
$C->panic("$_() interpreted as function call at line " . $m->{'line'} .
"; please use whitespace instead of parens\nUnexpected block in infix position (two terms in a row)");
}
};
$C->panic("Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)");

}, $C);
}
else {
();
}
}
);
}

## token circumfix__S_300sigil (  :$sym is context<rw> = 'sigil' --> Term)
##      token circumfix:sigil ( --> Term)
##          { :dba('contextualizer') <sigil> '(' ~ ')' <semilist> { $*SIGIL ||= $<sigil>.Str } }

sub circumfix__S_300sigil__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_300sigil',$retree) }
sub circumfix__S_300sigil {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_300sigil",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $::SIGIL ||= $M->{sigil}->Str ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'contextualizer')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
);
}

#token circumfix:typecast ( --> Term)
#    { <typename> '(' ~ ')' <semilist> }

## token circumfix__S_301Paren_Thesis (  :$sym is context<rw> = <( )> --> Term)
##      token circumfix:sym<( )> ( --> Term)
##          { :dba('parenthesized expression') '(' ~ ')' <semilist> }

sub circumfix__S_301Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_301Paren_Thesis',$retree) }
sub circumfix__S_301Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_301Paren_Thesis",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'parenthesized expression')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

## token circumfix__S_302Bra_Ket (  :$sym is context<rw> = <[ ]> --> Term)
##      token circumfix:sym<[ ]> ( --> Term)
##          { :dba('array composer') '[' ~ ']' <semilist> }

sub circumfix__S_302Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_302Bra_Ket',$retree) }
sub circumfix__S_302Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_302Bra_Ket",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'array composer')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
);
}

## methodcall

## token postfix__S_303i (  :$sym is context<rw> = <i> --> Methodcall)
##      token postfix:sym<i> ( --> Methodcall)
##          { <sym>  }

sub postfix__S_303i__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_303i',$retree) }
sub postfix__S_303i {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_303i",  map { STD::Methodcall->coerce($_) } 
$C->_PATTERN(qr/\Gi\b/)
);
}

## token infix__S_304Dot (:$sym is context<rw> = <.>)
##      token infix:sym<.> ()
##          { '.' <[\]\)\},:\s\$"']> <.obs('. to concatenate strings', '~')> }

sub infix__S_304Dot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_304Dot',$retree) }
sub infix__S_304Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_304Dot", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\]\)\},:\s\$"']/))) {
$C->obs('. to concatenate strings', '~');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postfix__S_305MinusGt (:$sym is context<rw> = ['->'])
##      token postfix:sym['->'] ()
##          { '->' <.obs('-> to call a method', '.')> }

sub postfix__S_305MinusGt__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_305MinusGt',$retree) }
sub postfix__S_305MinusGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // ['->'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_305MinusGt", 
do {
if (my ($C) = ($C->_EXACT('->'))) {
$C->obs('-> to call a method', '.');
}
else {
();
}
}
);
}

## autoincrement
## token postfix__S_306PlusPlus (  :$sym is context<rw> = <++> --> Autoincrement)
##      token postfix:sym<++> ( --> Autoincrement)
##          { <sym> }

sub postfix__S_306PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_306PlusPlus',$retree) }
sub postfix__S_306PlusPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(++);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_306PlusPlus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\+\+/)
);
}

## token postfix__S_307MinusMinus (  :$sym is context<rw> = <--> --> Autoincrement)
##      token postfix:sym<--> ( --> Autoincrement)
##          { <sym> }

sub postfix__S_307MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_307MinusMinus',$retree) }
sub postfix__S_307MinusMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(--);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_307MinusMinus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\-\-/)
);
}

## token prefix__S_308PlusPlus (  :$sym is context<rw> = <++> --> Autoincrement)
##      token prefix:sym<++> ( --> Autoincrement)
##          { <sym> }

sub prefix__S_308PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_308PlusPlus',$retree) }
sub prefix__S_308PlusPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(++);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_308PlusPlus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\+\+/)
);
}

## token prefix__S_309MinusMinus (  :$sym is context<rw> = <--> --> Autoincrement)
##      token prefix:sym<--> ( --> Autoincrement)
##          { <sym> }

sub prefix__S_309MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_309MinusMinus',$retree) }
sub prefix__S_309MinusMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(--);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_309MinusMinus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\-\-/)
);
}

## exponentiation
## token infix__S_310StarStar (  :$sym is context<rw> = <**> --> Exponentiation)
##      token infix:sym<**> ( --> Exponentiation)
##          { <sym> }

sub infix__S_310StarStar__PEEK { $_[0]->_AUTOLEXpeek('infix__S_310StarStar',$retree) }
sub infix__S_310StarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_310StarStar",  map { STD::Exponentiation->coerce($_) } 
$C->_PATTERN(qr/\G\*\*/)
);
}

## symbolic unary
## token prefix__S_311Bang (  :$sym is context<rw> = <!> --> Symbolic_unary)
##      token prefix:sym<!> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_311Bang__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_311Bang',$retree) }
sub prefix__S_311Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_311Bang",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\!/)
);
}

## token prefix__S_312Plus (  :$sym is context<rw> = <+> --> Symbolic_unary)
##      token prefix:sym<+> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_312Plus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_312Plus',$retree) }
sub prefix__S_312Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_312Plus",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\+/)
);
}

## token prefix__S_313Minus (  :$sym is context<rw> = <-> --> Symbolic_unary)
##      token prefix:sym<-> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_313Minus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_313Minus',$retree) }
sub prefix__S_313Minus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_313Minus",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\-/)
);
}

## token prefix__S_314Tilde (  :$sym is context<rw> = <~> --> Symbolic_unary)
##      token prefix:sym<~> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_314Tilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_314Tilde',$retree) }
sub prefix__S_314Tilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_314Tilde",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}

## token prefix__S_315Question (  :$sym is context<rw> = <?> --> Symbolic_unary)
##      token prefix:sym<?> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_315Question__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_315Question',$retree) }
sub prefix__S_315Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_315Question",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\?/)
);
}

## token prefix__S_316TildeCaret (  :$sym is context<rw> = <~^> --> Symbolic_unary)
##      token prefix:sym<~^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_316TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_316TildeCaret',$retree) }
sub prefix__S_316TildeCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_316TildeCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\~\^/)
);
}

## token prefix__S_317PlusCaret (  :$sym is context<rw> = <+^> --> Symbolic_unary)
##      token prefix:sym<+^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_317PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_317PlusCaret',$retree) }
sub prefix__S_317PlusCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_317PlusCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\+\^/)
);
}

## token prefix__S_318QuestionCaret (  :$sym is context<rw> = <?^> --> Symbolic_unary)
##      token prefix:sym<?^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_318QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_318QuestionCaret',$retree) }
sub prefix__S_318QuestionCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_318QuestionCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\?\^/)
);
}

## token prefix__S_319Caret (  :$sym is context<rw> = <^> --> Symbolic_unary)
##      token prefix:sym<^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_319Caret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_319Caret',$retree) }
sub prefix__S_319Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_319Caret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\^/)
);
}

## token prefix__S_320Vert (  :$sym is context<rw> = <|> --> Symbolic_unary)
##      token prefix:sym<|> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_320Vert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_320Vert',$retree) }
sub prefix__S_320Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_320Vert",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}


## multiplicative
## token infix__S_321Star (  :$sym is context<rw> = <*> --> Multiplicative)
##      token infix:sym<*> ( --> Multiplicative)
##          { <sym> }

sub infix__S_321Star__PEEK { $_[0]->_AUTOLEXpeek('infix__S_321Star',$retree) }
sub infix__S_321Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_321Star",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\*/)
);
}

## token infix__S_322Slash (  :$sym is context<rw> = </> --> Multiplicative)
##      token infix:sym</> ( --> Multiplicative)
##          { <sym> }

sub infix__S_322Slash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_322Slash',$retree) }
sub infix__S_322Slash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(/);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_322Slash",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\//)
);
}

## token infix__S_323div (  :$sym is context<rw> = <div> --> Multiplicative)
##      token infix:sym<div> ( --> Multiplicative)
##          { <sym> }

sub infix__S_323div__PEEK { $_[0]->_AUTOLEXpeek('infix__S_323div',$retree) }
sub infix__S_323div {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(div);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_323div",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\Gdiv/)
);
}

## token infix__S_324Percent (  :$sym is context<rw> = <%> --> Multiplicative)
##      token infix:sym<%> ( --> Multiplicative)
##          { <sym> <?{ $<O><iffy> = 1; }> }

sub infix__S_324Percent__PEEK { $_[0]->_AUTOLEXpeek('infix__S_324Percent',$retree) }
sub infix__S_324Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_324Percent",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\%/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{iffy} = 1; ;
})
});
}
else {
();
}
}
);
}   # Allow !% operator

## token infix__S_325mod (  :$sym is context<rw> = <mod> --> Multiplicative)
##      token infix:sym<mod> ( --> Multiplicative)
##          { <sym> }

sub infix__S_325mod__PEEK { $_[0]->_AUTOLEXpeek('infix__S_325mod',$retree) }
sub infix__S_325mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(mod);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_325mod",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\Gmod/)
);
}

## token infix__S_326PlusAmp (  :$sym is context<rw> = <+&> --> Multiplicative)
##      token infix:sym<+&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_326PlusAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_326PlusAmp',$retree) }
sub infix__S_326PlusAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_326PlusAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\+\&/)
);
}

## token infix__S_327PlusLt (  :$sym is context<rw> =  +<  --> Multiplicative)
##      token infix:sym +<  ( --> Multiplicative)
##          { <sym> <!before '<'> }

sub infix__S_327PlusLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_327PlusLt',$retree) }
sub infix__S_327PlusLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['+<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_327PlusLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\</))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('<')
})
});
}
else {
();
}
}
);
}

## token infix__S_328LtLt (  :$sym is context<rw> =  <<  --> Multiplicative)
##      token infix:sym <<  ( --> Multiplicative)
##          { <sym> \s <.obs('<< to do left shift', '+< or ~<')> }

sub infix__S_328LtLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_328LtLt',$retree) }
sub infix__S_328LtLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_328LtLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\</))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('<< to do left shift', '+< or ~<');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_329GtGt (  :$sym is context<rw> =  >>  --> Multiplicative)
##      token infix:sym >>  ( --> Multiplicative)
##          { <sym> \s <.obs('>> to do right shift', '+> or ~>')> }

sub infix__S_329GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_329GtGt',$retree) }
sub infix__S_329GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_329GtGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>\>/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('>> to do right shift', '+> or ~>');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_330PlusGt (  :$sym is context<rw> =  +>  --> Multiplicative)
##      token infix:sym +>  ( --> Multiplicative)
##          { <sym> <!before '>'> }

sub infix__S_330PlusGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_330PlusGt',$retree) }
sub infix__S_330PlusGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['+>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_330PlusGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\>/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
});
}
else {
();
}
}
);
}

## token infix__S_331TildeAmp (  :$sym is context<rw> = <~&> --> Multiplicative)
##      token infix:sym<~&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_331TildeAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_331TildeAmp',$retree) }
sub infix__S_331TildeAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_331TildeAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\~\&/)
);
}

## token infix__S_332QuestionAmp (  :$sym is context<rw> = <?&> --> Multiplicative)
##      token infix:sym<?&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_332QuestionAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_332QuestionAmp',$retree) }
sub infix__S_332QuestionAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_332QuestionAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\?\&/)
);
}

## token infix__S_333TildeLt (  :$sym is context<rw> =  ~<  --> Multiplicative)
##      token infix:sym ~<  ( --> Multiplicative)
##          { <sym> <!before '<'> }

sub infix__S_333TildeLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_333TildeLt',$retree) }
sub infix__S_333TildeLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['~<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_333TildeLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\</))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('<')
})
});
}
else {
();
}
}
);
}

## token infix__S_334TildeGt (  :$sym is context<rw> =  ~>  --> Multiplicative)
##      token infix:sym ~>  ( --> Multiplicative)
##          { <sym> <!before '>'> }

sub infix__S_334TildeGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_334TildeGt',$retree) }
sub infix__S_334TildeGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['~>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_334TildeGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\>/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
});
}
else {
();
}
}
);
}


## additive
## token infix__S_335Plus (  :$sym is context<rw> = <+> --> Additive)
##      token infix:sym<+> ( --> Additive)
##          { <sym> }

sub infix__S_335Plus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_335Plus',$retree) }
sub infix__S_335Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_335Plus",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+/)
);
}

## token infix__S_336Minus (  :$sym is context<rw> = <-> --> Additive)
##      token infix:sym<-> ( --> Additive)
##          { <sym> }

sub infix__S_336Minus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_336Minus',$retree) }
sub infix__S_336Minus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_336Minus",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\-/)
);
}

## token infix__S_337PlusVert (  :$sym is context<rw> = <+|> --> Additive)
##      token infix:sym<+|> ( --> Additive)
##          { <sym> }

sub infix__S_337PlusVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_337PlusVert',$retree) }
sub infix__S_337PlusVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_337PlusVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+\|/)
);
}

## token infix__S_338PlusCaret (  :$sym is context<rw> = <+^> --> Additive)
##      token infix:sym<+^> ( --> Additive)
##          { <sym> }

sub infix__S_338PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_338PlusCaret',$retree) }
sub infix__S_338PlusCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_338PlusCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+\^/)
);
}

## token infix__S_339TildeVert (  :$sym is context<rw> = <~|> --> Additive)
##      token infix:sym<~|> ( --> Additive)
##          { <sym> }

sub infix__S_339TildeVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_339TildeVert',$retree) }
sub infix__S_339TildeVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_339TildeVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~\|/)
);
}

## token infix__S_340TildeCaret (  :$sym is context<rw> = <~^> --> Additive)
##      token infix:sym<~^> ( --> Additive)
##          { <sym> }

sub infix__S_340TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_340TildeCaret',$retree) }
sub infix__S_340TildeCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_340TildeCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~\^/)
);
}

## token infix__S_341QuestionVert (  :$sym is context<rw> = <?|> --> Additive)
##      token infix:sym<?|> ( --> Additive)
##          { <sym> }

sub infix__S_341QuestionVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_341QuestionVert',$retree) }
sub infix__S_341QuestionVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_341QuestionVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\?\|/)
);
}

## token infix__S_342QuestionCaret (  :$sym is context<rw> = <?^> --> Additive)
##      token infix:sym<?^> ( --> Additive)
##          { <sym> }

sub infix__S_342QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_342QuestionCaret',$retree) }
sub infix__S_342QuestionCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_342QuestionCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\?\^/)
);
}

## replication
# Note: no word boundary check after x, relies on longest token for x2 xx2 etc
## token infix__S_343x (  :$sym is context<rw> = <x> --> Replication)
##      token infix:sym<x> ( --> Replication)
##          { <sym> }

sub infix__S_343x__PEEK { $_[0]->_AUTOLEXpeek('infix__S_343x',$retree) }
sub infix__S_343x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(x);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_343x",  map { STD::Replication->coerce($_) } 
$C->_PATTERN(qr/\Gx/)
);
}

## token infix__S_344xx (  :$sym is context<rw> = <xx> --> Replication)
##      token infix:sym<xx> ( --> Replication)
##          { <sym> }

sub infix__S_344xx__PEEK { $_[0]->_AUTOLEXpeek('infix__S_344xx',$retree) }
sub infix__S_344xx {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(xx);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_344xx",  map { STD::Replication->coerce($_) } 
$C->_PATTERN(qr/\Gxx/)
);
}

## concatenation
## token infix__S_345Tilde (  :$sym is context<rw> = <~> --> Concatenation)
##      token infix:sym<~> ( --> Concatenation)
##          { <sym> }

sub infix__S_345Tilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_345Tilde',$retree) }
sub infix__S_345Tilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_345Tilde",  map { STD::Concatenation->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}


## junctive and (all)
## token infix__S_346Amp (  :$sym is context<rw> = <&> --> Junctive_and)
##      token infix:sym<&> ( --> Junctive_and)
##          { <sym> }

sub infix__S_346Amp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_346Amp',$retree) }
sub infix__S_346Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_346Amp",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\G\&/)
);
}

## token infix__S_347also (  :$sym is context<rw> = <also> --> Junctive_and)
##      token infix:sym<also> ( --> Junctive_and)
##          { <sym> }

sub infix__S_347also__PEEK { $_[0]->_AUTOLEXpeek('infix__S_347also',$retree) }
sub infix__S_347also {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(also);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_347also",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\Galso/)
);
}


## junctive or (any)
## token infix__S_348Vert (  :$sym is context<rw> = <|> --> Junctive_or)
##      token infix:sym<|> ( --> Junctive_or)
##          { <sym> }

sub infix__S_348Vert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_348Vert',$retree) }
sub infix__S_348Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_348Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}

## token infix__S_349Caret (  :$sym is context<rw> = <^> --> Junctive_or)
##      token infix:sym<^> ( --> Junctive_or)
##          { <sym> }

sub infix__S_349Caret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_349Caret',$retree) }
sub infix__S_349Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_349Caret",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\^/)
);
}


## named unary examples
# (need \s* to win LTM battle with listops)
## token prefix__S_350sleep (  :$sym is context<rw> = 'sleep' --> Named_unary)
##      token prefix:sleep ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_350sleep__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_350sleep',$retree) }
sub prefix__S_350sleep {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sleep';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_350sleep",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsleep/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_351abs (  :$sym is context<rw> = 'abs' --> Named_unary)
##      token prefix:abs ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_351abs__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_351abs',$retree) }
sub prefix__S_351abs {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'abs';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_351abs",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gabs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_352let (  :$sym is context<rw> = 'let' --> Named_unary)
##      token prefix:let ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_352let__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_352let',$retree) }
sub prefix__S_352let {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'let';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_352let",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glet/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_353temp (  :$sym is context<rw> = 'temp' --> Named_unary)
##      token prefix:temp ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_353temp__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_353temp',$retree) }
sub prefix__S_353temp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'temp';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_353temp",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtemp/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}


## nonchaining binary
## token infix__S_354LtEqualGt (  :$sym is context<rw> =  <=>  --> Nonchaining)
##      token infix:sym <=>  ( --> Nonchaining)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_354LtEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_354LtEqualGt',$retree) }
sub infix__S_354LtEqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<=>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_354LtEqualGt",  map { STD::Nonchaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\=\>/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{returns} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_355cmp (  :$sym is context<rw> = 'cmp' --> Nonchaining)
##      token infix:cmp ( --> Nonchaining)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_355cmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_355cmp',$retree) }
sub infix__S_355cmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'cmp';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_355cmp",  map { STD::Nonchaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gcmp/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{returns} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_356leg (  :$sym is context<rw> = 'leg' --> Nonchaining)
##      token infix:leg ( --> Nonchaining)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_356leg__PEEK { $_[0]->_AUTOLEXpeek('infix__S_356leg',$retree) }
sub infix__S_356leg {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'leg';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_356leg",  map { STD::Nonchaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gleg/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{returns} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_357but (  :$sym is context<rw> = 'but' --> Nonchaining)
##      token infix:but ( --> Nonchaining)
##          { <sym> }

sub infix__S_357but__PEEK { $_[0]->_AUTOLEXpeek('infix__S_357but',$retree) }
sub infix__S_357but {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'but';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_357but",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gbut/)
);
}

## token infix__S_358does (  :$sym is context<rw> = 'does' --> Nonchaining)
##      token infix:does ( --> Nonchaining)
##          { <sym> }

sub infix__S_358does__PEEK { $_[0]->_AUTOLEXpeek('infix__S_358does',$retree) }
sub infix__S_358does {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'does';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_358does",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gdoes/)
);
}

## token infix__S_359DotDot (  :$sym is context<rw> = <..> --> Nonchaining)
##      token infix:sym<..> ( --> Nonchaining)
##          { <sym> [<!{ $*IN_META }> <?before ')' | ']'> <.panic: "Please use ..* for indefinite range">]? }

sub infix__S_359DotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_359DotDot',$retree) }
sub infix__S_359DotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(..);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_359DotDot",  map { STD::Nonchaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\./))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::IN_META 
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix__S_359DotDot_02') {
$C->deb("Fate passed to infix__S_359DotDot_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_359DotDot_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_359DotDot_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->panic("Please use ..* for indefinite range");
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token infix__S_360CaretDotDot (  :$sym is context<rw> = <^..> --> Nonchaining)
##      token infix:sym<^..> ( --> Nonchaining)
##          { <sym> }

sub infix__S_360CaretDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_360CaretDotDot',$retree) }
sub infix__S_360CaretDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^..);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_360CaretDotDot",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^\.\./)
);
}

## token infix__S_361DotDotCaret (  :$sym is context<rw> = <..^> --> Nonchaining)
##      token infix:sym<..^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_361DotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_361DotDotCaret',$retree) }
sub infix__S_361DotDotCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(..^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_361DotDotCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\.\.\^/)
);
}

## token infix__S_362CaretDotDotCaret (  :$sym is context<rw> = <^..^> --> Nonchaining)
##      token infix:sym<^..^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_362CaretDotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_362CaretDotDotCaret',$retree) }
sub infix__S_362CaretDotDotCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^..^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_362CaretDotDotCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^\.\.\^/)
);
}


## chaining binary
## token infix__S_363EqualEqual (  :$sym is context<rw> = <==> --> Chaining)
##      token infix:sym<==> ( --> Chaining)
##          { <sym> <!before '=' > }

sub infix__S_363EqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_363EqualEqual',$retree) }
sub infix__S_363EqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(==);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_363EqualEqual",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('=')
})
});
}
else {
();
}
}
);
}

## token infix__S_364BangEqual (  :$sym is context<rw> = <!=> --> Chaining)
##      token infix:sym<!=> ( --> Chaining)
##          { <sym> <?before \s> }

sub infix__S_364BangEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_364BangEqual',$retree) }
sub infix__S_364BangEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_364BangEqual",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\=/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
});
}
else {
();
}
}
);
}

## token infix__S_365Lt (  :$sym is context<rw> =  <  --> Chaining)
##      token infix:sym <  ( --> Chaining)
##          { <sym> }

sub infix__S_365Lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_365Lt',$retree) }
sub infix__S_365Lt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_365Lt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\</)
);
}

## token infix__S_366LtEqual (  :$sym is context<rw> =  <=  --> Chaining)
##      token infix:sym <=  ( --> Chaining)
##          { <sym> }

sub infix__S_366LtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_366LtEqual',$retree) }
sub infix__S_366LtEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_366LtEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\<\=/)
);
}

## token infix__S_367Gt (  :$sym is context<rw> =  >  --> Chaining)
##      token infix:sym >  ( --> Chaining)
##          { <sym> }

sub infix__S_367Gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_367Gt',$retree) }
sub infix__S_367Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_367Gt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\>/)
);
}

## token infix__S_368GtEqual (  :$sym is context<rw> =  >=  --> Chaining)
##      token infix:sym >=  ( --> Chaining)
##          { <sym> }

sub infix__S_368GtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_368GtEqual',$retree) }
sub infix__S_368GtEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_368GtEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\>\=/)
);
}

## token infix__S_369TildeTilde (  :$sym is context<rw> = <~~> --> Chaining)
##      token infix:sym<~~> ( --> Chaining)
##          { <sym> }

sub infix__S_369TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_369TildeTilde',$retree) }
sub infix__S_369TildeTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_369TildeTilde",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\~\~/)
);
}

# XXX should move to inside meta !
## token infix__S_370BangTilde (  :$sym is context<rw> = <!~> --> Chaining)
##      token infix:sym<!~> ( --> Chaining)
##          { <sym> \s <.obs('!~ to do negated pattern matching', '!~~')> }

sub infix__S_370BangTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_370BangTilde',$retree) }
sub infix__S_370BangTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_370BangTilde",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\~/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('!~ to do negated pattern matching', '!~~');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_371EqualTilde (  :$sym is context<rw> = <=~> --> Chaining)
##      token infix:sym<=~> ( --> Chaining)
##          { <sym> <.obs('=~ to do pattern matching', '~~')> }

sub infix__S_371EqualTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_371EqualTilde',$retree) }
sub infix__S_371EqualTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_371EqualTilde",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\~/))) {
$C->obs('=~ to do pattern matching', '~~');
}
else {
();
}
}
);
}

## token infix__S_372eq (  :$sym is context<rw> = <eq> --> Chaining)
##      token infix:sym<eq> ( --> Chaining)
##          { <sym> }

sub infix__S_372eq__PEEK { $_[0]->_AUTOLEXpeek('infix__S_372eq',$retree) }
sub infix__S_372eq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(eq);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_372eq",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Geq/)
);
}

## token infix__S_373ne (  :$sym is context<rw> = <ne> --> Chaining)
##      token infix:sym<ne> ( --> Chaining)
##          { <sym> }

sub infix__S_373ne__PEEK { $_[0]->_AUTOLEXpeek('infix__S_373ne',$retree) }
sub infix__S_373ne {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ne);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_373ne",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gne/)
);
}

## token infix__S_374lt (  :$sym is context<rw> = <lt> --> Chaining)
##      token infix:sym<lt> ( --> Chaining)
##          { <sym> }

sub infix__S_374lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_374lt',$retree) }
sub infix__S_374lt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(lt);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_374lt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Glt/)
);
}

## token infix__S_375le (  :$sym is context<rw> = <le> --> Chaining)
##      token infix:sym<le> ( --> Chaining)
##          { <sym> }

sub infix__S_375le__PEEK { $_[0]->_AUTOLEXpeek('infix__S_375le',$retree) }
sub infix__S_375le {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(le);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_375le",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gle/)
);
}

## token infix__S_376gt (  :$sym is context<rw> = <gt> --> Chaining)
##      token infix:sym<gt> ( --> Chaining)
##          { <sym> }

sub infix__S_376gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_376gt',$retree) }
sub infix__S_376gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(gt);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_376gt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Ggt/)
);
}

## token infix__S_377ge (  :$sym is context<rw> = <ge> --> Chaining)
##      token infix:sym<ge> ( --> Chaining)
##          { <sym> }

sub infix__S_377ge__PEEK { $_[0]->_AUTOLEXpeek('infix__S_377ge',$retree) }
sub infix__S_377ge {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ge);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_377ge",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gge/)
);
}

## token infix__S_378EqualColonEqual (  :$sym is context<rw> = <=:=> --> Chaining)
##      token infix:sym<=:=> ( --> Chaining)
##          { <sym> }

sub infix__S_378EqualColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_378EqualColonEqual',$retree) }
sub infix__S_378EqualColonEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=:=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_378EqualColonEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\=\:\=/)
);
}

## token infix__S_379EqualEqualEqual (  :$sym is context<rw> = <===> --> Chaining)
##      token infix:sym<===> ( --> Chaining)
##          { <sym> }

sub infix__S_379EqualEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_379EqualEqualEqual',$retree) }
sub infix__S_379EqualEqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(===);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_379EqualEqualEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\=\=\=/)
);
}

## token infix__S_380eqv (  :$sym is context<rw> = <eqv> --> Chaining)
##      token infix:sym<eqv> ( --> Chaining)
##          { <sym> }

sub infix__S_380eqv__PEEK { $_[0]->_AUTOLEXpeek('infix__S_380eqv',$retree) }
sub infix__S_380eqv {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(eqv);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_380eqv",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Geqv/)
);
}

## token infix__S_381before (  :$sym is context<rw> = <before> --> Chaining)
##      token infix:sym<before> ( --> Chaining)
##          { <sym> }

sub infix__S_381before__PEEK { $_[0]->_AUTOLEXpeek('infix__S_381before',$retree) }
sub infix__S_381before {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(before);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_381before",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gbefore/)
);
}

## token infix__S_382after (  :$sym is context<rw> = <after> --> Chaining)
##      token infix:sym<after> ( --> Chaining)
##          { <sym> }

sub infix__S_382after__PEEK { $_[0]->_AUTOLEXpeek('infix__S_382after',$retree) }
sub infix__S_382after {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(after);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_382after",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gafter/)
);
}


## tight and
## token infix__S_383AmpAmp (  :$sym is context<rw> = <&&> --> Tight_and)
##      token infix:sym<&&> ( --> Tight_and)
##          { <sym> }

sub infix__S_383AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_383AmpAmp',$retree) }
sub infix__S_383AmpAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_383AmpAmp",  map { STD::Tight_and->coerce($_) } 
$C->_PATTERN(qr/\G\&\&/)
);
}


## tight or
## token infix__S_384VertVert (  :$sym is context<rw> = <||> --> Tight_or)
##      token infix:sym<||> ( --> Tight_or)
##          { <sym> }

sub infix__S_384VertVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_384VertVert',$retree) }
sub infix__S_384VertVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_384VertVert",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\|\|/)
);
}

## token infix__S_385CaretCaret (  :$sym is context<rw> = <^^> --> Tight_or)
##      token infix:sym<^^> ( --> Tight_or)
##          { <sym> }

sub infix__S_385CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_385CaretCaret',$retree) }
sub infix__S_385CaretCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_385CaretCaret",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\^\^/)
);
}

## token infix__S_386SlashSlash (  :$sym is context<rw> = <//> --> Tight_or)
##      token infix:sym<//> ( --> Tight_or)
##          { <sym> }

sub infix__S_386SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_386SlashSlash',$retree) }
sub infix__S_386SlashSlash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(//);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_386SlashSlash",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\/\//)
);
}

## token infix__S_387min (  :$sym is context<rw> = <min> --> Tight_or)
##      token infix:sym<min> ( --> Tight_or)
##          { <sym> }

sub infix__S_387min__PEEK { $_[0]->_AUTOLEXpeek('infix__S_387min',$retree) }
sub infix__S_387min {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(min);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_387min",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\Gmin/)
);
}

## token infix__S_388max (  :$sym is context<rw> = <max> --> Tight_or)
##      token infix:sym<max> ( --> Tight_or)
##          { <sym> }

sub infix__S_388max__PEEK { $_[0]->_AUTOLEXpeek('infix__S_388max',$retree) }
sub infix__S_388max {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(max);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_388max",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\Gmax/)
);
}


## conditional
## token infix__S_389QuestionQuestion_BangBang (  :$sym is context<rw> = <?? !!> --> Conditional)
##      token infix:sym<?? !!> ( --> Conditional) {
##          :my $GOAL is context = '!!';
##          '??'
##          <.ws>
##          <EXPR(item %item_assignment)>
##          [ '!!' ||
##              [
##              || <?before '='> <.panic: "Assignment not allowed within ??!!">
##              || <?before '::'> <.panic: "Please use !! rather than ::">
##              || <?before <infixish>>    # Note: a tight infix would have parsed right
##                  <.panic: "Precedence too loose within ??!!; use ??()!! instead ">
##              || <.panic: "Found ?? but no !!; possible precedence problem">
##              ]
##          ]
##      }

sub infix__S_389QuestionQuestion_BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_389QuestionQuestion_BangBang',$retree) }
sub infix__S_389QuestionQuestion_BangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(?? !!)];
local $::GOAL =  '!!';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_389QuestionQuestion_BangBang",  map { STD::Conditional->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('??'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('!!')} 
or
eval { push @gather, $C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
$C->panic("Assignment not allowed within ??!!");
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('::')
}))) {
$C->panic("Please use !! rather than ::");
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}))) {
$C->panic("Precedence too loose within ??!!; use ??()!! instead ");
}
else {
();
}
}} 
or
eval { push @gather, $C->panic("Found ?? but no !!; possible precedence problem")} or do { die $@ if $@ };
@gather;
}
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_390Question (  :$sym is context<rw> = <?> --> Conditional)
##      token infix:sym<?> ( --> Conditional)
##          { <sym> <.obs('?: for the conditional operator', '??!!')> }

sub infix__S_390Question__PEEK { $_[0]->_AUTOLEXpeek('infix__S_390Question',$retree) }
sub infix__S_390Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_390Question",  map { STD::Conditional->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->obs('?: for the conditional operator', '??!!');
}
else {
();
}
}
);
}

## token infix__S_391ff (  :$sym is context<rw> = <ff> --> Conditional)
##      token infix:sym<ff> ( --> Conditional)
##          { <sym> }

sub infix__S_391ff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_391ff',$retree) }
sub infix__S_391ff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_391ff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gff/)
);
}

## token infix__S_392Caretff (  :$sym is context<rw> = <^ff> --> Conditional)
##      token infix:sym<^ff> ( --> Conditional)
##          { <sym> }

sub infix__S_392Caretff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_392Caretff',$retree) }
sub infix__S_392Caretff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^ff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_392Caretff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^ff/)
);
}

## token infix__S_393ffCaret (  :$sym is context<rw> = <ff^> --> Conditional)
##      token infix:sym<ff^> ( --> Conditional)
##          { <sym> }

sub infix__S_393ffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_393ffCaret',$retree) }
sub infix__S_393ffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_393ffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gff\^/)
);
}

## token infix__S_394CaretffCaret (  :$sym is context<rw> = <^ff^> --> Conditional)
##      token infix:sym<^ff^> ( --> Conditional)
##          { <sym> }

sub infix__S_394CaretffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_394CaretffCaret',$retree) }
sub infix__S_394CaretffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^ff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_394CaretffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^ff\^/)
);
}

## token infix__S_395fff (  :$sym is context<rw> = <fff> --> Conditional)
##      token infix:sym<fff> ( --> Conditional)
##          { <sym> }

sub infix__S_395fff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_395fff',$retree) }
sub infix__S_395fff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(fff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_395fff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gfff/)
);
}

## token infix__S_396Caretfff (  :$sym is context<rw> = <^fff> --> Conditional)
##      token infix:sym<^fff> ( --> Conditional)
##          { <sym> }

sub infix__S_396Caretfff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_396Caretfff',$retree) }
sub infix__S_396Caretfff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^fff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_396Caretfff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^fff/)
);
}

## token infix__S_397fffCaret (  :$sym is context<rw> = <fff^> --> Conditional)
##      token infix:sym<fff^> ( --> Conditional)
##          { <sym> }

sub infix__S_397fffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_397fffCaret',$retree) }
sub infix__S_397fffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(fff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_397fffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gfff\^/)
);
}

## token infix__S_398CaretfffCaret (  :$sym is context<rw> = <^fff^> --> Conditional)
##      token infix:sym<^fff^> ( --> Conditional)
##          { <sym> }

sub infix__S_398CaretfffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_398CaretfffCaret',$retree) }
sub infix__S_398CaretfffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^fff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_398CaretfffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^fff\^/)
);
}

## assignment
# There is no "--> type" because assignment may be coerced to either
# item assignment or list assignment at "make" time.

## token infix__S_399Equal (:$sym is context<rw> = <=>)
##      token infix:sym<=> ()
##      {
##          <sym>
##          { $ = $*SIGIL eq '$' 
##              ?? ::Item_assignment.coerce($)
##              !! ::List_assignment.coerce($);
##          }
##      }

sub infix__S_399Equal__PEEK { $_[0]->_AUTOLEXpeek('infix__S_399Equal',$retree) }
sub infix__S_399Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_399Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
scalar(do {
$C = $::SIGIL eq '$' 
? 'STD::Item_assignment'->coerce($C)
: 'STD::List_assignment'->coerce($C);

}, $C);
}
else {
();
}
}
);
}

## token infix__S_400ColonEqual (  :$sym is context<rw> = <:=> --> Item_assignment)
##      token infix:sym<:=> ( --> Item_assignment)
##          { <sym> }

sub infix__S_400ColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_400ColonEqual',$retree) }
sub infix__S_400ColonEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_400ColonEqual",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\:\=/)
);
}

## token infix__S_401ColonColonEqual (  :$sym is context<rw> = <::=> --> Item_assignment)
##      token infix:sym<::=> ( --> Item_assignment)
##          { <sym> }

sub infix__S_401ColonColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_401ColonColonEqual',$retree) }
sub infix__S_401ColonColonEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_401ColonColonEqual",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\:\:\=/)
);
}

## token infix__S_402DotEqual (  :$sym is context<rw> = <.=> --> Item_assignment)
##      token infix:sym<.=> ( --> Item_assignment) {
##          <sym> <.ws>
##          [ <?before \w+';' | 'new'|'sort'|'subst'|'trans'|'reverse'|'uniq'|'map'|'samecase'|'substr'|'flip' > || <worryobs('.= as append operator', '~=')> ]
##          { $<O><nextterm> = 'dottyopish' }
##      }

sub infix__S_402DotEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_402DotEqual',$retree) }
sub infix__S_402DotEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_402DotEqual",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\=/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix__S_402DotEqual_02') {
$C->deb("Fate passed to infix__S_402DotEqual_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_402DotEqual_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_402DotEqual_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
$C->_EXACT(';');
}
else {
();
}
}
},
sub { my $C=shift;
$C->_EXACT('new')
},
sub { my $C=shift;
$C->_EXACT('sort')
},
sub { my $C=shift;
$C->_EXACT('subst')
},
sub { my $C=shift;
$C->_EXACT('trans')
},
sub { my $C=shift;
$C->_EXACT('reverse')
},
sub { my $C=shift;
$C->_EXACT('uniq')
},
sub { my $C=shift;
$C->_EXACT('map')
},
sub { my $C=shift;
$C->_EXACT('samecase')
},
sub { my $C=shift;
$C->_EXACT('substr')
},
sub { my $C=shift;
$C->_EXACT('flip')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} 
or
eval { push @gather, $C->_SUBSUMEr(['worryobs'], sub {
my $C = shift;
$C->worryobs('.= as append operator', '~=')
})} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{O}{nextterm} = 'dottyopish' ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_403EqualGt (  :$sym is context<rw> =  =>  --> Item_assignment)
##      token infix:sym =>  ( --> Item_assignment)
##          { <sym> { $<O><fiddly> = 0; } }

sub infix__S_403EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_403EqualGt',$retree) }
sub infix__S_403EqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['=>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_403EqualGt",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\>/))) {
scalar(do {
my $M = $C;  $M->{O}{fiddly} = 0; ;
}, $C);
}
else {
();
}
}
);
}

# Note, other assignment ops generated by infix_postfix_meta_operator rule

## loose unary
## token prefix__S_404true (  :$sym is context<rw> = <true> --> Loose_unary)
##      token prefix:sym<true> ( --> Loose_unary)
##          { <sym>  }

sub prefix__S_404true__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_404true',$retree) }
sub prefix__S_404true {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(true);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_404true",  map { STD::Loose_unary->coerce($_) } 
$C->_PATTERN(qr/\Gtrue\b/)
);
}

## token prefix__S_405not (  :$sym is context<rw> = <not> --> Loose_unary)
##      token prefix:sym<not> ( --> Loose_unary)
##          { <sym>  }

sub prefix__S_405not__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_405not',$retree) }
sub prefix__S_405not {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(not);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_405not",  map { STD::Loose_unary->coerce($_) } 
$C->_PATTERN(qr/\Gnot\b/)
);
}

## list item separator
## token infix__S_406Comma (  :$sym is context<rw> = <,> --> Comma)
##      token infix:sym<,> ( --> Comma)
##          { <sym> { $<O><fiddly> = 0; } }

sub infix__S_406Comma__PEEK { $_[0]->_AUTOLEXpeek('infix__S_406Comma',$retree) }
sub infix__S_406Comma {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[,];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_406Comma",  map { STD::Comma->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\,/))) {
scalar(do {
my $M = $C;  $M->{O}{fiddly} = 0; ;
}, $C);
}
else {
();
}
}
);
}

## token infix__S_407Colon (  :$sym is context<rw> = <:> --> Comma)
##      token infix:sym<:> ( --> Comma)
##          { <sym> <?before \s | <terminator> >
##              { $.panic("Illegal use of colon as invocant marker") unless $*INVOCANT_OK--; }
##          }

sub infix__S_407Colon__PEEK { $_[0]->_AUTOLEXpeek('infix__S_407Colon',$retree) }
sub infix__S_407Colon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_407Colon",  map { STD::Comma->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix__S_407Colon_01') {
$C->deb("Fate passed to infix__S_407Colon_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_407Colon_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_407Colon_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$C->panic("Illegal use of colon as invocant marker") unless $::INVOCANT_OK--; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_408p5EqualGt (  :$sym is context<rw> =  p5=>  --> Comma)
##      token infix:sym p5=>  ( --> Comma)
##          { <sym> }

sub infix__S_408p5EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_408p5EqualGt',$retree) }
sub infix__S_408p5EqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['p5=>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_408p5EqualGt",  map { STD::Comma->coerce($_) } 
$C->_PATTERN(qr/\Gp5\=\>/)
);
}

## token infix__S_409Z (  :$sym is context<rw> = <Z> --> List_infix)
##      token infix:sym<Z> ( --> List_infix)
##          { <sym> }

sub infix__S_409Z__PEEK { $_[0]->_AUTOLEXpeek('infix__S_409Z',$retree) }
sub infix__S_409Z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(Z);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_409Z",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\GZ/)
);
}

## token infix__S_410minmax (  :$sym is context<rw> = <minmax> --> List_infix)
##      token infix:sym<minmax> ( --> List_infix)
##          { <sym> }

sub infix__S_410minmax__PEEK { $_[0]->_AUTOLEXpeek('infix__S_410minmax',$retree) }
sub infix__S_410minmax {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(minmax);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_410minmax",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\Gminmax/)
);
}

## token infix__S_411DotDotDot (  :$sym is context<rw> = <...> --> List_infix)
##      token infix:sym<...> ( --> List_infix)
##          { <sym> }

sub infix__S_411DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_411DotDotDot',$retree) }
sub infix__S_411DotDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_411DotDotDot",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\G\.\.\./)
);
}

## token term__S_412DotDotDot (  :$sym is context<rw> = <...> --> List_prefix)
##      token term:sym<...> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_412DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('term__S_412DotDotDot',$retree) }
sub term__S_412DotDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{_pos};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_412DotDotDot",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\.\./))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_413QuestionQuestionQuestion (  :$sym is context<rw> = <???> --> List_prefix)
##      token term:sym<???> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_413QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('term__S_413QuestionQuestionQuestion',$retree) }
sub term__S_413QuestionQuestionQuestion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(???);


my $C = $self;
my $S = $C->{_pos};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_413QuestionQuestionQuestion",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\?\?/))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_414BangBangBang (  :$sym is context<rw> = <!!!> --> List_prefix)
##      token term:sym<!!!> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_414BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('term__S_414BangBangBang',$retree) }
sub term__S_414BangBangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!!);


my $C = $self;
my $S = $C->{_pos};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_414BangBangBang",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\!\!/))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

# token term:typecast ( --> List_prefix)
#     { <typename> <?spacey> <arglist> { $<sym> = $<typename>.Str; } }

# force identifier(), identifier.(), etc. to be a function call always
## token term__S_415identifier (  :$sym is context<rw> = 'identifier' --> Term )
##      token term:identifier ( --> Term )
##      {
##          :my $name;
##          :my $pos;
##          <identifier> <?before [<unsp>|'(']? >
##          { $name = $<identifier>.Str; $pos = $.pos; }
##          <args( $.is_name($name) )>
##          { self.add_mystery($name,$pos) unless $<args><invocant>; }
##      }

sub term__S_415identifier__PEEK { $_[0]->_AUTOLEXpeek('term__S_415identifier',$retree) }
sub term__S_415identifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'identifier';
my $name;
my $pos;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_415identifier",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'term__S_415identifier_02') {
$C->deb("Fate passed to term__S_415identifier_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_415identifier_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_415identifier_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $name = $M->{identifier}->Str; $pos = $C->{_pos}; ;
}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args( $C->is_name($name) )
}))) {
scalar(do {
my $M = $C;  $self->add_mystery($name,$pos) unless $M->{args}{invocant}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_416opfunc (  :$sym is context<rw> = 'opfunc' --> Term )
##      token term:opfunc ( --> Term )
##      {
##          <category> <colonpair>+ <args>
##      }

sub term__S_416opfunc__PEEK { $_[0]->_AUTOLEXpeek('term__S_416opfunc',$retree) }
sub term__S_416opfunc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'opfunc';


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_416opfunc",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token args ($istype = 0)
##      token args ($istype = 0) {
##          :my $listopish = 0;
##          :my $GOAL is context = '';
##          :my $INVOCANT_OK is context<rw> = 1;
##          :my $INVOCANT_IS is context<rw>;
##          [
##      #    | :dba('argument list') '.(' ~ ')' <semiarglist> {*}             #= func args
##          | :dba('argument list') '(' ~ ')' <semiarglist> {*}              #= func args
##          | :dba('argument list') <.unsp> '(' ~ ')' <semiarglist> {*} #= func args
##          |  { $listopish = 1 } [<?before \s> <!{ $istype }> <.ws> <!infixstopper> <arglist>]?
##          ]
##          { $<invocant> = $*INVOCANT_IS; }
##      
##          :dba('extra arglist after (...):')
##          [
##          || <?{ $listopish }>
##          || ':' <?before \s> <moreargs=arglist>    # either switch to listopiness
##          || {{ $<O> = {}; }}   # or allow adverbs (XXX needs hoisting?)
##          ]
##      }

sub args__PEEK { $_[0]->_AUTOLEXpeek('args',$retree) }
sub args {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $istype = shift() // 0;
my $listopish = 0;
local $::GOAL =  '';
local $::INVOCANT_OK =  1;
local $::INVOCANT_IS;


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];

$self->_MATCHIFY($S, "args", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$listopish 
})
})} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['moreargs'], sub {
my $C = shift;
$C->arglist
})
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
}, $C->_EXACT(':'))} 
or
eval { push @gather, scalar(do {
my $M = $C;  $M->{O} = {}; ;
}, $C)} or do { die $@ if $@ };
@gather;
}
})
}, scalar(do {
my $M = $C;  $M->{invocant} = $::INVOCANT_IS; ;
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'args_01') {
$C->deb("Fate passed to args_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'args_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("args_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args_func_args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args_func_args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
}, $C->unsp)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['arglist'], sub {
my $C = shift;
$C->arglist
})
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))
}, $C->ws)
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$istype 
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
})
})
}, scalar(do {
$listopish = 1 
}, $C))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

# names containing :: may or may not be function calls
# bare identifier without parens also handled here if no other rule parses it
## token term__S_417name (  :$sym is context<rw> = 'name' --> Term)
##      token term:name ( --> Term)
##      {
##          :my $name;
##          :my $pos;
##          <longname>
##          {
##              $name = $<longname>.Str;
##              $pos = $.pos;
##          }
##          [
##          ||  <?{
##                  $.is_name($<longname>.Str) or substr($<longname>.Str,0,2) eq '::'
##              }>
##              # parametric type?
##              <.unsp>? [ <?before '['> <postcircumfix> ]?
##              :dba('type parameter')
##              [
##                  '::'
##                  <?before [ '' | '<' | '{' | '<<' ] > <postcircumfix>
##                  {*}                                                 #= packagevar 
##              ]?
##              {*}                                                     #= typename
##      
##          # unrecognized names are assumed to be post-declared listops.
##          || <args> { self.add_mystery($name,$pos) unless $<args><invocant>; }
##          ]
##      }

sub term__S_417name__PEEK { $_[0]->_AUTOLEXpeek('term__S_417name',$retree) }
sub term__S_417name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'name';
my $name;
my $pos;


my $C = $self;
my $S = $C->{_pos};
$C->{'postcircumfix'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_417name",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$name = $M->{longname}->Str;
$pos = $C->{_pos};
;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
$C->is_name($M->{longname}->Str) or substr($M->{longname}->Str,0,2) eq '::'
;
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'term__S_417name_06') {
$C->deb("Fate passed to term__S_417name_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_417name_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_417name_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->_REDUCE($S, 'term__S_417name_packagevar_');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_REDUCE($S, 'term__S_417name_typename');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
}))) {
scalar(do {
my $M = $C;  $self->add_mystery($name,$pos) unless $M->{args}{invocant}; ;
}, $C);
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## loose and
## token infix__S_418and (  :$sym is context<rw> = <and> --> Loose_and)
##      token infix:sym<and> ( --> Loose_and)
##          { <sym> }

sub infix__S_418and__PEEK { $_[0]->_AUTOLEXpeek('infix__S_418and',$retree) }
sub infix__S_418and {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(and);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_418and",  map { STD::Loose_and->coerce($_) } 
$C->_PATTERN(qr/\Gand/)
);
}

## token infix__S_419andthen (  :$sym is context<rw> = <andthen> --> Loose_and)
##      token infix:sym<andthen> ( --> Loose_and)
##          { <sym> }

sub infix__S_419andthen__PEEK { $_[0]->_AUTOLEXpeek('infix__S_419andthen',$retree) }
sub infix__S_419andthen {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(andthen);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_419andthen",  map { STD::Loose_and->coerce($_) } 
$C->_PATTERN(qr/\Gandthen/)
);
}

## loose or
## token infix__S_420or (  :$sym is context<rw> = <or> --> Loose_or)
##      token infix:sym<or> ( --> Loose_or)
##          { <sym> }

sub infix__S_420or__PEEK { $_[0]->_AUTOLEXpeek('infix__S_420or',$retree) }
sub infix__S_420or {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(or);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_420or",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gor/)
);
}

## token infix__S_421orelse (  :$sym is context<rw> = <orelse> --> Loose_or)
##      token infix:sym<orelse> ( --> Loose_or)
##          { <sym> }

sub infix__S_421orelse__PEEK { $_[0]->_AUTOLEXpeek('infix__S_421orelse',$retree) }
sub infix__S_421orelse {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(orelse);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_421orelse",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gorelse/)
);
}

## token infix__S_422xor (  :$sym is context<rw> = <xor> --> Loose_or)
##      token infix:sym<xor> ( --> Loose_or)
##          { <sym> }

sub infix__S_422xor__PEEK { $_[0]->_AUTOLEXpeek('infix__S_422xor',$retree) }
sub infix__S_422xor {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(xor);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_422xor",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gxor/)
);
}

## sequencer
## token infix__S_423LtEqualEqual (  :$sym is context<rw> =  <==  --> Sequencer)
##      token infix:sym <==  ( --> Sequencer)
##          { <sym> }

sub infix__S_423LtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_423LtEqualEqual',$retree) }
sub infix__S_423LtEqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<=='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_423LtEqualEqual",  map { STD::Sequencer->coerce($_) } 
$C->_PATTERN(qr/\G\<\=\=/)
);
}

## token infix__S_424EqualEqualGt (  :$sym is context<rw> =  ==>  --> Sequencer)
##      token infix:sym ==>  ( --> Sequencer)
##          { <sym> {*} }

sub infix__S_424EqualEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_424EqualEqualGt',$retree) }
sub infix__S_424EqualEqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['==>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_424EqualEqualGt",  map { STD::Sequencer->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>/))) {
$C->_REDUCE($S, 'infix__S_424EqualEqualGt');
}
else {
();
}
}
);
}              #'

## token infix__S_425LtLtEqualEqual (  :$sym is context<rw> =  <<==  --> Sequencer)
##      token infix:sym <<==  ( --> Sequencer)
##          { <sym> }

sub infix__S_425LtLtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_425LtLtEqualEqual',$retree) }
sub infix__S_425LtLtEqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<=='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_425LtLtEqualEqual",  map { STD::Sequencer->coerce($_) } 
$C->_PATTERN(qr/\G\<\<\=\=/)
);
}

## token infix__S_426EqualEqualGtGt (  :$sym is context<rw> =  ==>>  --> Sequencer)
##      token infix:sym ==>>  ( --> Sequencer)
##          { <sym> {*} }

sub infix__S_426EqualEqualGtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_426EqualEqualGtGt',$retree) }
sub infix__S_426EqualEqualGtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['==>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_426EqualEqualGtGt",  map { STD::Sequencer->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>\>/))) {
$C->_REDUCE($S, 'infix__S_426EqualEqualGtGt');
}
else {
();
}
}
);
}              #'

## expression terminator
# Note: must always be called as <?terminator> or <?before ...<terminator>...>

## token terminator__S_427Semi (  :$sym is context<rw> = <;> --> Terminator)
##      token terminator:sym<;> ( --> Terminator)
##          { ';' }

sub terminator__S_427Semi__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_427Semi',$retree) }
sub terminator__S_427Semi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(;);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_427Semi",  map { STD::Terminator->coerce($_) } 
$C->_EXACT(';')
);
}

## token terminator__S_428if (  :$sym is context<rw> = <if> --> Terminator)
##      token terminator:sym<if> ( --> Terminator)
##          { 'if'  <.nofun> }

sub terminator__S_428if__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_428if',$retree) }
sub terminator__S_428if {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(if);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_428if",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('if'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_429unless (  :$sym is context<rw> = <unless> --> Terminator)
##      token terminator:sym<unless> ( --> Terminator)
##          { 'unless'  <.nofun> }

sub terminator__S_429unless__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_429unless',$retree) }
sub terminator__S_429unless {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(unless);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_429unless",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('unless'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_430while (  :$sym is context<rw> = <while> --> Terminator)
##      token terminator:sym<while> ( --> Terminator)
##          { 'while'  <.nofun> }

sub terminator__S_430while__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_430while',$retree) }
sub terminator__S_430while {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(while);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_430while",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('while'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_431until (  :$sym is context<rw> = <until> --> Terminator)
##      token terminator:sym<until> ( --> Terminator)
##          { 'until'  <.nofun> }

sub terminator__S_431until__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_431until',$retree) }
sub terminator__S_431until {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(until);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_431until",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('until'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_432for (  :$sym is context<rw> = <for> --> Terminator)
##      token terminator:sym<for> ( --> Terminator)
##          { 'for'  <.nofun> }

sub terminator__S_432for__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_432for',$retree) }
sub terminator__S_432for {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(for);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_432for",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('for'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_433given (  :$sym is context<rw> = <given> --> Terminator)
##      token terminator:sym<given> ( --> Terminator)
##          { 'given'  <.nofun> }

sub terminator__S_433given__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_433given',$retree) }
sub terminator__S_433given {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(given);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_433given",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('given'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_434when (  :$sym is context<rw> = <when> --> Terminator)
##      token terminator:sym<when> ( --> Terminator)
##          { 'when'  <.nofun> }

sub terminator__S_434when__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_434when',$retree) }
sub terminator__S_434when {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(when);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_434when",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('when'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_435MinusMinusGt (  :$sym is context<rw> =  -->  --> Terminator)
##      token terminator:sym -->  ( --> Terminator)
##          { '-->' {*} }

sub terminator__S_435MinusMinusGt__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_435MinusMinusGt',$retree) }
sub terminator__S_435MinusMinusGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['-->'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_435MinusMinusGt",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('-->'))) {
$C->_REDUCE($S, 'terminator__S_435MinusMinusGt');
}
else {
();
}
}
);
}              #'

## token terminator__S_436Thesis (  :$sym is context<rw> = <)> --> Terminator)
##      token terminator:sym<)> ( --> Terminator)
##          { <sym> }

sub terminator__S_436Thesis__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_436Thesis',$retree) }
sub terminator__S_436Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_436Thesis",  map { STD::Terminator->coerce($_) } 
$C->_PATTERN(qr/\G\)/)
);
}

## token terminator__S_437Ket (  :$sym is context<rw> = <]> --> Terminator)
##      token terminator:sym<]> ( --> Terminator)
##          { ']' }

sub terminator__S_437Ket__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_437Ket',$retree) }
sub terminator__S_437Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(]);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_437Ket",  map { STD::Terminator->coerce($_) } 
$C->_EXACT(']')
);
}

## token terminator__S_438Ly (  :$sym is context<rw> = <}> --> Terminator)
##      token terminator:sym<}> ( --> Terminator)
##          { '}' }

sub terminator__S_438Ly__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_438Ly',$retree) }
sub terminator__S_438Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(});


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_438Ly",  map { STD::Terminator->coerce($_) } 
$C->_EXACT('}')
);
}

## token terminator__S_439BangBang (  :$sym is context<rw> = <!!> --> Terminator)
##      token terminator:sym<!!> ( --> Terminator)
##          { '!!' <?{ $*GOAL eq '!!' }> }

sub terminator__S_439BangBang__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_439BangBang',$retree) }
sub terminator__S_439BangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_439BangBang",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('!!'))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
});
}
else {
();
}
}
);
}

# disallow &[] and such as infix
# token infix:sigil ( --> Term )
#     { <sigil><-[&]> <.worry: "Sigiled form not allowed where infix expected"> <!> }

## regex infixstopper
##      regex infixstopper {
##          :dba('infix stopper')
##          [
##          | <?before <stopper> >
##          | <?before '!!' > <?{ $*GOAL eq '!!' }>
##          | <?before '{' | <lambda> > <?{ ($*GOAL eq '{' or $*GOAL eq 'endargs') and @*MEMOS[$.pos]<ws> }>
##          | <?{ $*GOAL eq 'endargs' and @*MEMOS[$.pos]<endargs> }>
##          ]
##      }

sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper',$retree) }
sub infixstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "infixstopper", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infixstopper_01') {
$C->deb("Fate passed to infixstopper_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
})
}, $C->before(sub { my $C=shift;
$C->_EXACT('!!')
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
($::GOAL eq '{' or $::GOAL eq 'endargs') and $::MEMOS[$C->{_pos}]{'ws'} 
})
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infixstopper_04') {
$C->deb("Fate passed to infixstopper_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixstopper_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_SUBSUME(['lambda'], sub {
my $C = shift;
$C->lambda
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq 'endargs' and $::MEMOS[$C->{_pos}]{'endargs'} 
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# overridden in subgrammars
## token stopper
##      token stopper { <!> }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

# hopefully we can include these tokens in any outer LTM matcher
## regex stdstopper
##      regex stdstopper {
##          :my @stub = return self if @*MEMOS[self.pos]<endstmt> :exists;
##          :dba('standard stopper')
##          [
##          | <?terminator>
##          | <?unitstopper>
##          | $                                 # unlikely, check last (normal LTM behavior)
##          ]
##          { @*MEMOS[$.pos]<endstmt> ||= 1; }
##      }

sub stdstopper__PEEK { $_[0]->_AUTOLEXpeek('stdstopper',$retree) }
sub stdstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $::MEMOS[$self->{_pos}]{'endstmt'};


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "stdstopper", 
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$::MEMOS[$C->{_pos}]{'endstmt'} ||= 1; 
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'stdstopper_01') {
$C->deb("Fate passed to stdstopper_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'stdstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("stdstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->terminator
})
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->unitstopper
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

# A fairly complete operator precedence parser

## method EXPR ($preclvl)
sub EXPR {
my $self = shift;
my $preclvl = shift;


local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
if ($self->peek) {
return $self->_AUTOLEXpeek('EXPR');
}
my $preclim = $preclvl ? $preclvl->{'prec'} // $LOOSEST : $LOOSEST;
local $::SIGIL =  '';
my @termstack;
my @opstack;
my $termish = 'termish';

push @opstack, { 'O' => \%terminator, 'sym' => '' };         # (just a sentinel value)

my $here = $self;
my $S = $here->{_pos};
$self->deb("In EXPR, at $S") if $::DEBUG & DEBUG::EXPR;

my $reduce = sub {
$self->deb("entering reduce, termstack == ", 0+@termstack, " opstack == ", 0+@opstack) if $::DEBUG & DEBUG::EXPR;
my $op = pop @opstack;
my $sym = $op->{sym};
do { my $_ = $op->{O}{assoc} // 'unary'; if ((0)) {}
elsif ($_ eq 'chain') {
$self->deb("reducing chain") if $::DEBUG & DEBUG::EXPR;
my @chain;
push @chain, pop(@termstack);
push @chain, $op;
while (@opstack) {
last if $op->{O}{prec} ne $opstack[-1]{'O'}{'prec'};
push @chain, pop(@termstack);
push @chain, pop(@opstack);
}
push @chain, pop(@termstack);
my $endpos = $chain[0]{'_pos'};
@chain = reverse @chain if @chain > 1;
my $startpos = $chain[0]{'_from'};
my $nop = $op->cursor_fresh();
$nop->{chain} = [@chain];
$nop->{_arity} = 'CHAIN';
$nop->{_from} = $startpos;
$nop->{_pos} = $endpos;
push @termstack, $nop->_REDUCE($startpos, 'EXPR');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
elsif ($_ eq 'list') {
$self->deb("reducing list") if $::DEBUG & DEBUG::EXPR;
my @list;
my @delims = $op;
push @list, pop(@termstack);
while (@opstack) {
$self->deb($sym . " vs " . $opstack[-1]{'sym'}) if $::DEBUG & DEBUG::EXPR;
last if $sym ne $opstack[-1]{'sym'};
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
else {
$self->worry("Missing term in " . $sym . " list");
}
push @delims, pop(@opstack);
}
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
else {
$self->worry("Missing final term in '" . $sym . "' list");
}
my $endpos = $list[0]{'_pos'};
@list = reverse @list if @list > 1;
my $startpos = $list[0]{'_from'};
@delims = reverse @delims if @delims > 1;
my $nop = $op->cursor_fresh();
$nop->{sym} = $sym;
$nop->{O} = $op->{O};
$nop->{list} = [@list];
$nop->{delims} = [@delims];
$nop->{_arity} = 'LIST';
$nop->{_from} = $startpos;
$nop->{_pos} = $endpos;
if (@list) {
my @caps;
push @caps, $list[0]->caps if $list[0];
for (0..@delims-1) {
my $d = $delims[$_];
my $l = $list[$_+1];
my @d = $d->caps;
my @l = $l->caps if $l and exists $l->{_pos} ;
push @caps, @d;
push @caps, @l;  # nullterm?
}
$nop->{'~CAPS'} = \@caps;
}
push @termstack, $nop->_REDUCE($startpos, 'EXPR');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
elsif ($_ eq 'unary') {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
my $nop = $op->cursor_fresh();
my $arg = pop @termstack;
$op->{arg} = $arg;
my $a = $op->{'~CAPS'};
if (($arg->{_from} < $op->{_from})) { # postfix
$op->{_from} = $arg->{_from};   # extend ->from to include arg
my @acaps = $arg->caps;
#                    warn "OOPS ", $arg.Str, "\n" if @acaps > 1;
unshift @$a, @acaps;
}
elsif (($arg->{_pos} > $op->{_pos})) {   # prefix
$op->{_pos} = $arg->{_pos};     # extend ->to to include arg
my @acaps = $arg->caps;
#                    warn "OOPS ", $arg.Str, "\n" if @acaps > 1;
push @$a, @acaps;
}
$op->{_arity} = 'UNARY';
push @termstack, $op->_REDUCE($op->{_from}, 'EXPR');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
else {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

my $right = pop @termstack;
my $left = pop @termstack;
$op->{right} = $right;
$op->{left} = $left;
$op->{_from} = $left->{_from};
$op->{_pos} = $right->{_pos};
$op->{_arity} = 'BINARY';

my $a = $op->{'~CAPS'};
unshift @$a, $left->caps;
push @$a, $right->caps;

$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
push @termstack, $op->_REDUCE($op->{_from}, 'EXPR');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
};
};

TERM:
for (;;) {
$self->deb("In loop, at ", $here->{_pos}) if $::DEBUG & DEBUG::EXPR;
my $oldpos = $here->{_pos};
$here = $here->cursor_fresh();
$::SIGIL = $opstack[-1]{'O'}{'prec'} gt $item_assignment_prec ? '@' : '';
my @t = $here->$termish;

if (not @t or not $here = $t[0] or ($here->{_pos} == $oldpos and $termish eq 'termish')) {
return ();
# $here->panic("Failed to parse a required term");
}
$termish = 'termish';
my $PRE = delete $here->{'PRE'} // [];
my $POST = delete $here->{'POST'} // [];
my @PRE = @$PRE;
my @POST = reverse @$POST;

# interleave prefix and postfix, pretend they're infixish
my $M = $here;

# note that we push loose stuff onto opstack before tight stuff
while (@PRE and @POST) {
my $postO = $POST[0]{'O'};
my $preO = $PRE[0]{'O'};
if ($postO->{prec} lt $preO->{prec}) {
push @opstack, shift @POST;
}
elsif ($postO->{prec} gt $preO->{prec}) {
push @opstack, shift @PRE;
}
elsif ($postO->{uassoc} eq 'left') {
push @opstack, shift @POST;
}
elsif ($postO->{uassoc} eq 'right') {
push @opstack, shift @PRE;
}
else {
$here->panic('"' . $PRE[0]{'sym'} . '" and "' . $POST[0]{'sym'} . '" are not associative');
}
}
push @opstack, @PRE,@POST;

push @termstack, $here->{'noun'};
delete $termstack[-1]->{'POST'};
$self->deb("after push: " . (0+@termstack)) if $::DEBUG & DEBUG::EXPR;

for (;;) {     # while we see adverbs
$oldpos = $here->{_pos};
last TERM if ($::MEMOS[$oldpos]{'endstmt'} // 0) == 2;
$here = $here->cursor_fresh->ws;
my @infix = $here->cursor_fresh->infixish();
last TERM unless @infix;
my $infix = $infix[0];
last TERM unless $infix->{_pos} > $oldpos;

if (not $infix->{sym}) {
die $infix->dump if $::DEBUG & DEBUG::EXPR;
}

my $inO = $infix->{O};
my $inprec = $inO->{prec};
if (not defined $inprec) {
$self->deb("No prec given in infix!") if $::DEBUG & DEBUG::EXPR;
die $infix->dump if $::DEBUG & DEBUG::EXPR;
$inprec = $terminator{prec};
}

if ($inprec le $preclim) {
if ($preclim ne $LOOSEST) {
my $dba = $preclvl->{'dba'};
my $h = $::HIGHEXPECT;
my $k = 'infix or meta-infix';
delete $h->{$k};
$h->{"infix or meta-infix (with precedence tighter than $dba)"} = 1;
};
last TERM;
}

$here = $infix->cursor_fresh->ws();

# substitute precedence for listops
$inO->{prec} = $inO->{sub} if $inO->{sub};

# Does new infix (or terminator) force any reductions?
while ($opstack[-1]{'O'}{'prec'} gt $inprec) {
$reduce->();
}

# Not much point in reducing the sentinels...
last if $inprec lt $LOOSEST;

if ($infix->{fake}) {
my $adverbs = $termstack[-1]{'ADV'} ||= [];
push @$adverbs, $infix->{colonpair};
next;  # not really an infix, so keep trying
}

# Equal precedence, so use associativity to decide.
if ($opstack[-1]{'O'}{'prec'} eq $inprec) {
do { my $_ = $inO->{assoc}; if ((0)) {}
elsif ($_ eq 'non') { $here->panic('"' . $infix->Str . '" is not associative') }
elsif ($_ eq 'left') { $reduce->() }   # reduce immediately
elsif ($_ eq 'right') { }            # just shift
elsif ($_ eq 'chain') { }            # just shift
elsif ($_ eq 'unary') { }            # just shift
elsif ($_ eq 'list') {              # if op differs reduce else shift
# $reduce->() if $infix->{sym} ne $opstack[-1]{'sym'};
}
else { $here->panic('Unknown associativity "' . $_ . '" for "' . $infix->{sym} . '"') }
};
}

$termish = $inO->{nextterm} if $inO->{nextterm};
push @opstack, $infix;              # The Shift
last;
}
}
$reduce->() while 0+@opstack > 1;
if (@termstack) {
0+@termstack == 1 or $here->panic("Internal operator parser error, termstack == " . (+@termstack));
$termstack[0]{'_from'} = $self->{_pos};
$termstack[0]{'_pos'} = $here->{_pos};
}
$self->_MATCHIFYr($S, "EXPR", @termstack);
}

#################################################
## Regex
#################################################

{ package STD::Regex;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'Perl5' or $k eq 'P5') {
my $P5 = $v;  $self->cursor_fresh( 'STD::Q' )->mixin( 'STD::Q::q' )->mixin( 'STD::Q::p5' ) }
elsif ($k eq 'overlap' or $k eq 'ov') {
my $ov = $v;  $self }
elsif ($k eq 'exhaustive' or $k eq 'ex') {
my $ex = $v;  $self }
elsif ($k eq 'continue' or $k eq 'c') {
my $c = $v;  $self }
elsif ($k eq 'pos' or $k eq 'p') {
my $p = $v;  $self }
elsif ($k eq 'sigspace' or $k eq 's') {
my $s = $v;  $self }
elsif ($k eq 'ratchet' or $k eq 'r') {
my $r = $v;  $self }
elsif ($k eq 'global' or $k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'ignorecase' or $k eq 'i') {
my $i = $v;  $self }
elsif ($k eq 'ignoreaccent' or $k eq 'a') {
my $a = $v;  $self }
elsif ($k eq 'samecase' or $k eq 'ii') {
my $ii = $v;  $self }
elsif ($k eq 'sameaccent' or $k eq 'aa') {
my $aa = $v;  $self }
elsif ($k eq 'nth') {
my $nth = $v;  $self }
elsif ($k eq 'st' or $k eq 'nd') {
my $nd = $v;  $self }
elsif ($k eq 'rd' or $k eq 'th') {
my $th = $v;  $self }
elsif ($k eq 'x') {
my $x = $v;  $self }
elsif ($k eq 'bytes') {
my $bytes = $v;  $self }
elsif ($k eq 'codes') {
my $codes = $v;  $self }
elsif ($k eq 'graphs') {
my $graphs = $v;  $self }
elsif ($k eq 'chars') {
my $chars = $v;  $self }
elsif ($k eq 'rw') {
my $rw = $v;  $self->panic(":rw not implemented") }
elsif ($k eq 'keepall') {
my $keepall = $v;  $self->panic(":keepall not implemented") }
elsif ($k eq 'panic') {
my $panic = $v;  $self->panic(":panic not implemented") }
else { die 'NOMATCH' }
} # end tweaks

##     token category__S_440metachar (:$sym is context<rw> = 'metachar')
##          token category:metachar { <sym> }

sub category__S_440metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_440metachar',$retree) }
sub category__S_440metachar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'metachar';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_440metachar", 
$C->_PATTERN(qr/\Gmetachar/)
);
}
#proto token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "metachar", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_441backslash (:$sym is context<rw> = 'backslash')
##          token category:backslash { <sym> }

sub category__S_441backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_441backslash',$retree) }
sub category__S_441backslash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'backslash';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_441backslash", 
$C->_PATTERN(qr/\Gbackslash/)
);
}
#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_442assertion (:$sym is context<rw> = 'assertion')
##          token category:assertion { <sym> }

sub category__S_442assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_442assertion',$retree) }
sub category__S_442assertion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'assertion';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_442assertion", 
$C->_PATTERN(qr/\Gassertion/)
);
}
#proto token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "assertion", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_443quantifier (:$sym is context<rw> = 'quantifier')
##          token category:quantifier { <sym> }

sub category__S_443quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_443quantifier',$retree) }
sub category__S_443quantifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quantifier';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_443quantifier", 
$C->_PATTERN(qr/\Gquantifier/)
);
}
#proto token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quantifier", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_444mod_internal (:$sym is context<rw> = 'mod_internal')
##          token category:mod_internal { <sym> }

sub category__S_444mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_444mod_internal',$retree) }
sub category__S_444mod_internal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod_internal';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_444mod_internal", 
$C->_PATTERN(qr/\Gmod_internal/)
);
}
#proto token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "mod_internal", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


#proto token rxinfix { <...> }
sub rxinfix__PEEK { $_[0]->_AUTOLEXpeek('rxinfix:*',$retree); }
sub rxinfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'rxinfix') {
$C->deb("Fate passed to rxinfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'rxinfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("rxinfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "rxinfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token ws
##          token ws {
##              <?{ $*sigspace }>
##              || [ <?before \s | '#'> <.nextsame> ]?   # still get all the pod goodness, hopefully
##          }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
my @origargs = @_;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "ws", 
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$::sigspace 
})
})} 
or
eval { push @gather, $C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'ws_03') {
$C->deb("Fate passed to ws_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'ws_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$self->SUPER::ws(@origargs);
}
else {
();
}
}
})
})} or do { die $@ if $@ };
@gather;
}
);
}

##     token normspace
##          token normspace {
##              <?before \s | '#'> [ :lang($.cursor_fresh($*LANG)) <.ws> ]
##          }

sub normspace__PEEK { $_[0]->_AUTOLEXpeek('normspace',$retree) }
sub normspace {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "normspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'normspace_01') {
$C->deb("Fate passed to normspace_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'normspace_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("normspace_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->ws
});
}
else {
();
}
}
);
}

# suppress fancy end-of-line checking
##     token codeblock
##          token codeblock {
##              :my $GOAL is context = '}';
##              '{' :: [ :lang($.cursor_fresh($*LANG)) <statementlist> ]
##              [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
##          }

sub codeblock__PEEK { $_[0]->_AUTOLEXpeek('codeblock',$retree) }
sub codeblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL =  '}';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "codeblock", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->panic("Unable to parse statement list; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
);
}

##     rule nibbler
##          rule nibbler {
##              :my $sigspace    is context<rw> = $*sigspace    // 0;
##              :my $ratchet     is context<rw> = $*ratchet     // 0;
##              :my $ignorecase is context<rw> = $*ignorecase // 0;
##              :my $ignoreaccent    is context<rw> = $*ignoreaccent    // 0;
##              [ \s* < || | && & > ]?
##              <EXPR>
##          }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::sigspace =  $::sigspace    // 0;
local $::ratchet =  $::ratchet     // 0;
local $::ignorecase =  $::ignorecase // 0;
local $::ignoreaccent =  $::ignoreaccent    // 0;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_ARRAY( qw< || | && & > ))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token termish
##          token termish {
##              <.ws>
##              <noun=quantified_atom>+
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantified_atom'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->ws)) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['noun','quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
});
}
else {
();
}
}
);
}
##     token infixish
##          token infixish {
##              <!infixstopper>
##              <!stdstopper>
##              <rxinfix>
##              {
##                  $<O> = $<rxinfix><O>;
##                  $<sym> = $<rxinfix><sym>;
##              }
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rxinfix'], sub {
my $C = shift;
$C->rxinfix
}))) {
scalar(do {
my $M = $C; 
$M->{O} = $M->{rxinfix}{O};
$M->{sym} = $M->{rxinfix}{sym};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token rxinfix__S_445VertVert (  :$sym is context<rw> = <||> --> Tight_or )
##          token rxinfix:sym<||> ( --> Tight_or ) { <sym> }

sub rxinfix__S_445VertVert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_445VertVert',$retree) }
sub rxinfix__S_445VertVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_445VertVert",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\|\|/)
);
}
##     token rxinfix__S_446AmpAmp (  :$sym is context<rw> = <&&> --> Tight_and )
##          token rxinfix:sym<&&> ( --> Tight_and ) { <sym> }

sub rxinfix__S_446AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_446AmpAmp',$retree) }
sub rxinfix__S_446AmpAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_446AmpAmp",  map { STD::Tight_and->coerce($_) } 
$C->_PATTERN(qr/\G\&\&/)
);
}
##     token rxinfix__S_447Vert (  :$sym is context<rw> = <|> --> Junctive_or )
##          token rxinfix:sym<|> ( --> Junctive_or ) { <sym> }

sub rxinfix__S_447Vert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_447Vert',$retree) }
sub rxinfix__S_447Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_447Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}
##     token rxinfix__S_448Amp (  :$sym is context<rw> = <&> --> Junctive_and )
##          token rxinfix:sym<&> ( --> Junctive_and ) { <sym> }

sub rxinfix__S_448Amp__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_448Amp',$retree) }
sub rxinfix__S_448Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_448Amp",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\G\&/)
);
}
##     token rxinfix__S_449Tilde (  :$sym is context<rw> = <~> --> Additive )
##          token rxinfix:sym<~> ( --> Additive ) { <sym> }

sub rxinfix__S_449Tilde__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_449Tilde',$retree) }
sub rxinfix__S_449Tilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_449Tilde",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}

##     token quantified_atom
##          token quantified_atom {
##              <!stopper>
##              <!rxinfix>
##              <atom>
##              <.ws>
##              [ <quantifier> <.ws> ]?
##      #            <?{ $<atom>.max_width }>
##      #                || <.panic: "Can't quantify zero-width atom">
##          }

sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom',$retree) }
sub quantified_atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantifier'} = [];

$self->_MATCHIFYr($S, "quantified_atom", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->rxinfix
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->ws;
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token atom
##          token atom {
##              :dba('regex atom')
##              [
##              | \w
##              | <metachar> ::
##              | <.panic: "Unrecognized regex metacharacter">
##              ]
##          }

sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom',$retree) }
sub atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "atom", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'atom_01') {
$C->deb("Fate passed to atom_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'atom_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("atom_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_COMMITBRANCH()
}, $C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
}))
},
sub { my $C=shift;
$C->panic("Unrecognized regex metacharacter")
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# sequence stoppers
##     token metachar__S_450Gt (:$sym is context<rw> =  > )
##          token metachar:sym >  { '>'  :: <fail> }

sub metachar__S_450Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_450Gt',$retree) }
sub metachar__S_450Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_450Gt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('>'))
);
}
##     token metachar__S_451AmpAmp (:$sym is context<rw> = <&&>)
##          token metachar:sym<&&>  { '&&' :: <fail> }

sub metachar__S_451AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_451AmpAmp',$retree) }
sub metachar__S_451AmpAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_451AmpAmp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('&&'))
);
}
##     token metachar__S_452Amp (:$sym is context<rw> = <&>)
##          token metachar:sym<&>   { '&'  :: <fail> }

sub metachar__S_452Amp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_452Amp',$retree) }
sub metachar__S_452Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_452Amp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('&'))
);
}
##     token metachar__S_453VertVert (:$sym is context<rw> = <||>)
##          token metachar:sym<||>  { '||' :: <fail> }

sub metachar__S_453VertVert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_453VertVert',$retree) }
sub metachar__S_453VertVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_453VertVert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('||'))
);
}
##     token metachar__S_454Vert (:$sym is context<rw> = <|>)
##          token metachar:sym<|>   { '|'  :: <fail> }

sub metachar__S_454Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_454Vert',$retree) }
sub metachar__S_454Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_454Vert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('|'))
);
}
##     token metachar__S_455Ket (:$sym is context<rw> = <]>)
##          token metachar:sym<]>   { ']'  :: <fail> }

sub metachar__S_455Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_455Ket',$retree) }
sub metachar__S_455Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(]);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_455Ket", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(']'))
);
}
##     token metachar__S_456Thesis (:$sym is context<rw> = <)>)
##          token metachar:sym<)>   { ')'  :: <fail> }

sub metachar__S_456Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_456Thesis',$retree) }
sub metachar__S_456Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_456Thesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(')'))
);
}

##     token metachar__S_457quant (:$sym is context<rw> = 'quant')
##          token metachar:quant { <quantifier> <.panic: "quantifier quantifies nothing"> }

sub metachar__S_457quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_457quant',$retree) }
sub metachar__S_457quant {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quant';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_457quant", 
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->panic("quantifier quantifies nothing");
}
else {
();
}
}
);
}

# "normal" metachars

##     token metachar__S_458sigwhite (:$sym is context<rw> = 'sigwhite')
##          token metachar:sigwhite {
##              <normspace>
##          }

sub metachar__S_458sigwhite__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_458sigwhite',$retree) }
sub metachar__S_458sigwhite {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigwhite';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_458sigwhite", 
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
);
}

##     token metachar__S_459Cur_Ly (:$sym is context<rw> = <{ }>)
##          token metachar:sym<{ }> {
##              <?before '{'>
##              <codeblock>
##              {{ $/<sym> := <{ }> }}
##          }

sub metachar__S_459Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_459Cur_Ly',$retree) }
sub metachar__S_459Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_459Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw({ })] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_460mod (:$sym is context<rw> = 'mod')
##          token metachar:mod {
##              <mod_internal>
##              { $/<sym> := $<mod_internal><sym> }
##          }

sub metachar__S_460mod__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_460mod',$retree) }
sub metachar__S_460mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_460mod", 
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_internal'], sub {
my $C = shift;
$C->mod_internal
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = $M->{mod_internal}{sym} ;
}, $C);
}
else {
();
}
}
);
}

##     token metachar__S_461Colon (:$sym is context<rw> = <:>)
##          token metachar:sym<:> {
##              <sym>
##          }

sub metachar__S_461Colon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_461Colon',$retree) }
sub metachar__S_461Colon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_461Colon", 
$C->_PATTERN(qr/\G\:/)
);
}

##     token metachar__S_462ColonColon (:$sym is context<rw> = <::>)
##          token metachar:sym<::> {
##              <sym>
##          }

sub metachar__S_462ColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_462ColonColon',$retree) }
sub metachar__S_462ColonColon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_462ColonColon", 
$C->_PATTERN(qr/\G\:\:/)
);
}

##     token metachar__S_463ColonColonColon (:$sym is context<rw> = <:::>)
##          token metachar:sym<:::> {
##              <sym>
##          }

sub metachar__S_463ColonColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_463ColonColonColon',$retree) }
sub metachar__S_463ColonColonColon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:::);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_463ColonColonColon", 
$C->_PATTERN(qr/\G\:\:\:/)
);
}

##     token metachar__S_464Bra_Ket (:$sym is context<rw> = <[ ]>)
##          token metachar:sym<[ ]> {
##              '[' {} [:lang(self.unbalanced(']')) <nibbler>]
##              [ ']' || <.panic: "Unable to parse regex; couldn't find right bracket"> ]
##              { $/<sym> := <[ ]> }
##          }

sub metachar__S_464Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_464Bra_Ket',$retree) }
sub metachar__S_464Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_464Bra_Ket", 
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(']'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right bracket")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw([ ])] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_465Paren_Thesis (:$sym is context<rw> = <( )>)
##          token metachar:sym<( )> {
##              '(' {} [:lang(self.unbalanced(')')) <nibbler>]
##              [ ')' || <.panic: "Unable to parse regex; couldn't find right parenthesis"> ]
##              { $/<sym> := <( )> }
##          }

sub metachar__S_465Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_465Paren_Thesis',$retree) }
sub metachar__S_465Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_465Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw[( )]] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_466LtParen (:$sym is context<rw> =  <( )
##          token metachar:sym <(  { '<(' }

sub metachar__S_466LtParen__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_466LtParen',$retree) }
sub metachar__S_466LtParen {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<('];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_466LtParen", 
$C->_EXACT('<(')
);
}
##     token metachar__S_467ThesisGt (:$sym is context<rw> =  )> )
##          token metachar:sym )>  { ')>' }

sub metachar__S_467ThesisGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_467ThesisGt',$retree) }
sub metachar__S_467ThesisGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //[')>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_467ThesisGt", 
$C->_EXACT(')>')
);
}

##     token metachar__S_468LtLt (:$sym is context<rw> =  << )
##          token metachar:sym <<  { '<<' }

sub metachar__S_468LtLt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_468LtLt',$retree) }
sub metachar__S_468LtLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_468LtLt", 
$C->_EXACT('<<')
);
}
##     token metachar__S_469GtGt (:$sym is context<rw> =  >> )
##          token metachar:sym >>  { '>>' }

sub metachar__S_469GtGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_469GtGt',$retree) }
sub metachar__S_469GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_469GtGt", 
$C->_EXACT('>>')
);
}
##     token metachar__S_470Fre (:$sym is context<rw> = <  >)
##          token metachar:sym<  > { '' }

sub metachar__S_470Fre__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_470Fre',$retree) }
sub metachar__S_470Fre {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_470Fre", 
$C->_EXACT('')
);
}
##     token metachar__S_471Nch (:$sym is context<rw> = <  >)
##          token metachar:sym<  > { '' }

sub metachar__S_471Nch__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_471Nch',$retree) }
sub metachar__S_471Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_471Nch", 
$C->_EXACT('')
);
}

##     token metachar__S_472qw (:$sym is context<rw> = 'qw')
##          token metachar:qw {
##              <?before '<' \s >  # (note required whitespace)
##              <quote>
##          }

sub metachar__S_472qw__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_472qw',$retree) }
sub metachar__S_472qw {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qw';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_472qw", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('<'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
});
}
else {
();
}
}
);
}

##     token metachar__S_473Lt_Gt (:$sym is context<rw> = < >)
##          token metachar:sym< > {
##              '<' <unsp>? {} <assertion>
##              [ '>' || <.panic: "regex assertion not terminated by angle bracket"> ]
##          }

sub metachar__S_473Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_473Lt_Gt',$retree) }
sub metachar__S_473Lt_Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'unsp'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_473Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>')} 
or
eval { push @gather, $C->panic("regex assertion not terminated by angle bracket")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_474Back (:$sym is context<rw> = <\\>)
##          token metachar:sym<\\> { <sym> <backslash> }

sub metachar__S_474Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_474Back',$retree) }
sub metachar__S_474Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_474Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##     token metachar__S_475Dot (:$sym is context<rw> = <.>)
##          token metachar:sym<.>  { <sym> }

sub metachar__S_475Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_475Dot',$retree) }
sub metachar__S_475Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_475Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token metachar__S_476CaretCaret (:$sym is context<rw> = <^^>)
##          token metachar:sym<^^> { <sym> }

sub metachar__S_476CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_476CaretCaret',$retree) }
sub metachar__S_476CaretCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_476CaretCaret", 
$C->_PATTERN(qr/\G\^\^/)
);
}
##     token metachar__S_477Caret (:$sym is context<rw> = <^>)
##          token metachar:sym<^>  { <sym> }

sub metachar__S_477Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_477Caret',$retree) }
sub metachar__S_477Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_477Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
##     token metachar__S_478DollarDollar (:$sym is context<rw> = <$$>)
##          token metachar:sym<$$> {
##              <sym>
##              [ (\w+) <.obs("\$\$" ~ $0.Str ~ " to deref var inside a regex", "\$(\$" ~ $0.Str ~ ")")> ]?
##          }

sub metachar__S_478DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_478DollarDollar',$retree) }
sub metachar__S_478DollarDollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($$);


my $C = $self;
my $S = $C->{_pos};
$C->{'0'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_478DollarDollar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\$/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))) {
$C->obs("\$\$" . $$C{0}->Str . " to deref var inside a regex", "\$(\$" . $$C{0}->Str . ")");
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}
##     token metachar__S_479Dollar (:$sym is context<rw> = <$>)
##          token metachar:sym<$>  {
##              '$'
##              <?before
##              | \s
##              | '|'
##              | '&'
##              | ')'
##              | ']'
##              | '>'
##              | $
##              | <.stopper>
##              >
##          }

sub metachar__S_479Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_479Dollar',$retree) }
sub metachar__S_479Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_479Dollar", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'metachar__S_479Dollar_01') {
$C->deb("Fate passed to metachar__S_479Dollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar__S_479Dollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar__S_479Dollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('|')
},
sub { my $C=shift;
$C->_EXACT('&')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('>')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
sub { my $C=shift;
$C->stopper
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token metachar__S_480Single_Single (:$sym is context<rw> = <' '>)
##          token metachar:sym<' '> { <?before "'"> [:lang($.cursor_fresh($*LANG)) <quote>] }

sub metachar__S_480Single_Single__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_480Single_Single',$retree) }
sub metachar__S_480Single_Single {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(' ')];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_480Single_Single", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G'/)
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}
##     token metachar__S_481Double_Double (:$sym is context<rw> = <" ">)
##          token metachar:sym<" "> { <?before '"'> [:lang($.cursor_fresh($*LANG)) <quote>] }

sub metachar__S_481Double_Double__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_481Double_Double',$retree) }
sub metachar__S_481Double_Double {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(" ")];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_481Double_Double", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('"')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}

##     token metachar__S_482var (:$sym is context<rw> = 'var')
##          token metachar:var {
##              <!before '$$'>
##              <?before <sigil>>
##              [:lang($.cursor_fresh($*LANG)) <variable> <.ws> <.check_variable($<variable>)> ]
##              $<binding> = ( <.ws> '=' <.ws> <quantified_atom> )?
##              { $<sym> = $<variable>.Str; }
##          }

sub metachar__S_482var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_482var',$retree) }
sub metachar__S_482var {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'var';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_482var", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('$$')
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
do {
if (my ($C) = ($C->ws)) {
do { my $M = $C;
$C->check_variable($M->{variable})
; };
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['binding'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
scalar(do {
my $M = $C;  $M->{sym} = $M->{variable}->Str; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token backslash__S_483unspace (:$sym is context<rw> = 'unspace')
##          token backslash:unspace { <?before \s> <.SUPER::ws> }

sub backslash__S_483unspace__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_483unspace',$retree) }
sub backslash__S_483unspace {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unspace';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_483unspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
$C->SUPER::ws;
}
else {
();
}
}
);
}

##     token backslash__S_4840 (:$sym is context<rw> = <0>)
##          token backslash:sym<0> { '0' <!before <[0..7]> > }

sub backslash__S_4840__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_4840',$retree) }
sub backslash__S_4840 {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(0);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "backslash__S_4840", 
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[0-7]/)
})
});
}
else {
();
}
}
);
}

##     token backslash__S_485A (:$sym is context<rw> = 'A')
##          token backslash:A { <sym> <.obs('\\A as beginning-of-string matcher', '^')> }

sub backslash__S_485A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_485A',$retree) }
sub backslash__S_485A {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'A';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_485A", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GA/))) {
$C->obs('\\A as beginning-of-string matcher', '^');
}
else {
();
}
}
);
}
##     token backslash__S_486a (:$sym is context<rw> = 'a')
##          token backslash:a { <sym> <.panic: "\\a is allowed only in strings, not regexes"> }

sub backslash__S_486a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_486a',$retree) }
sub backslash__S_486a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_486a", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ga/))) {
$C->panic("\\a is allowed only in strings, not regexes");
}
else {
();
}
}
);
}
##     token backslash__S_487b (:$sym is context<rw> = 'b')
##          token backslash:b { :i <sym> }

sub backslash__S_487b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_487b',$retree) }
sub backslash__S_487b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_487b", 
$C->_PATTERN(qr/\G(?i:b)/)
);
}
##     token backslash__S_488c (:$sym is context<rw> = 'c')
##          token backslash:c { :i <sym>
##              [
##              | <codepoint>
##              | \d+
##              | [ <[ ?.._ ]> || <.panic: "Unrecognized \\c character"> ]
##              ]
##          }

sub backslash__S_488c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_488c',$retree) }
sub backslash__S_488c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_488c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:c)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_488c_01') {
$C->deb("Fate passed to backslash__S_488c_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_488c_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_488c_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['codepoint'], sub {
my $C = shift;
$C->codepoint
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:[?-_])/)} 
or
eval { push @gather, $C->panic("Unrecognized \\c character")} or do { die $@ if $@ };
@gather;
}
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_489d (:$sym is context<rw> = 'd')
##          token backslash:d { :i <sym> }

sub backslash__S_489d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_489d',$retree) }
sub backslash__S_489d {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'd';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_489d", 
$C->_PATTERN(qr/\G(?i:d)/)
);
}
##     token backslash__S_490e (:$sym is context<rw> = 'e')
##          token backslash:e { :i <sym> }

sub backslash__S_490e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_490e',$retree) }
sub backslash__S_490e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_490e", 
$C->_PATTERN(qr/\G(?i:e)/)
);
}
##     token backslash__S_491f (:$sym is context<rw> = 'f')
##          token backslash:f { :i <sym> }

sub backslash__S_491f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_491f',$retree) }
sub backslash__S_491f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_491f", 
$C->_PATTERN(qr/\G(?i:f)/)
);
}
##     token backslash__S_492h (:$sym is context<rw> = 'h')
##          token backslash:h { :i <sym> }

sub backslash__S_492h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_492h',$retree) }
sub backslash__S_492h {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_492h", 
$C->_PATTERN(qr/\G(?i:h)/)
);
}
##     token backslash__S_493n (:$sym is context<rw> = 'n')
##          token backslash:n { :i <sym> }

sub backslash__S_493n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_493n',$retree) }
sub backslash__S_493n {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_493n", 
$C->_PATTERN(qr/\G(?i:n)/)
);
}
##     token backslash__S_494o (:$sym is context<rw> = 'o')
##          token backslash:o { :i <sym> [ <octint> | '['<octint>[','<octint>]*']' ] }

sub backslash__S_494o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_494o',$retree) }
sub backslash__S_494o {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{_pos};
$C->{'octint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_494o", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:o)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_494o_01') {
$C->deb("Fate passed to backslash__S_494o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_494o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_494o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\[)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\,)/))) {
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
});
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G(?i:\])/);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_495Q (:$sym is context<rw> = 'Q')
##          token backslash:Q { <sym> <.obs('\\Q as quotemeta', 'quotes or literal variable match')> }

sub backslash__S_495Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_495Q',$retree) }
sub backslash__S_495Q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_495Q", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GQ/))) {
$C->obs('\\Q as quotemeta', 'quotes or literal variable match');
}
else {
();
}
}
);
}
##     token backslash__S_496r (:$sym is context<rw> = 'r')
##          token backslash:r { :i <sym> }

sub backslash__S_496r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_496r',$retree) }
sub backslash__S_496r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_496r", 
$C->_PATTERN(qr/\G(?i:r)/)
);
}
##     token backslash__S_497s (:$sym is context<rw> = 's')
##          token backslash:s { :i <sym> }

sub backslash__S_497s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_497s',$retree) }
sub backslash__S_497s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_497s", 
$C->_PATTERN(qr/\G(?i:s)/)
);
}
##     token backslash__S_498t (:$sym is context<rw> = 't')
##          token backslash:t { :i <sym> }

sub backslash__S_498t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_498t',$retree) }
sub backslash__S_498t {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_498t", 
$C->_PATTERN(qr/\G(?i:t)/)
);
}
##     token backslash__S_499v (:$sym is context<rw> = 'v')
##          token backslash:v { :i <sym> }

sub backslash__S_499v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_499v',$retree) }
sub backslash__S_499v {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'v';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_499v", 
$C->_PATTERN(qr/\G(?i:v)/)
);
}
##     token backslash__S_500w (:$sym is context<rw> = 'w')
##          token backslash:w { :i <sym> }

sub backslash__S_500w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_500w',$retree) }
sub backslash__S_500w {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_500w", 
$C->_PATTERN(qr/\G(?i:w)/)
);
}
##     token backslash__S_501x (:$sym is context<rw> = 'x')
##          token backslash:x { :i <sym> [ <hexint> | '[' [<.ws><hexint><.ws> ] ** ',' ']' ] }

sub backslash__S_501x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_501x',$retree) }
sub backslash__S_501x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'hexint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_501x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:x)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_501x_01') {
$C->deb("Fate passed to backslash__S_501x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_501x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_501x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\[)/))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_PATTERN(qr/\G(?i:\,)/)
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G(?i:\])/);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_502z (:$sym is context<rw> = 'z')
##          token backslash:z { <sym> <.obs('\\z as end-of-string matcher', '$')> }

sub backslash__S_502z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_502z',$retree) }
sub backslash__S_502z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'z';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_502z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gz/))) {
$C->obs('\\z as end-of-string matcher', '$');
}
else {
();
}
}
);
}
##     token backslash__S_503Z (:$sym is context<rw> = 'Z')
##          token backslash:Z { <sym> <.obs('\\Z as end-of-string matcher', '\\n?$')> }

sub backslash__S_503Z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_503Z',$retree) }
sub backslash__S_503Z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Z';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_503Z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GZ/))) {
$C->obs('\\Z as end-of-string matcher', '\\n?$');
}
else {
();
}
}
);
}
##     token backslash__S_504misc (:$sym is context<rw> = 'misc')
##          token backslash:misc { $<litchar>=(\W) }

sub backslash__S_504misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_504misc',$retree) }
sub backslash__S_504misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_504misc", 
$C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
})
);
}
##     token backslash__S_505oops (:$sym is context<rw> = 'oops')
##          token backslash:oops { <.panic: "Unrecognized regex backslash sequence"> }

sub backslash__S_505oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_505oops',$retree) }
sub backslash__S_505oops {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_505oops", 
$C->panic("Unrecognized regex backslash sequence")
);
}

##     token assertion__S_506DotDotDot (:$sym is context<rw> = <...>)
##          token assertion:sym<...> { <sym> }

sub assertion__S_506DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_506DotDotDot',$retree) }
sub assertion__S_506DotDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_506DotDotDot", 
$C->_PATTERN(qr/\G\.\.\./)
);
}
##     token assertion__S_507QuestionQuestionQuestion (:$sym is context<rw> = <???>)
##          token assertion:sym<???> { <sym> }

sub assertion__S_507QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_507QuestionQuestionQuestion',$retree) }
sub assertion__S_507QuestionQuestionQuestion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(???);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_507QuestionQuestionQuestion", 
$C->_PATTERN(qr/\G\?\?\?/)
);
}
##     token assertion__S_508BangBangBang (:$sym is context<rw> = <!!!>)
##          token assertion:sym<!!!> { <sym> }

sub assertion__S_508BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_508BangBangBang',$retree) }
sub assertion__S_508BangBangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_508BangBangBang", 
$C->_PATTERN(qr/\G\!\!\!/)
);
}

##     token assertion__S_509Question (:$sym is context<rw> = <?>)
##          token assertion:sym<?> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_509Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_509Question',$retree) }
sub assertion__S_509Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_509Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_509Question_01') {
$C->deb("Fate passed to assertion__S_509Question_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_509Question_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_509Question_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_510Bang (:$sym is context<rw> = <!>)
##          token assertion:sym<!> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_510Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_510Bang',$retree) }
sub assertion__S_510Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_510Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_510Bang_01') {
$C->deb("Fate passed to assertion__S_510Bang_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_510Bang_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_510Bang_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_511Star (:$sym is context<rw> = <*>)
##          token assertion:sym<*> { <sym> [ <?before '>'> | <.ws> <nibbler> ] }

sub assertion__S_511Star__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_511Star',$retree) }
sub assertion__S_511Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_511Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_511Star_01') {
$C->deb("Fate passed to assertion__S_511Star_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_511Star_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_511Star_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_512Cur_Ly (:$sym is context<rw> = <{ }>)
##          token assertion:sym<{ }> { <codeblock> }

sub assertion__S_512Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_512Cur_Ly',$retree) }
sub assertion__S_512Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_512Cur_Ly", 
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
);
}

##     token assertion__S_513variable (:$sym is context<rw> = 'variable')
##          token assertion:variable {
##              <?before <sigil>>  # note: semantics must be determined per-sigil
##              [:lang($.cursor_fresh($*LANG).unbalanced('>')) <variable=EXPR(item %LOOSEST)>]
##          }

sub assertion__S_513variable__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_513variable',$retree) }
sub assertion__S_513variable {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'variable';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_513variable", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;    $C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->EXPR(\%LOOSEST)
})
});
}
else {
();
}
}
);
}

##     token assertion__S_514method (:$sym is context<rw> = 'method')
##          token assertion:method {
##              '.' [
##                  | <?before <alpha> > <assertion>
##                  | [ :lang($.cursor_fresh($*LANG).unbalanced('>')) <dottyop> ]
##                  ]
##          }

sub assertion__S_514method__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_514method',$retree) }
sub assertion__S_514method {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'method';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_514method", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_514method_01') {
$C->deb("Fate passed to assertion__S_514method_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_514method_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_514method_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_515name (:$sym is context<rw> = 'name')
##          token assertion:name { [ :lang($.cursor_fresh($*LANG).unbalanced('>')) <longname> ]
##                                          [
##                                          | <?before '>' >
##                                          | <.ws> <nibbler>
##                                          | '=' <assertion>
##                                          | ':' <.ws>
##                                              [ :lang($.cursor_fresh($*LANG).unbalanced('>')) <arglist> ]
##                                          | '(' {}
##                                              [ :lang($.cursor_fresh($*LANG)) <arglist> ]
##                                              [ ')' || <.panic: "Assertion call missing right parenthesis"> ]
##                                          ]?
##          }

sub assertion__S_515name__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_515name',$retree) }
sub assertion__S_515name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'name';


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'nibbler'} = [];
$C->{'assertion'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_515name", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_515name_02') {
$C->deb("Fate passed to assertion__S_515name_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_515name_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_515name_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Assertion call missing right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}

##     token assertion__S_516Bra (:$sym is context<rw> = <[>)
##          token assertion:sym<[> { <?before '['> <cclass_elem>+ }

sub assertion__S_516Bra__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_516Bra',$retree) }
sub assertion__S_516Bra {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q([);


my $C = $self;
my $S = $C->{_pos};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_516Bra", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_517Plus (:$sym is context<rw> = <+>)
##          token assertion:sym<+> { <?before '+'> <cclass_elem>+ }

sub assertion__S_517Plus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_517Plus',$retree) }
sub assertion__S_517Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_517Plus", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('+')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_518Minus (:$sym is context<rw> = <->)
##          token assertion:sym<-> { <?before '-'> <cclass_elem>+ }

sub assertion__S_518Minus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_518Minus',$retree) }
sub assertion__S_518Minus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{_pos};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_518Minus", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('-')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_519Dot (:$sym is context<rw> = <.>)
##          token assertion:sym<.> { <sym> }

sub assertion__S_519Dot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_519Dot',$retree) }
sub assertion__S_519Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_519Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token assertion__S_520Comma (:$sym is context<rw> = <,>)
##          token assertion:sym<,> { <sym> }

sub assertion__S_520Comma__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_520Comma',$retree) }
sub assertion__S_520Comma {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[,];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_520Comma", 
$C->_PATTERN(qr/\G\,/)
);
}
##     token assertion__S_521TildeTilde (:$sym is context<rw> = <~~>)
##          token assertion:sym<~~> { <sym> [ <?before '>'> | \d+ | <desigilname> ] }

sub assertion__S_521TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_521TildeTilde',$retree) }
sub assertion__S_521TildeTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_521TildeTilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\~/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_521TildeTilde_01') {
$C->deb("Fate passed to assertion__S_521TildeTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_521TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_521TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_522bogus (:$sym is context<rw> = 'bogus')
##          token assertion:bogus { <.panic: "Unrecognized regex assertion"> }

sub assertion__S_522bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_522bogus',$retree) }
sub assertion__S_522bogus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'bogus';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_522bogus", 
$C->panic("Unrecognized regex assertion")
);
}

##     token sign
##          token sign { '+' | '-' | <?> }

sub sign__PEEK { $_[0]->_AUTOLEXpeek('sign',$retree) }
sub sign {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "sign", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'sign_00') {
$C->deb("Fate passed to sign_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'sign_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sign_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('+')
},
sub { my $C=shift;
$C->_EXACT('-')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}
##     token cclass_elem
##          token cclass_elem {
##              :dba('character class element')
##              <sign>
##              <.normspace>?
##              [
##              | <name>
##              | <before '['> <quibble($.cursor_fresh( ::STD::Q ).tweak(:q))> # XXX parse as q[] for now
##              ]
##              <.normspace>?
##          }

sub cclass_elem__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem',$retree) }
sub cclass_elem {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "cclass_elem", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sign'], sub {
my $C = shift;
$C->sign
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->normspace
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'cclass_elem_01') {
$C->deb("Fate passed to cclass_elem_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'cclass_elem_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("cclass_elem_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_OPTr(sub { my $C=shift;
$C->normspace
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_arg
##          token mod_arg { :dba('modifier argument') '(' ~ ')' <semilist> }

sub mod_arg__PEEK { $_[0]->_AUTOLEXpeek('mod_arg',$retree) }
sub mod_arg {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "mod_arg", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'modifier argument')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

##     token mod_internal__S_523Colonmy (:$sym is context<rw> = <:my>)
##          token mod_internal:sym<:my>    { ':' <?before 'my' \s > [:lang($.cursor_fresh($*LANG)) <statement> <eat_terminator> ] }

sub mod_internal__S_523Colonmy__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_523Colonmy',$retree) }
sub mod_internal__S_523Colonmy {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:my);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_523Colonmy", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('my'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
});
}
else {
();
}
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX needs some generalization

##     token mod_internal__S_524Coloni (:$sym is context<rw> = <:i>)
##          token mod_internal:sym<:i>    { $<sym>=[':i'|':ignorecase']  { $*ignorecase = 1 } }

sub mod_internal__S_524Coloni__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_524Coloni',$retree) }
sub mod_internal__S_524Coloni {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_524Coloni", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_524Coloni_01') {
$C->deb("Fate passed to mod_internal__S_524Coloni_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_524Coloni_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_524Coloni_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignorecase = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_525ColonBangi (:$sym is context<rw> = <:!i>)
##          token mod_internal:sym<:!i>   { $<sym>=[':!i'|':!ignorecase']  { $*ignorecase = 0 } }

sub mod_internal__S_525ColonBangi__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_525ColonBangi',$retree) }
sub mod_internal__S_525ColonBangi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_525ColonBangi", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_525ColonBangi_01') {
$C->deb("Fate passed to mod_internal__S_525ColonBangi_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_525ColonBangi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_525ColonBangi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!i')
},
sub { my $C=shift;
$C->_EXACT(':!ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignorecase = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_526ColoniParen_Thesis (:$sym is context<rw> = <:i( )>)
##          token mod_internal:sym<:i( )> { $<sym>=[':i'|':ignorecase'] <mod_arg> { $*ignorecase = eval $<mod_arg>.Str } }

sub mod_internal__S_526ColoniParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_526ColoniParen_Thesis',$retree) }
sub mod_internal__S_526ColoniParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:i( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_526ColoniParen_Thesis", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_526ColoniParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_526ColoniParen_Thesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_526ColoniParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_526ColoniParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ignorecase = eval $M->{mod_arg}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_527Colon0i (:$sym is context<rw> = <:0i>)
##          token mod_internal:sym<:0i>   { ':' (\d+) ['i'|'ignorecase'] { $*ignorecase = $0 } }

sub mod_internal__S_527Colon0i__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_527Colon0i',$retree) }
sub mod_internal__S_527Colon0i {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_527Colon0i", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_527Colon0i_02') {
$C->deb("Fate passed to mod_internal__S_527Colon0i_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_527Colon0i_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_527Colon0i_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('i')
},
sub { my $C=shift;
$C->_EXACT('ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::ignorecase = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_528Colona (:$sym is context<rw> = <:a>)
##          token mod_internal:sym<:a>    { $<sym>=[':a'|':ignoreaccent']  { $*ignoreaccent = 1 } }

sub mod_internal__S_528Colona__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_528Colona',$retree) }
sub mod_internal__S_528Colona {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:a);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_528Colona", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_528Colona_01') {
$C->deb("Fate passed to mod_internal__S_528Colona_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_528Colona_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_528Colona_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignoreaccent = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_529ColonBanga (:$sym is context<rw> = <:!a>)
##          token mod_internal:sym<:!a>   { $<sym>=[':!a'|':!ignoreaccent']  { $*ignoreaccent = 0 } }

sub mod_internal__S_529ColonBanga__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_529ColonBanga',$retree) }
sub mod_internal__S_529ColonBanga {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!a);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_529ColonBanga", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_529ColonBanga_01') {
$C->deb("Fate passed to mod_internal__S_529ColonBanga_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_529ColonBanga_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_529ColonBanga_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!a')
},
sub { my $C=shift;
$C->_EXACT(':!ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignoreaccent = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_530ColonaParen_Thesis (:$sym is context<rw> = <:a( )>)
##          token mod_internal:sym<:a( )> { $<sym>=[':a'|':ignoreaccent'] <mod_arg> { $*ignoreaccent = eval $<mod_arg>.Str } }

sub mod_internal__S_530ColonaParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_530ColonaParen_Thesis',$retree) }
sub mod_internal__S_530ColonaParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:a( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_530ColonaParen_Thesis", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_530ColonaParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_530ColonaParen_Thesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_530ColonaParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_530ColonaParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ignoreaccent = eval $M->{mod_arg}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_531Colon0a (:$sym is context<rw> = <:0a>)
##          token mod_internal:sym<:0a>   { ':' (\d+) ['a'|'ignoreaccent'] { $*ignoreaccent = $0 } }

sub mod_internal__S_531Colon0a__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_531Colon0a',$retree) }
sub mod_internal__S_531Colon0a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0a);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_531Colon0a", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_531Colon0a_02') {
$C->deb("Fate passed to mod_internal__S_531Colon0a_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_531Colon0a_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_531Colon0a_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('a')
},
sub { my $C=shift;
$C->_EXACT('ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::ignoreaccent = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_532Colons (:$sym is context<rw> = <:s>)
##          token mod_internal:sym<:s>    { ':s' 'igspace'?  { $*sigspace = 1 } }

sub mod_internal__S_532Colons__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_532Colons',$retree) }
sub mod_internal__S_532Colons {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:s);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_532Colons", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_533ColonBangs (:$sym is context<rw> = <:!s>)
##          token mod_internal:sym<:!s>   { ':!s' 'igspace'?  { $*sigspace = 0 } }

sub mod_internal__S_533ColonBangs__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_533ColonBangs',$retree) }
sub mod_internal__S_533ColonBangs {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!s);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_533ColonBangs", 
do {
if (my ($C) = ($C->_EXACT(':!s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_534ColonsParen_Thesis (:$sym is context<rw> = <:s( )>)
##          token mod_internal:sym<:s( )> { ':s' 'igspace'? <mod_arg> { $*sigspace = eval $<mod_arg>.Str } }

sub mod_internal__S_534ColonsParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_534ColonsParen_Thesis',$retree) }
sub mod_internal__S_534ColonsParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:s( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_534ColonsParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::sigspace = eval $M->{mod_arg}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_535Colon0s (:$sym is context<rw> = <:0s>)
##          token mod_internal:sym<:0s>   { ':' (\d+) 's' 'igspace'?  { $*sigspace = $0 } }

sub mod_internal__S_535Colon0s__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_535Colon0s',$retree) }
sub mod_internal__S_535Colon0s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0s);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_535Colon0s", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_536Colonr (:$sym is context<rw> = <:r>)
##          token mod_internal:sym<:r>    { ':r' 'atchet'?  { $*ratchet = 1 } }

sub mod_internal__S_536Colonr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_536Colonr',$retree) }
sub mod_internal__S_536Colonr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:r);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_536Colonr", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_537ColonBangr (:$sym is context<rw> = <:!r>)
##          token mod_internal:sym<:!r>   { ':!r' 'atchet'?  { $*ratchet = 0 } }

sub mod_internal__S_537ColonBangr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_537ColonBangr',$retree) }
sub mod_internal__S_537ColonBangr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!r);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_537ColonBangr", 
do {
if (my ($C) = ($C->_EXACT(':!r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_538ColonrParen_Thesis (:$sym is context<rw> = <:r( )>)
##          token mod_internal:sym<:r( )> { ':r' 'atchet'?  <mod_arg> { $*ratchet = eval $<mod_arg>.Str } }

sub mod_internal__S_538ColonrParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_538ColonrParen_Thesis',$retree) }
sub mod_internal__S_538ColonrParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:r( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_538ColonrParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ratchet = eval $M->{mod_arg}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_539Colon0r (:$sym is context<rw> = <:0r>)
##          token mod_internal:sym<:0r>   { ':' (\d+) 'r' 'atchet'?  { $*ratchet = $0 } }

sub mod_internal__S_539Colon0r__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_539Colon0r',$retree) }
sub mod_internal__S_539Colon0r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0r);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_539Colon0r", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_540ColonPerl5 (:$sym is context<rw> = <:Perl5>)
##          token mod_internal:sym<:Perl5>    { [':Perl5' | ':P5'] [ :lang( $.cursor_fresh( ::STD::P5Regex ).unbalanced($*GOAL) ) <nibbler> ] }

sub mod_internal__S_540ColonPerl5__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_540ColonPerl5',$retree) }
sub mod_internal__S_540ColonPerl5 {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:Perl5);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_540ColonPerl5", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_540ColonPerl5_01') {
$C->deb("Fate passed to mod_internal__S_540ColonPerl5_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_540ColonPerl5_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_540ColonPerl5_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':Perl5')
},
sub { my $C=shift;
$C->_EXACT(':P5')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($::GOAL) );  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
});
}
else {
();
}
}
);
}

##     token mod_internal__S_541adv (:$sym is context<rw> = 'adv')
##          token mod_internal:adv {
##              <?before ':' <.identifier> > [ :lang($.cursor_fresh($*LANG)) <quotepair> ] { $/<sym> := : $<quotepair><key> }
##          }

sub mod_internal__S_541adv__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_541adv',$retree) }
sub mod_internal__S_541adv {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'adv';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_541adv", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->identifier;
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
})
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} =[':','$<quotepair><key>'] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_542oops (:$sym is context<rw> = 'oops')
##          token mod_internal:oops { ':'\w+ <.panic: "Unrecognized regex modifier"> }

sub mod_internal__S_542oops__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_542oops',$retree) }
sub mod_internal__S_542oops {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_542oops", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
$C->panic("Unrecognized regex modifier");
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantifier__S_543Star (:$sym is context<rw> = <*>)
##          token quantifier:sym<*>  { <sym> <quantmod> }

sub quantifier__S_543Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_543Star',$retree) }
sub quantifier__S_543Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_543Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_544Plus (:$sym is context<rw> = <+>)
##          token quantifier:sym<+>  { <sym> <quantmod> }

sub quantifier__S_544Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_544Plus',$retree) }
sub quantifier__S_544Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_544Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_545Question (:$sym is context<rw> = <?>)
##          token quantifier:sym<?>  { <sym> <quantmod> }

sub quantifier__S_545Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_545Question',$retree) }
sub quantifier__S_545Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_545Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_546StarStar (:$sym is context<rw> = <**>)
##          token quantifier:sym<**> { <sym> :: <normspace>? <quantmod> <normspace>?
##              [
##              | \d+ [ '..' [ \d+ | '*' ] ]?
##              | <codeblock>
##              | <quantified_atom>
##              ]
##          }

sub quantifier__S_546StarStar__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_546StarStar',$retree) }
sub quantifier__S_546StarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{_pos};
$C->{'normspace'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "quantifier__S_546StarStar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantifier__S_546StarStar_01') {
$C->deb("Fate passed to quantifier__S_546StarStar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_546StarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_546StarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantifier__S_546StarStar_03') {
$C->deb("Fate passed to quantifier__S_546StarStar_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_546StarStar_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_546StarStar_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('..'))
})
})
}, $C->_PATTERN(qr/\G((?:\d)++)/))
},
sub { my $C=shift;
$C->_SUBSUME(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
},
sub { my $C=shift;
$C->_SUBSUME(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
}, $C->_SUBSUME(['quantmod'], sub {
my $C = shift;
$C->quantmod
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\*\*/))
);
}

##     token quantifier__S_547TildeTilde (:$sym is context<rw> = <~~>)
##          token quantifier:sym<~~> {
##              [
##              | '!' <sym>
##              | <sym>
##              ]
##              <normspace> <quantified_atom> }

sub quantifier__S_547TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_547TildeTilde',$retree) }
sub quantifier__S_547TildeTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_547TildeTilde", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantifier__S_547TildeTilde_01') {
$C->deb("Fate passed to quantifier__S_547TildeTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_547TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_547TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
$C->_PATTERN(qr/\G\~\~/);
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\~\~/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantmod
##          token quantmod { ':'? [ '?' | '!' | '+' ]? }

sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod',$retree) }
sub quantmod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quantmod", 
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantmod_01') {
$C->deb("Fate passed to quantmod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantmod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantmod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('?')
},
sub { my $C=shift;
$C->_EXACT('!')
},
sub { my $C=shift;
$C->_EXACT('+')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
assertion__S_506DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_506DotDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ...
assertion__S_507QuestionQuestionQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_507QuestionQuestionQuestion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ???
assertion__S_508BangBangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_508BangBangBang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!!!"
assertion__S_509Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_509Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_509Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &14 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_509Question_01
          dba: assertion__S_509Question
          i: 0
          min: 0
          name: assertion__S_509Question_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_509Question_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_509Question
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_509Question
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_509Question_01 1
              dba: assertion__S_509Question
              i: 0
              min: 12345
              name: assertion
              r: 1
              rest: ''
              s: 0
assertion__S_509Question_01: *14
assertion__S_510Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_510Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_510Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &4 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_510Bang_01
          dba: assertion__S_510Bang
          i: 0
          min: 0
          name: assertion__S_510Bang_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_510Bang_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_510Bang
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_510Bang
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_510Bang_01 1
              dba: assertion__S_510Bang
              i: 0
              min: 12345
              name: assertion
              r: 1
              rest: ''
              s: 0
assertion__S_510Bang_01: *4
assertion__S_511Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_511Star
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_511Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &18 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_511Star_01
          dba: assertion__S_511Star
          i: 0
          min: 0
          name: assertion__S_511Star_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_511Star_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_511Star
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_511Star
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_511Star_01 1
              dba: assertion__S_511Star
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_511Star
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_511Star
                  i: 0
                  min: 12345
                  name: nibbler
                  r: 1
                  rest: ''
                  s: 0
assertion__S_511Star_01: *18
assertion__S_512Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_512Cur_Ly
    i: 0
    min: 12345
    name: codeblock
    r: 1
    rest: ''
    s: 0
assertion__S_513variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_513variable
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_513variable
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: assertion__S_513variable
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: assertion__S_513variable
          i: 0
          lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: assertion__S_513variable
              i: 0
              lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_method 
                min: 0
                name: EXPR
                nobind: 1
                rest: (item %LOOSEST)
              dba: assertion__S_513variable
              i: 0
              lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
              min: 0
              r: 1
              s: 0
              var: variable
assertion__S_514method: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_514method
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: assertion__S_514method
        i: 0
        min: 1
        r: 1
        s: 0
        text: .
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &27 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_514method_01
          dba: assertion__S_514method
          i: 0
          min: 12345
          name: assertion__S_514method_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_514method_01 0
              dba: assertion__S_514method
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: assertion__S_514method
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 12345
                      re: !!perl/hash:RE_method 
                        a: 0
                        dba: assertion__S_514method
                        i: 0
                        min: 12345
                        name: alpha
                        r: 1
                        rest: ''
                        s: 0
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_514method
                  i: 0
                  min: 12345
                  name: assertion
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_bracket 
              alt: assertion__S_514method_01 1
              decl: []

              min: 12345
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: assertion__S_514method
                i: 0
                lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_decl 
                    a: 0
                    dba: assertion__S_514method
                    i: 0
                    lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
                    max: 0
                    min: 0
                    noquant: 1
                    r: 1
                    s: 0
                    text: "my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_514method
                    i: 0
                    lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
                    min: 12345
                    name: dottyop
                    r: 1
                    rest: ''
                    s: 0
assertion__S_514method_01: *27
assertion__S_515name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_515name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: assertion__S_515name
          i: 0
          lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: assertion__S_515name
              i: 0
              lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: assertion__S_515name
              i: 0
              lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
              min: 12345
              name: longname
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &1 !!perl/hash:RE_any 
            a: 0
            altname: assertion__S_515name_02
            dba: assertion__S_515name
            i: 0
            min: 0
            name: assertion__S_515name_02
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                alt: assertion__S_515name_02 0
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: assertion__S_515name
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: assertion__S_515name
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ">"
                  s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_515name_02 1
                dba: assertion__S_515name
                i: 0
                min: 24690
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_515name
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_515name
                    i: 0
                    min: 12345
                    name: nibbler
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_515name_02 2
                dba: assertion__S_515name
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_515name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_515name
                    i: 0
                    min: 12345
                    name: assertion
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_515name_02 3
                dba: assertion__S_515name
                i: 0
                min: 24691
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_515name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_515name
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_515name
                      i: 0
                      lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_515name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_515name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG)->unbalanced('>'))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_515name_02 4
                dba: assertion__S_515name
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_515name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: (
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: assertion__S_515name
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: ''
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_515name
                      i: 0
                      lang: ($C->cursor_fresh($::LANG))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_515name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_515name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 0
                    re: !!perl/hash:RE_first 
                      a: 0
                      dba: assertion__S_515name
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: assertion__S_515name
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Assertion call missing right parenthesis")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
assertion__S_515name_02: *1
assertion__S_516Bra: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_516Bra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_516Bra
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_516Bra
              i: 0
              min: 1
              r: 1
              s: 0
              text: "["
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_516Bra
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_517Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_517Plus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_517Plus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_517Plus
              i: 0
              min: 1
              r: 1
              s: 0
              text: +
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_517Plus
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_518Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_518Minus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_518Minus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_518Minus
              i: 0
              min: 1
              r: 1
              s: 0
              text: "-"
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_518Minus
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_519Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_519Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
assertion__S_520Comma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_520Comma
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ","
assertion__S_521TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_521TildeTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_521TildeTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~~
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &6 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_521TildeTilde_01
          dba: assertion__S_521TildeTilde
          i: 0
          min: 0
          name: assertion__S_521TildeTilde_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_521TildeTilde_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_521TildeTilde
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_521TildeTilde
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_quantified_atom 
              alt: assertion__S_521TildeTilde_01 1
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: assertion__S_521TildeTilde
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_521TildeTilde_01 2
              dba: assertion__S_521TildeTilde
              i: 0
              min: 12345
              name: desigilname
              r: 1
              rest: ''
              s: 0
assertion__S_521TildeTilde_01: *6
assertion__S_522bogus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex assertion")
atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &16 !!perl/hash:RE_any 
      a: 0
      altname: atom_01
      dba: regex atom
      i: 0
      min: 0
      name: atom_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_meta 
          a: 0
          alt: atom_01 0
          dba: regex atom
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        - !!perl/hash:RE_sequence 
          a: 0
          alt: atom_01 1
          dba: regex atom
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: regex atom
              i: 0
              min: 12345
              name: metachar
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_meta 
              a: 0
              dba: regex atom
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
        - !!perl/hash:RE_method 
          alt: atom_01 2
          min: 0
          name: panic
          nobind: 1
          rest: ("Unrecognized regex metacharacter")
atom_01: *16
backslash__S_483unspace: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_483unspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_483unspace
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: backslash__S_483unspace
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_483unspace
        i: 0
        min: 12345
        name: SUPER::ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
backslash__S_4840: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_4840
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_4840
        i: 0
        min: 1
        r: 1
        s: 0
        text: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_4840
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: backslash__S_4840
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[0..7]"
          s: 0
backslash__S_485A: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_485A
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_485A
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: A
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\A as beginning-of-string matcher', '^')
backslash__S_486a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_486a
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_486a
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: a
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("\\a is allowed only in strings, not regexes")
backslash__S_487b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_487b
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_488c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_488c
    i: 1
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_488c
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: c
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &7 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_488c_01
          dba: backslash__S_488c
          i: 1
          min: 0
          name: backslash__S_488c_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_488c_01 0
              dba: backslash__S_488c
              i: 1
              min: 12345
              name: codepoint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              alt: backslash__S_488c_01 1
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: backslash__S_488c
                i: 1
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_bracket 
              alt: backslash__S_488c_01 2
              decl: []

              min: 0
              re: !!perl/hash:RE_first 
                a: 0
                dba: backslash__S_488c
                i: 1
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_cclass 
                    a: 0
                    dba: backslash__S_488c
                    i: 1
                    min: 1
                    r: 1
                    s: 0
                    text: "[ ?.._ ]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Unrecognized \\c character")
backslash__S_488c_01: *7
backslash__S_489d: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_489d
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: d
backslash__S_490e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_490e
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_491f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_491f
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_492h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_492h
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
backslash__S_493n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_493n
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_494o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_494o
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_494o
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: o
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &19 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_494o_01
          dba: backslash__S_494o
          i: 1
          min: 12345
          name: backslash__S_494o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_494o_01 0
              dba: backslash__S_494o
              i: 1
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_494o_01 1
              dba: backslash__S_494o
              i: 1
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_494o
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_method 
                  a: 0
                  dba: backslash__S_494o
                  i: 1
                  min: 12345
                  name: octint
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12346
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_494o
                      i: 1
                      min: 12346
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: backslash__S_494o
                          i: 1
                          min: 1
                          r: 1
                          s: 0
                          text: ","
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_494o
                          i: 1
                          min: 12345
                          name: octint
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_494o
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_494o_01: *19
backslash__S_495Q: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_495Q
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_495Q
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Q
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\Q as quotemeta', 'quotes or literal variable match')
backslash__S_496r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_496r
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_497s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_497s
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
backslash__S_498t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_498t
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_499v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_499v
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: v
backslash__S_500w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_500w
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
backslash__S_501x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_501x
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_501x
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &3 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_501x_01
          dba: backslash__S_501x
          i: 1
          min: 12345
          name: backslash__S_501x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_501x_01 0
              dba: backslash__S_501x
              i: 1
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_501x_01 1
              dba: backslash__S_501x
              i: 1
              min: 37037
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_501x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 37035
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_501x
                      i: 1
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_501x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_501x
                          i: 1
                          min: 12345
                          name: hexint
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_501x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                  min: 37035
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_501x
                      i: 1
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_501x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_501x_01: *3
backslash__S_502z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_502z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_502z
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: z
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\z as end-of-string matcher', '$')
backslash__S_503Z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_503Z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_503Z
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Z
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\Z as end-of-string matcher', '\\n?$')
backslash__S_504misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_paren 
      decl: []

      min: 1
      nobind: 1
      re: !!perl/hash:RE_meta 
        a: 0
        dba: backslash__S_504misc
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
    dba: backslash__S_504misc
    i: 0
    min: 1
    r: 1
    s: 0
    var: litchar
backslash__S_505oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex backslash sequence")
category__S_440metachar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_440metachar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: metachar
category__S_441backslash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_441backslash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: backslash
category__S_442assertion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_442assertion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: assertion
category__S_443quantifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_443quantifier
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quantifier
category__S_444mod_internal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_444mod_internal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod_internal
cclass_elem: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: character class element
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: character class element
        i: 0
        min: 12345
        name: sign
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: character class element
          i: 0
          min: 12345
          name: normspace
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &26 !!perl/hash:RE_any 
          a: 0
          altname: cclass_elem_01
          dba: character class element
          i: 0
          min: 0
          name: cclass_elem_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: cclass_elem_01 0
              dba: character class element
              i: 0
              min: 12345
              name: name
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: cclass_elem_01 1
              dba: character class element
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method_re 
                  a: 0
                  dba: character class element
                  i: 0
                  min: 0
                  name: before
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: character class element
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:q))
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: character class element
          i: 0
          min: 12345
          name: normspace
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
cclass_elem_01: *26
codeblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: codeblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codeblock
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codeblock
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: codeblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: codeblock
          i: 0
          lang: ($C->cursor_fresh($::LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              min: 12345
              name: statementlist
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: codeblock
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: codeblock
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse statement list; couldn't find right brace")
infixish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infixish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: rxinfix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infixish
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n            $<O> = $<rxinfix><O>;\n            $<sym> = $<rxinfix><sym>;\n        "
metachar__S_450Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_450Gt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_450Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: ">"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_450Gt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_450Gt
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_451AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_451AmpAmp
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_451AmpAmp
        i: 0
        min: 2
        r: 1
        s: 0
        text: "&&"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_451AmpAmp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_451AmpAmp
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_452Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_452Amp
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_452Amp
        i: 0
        min: 1
        r: 1
        s: 0
        text: "&"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_452Amp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_452Amp
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_453VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_453VertVert
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_453VertVert
        i: 0
        min: 2
        r: 1
        s: 0
        text: "||"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_453VertVert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_453VertVert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_454Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_454Vert
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_454Vert
        i: 0
        min: 1
        r: 1
        s: 0
        text: "|"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_454Vert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_454Vert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_455Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_455Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_455Ket
        i: 0
        min: 1
        r: 1
        s: 0
        text: "]"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_455Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_455Ket
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_456Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_456Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_456Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: )
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_456Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_456Thesis
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_457quant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_457quant
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_457quant
        i: 0
        min: 12345
        name: quantifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("quantifier quantifies nothing")
metachar__S_458sigwhite: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_458sigwhite
    i: 0
    min: 12345
    name: normspace
    r: 1
    rest: ''
    s: 0
metachar__S_459Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_459Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_459Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_459Cur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_459Cur_Ly
        i: 0
        min: 12345
        name: codeblock
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_459Cur_Ly
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <{ }> "
metachar__S_460mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_460mod
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_460mod
        i: 0
        min: 12345
        name: mod_internal
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_460mod
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := $<mod_internal><sym> "
metachar__S_461Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_461Colon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ":"
metachar__S_462ColonColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_462ColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "::"
metachar__S_463ColonColonColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_463ColonColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ":::"
metachar__S_464Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_464Bra_Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_464Bra_Ket
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_464Bra_Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_464Bra_Ket
          i: 0
          lang: ($self->unbalanced(']'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_464Bra_Ket
              i: 0
              lang: ($self->unbalanced(']'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(']'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_464Bra_Ket
              i: 0
              lang: ($self->unbalanced(']'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_464Bra_Ket
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_464Bra_Ket
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right bracket")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_464Bra_Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <[ ]> "
metachar__S_465Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_465Paren_Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_465Paren_Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_465Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_465Paren_Thesis
          i: 0
          lang: ($self->unbalanced(')'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_465Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_465Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_465Paren_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_465Paren_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right parenthesis")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_465Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <( )> "
metachar__S_466LtParen: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_466LtParen
    i: 0
    min: 2
    r: 1
    s: 0
    text: <(
metachar__S_467ThesisGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_467ThesisGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: )>
metachar__S_468LtLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_468LtLt
    i: 0
    min: 2
    r: 1
    s: 0
    text: <<
metachar__S_469GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_469GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: ">>"
metachar__S_470Fre: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_470Fre
    i: 0
    min: 1
    r: 1
    s: 0
    text: 
metachar__S_471Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_471Nch
    i: 0
    min: 1
    r: 1
    s: 0
    text: 
metachar__S_472qw: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_472qw
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_472qw
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_472qw
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: metachar__S_472qw
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: <
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: metachar__S_472qw
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_472qw
        i: 0
        min: 12345
        name: quote
        r: 1
        rest: ''
        s: 0
metachar__S_473Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_473Lt_Gt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_473Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: metachar__S_473Lt_Gt
          i: 0
          min: 12345
          name: unsp
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_473Lt_Gt
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_473Lt_Gt
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_473Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_473Lt_Gt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("regex assertion not terminated by angle bracket")
metachar__S_474Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_474Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_474Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_474Back
        i: 0
        min: 12345
        name: backslash
        r: 1
        rest: ''
        s: 0
metachar__S_475Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_475Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
metachar__S_476CaretCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_476CaretCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^^"
metachar__S_477Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_477Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
metachar__S_478DollarDollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_478DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_478DollarDollar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $$
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: metachar__S_478DollarDollar
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_meta 
                      a: 0
                      dba: metachar__S_478DollarDollar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \w
                    min: 1
                    quant: 
                      - +
                      - ":"
                      - ''
                      - 1
                min: 1
                var: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ("\$\$" ~ $0.Str ~ " to deref var inside a regex", "\$(\$" ~ $0.Str ~ ")")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
metachar__S_479Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_479Dollar
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_479Dollar
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_479Dollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: &17 !!perl/hash:RE_any 
              a: 0
              altname: metachar__S_479Dollar_01
              dba: metachar__S_479Dollar
              i: 0
              min: 0
              name: metachar__S_479Dollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_479Dollar_01 0
                  dba: metachar__S_479Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_479Dollar_01 1
                  dba: metachar__S_479Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "|"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_479Dollar_01 2
                  dba: metachar__S_479Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "&"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_479Dollar_01 3
                  dba: metachar__S_479Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: )
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_479Dollar_01 4
                  dba: metachar__S_479Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_479Dollar_01 5
                  dba: metachar__S_479Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_479Dollar_01 6
                  dba: metachar__S_479Dollar
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $
                - !!perl/hash:RE_method 
                  a: 0
                  alt: metachar__S_479Dollar_01 7
                  dba: metachar__S_479Dollar
                  i: 0
                  min: 12345
                  name: stopper
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
          s: 0
metachar__S_479Dollar_01: *17
metachar__S_480Single_Single: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_480Single_Single
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_480Single_Single
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_double 
              a: 0
              dba: metachar__S_480Single_Single
              i: 0
              min: 1
              r: 1
              s: 0
              text: "'"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_480Single_Single
          i: 0
          lang: ($C->cursor_fresh($::LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_480Single_Single
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_480Single_Single
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              min: 12345
              name: quote
              r: 1
              rest: ''
              s: 0
metachar__S_481Double_Double: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_481Double_Double
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_481Double_Double
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_481Double_Double
              i: 0
              min: 1
              r: 1
              s: 0
              text: "\""
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_481Double_Double
          i: 0
          lang: ($C->cursor_fresh($::LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_481Double_Double
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_481Double_Double
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              min: 12345
              name: quote
              r: 1
              rest: ''
              s: 0
metachar__S_482var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_482var
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_482var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_482var
              i: 0
              min: 2
              r: 1
              s: 0
              text: $$
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_482var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_482var
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_482var
          i: 0
          lang: ($C->cursor_fresh($::LANG))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_482var
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_482var
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              min: 12345
              name: variable
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_482var
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: check_variable
              nobind: 1
              rest: ($<variable>)
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_paren 
            decl: []

            min: 37036
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_482var
              i: 0
              min: 37036
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_482var
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: metachar__S_482var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_482var
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_482var
                  i: 0
                  min: 12345
                  name: quantified_atom
                  r: 1
                  rest: ''
                  s: 0
          min: 0
          nobind: 1
          quant: 
            - "?"
            - ":"
            - ''
            - 0
        dba: metachar__S_482var
        i: 0
        min: 0
        r: 1
        s: 0
        var: binding
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_482var
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $<variable>.Str; "
mod_arg: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: modifier argument
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: modifier argument
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: modifier argument
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: modifier argument
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: modifier argument
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: modifier argument
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'modifier argument')
mod_internal__S_523Colonmy: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_523Colonmy
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_523Colonmy
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_523Colonmy
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 3
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_523Colonmy
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: mod_internal__S_523Colonmy
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: my
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: mod_internal__S_523Colonmy
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_523Colonmy
          i: 0
          lang: ($C->cursor_fresh($::LANG))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_523Colonmy
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_523Colonmy
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              min: 12345
              name: statement
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_523Colonmy
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              min: 12345
              name: eat_terminator
              r: 1
              rest: ''
              s: 0
mod_internal__S_524Coloni: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_524Coloni
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &11 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_524Coloni_01
            dba: mod_internal__S_524Coloni
            i: 0
            min: 2
            name: mod_internal__S_524Coloni_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_524Coloni_01 0
                dba: mod_internal__S_524Coloni
                i: 0
                min: 2
                r: 1
                s: 0
                text: :i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_524Coloni_01 1
                dba: mod_internal__S_524Coloni
                i: 0
                min: 11
                r: 1
                s: 0
                text: :ignorecase
        dba: mod_internal__S_524Coloni
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_524Coloni
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_524Coloni
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = 1 "
mod_internal__S_524Coloni_01: *11
mod_internal__S_525ColonBangi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_525ColonBangi
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 3
          nobind: 1
          re: &22 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_525ColonBangi_01
            dba: mod_internal__S_525ColonBangi
            i: 0
            min: 3
            name: mod_internal__S_525ColonBangi_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_525ColonBangi_01 0
                dba: mod_internal__S_525ColonBangi
                i: 0
                min: 3
                r: 1
                s: 0
                text: :!i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_525ColonBangi_01 1
                dba: mod_internal__S_525ColonBangi
                i: 0
                min: 12
                r: 1
                s: 0
                text: :!ignorecase
        dba: mod_internal__S_525ColonBangi
        i: 0
        min: 3
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_525ColonBangi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_525ColonBangi
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = 0 "
mod_internal__S_525ColonBangi_01: *22
mod_internal__S_526ColoniParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_526ColoniParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &24 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_526ColoniParen_Thesis_01
            dba: mod_internal__S_526ColoniParen_Thesis
            i: 0
            min: 2
            name: mod_internal__S_526ColoniParen_Thesis_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_526ColoniParen_Thesis_01 0
                dba: mod_internal__S_526ColoniParen_Thesis
                i: 0
                min: 2
                r: 1
                s: 0
                text: :i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_526ColoniParen_Thesis_01 1
                dba: mod_internal__S_526ColoniParen_Thesis
                i: 0
                min: 11
                r: 1
                s: 0
                text: :ignorecase
        dba: mod_internal__S_526ColoniParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_526ColoniParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_526ColoniParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = eval $<mod_arg>.Str "
mod_internal__S_526ColoniParen_Thesis_01: *24
mod_internal__S_527Colon0i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_527Colon0i
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_527Colon0i
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_527Colon0i
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &12 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_527Colon0i_02
          dba: mod_internal__S_527Colon0i
          i: 0
          min: 1
          name: mod_internal__S_527Colon0i_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_527Colon0i_02 0
              dba: mod_internal__S_527Colon0i
              i: 0
              min: 1
              r: 1
              s: 0
              text: i
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_527Colon0i_02 1
              dba: mod_internal__S_527Colon0i
              i: 0
              min: 10
              r: 1
              s: 0
              text: ignorecase
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_527Colon0i
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = $0 "
mod_internal__S_527Colon0i_02: *12
mod_internal__S_528Colona: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_528Colona
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &21 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_528Colona_01
            dba: mod_internal__S_528Colona
            i: 0
            min: 2
            name: mod_internal__S_528Colona_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_528Colona_01 0
                dba: mod_internal__S_528Colona
                i: 0
                min: 2
                r: 1
                s: 0
                text: :a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_528Colona_01 1
                dba: mod_internal__S_528Colona
                i: 0
                min: 13
                r: 1
                s: 0
                text: :ignoreaccent
        dba: mod_internal__S_528Colona
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_528Colona
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_528Colona
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = 1 "
mod_internal__S_528Colona_01: *21
mod_internal__S_529ColonBanga: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_529ColonBanga
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 3
          nobind: 1
          re: &2 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_529ColonBanga_01
            dba: mod_internal__S_529ColonBanga
            i: 0
            min: 3
            name: mod_internal__S_529ColonBanga_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_529ColonBanga_01 0
                dba: mod_internal__S_529ColonBanga
                i: 0
                min: 3
                r: 1
                s: 0
                text: :!a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_529ColonBanga_01 1
                dba: mod_internal__S_529ColonBanga
                i: 0
                min: 14
                r: 1
                s: 0
                text: :!ignoreaccent
        dba: mod_internal__S_529ColonBanga
        i: 0
        min: 3
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_529ColonBanga
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_529ColonBanga
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = 0 "
mod_internal__S_529ColonBanga_01: *2
mod_internal__S_530ColonaParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_530ColonaParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &28 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_530ColonaParen_Thesis_01
            dba: mod_internal__S_530ColonaParen_Thesis
            i: 0
            min: 2
            name: mod_internal__S_530ColonaParen_Thesis_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_530ColonaParen_Thesis_01 0
                dba: mod_internal__S_530ColonaParen_Thesis
                i: 0
                min: 2
                r: 1
                s: 0
                text: :a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_530ColonaParen_Thesis_01 1
                dba: mod_internal__S_530ColonaParen_Thesis
                i: 0
                min: 13
                r: 1
                s: 0
                text: :ignoreaccent
        dba: mod_internal__S_530ColonaParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_530ColonaParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_530ColonaParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = eval $<mod_arg>.Str "
mod_internal__S_530ColonaParen_Thesis_01: *28
mod_internal__S_531Colon0a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_531Colon0a
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_531Colon0a
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_531Colon0a
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &15 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_531Colon0a_02
          dba: mod_internal__S_531Colon0a
          i: 0
          min: 1
          name: mod_internal__S_531Colon0a_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_531Colon0a_02 0
              dba: mod_internal__S_531Colon0a
              i: 0
              min: 1
              r: 1
              s: 0
              text: a
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_531Colon0a_02 1
              dba: mod_internal__S_531Colon0a
              i: 0
              min: 12
              r: 1
              s: 0
              text: ignoreaccent
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_531Colon0a
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = $0 "
mod_internal__S_531Colon0a_02: *15
mod_internal__S_532Colons: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_532Colons
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_532Colons
        i: 0
        min: 2
        r: 1
        s: 0
        text: :s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_532Colons
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_532Colons
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_532Colons
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = 1 "
mod_internal__S_533ColonBangs: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_533ColonBangs
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_533ColonBangs
        i: 0
        min: 3
        r: 1
        s: 0
        text: :!s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_533ColonBangs
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_533ColonBangs
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_533ColonBangs
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = 0 "
mod_internal__S_534ColonsParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_534ColonsParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_534ColonsParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: :s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_534ColonsParen_Thesis
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_534ColonsParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_534ColonsParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = eval $<mod_arg>.Str "
mod_internal__S_535Colon0s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_535Colon0s
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_535Colon0s
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_535Colon0s
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_535Colon0s
        i: 0
        min: 1
        r: 1
        s: 0
        text: s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_535Colon0s
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_535Colon0s
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_535Colon0s
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = $0 "
mod_internal__S_536Colonr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_536Colonr
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_536Colonr
        i: 0
        min: 2
        r: 1
        s: 0
        text: :r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_536Colonr
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_536Colonr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_536Colonr
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = 1 "
mod_internal__S_537ColonBangr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_537ColonBangr
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_537ColonBangr
        i: 0
        min: 3
        r: 1
        s: 0
        text: :!r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_537ColonBangr
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_537ColonBangr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_537ColonBangr
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = 0 "
mod_internal__S_538ColonrParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_538ColonrParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_538ColonrParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: :r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_538ColonrParen_Thesis
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_538ColonrParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_538ColonrParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_538ColonrParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = eval $<mod_arg>.Str "
mod_internal__S_539Colon0r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_539Colon0r
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_539Colon0r
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_539Colon0r
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_539Colon0r
        i: 0
        min: 1
        r: 1
        s: 0
        text: r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_539Colon0r
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_539Colon0r
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_539Colon0r
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = $0 "
mod_internal__S_540ColonPerl5: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_540ColonPerl5
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 3
        re: &10 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_540ColonPerl5_01
          dba: mod_internal__S_540ColonPerl5
          i: 0
          min: 3
          name: mod_internal__S_540ColonPerl5_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_540ColonPerl5_01 0
              dba: mod_internal__S_540ColonPerl5
              i: 0
              min: 6
              r: 1
              s: 0
              text: :Perl5
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_540ColonPerl5_01 1
              dba: mod_internal__S_540ColonPerl5
              i: 0
              min: 3
              r: 1
              s: 0
              text: :P5
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_540ColonPerl5
          i: 0
          lang: ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($::GOAL) )
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_540ColonPerl5
              i: 0
              lang: ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($::GOAL) )
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($::GOAL) );  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_540ColonPerl5
              i: 0
              lang: ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($::GOAL) )
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
mod_internal__S_540ColonPerl5_01: *10
mod_internal__S_541adv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_541adv
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_541adv
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12346
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_541adv
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: mod_internal__S_541adv
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: mod_internal__S_541adv
                  i: 0
                  min: 12345
                  name: identifier
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_541adv
          i: 0
          lang: ($C->cursor_fresh($::LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_541adv
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_541adv
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              min: 12345
              name: quotepair
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_541adv
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := : $<quotepair><key> "
mod_internal__S_542oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_542oops
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_542oops
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: mod_internal__S_542oops
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized regex modifier")
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $sigspace    is context<rw> = $*sigspace    // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ratchet     is context<rw> = $*ratchet     // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignorecase is context<rw> = $*ignorecase // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignoreaccent    is context<rw> = $*ignoreaccent    // 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: nibbler
            i: 0
            min: 1
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: \s
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_qw 
                a: 0
                dba: nibbler
                i: 0
                min: 1
                r: 1
                s: 1
                text: < || | && & >
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: nibbler
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
normspace: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: normspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: normspace
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &25 !!perl/hash:RE_any 
              a: 0
              altname: normspace_01
              dba: normspace
              i: 0
              min: 1
              name: normspace_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: normspace_01 0
                  dba: normspace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: normspace_01 1
                  dba: normspace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "#"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: normspace
          i: 0
          lang: ($C->cursor_fresh($::LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: normspace
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: normspace
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
normspace_01: *25
quantified_atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantified_atom
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: stopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: rxinfix
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: atom
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantified_atom
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: quantifier
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantifier__S_543Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_543Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_543Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_543Star
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_544Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_544Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_544Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_544Plus
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_545Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_545Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_545Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_545Question
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_546StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_546StarStar
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_546StarStar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "**"
      - !!perl/hash:RE_meta 
        a: 0
        dba: quantifier__S_546StarStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quantifier__S_546StarStar
          i: 0
          min: 12345
          name: normspace
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_546StarStar
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quantifier__S_546StarStar
          i: 0
          min: 12345
          name: normspace
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &5 !!perl/hash:RE_any 
          a: 0
          altname: quantifier__S_546StarStar_01
          dba: quantifier__S_546StarStar
          i: 0
          min: 1
          name: quantifier__S_546StarStar_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quantifier__S_546StarStar_01 0
              dba: quantifier__S_546StarStar
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: quantifier__S_546StarStar
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \d
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 3
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: quantifier__S_546StarStar
                      i: 0
                      min: 3
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: quantifier__S_546StarStar
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: ..
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: &13 !!perl/hash:RE_any 
                            a: 0
                            altname: quantifier__S_546StarStar_03
                            dba: quantifier__S_546StarStar
                            i: 0
                            min: 1
                            name: quantifier__S_546StarStar_03
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_quantified_atom 
                                alt: quantifier__S_546StarStar_03 0
                                atom: !!perl/hash:RE_meta 
                                  a: 0
                                  dba: quantifier__S_546StarStar
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \d
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: quantifier__S_546StarStar_03 1
                                dba: quantifier__S_546StarStar
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "*"
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_546StarStar_01 1
              dba: quantifier__S_546StarStar
              i: 0
              min: 12345
              name: codeblock
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_546StarStar_01 2
              dba: quantifier__S_546StarStar
              i: 0
              min: 12345
              name: quantified_atom
              r: 1
              rest: ''
              s: 0
quantifier__S_546StarStar_01: *5
quantifier__S_546StarStar_03: *13
quantifier__S_547TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_547TildeTilde
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &20 !!perl/hash:RE_any 
          a: 0
          altname: quantifier__S_547TildeTilde_01
          dba: quantifier__S_547TildeTilde
          i: 0
          min: 12345
          name: quantifier__S_547TildeTilde_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quantifier__S_547TildeTilde_01 0
              dba: quantifier__S_547TildeTilde
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: quantifier__S_547TildeTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quantifier__S_547TildeTilde
                  i: 0
                  min: 12345
                  name: sym
                  r: 1
                  rest: ''
                  s: 0
                  sym: ~~
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_547TildeTilde_01 1
              dba: quantifier__S_547TildeTilde
              i: 0
              min: 12345
              name: sym
              r: 1
              rest: ''
              s: 0
              sym: ~~
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_547TildeTilde
        i: 0
        min: 12345
        name: normspace
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_547TildeTilde
        i: 0
        min: 12345
        name: quantified_atom
        r: 1
        rest: ''
        s: 0
quantifier__S_547TildeTilde_01: *20
quantmod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantmod
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: quantmod
          i: 0
          min: 1
          r: 1
          s: 0
          text: ":"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &9 !!perl/hash:RE_any 
            a: 0
            altname: quantmod_01
            dba: quantmod
            i: 0
            min: 1
            name: quantmod_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 0
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: "?"
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 1
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: "!"
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 2
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: +
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantmod_01: *9
rxinfix__S_445VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_445VertVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "||"
rxinfix__S_446AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_446AmpAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&&"
rxinfix__S_447Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_447Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
rxinfix__S_448Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_448Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
rxinfix__S_449Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_449Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
sign: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: &8 !!perl/hash:RE_any 
    a: 0
    altname: sign_00
    dba: sign
    i: 0
    min: 0
    name: sign_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        alt: sign_00 0
        dba: sign
        i: 0
        min: 1
        r: 1
        s: 0
        text: +
      - !!perl/hash:RE_string 
        a: 0
        alt: sign_00 1
        dba: sign
        i: 0
        min: 1
        r: 1
        s: 0
        text: "-"
      - !!perl/hash:RE_assertion 
        alt: sign_00 2
        assert: "?"
        min: 0
        re: !!perl/hash:RE_noop 
          a: 0
          dba: sign
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
sign_00: *8
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: termish
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: termish
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_method 
            a: 0
            dba: termish
            i: 0
            min: 12345
            name: quantified_atom
            r: 1
            rest: ''
            s: 0
          min: 12345
          nobind: 1
          quant: 
            - +
            - ":"
            - ''
            - 1
        dba: termish
        i: 0
        min: 12345
        r: 1
        s: 0
        var: noun
ws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: ws
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: ws
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*sigspace "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: ws
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: ws
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &23 !!perl/hash:RE_any 
                      a: 0
                      altname: ws_03
                      dba: ws
                      i: 0
                      min: 1
                      name: ws_03
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          alt: ws_03 0
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: ws_03 1
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "#"
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: ws
                i: 0
                min: 12345
                name: nextsame
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws_03: *23
RETREE_END
}
} ## end grammar

{ package STD::P5Regex;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'global' or $k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'ignorecase' or $k eq 'i') {
my $i = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks

##     token category__S_548metachar (:$sym is context<rw> = 'metachar')
##          token category:metachar { <sym> }

sub category__S_548metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_548metachar',$retree) }
sub category__S_548metachar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'metachar';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_548metachar", 
$C->_PATTERN(qr/\Gmetachar/)
);
}
#proto token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'metachar:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "metachar", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_549backslash (:$sym is context<rw> = 'backslash')
##          token category:backslash { <sym> }

sub category__S_549backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_549backslash',$retree) }
sub category__S_549backslash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'backslash';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_549backslash", 
$C->_PATTERN(qr/\Gbackslash/)
);
}
#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_550assertion (:$sym is context<rw> = 'assertion')
##          token category:assertion { <sym> }

sub category__S_550assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_550assertion',$retree) }
sub category__S_550assertion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'assertion';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_550assertion", 
$C->_PATTERN(qr/\Gassertion/)
);
}
#proto token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "assertion", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_551quantifier (:$sym is context<rw> = 'quantifier')
##          token category:quantifier { <sym> }

sub category__S_551quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_551quantifier',$retree) }
sub category__S_551quantifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quantifier';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_551quantifier", 
$C->_PATTERN(qr/\Gquantifier/)
);
}
#proto token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'quantifier:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quantifier", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_552mod_internal (:$sym is context<rw> = 'mod_internal')
##          token category:mod_internal { <sym> }

sub category__S_552mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_552mod_internal',$retree) }
sub category__S_552mod_internal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod_internal';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_552mod_internal", 
$C->_PATTERN(qr/\Gmod_internal/)
);
}
#proto token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'mod_internal:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "mod_internal", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


#proto token rxinfix { <...> }
sub rxinfix__PEEK { $_[0]->_AUTOLEXpeek('rxinfix:*',$retree); }
sub rxinfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'rxinfix') {
$C->deb("Fate passed to rxinfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'rxinfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("rxinfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "rxinfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


# suppress fancy end-of-line checking
##     token codeblock
##          token codeblock {
##              :my $GOAL is context = '}';
##              '{' :: [ :lang($.cursor_fresh($*LANG)) <statementlist> ]
##              [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
##          }

sub codeblock__PEEK { $_[0]->_AUTOLEXpeek('codeblock',$retree) }
sub codeblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL =  '}';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "codeblock", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->panic("Unable to parse statement list; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
);
}

##     rule nibbler
##          rule nibbler {
##              :my $ignorecase is context<rw> = $*ignorecase // 0;
##              <EXPR>
##          }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::ignorecase =  $::ignorecase // 0;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token termish
##          token termish {
##              <.ws>  # XXX assuming old /x here?
##              <noun=quantified_atom>+
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantified_atom'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->ws)) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['noun','quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
});
}
else {
();
}
}
);
}
##     token infixish
##          token infixish {
##              <!infixstopper>
##              <!stdstopper>
##              <rxinfix>
##              {
##                  $<O> = $<rxinfix><O>;
##                  $<sym> = $<rxinfix><sym>;
##              }
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rxinfix'], sub {
my $C = shift;
$C->rxinfix
}))) {
scalar(do {
my $M = $C; 
$M->{O} = $M->{rxinfix}{O};
$M->{sym} = $M->{rxinfix}{sym};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token rxinfix__S_553Vert (  :$sym is context<rw> = <|> --> Junctive_or )
##          token rxinfix:sym<|> ( --> Junctive_or ) { <sym> }

sub rxinfix__S_553Vert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_553Vert',$retree) }
sub rxinfix__S_553Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_553Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}

##     token quantified_atom
##          token quantified_atom {
##              <!stopper>
##              <!rxinfix>
##              <atom>
##              [ <.ws> <quantifier>
##      #            <?{ $<atom>.max_width }>
##      #                || <.panic: "Can't quantify zero-width atom">
##              ]?
##              <.ws>
##          }

sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom',$retree) }
sub quantified_atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantifier'} = [];

$self->_MATCHIFYr($S, "quantified_atom", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->rxinfix
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
});
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token atom
##          token atom {
##              [
##              | \w
##              | <metachar>
##              | '\\' :: .
##              ]
##          }

sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom',$retree) }
sub atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "atom", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'atom_01') {
$C->deb("Fate passed to atom_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'atom_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("atom_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?s:.)/)
}, $C->_COMMITBRANCH())
}, $C->_EXACT('\\'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# sequence stoppers
##     token metachar__S_554Vert (:$sym is context<rw> = <|>)
##          token metachar:sym<|>   { '|'  :: <fail> }

sub metachar__S_554Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_554Vert',$retree) }
sub metachar__S_554Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_554Vert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('|'))
);
}
##     token metachar__S_555Thesis (:$sym is context<rw> = <)>)
##          token metachar:sym<)>   { ')'  :: <fail> }

sub metachar__S_555Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_555Thesis',$retree) }
sub metachar__S_555Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_555Thesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(')'))
);
}

##     token metachar__S_556quant (:$sym is context<rw> = 'quant')
##          token metachar:quant { <quantifier> <.panic: "quantifier quantifies nothing"> }

sub metachar__S_556quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_556quant',$retree) }
sub metachar__S_556quant {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quant';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_556quant", 
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->panic("quantifier quantifies nothing");
}
else {
();
}
}
);
}

# "normal" metachars

##     token metachar__S_557Bra_Ket (:$sym is context<rw> = <[ ]>)
##          token metachar:sym<[ ]> {
##              <before '['> <quibble($.cursor_fresh( ::STD::Q ).tweak(:q))> # XXX parse as q[] for now
##          }

sub metachar__S_557Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_557Bra_Ket',$retree) }
sub metachar__S_557Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_557Bra_Ket", 
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
});
}
else {
();
}
}
);
}

##     token metachar__S_558ParenQuestion_Thesis (:$sym is context<rw> = (? ))
##          token metachar:sym(? ) {
##              '(?' {} <assertion>
##              [ ')' || <.panic: "Perl 5 regex assertion not terminated by parenthesis"> ]
##          }

sub metachar__S_558ParenQuestion_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_558ParenQuestion_Thesis',$retree) }
sub metachar__S_558ParenQuestion_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['(?',')'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_558ParenQuestion_Thesis", 
do {
if (my ($C) = ($C->_EXACT('(?'))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Perl 5 regex assertion not terminated by parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_559Paren_Thesis (:$sym is context<rw> = <( )>)
##          token metachar:sym<( )> {
##              '(' {} [:lang(self.unbalanced(')')) <nibbler>]?
##              [ ')' || <.panic: "Unable to parse Perl 5 regex; couldn't find right parenthesis"> ]
##              { $/<sym> := <( )> }
##          }

sub metachar__S_559Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_559Paren_Thesis',$retree) }
sub metachar__S_559Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'nibbler'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_559Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Unable to parse Perl 5 regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw[( )]] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_560Back (:$sym is context<rw> = <\\>)
##          token metachar:sym<\\> { <sym> <backslash> }

sub metachar__S_560Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_560Back',$retree) }
sub metachar__S_560Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_560Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##     token metachar__S_561Dot (:$sym is context<rw> = <.>)
##          token metachar:sym<.>  { <sym> }

sub metachar__S_561Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_561Dot',$retree) }
sub metachar__S_561Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_561Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token metachar__S_562Caret (:$sym is context<rw> = <^>)
##          token metachar:sym<^>  { <sym> }

sub metachar__S_562Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_562Caret',$retree) }
sub metachar__S_562Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_562Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
##     token metachar__S_563Dollar (:$sym is context<rw> = <$>)
##          token metachar:sym<$>  {
##              '$' <?before \W | $>
##          }

sub metachar__S_563Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_563Dollar',$retree) }
sub metachar__S_563Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_563Dollar", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'metachar__S_563Dollar_01') {
$C->deb("Fate passed to metachar__S_563Dollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'metachar__S_563Dollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar__S_563Dollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token metachar__S_564var (:$sym is context<rw> = 'var')
##          token metachar:var {
##              <?before <sigil>\w>
##              <.panic: "Can't interpolate variable in Perl 5 regex">
##          }

sub metachar__S_564var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_564var',$retree) }
sub metachar__S_564var {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'var';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_564var", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
$C->_PATTERN(qr/\G\w/);
}
else {
();
}
}
}))) {
$C->panic("Can't interpolate variable in Perl 5 regex");
}
else {
();
}
}
);
}

##     token backslash__S_565A (:$sym is context<rw> = 'A')
##          token backslash:A { <sym> }

sub backslash__S_565A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_565A',$retree) }
sub backslash__S_565A {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'A';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_565A", 
$C->_PATTERN(qr/\GA/)
);
}
##     token backslash__S_566a (:$sym is context<rw> = 'a')
##          token backslash:a { <sym> }

sub backslash__S_566a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_566a',$retree) }
sub backslash__S_566a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_566a", 
$C->_PATTERN(qr/\Ga/)
);
}
##     token backslash__S_567b (:$sym is context<rw> = 'b')
##          token backslash:b { :i <sym> }

sub backslash__S_567b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_567b',$retree) }
sub backslash__S_567b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_567b", 
$C->_PATTERN(qr/\G(?i:b)/)
);
}
##     token backslash__S_568c (:$sym is context<rw> = 'c')
##          token backslash:c { :i <sym>
##              <[ ?.._ ]> || <.panic: "Unrecognized \\c character">
##          }

sub backslash__S_568c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_568c',$retree) }
sub backslash__S_568c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_568c", 
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:c)(?i:[?-_])/)} 
or
eval { push @gather, $C->panic("Unrecognized \\c character")} or do { die $@ if $@ };
@gather;
}
);
}
##     token backslash__S_569d (:$sym is context<rw> = 'd')
##          token backslash:d { :i <sym> }

sub backslash__S_569d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_569d',$retree) }
sub backslash__S_569d {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'd';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_569d", 
$C->_PATTERN(qr/\G(?i:d)/)
);
}
##     token backslash__S_570e (:$sym is context<rw> = 'e')
##          token backslash:e { :i <sym> }

sub backslash__S_570e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_570e',$retree) }
sub backslash__S_570e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_570e", 
$C->_PATTERN(qr/\G(?i:e)/)
);
}
##     token backslash__S_571f (:$sym is context<rw> = 'f')
##          token backslash:f { :i <sym> }

sub backslash__S_571f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_571f',$retree) }
sub backslash__S_571f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_571f", 
$C->_PATTERN(qr/\G(?i:f)/)
);
}
##     token backslash__S_572h (:$sym is context<rw> = 'h')
##          token backslash:h { :i <sym> }

sub backslash__S_572h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_572h',$retree) }
sub backslash__S_572h {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_572h", 
$C->_PATTERN(qr/\G(?i:h)/)
);
}
##     token backslash__S_573l (:$sym is context<rw> = 'l')
##          token backslash:l { :i <sym> }

sub backslash__S_573l__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_573l',$retree) }
sub backslash__S_573l {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'l';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_573l", 
$C->_PATTERN(qr/\G(?i:l)/)
);
}
##     token backslash__S_574n (:$sym is context<rw> = 'n')
##          token backslash:n { :i <sym> }

sub backslash__S_574n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_574n',$retree) }
sub backslash__S_574n {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_574n", 
$C->_PATTERN(qr/\G(?i:n)/)
);
}
##     token backslash__S_575o (:$sym is context<rw> = 'o')
##          token backslash:o { '0' [ <octint> | '{'<octint>[','<octint>]*'}' ]? }

sub backslash__S_575o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_575o',$retree) }
sub backslash__S_575o {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{_pos};
$C->{'octint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_575o", 
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_575o_01') {
$C->deb("Fate passed to backslash__S_575o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_575o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_575o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(','))) {
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
});
}
else {
();
}
}
})
}))) {
$C->_EXACT('}');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}
##     token backslash__S_576p (:$sym is context<rw> = 'p')
##          token backslash:p { :i <sym> '{' <[\w:]>+ '}' }

sub backslash__S_576p__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_576p',$retree) }
sub backslash__S_576p {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'p';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_576p", 
$C->_PATTERN(qr/\G(?i:p)(?i:\{)((?:(?i:[\w:]))++)(?i:\})/)
);
}
##     token backslash__S_577Q (:$sym is context<rw> = 'Q')
##          token backslash:Q { <sym> }

sub backslash__S_577Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_577Q',$retree) }
sub backslash__S_577Q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_577Q", 
$C->_PATTERN(qr/\GQ/)
);
}
##     token backslash__S_578r (:$sym is context<rw> = 'r')
##          token backslash:r { :i <sym> }

sub backslash__S_578r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_578r',$retree) }
sub backslash__S_578r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_578r", 
$C->_PATTERN(qr/\G(?i:r)/)
);
}
##     token backslash__S_579s (:$sym is context<rw> = 's')
##          token backslash:s { :i <sym> }

sub backslash__S_579s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_579s',$retree) }
sub backslash__S_579s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_579s", 
$C->_PATTERN(qr/\G(?i:s)/)
);
}
##     token backslash__S_580t (:$sym is context<rw> = 't')
##          token backslash:t { :i <sym> }

sub backslash__S_580t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_580t',$retree) }
sub backslash__S_580t {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_580t", 
$C->_PATTERN(qr/\G(?i:t)/)
);
}
##     token backslash__S_581u (:$sym is context<rw> = 'u')
##          token backslash:u { :i <sym> }

sub backslash__S_581u__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_581u',$retree) }
sub backslash__S_581u {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'u';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_581u", 
$C->_PATTERN(qr/\G(?i:u)/)
);
}
##     token backslash__S_582v (:$sym is context<rw> = 'v')
##          token backslash:v { :i <sym> }

sub backslash__S_582v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_582v',$retree) }
sub backslash__S_582v {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'v';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_582v", 
$C->_PATTERN(qr/\G(?i:v)/)
);
}
##     token backslash__S_583w (:$sym is context<rw> = 'w')
##          token backslash:w { :i <sym> }

sub backslash__S_583w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_583w',$retree) }
sub backslash__S_583w {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_583w", 
$C->_PATTERN(qr/\G(?i:w)/)
);
}
##     token backslash__S_584x (:$sym is context<rw> = 'x')
##          token backslash:x { :i <sym> [ <hexint> | '{' [<.ws><hexint><.ws> ] ** ',' '}' ] }

sub backslash__S_584x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_584x',$retree) }
sub backslash__S_584x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'hexint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_584x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:x)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_584x_01') {
$C->deb("Fate passed to backslash__S_584x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_584x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_584x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\{)/))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_PATTERN(qr/\G(?i:\,)/)
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G(?i:\})/);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_585z (:$sym is context<rw> = 'z')
##          token backslash:z { :i <sym> }

sub backslash__S_585z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_585z',$retree) }
sub backslash__S_585z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'z';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_585z", 
$C->_PATTERN(qr/\G(?i:z)/)
);
}
##     token backslash__S_586misc (:$sym is context<rw> = 'misc')
##          token backslash:misc { $<litchar>=(\W) | $<number>=(\d+) }

sub backslash__S_586misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_586misc',$retree) }
sub backslash__S_586misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_586misc", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_586misc_00') {
$C->deb("Fate passed to backslash__S_586misc_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_586misc_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_586misc_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}
##     token backslash__S_587oops (:$sym is context<rw> = 'oops')
##          token backslash:oops { <.panic: "Unrecognized Perl 5 regex backslash sequence"> }

sub backslash__S_587oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_587oops',$retree) }
sub backslash__S_587oops {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_587oops", 
$C->panic("Unrecognized Perl 5 regex backslash sequence")
);
}

##     token assertion__S_588Question (:$sym is context<rw> = <?>)
##          token assertion:sym<?> { <sym> <codeblock> }

sub assertion__S_588Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_588Question',$retree) }
sub assertion__S_588Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_588Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
});
}
else {
();
}
}
);
}
##     token assertion__S_589Cur_Ly (:$sym is context<rw> = <{ }>)
##          token assertion:sym<{ }> { <codeblock> }

sub assertion__S_589Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_589Cur_Ly',$retree) }
sub assertion__S_589Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_589Cur_Ly", 
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
);
}

##     token assertion__S_590Lt (:$sym is context<rw> = <)
##          token assertion:sym< { <sym> <?before '=' | '!'> <assertion> }

sub assertion__S_590Lt__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_590Lt',$retree) }
sub assertion__S_590Lt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_590Lt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\</))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_590Lt_01') {
$C->deb("Fate passed to assertion__S_590Lt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_590Lt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_590Lt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_EXACT('!')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token assertion__S_591Equal (:$sym is context<rw> = <=>)
##          token assertion:sym<=> { <sym> [ <?before ')'> | <rx> ] }

sub assertion__S_591Equal__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_591Equal',$retree) }
sub assertion__S_591Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_591Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_591Equal_01') {
$C->deb("Fate passed to assertion__S_591Equal_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_591Equal_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_591Equal_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_592Bang (:$sym is context<rw> = <!>)
##          token assertion:sym<!> { <sym> [ <?before ')'> | <rx> ] }

sub assertion__S_592Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_592Bang',$retree) }
sub assertion__S_592Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_592Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_592Bang_01') {
$C->deb("Fate passed to assertion__S_592Bang_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_592Bang_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_592Bang_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_593Gt (:$sym is context<rw> = >)
##          token assertion:sym> { <sym> <rx> }

sub assertion__S_593Gt__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_593Gt',$retree) }
sub assertion__S_593Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_593Gt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>/))) {
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
});
}
else {
();
}
}
);
}

##     token rx
##          token rx {
##              #[:lang(self.unbalanced(')')) <nibbler>]
##              <nibbler>
##              [ <?before ')'> || <.panic: "Unable to parse Perl 5 regex; couldn't find right parenthesis"> ]
##          }

sub rx__PEEK { $_[0]->_AUTOLEXpeek('rx',$retree) }
sub rx {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "rx", 
do {
if (my ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
$C->_EXACT(')')
})} 
or
eval { push @gather, $C->panic("Unable to parse Perl 5 regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}

#token assertion'identifier' => 1 { q(longname) [               # is qq right here?
#                                | [qw[?before ')' ]]
#                                | q(.ws) q(nibbler)
#                               ]
#                               [ ':' q(rx) ]?
#}
##     token p5mod
##          token p5mod { <[imox]>* }

sub p5mod__PEEK { $_[0]->_AUTOLEXpeek('p5mod',$retree) }
sub p5mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "p5mod", 
$C->_PATTERN(qr/\G((?:[imox])*+)/)
);
}
##     token p5mods
##          token p5mods { <on=p5mod> [ '-' <off=p5mod> ]? }

sub p5mods__PEEK { $_[0]->_AUTOLEXpeek('p5mods',$retree) }
sub p5mods {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'off'} = [];

$self->_MATCHIFYr($S, "p5mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['on'], sub {
my $C = shift;
$C->p5mod
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-'))) {
$C->_SUBSUMEr(['off'], sub {
my $C = shift;
$C->p5mod
});
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}
##     token assertion__S_594mod (:$sym is context<rw> = 'mod')
##          token assertion:mod { <p5mods> [               # is qq right here?
##                                         | ':' <rx>?
##                                         | <?before ')' >
##                                         ]
##          }

sub assertion__S_594mod__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_594mod',$retree) }
sub assertion__S_594mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod';


my $C = $self;
my $S = $C->{_pos};
$C->{'rx'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_594mod", 
do {
if (my ($C) = ($C->_SUBSUMEr(['p5mods'], sub {
my $C = shift;
$C->p5mods
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_594mod_01') {
$C->deb("Fate passed to assertion__S_594mod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_594mod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_594mod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_595bogus (:$sym is context<rw> = 'bogus')
##          token assertion:bogus { <.panic: "Unrecognized Perl 5 regex assertion"> }

sub assertion__S_595bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_595bogus',$retree) }
sub assertion__S_595bogus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'bogus';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_595bogus", 
$C->panic("Unrecognized Perl 5 regex assertion")
);
}

##     token quantifier__S_596Star (:$sym is context<rw> = <*>)
##          token quantifier:sym<*>  { <sym> <quantmod> }

sub quantifier__S_596Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_596Star',$retree) }
sub quantifier__S_596Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_596Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_597Plus (:$sym is context<rw> = <+>)
##          token quantifier:sym<+>  { <sym> <quantmod> }

sub quantifier__S_597Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_597Plus',$retree) }
sub quantifier__S_597Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_597Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_598Question (:$sym is context<rw> = <?>)
##          token quantifier:sym<?>  { <sym> <quantmod> }

sub quantifier__S_598Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_598Question',$retree) }
sub quantifier__S_598Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_598Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_599Cur_Ly (:$sym is context<rw> = <{ }>)
##          token quantifier:sym<{ }> { '{' \d+ [','\d*]? '}' <quantmod> }

sub quantifier__S_599Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_599Cur_Ly',$retree) }
sub quantifier__S_599Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_599Cur_Ly", 
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(','))) {
$C->_PATTERN(qr/\G((?:\d)*+)/);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('}'))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantmod
##          token quantmod { [ '?' | '+' ]? }

sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod',$retree) }
sub quantmod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quantmod", 
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantmod_01') {
$C->deb("Fate passed to quantmod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'quantmod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantmod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('?')
},
sub { my $C=shift;
$C->_EXACT('+')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
assertion__S_588Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_588Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_588Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_588Question
        i: 0
        min: 12345
        name: codeblock
        r: 1
        rest: ''
        s: 0
assertion__S_589Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_589Cur_Ly
    i: 0
    min: 12345
    name: codeblock
    r: 1
    rest: ''
    s: 0
assertion__S_590Lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_590Lt
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_590Lt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_590Lt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &5 !!perl/hash:RE_any 
              a: 0
              altname: assertion__S_590Lt_01
              dba: assertion__S_590Lt
              i: 0
              min: 1
              name: assertion__S_590Lt_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: assertion__S_590Lt_01 0
                  dba: assertion__S_590Lt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_string 
                  a: 0
                  alt: assertion__S_590Lt_01 1
                  dba: assertion__S_590Lt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_590Lt
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
assertion__S_590Lt_01: *5
assertion__S_591Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_591Equal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_591Equal
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &8 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_591Equal_01
          dba: assertion__S_591Equal
          i: 0
          min: 0
          name: assertion__S_591Equal_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_591Equal_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_591Equal
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_591Equal
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_591Equal_01 1
              dba: assertion__S_591Equal
              i: 0
              min: 12345
              name: rx
              r: 1
              rest: ''
              s: 0
assertion__S_591Equal_01: *8
assertion__S_592Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_592Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_592Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &10 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_592Bang_01
          dba: assertion__S_592Bang
          i: 0
          min: 0
          name: assertion__S_592Bang_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_592Bang_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_592Bang
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_592Bang
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_592Bang_01 1
              dba: assertion__S_592Bang
              i: 0
              min: 12345
              name: rx
              r: 1
              rest: ''
              s: 0
assertion__S_592Bang_01: *10
assertion__S_593Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_593Gt
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_593Gt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ">"
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_593Gt
        i: 0
        min: 12345
        name: rx
        r: 1
        rest: ''
        s: 0
assertion__S_594mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_594mod
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_594mod
        i: 0
        min: 12345
        name: p5mods
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &4 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_594mod_01
          dba: assertion__S_594mod
          i: 0
          min: 0
          name: assertion__S_594mod_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_594mod_01 0
              dba: assertion__S_594mod
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: assertion__S_594mod
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_594mod
                    i: 0
                    min: 12345
                    name: rx
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_assertion 
              alt: assertion__S_594mod_01 1
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_594mod
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_594mod
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
assertion__S_594mod_01: *4
assertion__S_595bogus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized Perl 5 regex assertion")
atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &3 !!perl/hash:RE_any 
      a: 0
      altname: atom_01
      dba: atom
      i: 0
      min: 1
      name: atom_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_meta 
          a: 0
          alt: atom_01 0
          dba: atom
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        - !!perl/hash:RE_method 
          a: 0
          alt: atom_01 1
          dba: atom
          i: 0
          min: 12345
          name: metachar
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: atom_01 2
          dba: atom
          i: 0
          min: 2
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: atom
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            - !!perl/hash:RE_meta 
              a: 0
              dba: atom
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_meta 
              a: 0
              dba: atom
              i: 0
              min: 1
              r: 1
              s: 0
              text: .
atom_01: *3
backslash__S_565A: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_565A
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: A
backslash__S_566a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_566a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
backslash__S_567b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_567b
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_568c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: backslash__S_568c
    i: 1
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: backslash__S_568c
        i: 1
        min: 12346
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: backslash__S_568c
            i: 1
            min: 12345
            name: sym
            r: 1
            rest: ''
            s: 0
            sym: c
          - !!perl/hash:RE_cclass 
            a: 0
            dba: backslash__S_568c
            i: 1
            min: 1
            r: 1
            s: 0
            text: "[ ?.._ ]"
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized \\c character")
backslash__S_569d: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_569d
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: d
backslash__S_570e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_570e
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_571f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_571f
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_572h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_572h
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
backslash__S_573l: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_573l
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: l
backslash__S_574n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_574n
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_575o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_575o
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_575o
        i: 0
        min: 1
        r: 1
        s: 0
        text: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &6 !!perl/hash:RE_any 
            a: 0
            altname: backslash__S_575o_01
            dba: backslash__S_575o
            i: 0
            min: 12345
            name: backslash__S_575o_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                alt: backslash__S_575o_01 0
                dba: backslash__S_575o
                i: 0
                min: 12345
                name: octint
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: backslash__S_575o_01 1
                dba: backslash__S_575o
                i: 0
                min: 12347
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: backslash__S_575o
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "{"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: backslash__S_575o
                    i: 0
                    min: 12345
                    name: octint
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_bracket 
                      decl: []

                      min: 12346
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: backslash__S_575o
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: backslash__S_575o
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: ","
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: backslash__S_575o
                            i: 0
                            min: 12345
                            name: octint
                            r: 1
                            rest: ''
                            s: 0
                    min: 0
                    quant: 
                      - "*"
                      - ":"
                      - ''
                      - 0
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: backslash__S_575o
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "}"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
backslash__S_575o_01: *6
backslash__S_576p: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_576p
    i: 1
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_576p
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: p
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_576p
        i: 1
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: backslash__S_576p
          i: 1
          min: 1
          r: 1
          s: 0
          text: "[\\w:]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_576p
        i: 1
        min: 1
        r: 1
        s: 0
        text: "}"
backslash__S_577Q: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_577Q
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: Q
backslash__S_578r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_578r
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_579s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_579s
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
backslash__S_580t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_580t
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_581u: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_581u
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: u
backslash__S_582v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_582v
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: v
backslash__S_583w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_583w
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
backslash__S_584x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_584x
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_584x
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &7 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_584x_01
          dba: backslash__S_584x
          i: 1
          min: 12345
          name: backslash__S_584x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_584x_01 0
              dba: backslash__S_584x
              i: 1
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_584x_01 1
              dba: backslash__S_584x
              i: 1
              min: 37037
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_584x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 37035
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_584x
                      i: 1
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_584x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_584x
                          i: 1
                          min: 12345
                          name: hexint
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_584x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                  min: 37035
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_584x
                      i: 1
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_584x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "}"
backslash__S_584x_01: *7
backslash__S_585z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_585z
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: z
backslash__S_586misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: &2 !!perl/hash:RE_any 
    a: 0
    altname: backslash__S_586misc_00
    dba: backslash__S_586misc
    i: 0
    min: 1
    name: backslash__S_586misc_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        alt: backslash__S_586misc_00 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_meta 
            a: 0
            dba: backslash__S_586misc
            i: 0
            min: 1
            r: 1
            s: 0
            text: \W
        dba: backslash__S_586misc
        i: 0
        min: 1
        r: 1
        s: 0
        var: litchar
      - !!perl/hash:RE_bindnamed 
        a: 0
        alt: backslash__S_586misc_00 1
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: backslash__S_586misc
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        dba: backslash__S_586misc
        i: 0
        min: 1
        r: 1
        s: 0
        var: number
backslash__S_586misc_00: *2
backslash__S_587oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized Perl 5 regex backslash sequence")
category__S_548metachar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_548metachar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: metachar
category__S_549backslash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_549backslash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: backslash
category__S_550assertion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_550assertion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: assertion
category__S_551quantifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_551quantifier
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quantifier
category__S_552mod_internal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_552mod_internal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod_internal
codeblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: codeblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codeblock
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codeblock
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: codeblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: codeblock
          i: 0
          lang: ($C->cursor_fresh($::LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG))
              min: 12345
              name: statementlist
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: codeblock
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: codeblock
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse statement list; couldn't find right brace")
infixish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infixish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: rxinfix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infixish
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n            $<O> = $<rxinfix><O>;\n            $<sym> = $<rxinfix><sym>;\n        "
metachar__S_554Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_554Vert
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_554Vert
        i: 0
        min: 1
        r: 1
        s: 0
        text: "|"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_554Vert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_554Vert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_555Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_555Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_555Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: )
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_555Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_555Thesis
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_556quant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_556quant
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_556quant
        i: 0
        min: 12345
        name: quantifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("quantifier quantifies nothing")
metachar__S_557Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_557Bra_Ket
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method_re 
        a: 0
        dba: metachar__S_557Bra_Ket
        i: 0
        min: 0
        name: before
        r: 1
        re: !!perl/hash:RE 
          decl: []

          min: 1
          re: !!perl/hash:RE_string 
            a: 0
            dba: metachar__S_557Bra_Ket
            i: 0
            min: 1
            r: 1
            s: 0
            text: "["
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q))
metachar__S_558ParenQuestion_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_558ParenQuestion_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_558ParenQuestion_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: (?
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_558ParenQuestion_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_558ParenQuestion_Thesis
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_558ParenQuestion_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_558ParenQuestion_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Perl 5 regex assertion not terminated by parenthesis")
metachar__S_559Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_559Paren_Thesis
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_559Paren_Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_559Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: metachar__S_559Paren_Thesis
            i: 0
            lang: ($self->unbalanced(')'))
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_decl 
                a: 0
                dba: metachar__S_559Paren_Thesis
                i: 0
                lang: ($self->unbalanced(')'))
                max: 0
                min: 0
                noquant: 1
                r: 1
                s: 0
                text: "my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); "
              - !!perl/hash:RE_method 
                a: 0
                dba: metachar__S_559Paren_Thesis
                i: 0
                lang: ($self->unbalanced(')'))
                min: 12345
                name: nibbler
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_559Paren_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_559Paren_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse Perl 5 regex; couldn't find right parenthesis")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_559Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <( )> "
metachar__S_560Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_560Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_560Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_560Back
        i: 0
        min: 12345
        name: backslash
        r: 1
        rest: ''
        s: 0
metachar__S_561Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_561Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
metachar__S_562Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_562Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
metachar__S_563Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_563Dollar
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_563Dollar
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_563Dollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: &9 !!perl/hash:RE_any 
              a: 0
              altname: metachar__S_563Dollar_01
              dba: metachar__S_563Dollar
              i: 0
              min: 0
              name: metachar__S_563Dollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_563Dollar_01 0
                  dba: metachar__S_563Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \W
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_563Dollar_01 1
                  dba: metachar__S_563Dollar
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $
          s: 0
metachar__S_563Dollar_01: *9
metachar__S_564var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_564var
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_564var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12346
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_564var
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_564var
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: metachar__S_564var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \w
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Can't interpolate variable in Perl 5 regex")
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignorecase is context<rw> = $*ignorecase // 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: nibbler
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
p5mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_cclass 
      a: 0
      dba: p5mod
      i: 0
      min: 1
      r: 1
      s: 0
      text: "[imox]"
    min: 0
    quant: 
      - "*"
      - ":"
      - ''
      - 0
p5mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: p5mods
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: p5mods
          i: 0
          min: 12345
          name: p5mod
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: p5mods
        i: 0
        min: 12345
        r: 1
        s: 0
        var: 'on'
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12346
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: p5mods
            i: 0
            min: 12346
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: p5mods
                i: 0
                min: 1
                r: 1
                s: 0
                text: "-"
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: p5mods
                  i: 0
                  min: 12345
                  name: p5mod
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                dba: p5mods
                i: 0
                min: 12345
                r: 1
                s: 0
                var: 'off'
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantified_atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantified_atom
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: stopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: rxinfix
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: atom
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantified_atom
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: quantifier
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
quantifier__S_596Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_596Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_596Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_596Star
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_597Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_597Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_597Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_597Plus
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_598Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_598Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_598Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_598Question
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_599Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_599Cur_Ly
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quantifier__S_599Cur_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: quantifier__S_599Cur_Ly
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantifier__S_599Cur_Ly
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: quantifier__S_599Cur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: ","
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: quantifier__S_599Cur_Ly
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: quantifier__S_599Cur_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        text: "}"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_599Cur_Ly
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantmod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 1
      re: &1 !!perl/hash:RE_any 
        a: 0
        altname: quantmod_01
        dba: quantmod
        i: 0
        min: 1
        name: quantmod_01
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_string 
            a: 0
            alt: quantmod_01 0
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: "?"
          - !!perl/hash:RE_string 
            a: 0
            alt: quantmod_01 1
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: +
    min: 0
    quant: 
      - "?"
      - ":"
      - ''
      - 0
quantmod_01: *1
rx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: rx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: rx
        i: 0
        min: 12345
        name: nibbler
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: rx
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: rx
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: rx
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse Perl 5 regex; couldn't find right parenthesis")
rxinfix__S_553Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_553Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: termish
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: termish
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_method 
            a: 0
            dba: termish
            i: 0
            min: 12345
            name: quantified_atom
            r: 1
            rest: ''
            s: 0
          min: 12345
          nobind: 1
          quant: 
            - +
            - ":"
            - ''
            - 1
        dba: termish
        i: 0
        min: 12345
        r: 1
        s: 0
        var: noun
RETREE_END
}
} ## end grammar

# token panic (Str $s) { <commit> <fail($s)> }

## method panic (Str $s)
sub panic {
my $self = shift;
my $s = shift;


my $m;
my $here = $self;

# Have we backed off recently?
my $highvalid = $self->{_pos} <= $::HIGHWATER;

$here = $self->cursor($::HIGHWATER) if $highvalid;

my $first = $here->lineof($COMPILING::LAST_NIBBLE->{'_from'});
my $last = $here->lineof($COMPILING::LAST_NIBBLE->{'_pos'});
if ($first != $last) {
if ($here->lineof($here->{_pos}) == $last) {
$m .= "\n(Possible runaway string from line $first)";
}
else {
$first = $here->lineof($COMPILING::LAST_NIBBLE_MULTILINE->{'_from'});
$last = $here->lineof($COMPILING::LAST_NIBBLE_MULTILINE->{'_pos'});
# the bigger the string (in lines), the further back we suspect it
if ($here->lineof($here->{_pos}) - $last < $last - $first ) {
$m .= "\n(Possible runaway string from line $first to line $last)";
}
}
}

$m .= "\n" . $s;

if ($highvalid) {
$m .= $::HIGHMESS if $::HIGHMESS;
$::HIGHMESS = $m;
}
else {
# not in backoff, so at "bleeding edge", as it were... therefore probably
# the exception will be caught and re-panicked later, so remember message
$::HIGHMESS .= "\n" . $s;
}

$m .= $here->locmess;

if ($highvalid and %$::HIGHEXPECT) {
my @keys = sort keys %$::HIGHEXPECT;
if (@keys > 1) {
$m .= "\n    expecting any of:\n\t" . join("\n\t", sort keys %$::HIGHEXPECT);
}
else {
$m .= "\n    expecting @keys" unless $keys[0] eq 'whitespace';
}
}
$m =~ s|Syntax error|Syntax error (two terms in a row?)| if $m =~ qr/infix|nofun/;

if (@COMPILING::WORRIES) {
$m .= "\nOther potential difficulties:\n  " . join( "\n  ", @COMPILING::WORRIES);
}

die "##### PARSE FAILED #####" . $m . "\n";
}

## method worry (Str $s)
sub worry {
my $self = shift;
my $s = shift;


push @COMPILING::WORRIES, $s . $self->locmess;
$self;
}

## method locmess ()
sub locmess {
my $self = shift;


my $pre = substr($::ORIG, 0, $self->{_pos});
my $line = $self->lineof($self->{_pos});
$pre = substr($pre, -40, 40);
1 while $pre =~ s!.*\n!!;
my $post = substr($::ORIG, $self->{_pos}, 40);
1 while $post =~ s!(\n.*)!!;
" at " . $COMPILING::FILE . " line $line:\n------> " . $Cursor::GREEN . $pre . $Cursor::RED . 
"$post$Cursor::CLEAR";
}

## method line
sub line {
my $self = shift;


$self->lineof($self->{_pos});
}

## method lineof ($p)
sub lineof {
my $self = shift;
my $p = shift;


return 1 unless defined $p;
my $line = $::MEMOS[$p]{'L'};
return $line if $line;
$line = 1;
my $pos = 0;
my @text = split(qr/^/,$::ORIG);   # XXX p5ism, should be ^^
for (@text) {
$::MEMOS[$pos++]{'L'} = $line
for 1 .. length($_);
$line++;
}
return $::MEMOS[$p]{'L'} // 0;
}

## method SETGOAL
sub SETGOAL {
my $self = shift;

}
## method FAILGOAL (Str $stop, Str $name)
sub FAILGOAL {
my $self = shift;
my $stop = shift;
my $name = shift;


$self->panic("Unable to parse $name; couldn't find final '$stop'");
}

# "when" arg assumes more things will become obsolete after Perl 6 comes out...
## method obs (Str $old, Str $new, Str $when = ' in Perl 6')
sub obs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


%$::HIGHEXPECT = ();
$self->panic("Obsolete use of $old;$when please use $new instead");
}

## method worryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub worryobs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


$self->worry("Possible obsolete use of $old;$when please use $new instead");
$self;
}

## vim: expandtab sw=4 ft=perl6
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
POST: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: POST
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: POST
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " @*MEMOS[$.pos]<ws> "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &17 !!perl/hash:RE_any 
            a: 0
            altname: POST_01
            dba: POST
            i: 0
            min: 1
            name: POST_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                alt: POST_01 0
                dba: POST
                i: 0
                min: 12345
                name: unsp
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_string 
                a: 0
                alt: POST_01 1
                dba: POST
                i: 0
                min: 1
                r: 1
                s: 0
                text: \
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: POST
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: POST
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: POST
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_method 
                          a: 0
                          dba: POST
                          i: 0
                          min: 12345
                          name: unsp
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                a: 0
                dba: POST
                i: 0
                min: 12345
                name: postfix_prefix_meta_operator
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: POST
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &55 !!perl/hash:RE_any 
          a: 0
          altname: POST_04
          dba: postfix
          i: 0
          min: 12345
          name: POST_04
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 0
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: dotty
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<dotty><O>;  $<sym> = $<dotty><sym>;  $<~CAPS> = $<dotty><~CAPS>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 1
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: privop
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<privop><O>; $<sym> = $<privop><sym>; $<~CAPS> = $<privop><~CAPS>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 2
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: postop
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<postop><O>; $<sym> = $<postop><sym>; $<~CAPS> = $<postop><~CAPS>; "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: postfix
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SIGIL = '@'; "
POST_01: *17
POST_04: *55
PRE: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix or meta-prefix
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &72 !!perl/hash:RE_any 
          a: 0
          altname: PRE_01
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          name: PRE_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: PRE_01 0
              dba: prefix or meta-prefix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or meta-prefix
                  i: 0
                  min: 12345
                  name: prefix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: prefix or meta-prefix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<prefix><O>; $<sym> = $<prefix><sym> "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'PRE_prefix'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: PRE_01 1
              dba: prefix or meta-prefix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or meta-prefix
                  i: 0
                  min: 12345
                  name: prefix_circumfix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: prefix or meta-prefix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.Str "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'PRE_precircum'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          name: prefix_postfix_meta_operator
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method_internal 
        args: $S, 'PRE_prepost'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix or meta-prefix
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
PRE_01: *72
apostrophe: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass 
    a: 0
    dba: apostrophe
    i: 0
    min: 1
    r: 1
    s: 0
    text: "[ ' \\- ]"
arglist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $inv_ok = $*INVOCANT_OK
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my StrPos $endargs is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = 'endargs'
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: argument list
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: arglist
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &29 !!perl/hash:RE_any 
          a: 0
          altname: arglist_01
          dba: argument list
          i: 0
          min: 0
          name: arglist_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: arglist_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: argument list
                i: 0
                min: 12345
                name: stdstopper
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: arglist_01 1
              dba: argument list
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %list_infix)
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: argument list
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            my $delims = $<EXPR><delims>;\n            for @$delims {\n                if ($_.<sym> // '') eq ':' {\n                    if $inv_ok {\n                        $*INVOCANT_IS = $<EXPR><list>[0];\n                    }\n                }\n            }\n        "
arglist_01: *29
args: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $listopish = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INVOCANT_OK is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INVOCANT_IS is context<rw>
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: "extra arglist after (...):"
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &112 !!perl/hash:RE_any 
          a: 0
          altname: args_01
          dba: argument list
          i: 0
          min: 0
          name: args_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 0
              dba: argument list
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semiarglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args_func_args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 1
              dba: argument list
              i: 0
              min: 24692
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semiarglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args_func_args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 2
              dba: argument list
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: argument list
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $listopish = 1 "
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: argument list
                      i: 0
                      min: 24690
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: argument list
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_meta 
                                a: 0
                                dba: argument list
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \s
                            s: 0
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: argument list
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $istype "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: argument list
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_method 
                            a: 0
                            dba: argument list
                            i: 0
                            min: 12345
                            name: infixstopper
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: argument list
                          i: 0
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: args
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<invocant> = $*INVOCANT_IS; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: "extra arglist after (...):"
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: "extra arglist after (...):"
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " $listopish "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: "extra arglist after (...):"
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: "extra arglist after (...):"
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: "extra arglist after (...):"
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: "extra arglist after (...):"
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \s
                    s: 0
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: "extra arglist after (...):"
                    i: 0
                    min: 12345
                    name: arglist
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: "extra arglist after (...):"
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: moreargs
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: "extra arglist after (...):"
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $<O> = {}; "
args_01: *112
babble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $lang = $l
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $start
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $stop
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: babble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: babble
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: babble
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: babble
                i: 0
                min: 12345
                name: quotepair
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: babble
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: babble
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            my $kv = $<quotepair>[*-1];\n            $lang = $lang.tweak($kv.<k>, $kv.<v>)\n                or self.panic(\"Unrecognized adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: babble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        ($start,$stop) = $.peek_delimiters();\n        $lang = $start ne $stop ?? $lang.balanced($start,$stop)\n                                !! $lang.unbalanced($stop);\n        $<B> = [$lang,$start,$stop];\n    "
block: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scoped block
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: scoped block
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: scoped block
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scoped block
        i: 0
        min: 12345
        name: newpad
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scoped block
        i: 0
        min: 12345
        name: blockoid
        r: 1
        rest: ''
        s: 0
blockoid: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: blockoid
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: blockoid
        i: 0
        min: 12345
        name: finishpad
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &133 !!perl/hash:RE_any 
          a: 0
          altname: blockoid_01
          dba: blockoid
          i: 0
          min: 0
          name: blockoid_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_01 0
              dba: blockoid
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: blockoid
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: blockoid
                  extra: "local $::GOAL = '}' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: blockoid
                  i: 0
                  min: 12345
                  name: statementlist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: blockoid
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "}"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: ('}' , 'blockoid')
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_01 1
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 12345
                    name: terminator
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ('Missing {...}')
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &66 !!perl/hash:RE_any 
          a: 0
          altname: blockoid_02
          dba: blockoid
          i: 0
          min: 0
          name: blockoid_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 0
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 0
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: blockoid
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: blockoid
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: blockoid
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid_endstmt_simple_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 1
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: blockoid
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[,:]"
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid_normal_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 2
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid_endstmt_complex'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 3
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endargs> = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid_endargs'
                  max: 0
                  min: 0
                  name: _REDUCE
blockoid_01: *133
blockoid_02: *66
capterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: capterm
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: capterm
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &128 !!perl/hash:RE_any 
          a: 0
          altname: capterm_01
          dba: capterm
          i: 0
          min: 2
          name: capterm_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: capterm_01 0
              dba: capterm
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: capterm
                    i: 0
                    min: 12345
                    name: capture
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: )
            - !!perl/hash:RE_sequence 
              a: 0
              alt: capterm_01 1
              dba: capterm
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: capterm
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: capterm
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \S
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 12345
                  name: termish
                  r: 1
                  rest: ''
                  s: 0
capterm_01: *128
capture: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: capture
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 1
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: capture
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: capture
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
category__S_000category: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_000category
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: category
category__S_001sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_001sigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: sigil
category__S_002twigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_002twigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: twigil
category__S_003special_variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_003special_variable
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: special_variable
category__S_004version: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_004version
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: version
category__S_005module_name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_005module_name
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: module_name
category__S_006noun: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_006noun
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: noun
category__S_007value: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_007value
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: value
category__S_008term: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_008term
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: term
category__S_009number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_009number
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: number
category__S_010quote: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_010quote
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote
category__S_011prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_011prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix
category__S_012infix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_012infix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix
category__S_013postfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_013postfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix
category__S_014dotty: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_014dotty
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: dotty
category__S_015circumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_015circumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: circumfix
category__S_016postcircumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_016postcircumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postcircumfix
category__S_017quote_mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_017quote_mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote_mod
category__S_018trait_verb: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_018trait_verb
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: trait_verb
category__S_019trait_auxiliary: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_019trait_auxiliary
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: trait_auxiliary
category__S_020type_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_020type_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: type_declarator
category__S_021scope_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_021scope_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: scope_declarator
category__S_022package_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_022package_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: package_declarator
category__S_023multi_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_023multi_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: multi_declarator
category__S_024routine_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_024routine_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: routine_declarator
category__S_025regex_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_025regex_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: regex_declarator
category__S_026statement_prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_026statement_prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_prefix
category__S_027statement_control: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_027statement_control
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_control
category__S_028statement_mod_cond: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_028statement_mod_cond
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_cond
category__S_029statement_mod_loop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_029statement_mod_loop
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_loop
category__S_030infix_prefix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_030infix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_prefix_meta_operator
category__S_031infix_postfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_031infix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_postfix_meta_operator
category__S_032infix_circumfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_032infix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_circumfix_meta_operator
category__S_033postfix_prefix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_033postfix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix_prefix_meta_operator
category__S_034prefix_postfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_034prefix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_postfix_meta_operator
category__S_035prefix_circumfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_035prefix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_circumfix_meta_operator
category__S_036terminator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_036terminator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: terminator
circumfix__S_115Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: circumfix__S_115Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: circumfix__S_115Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &116 !!perl/hash:RE_any 
              a: 0
              altname: circumfix__S_115Cur_Ly_01
              dba: circumfix__S_115Cur_Ly
              i: 0
              min: 1
              name: circumfix__S_115Cur_Ly_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: circumfix__S_115Cur_Ly_01 0
                  dba: circumfix__S_115Cur_Ly
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_method 
                  a: 0
                  alt: circumfix__S_115Cur_Ly_01 1
                  dba: circumfix__S_115Cur_Ly
                  i: 0
                  min: 12345
                  name: lambda
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: circumfix__S_115Cur_Ly
        i: 0
        min: 12345
        name: pblock
        r: 1
        rest: ''
        s: 0
circumfix__S_115Cur_Ly_01: *116
circumfix__S_300sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: contextualizer
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: contextualizer
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: contextualizer
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: contextualizer
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: contextualizer
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: contextualizer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: contextualizer
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'contextualizer')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: contextualizer
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SIGIL ||= $<sigil>.Str "
circumfix__S_301Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parenthesized expression
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: parenthesized expression
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: parenthesized expression
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: parenthesized expression
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: parenthesized expression
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: parenthesized expression
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'parenthesized expression')
circumfix__S_302Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: array composer
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: array composer
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_meta 
        a: 0
        dba: array composer
        extra: "local $::GOAL = ']' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: array composer
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: array composer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: array composer
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'array composer')
codepoint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codepoint
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codepoint
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: codepoint
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 0
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: codepoint
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_assertion 
                    assert: "!"
                    min: 0
                    re: !!perl/hash:RE_method_re 
                      a: 0
                      dba: codepoint
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE 
                        decl: []

                        min: 1
                        re: !!perl/hash:RE_string 
                          a: 0
                          dba: codepoint
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                      s: 0
                  - !!perl/hash:RE_meta 
                    a: 0
                    dba: codepoint
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .
            min: 0
            quant: 
              - "*"
              - "?"
              - ''
              - 0
        min: 0
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: codepoint
        i: 0
        min: 1
        r: 1
        s: 0
        text: "]"
colonpair: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: colonpair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $key
    - !!perl/hash:RE_decl 
      a: 0
      dba: colonpair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $value
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: colon pair
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: colonpair
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &34 !!perl/hash:RE_any 
          a: 0
          altname: colonpair_01
          dba: signature
          i: 0
          min: 12345
          name: colonpair_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 0
              dba: colon pair
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; $value = 0; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_false'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 1
              dba: colon pair
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: colon pair
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: num
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 2
              dba: colon pair
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: colon pair
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: colon pair
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: colon pair
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: colon pair
                            i: 0
                            min: 12345
                            name: postcircumfix
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: colon pair
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $value = $<postcircumfix>; "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: colon pair
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $value = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_value'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 3
              dba: signature
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: signature
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: signature
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: signature
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: signature
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'signature')
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 4
              dba: signature
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: signature
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = \"\"; $value = $<postcircumfix>; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_structural'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 5
              dba: signature
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 24690
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: signature
                      i: 0
                      min: 24690
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: signature
                          i: 0
                          min: 12345
                          name: sigil
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: signature
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: signature
                            i: 0
                            min: 12345
                            name: twigil
                            r: 1
                            rest: ''
                            s: 0
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: signature
                          i: 0
                          min: 12345
                          name: desigilname
                          r: 1
                          rest: ''
                          s: 0
                  dba: signature
                  i: 0
                  min: 24690
                  r: 1
                  s: 0
                  var: var
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: signature
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<var><desigilname>.Str; $value = $<var>; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_varname'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: colon pair
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<k> = $key; $<v> = $value; "
colonpair_01: *34
comp_unit: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $begin_compunit is context = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $endargs        is context<rw> = -1
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $LANG is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PKGDECL is context = ""
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PKGNAME is context = "GLOBAL"
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my @PKGS is context<rw> = ()
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PARSER is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INTERPOLATION is context<rw> = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_META is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $QUASI_QUASH is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $SCOPE is context = ""
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $SIGIL is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my %MYSTERY is context<rw> = ()
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my @MEMOS is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $VOID is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_IS is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $CURPAD is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $REALLYADD is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $CORE is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $CORESETTING is context = "CORE"
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $GLOBAL is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $CURPKG is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $UNIT is context
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: comp_unit
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        text: "\n        @COMPILING::WORRIES = ();\n        self.load_setting($*CORESETTING);\n        $*UNIT = self.newpad;\n        self.finishpad(1);\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: comp_unit
        i: 0
        min: 12345
        name: statementlist
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: comp_unit
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: comp_unit
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method 
                    a: 0
                    dba: comp_unit
                    i: 0
                    min: 12345
                    name: unitstopper
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: comp_unit
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Can't understand next input--giving up")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        text: " $<CORE> = $*CORE; "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        text: "\n        if @COMPILING::WORRIES {\n            warn \"Potential difficulties:\\n  \" ~ join( \"\\n  \", @COMPILING::WORRIES) ~ \"\\n\";\n        }\n\n        my %post_types;\n        my %unk_types;\n        my %unk_routines;\n        for keys(%*MYSTERY) {\n            my $p = %*MYSTERY{$_}.<pad>;\n            if $.is_name($_, $p) {\n                # types may not be post-declared\n                %post_types{$_} = %*MYSTERY{$_};\n                next;\n            }\n\n            next if $.is_known($_, $p);\n\n            # just a guess, but good enough to improve error reporting\n            if $_ lt 'a' {\n                %unk_types{$_} = %*MYSTERY{$_};\n            }\n            else {\n                %unk_routines{$_} = %*MYSTERY{$_};\n            }\n        }\n        if %post_types {\n            my @tmp = sort keys(%post_types);\n            warn \"Illegally post-declared type\" ~ ('s' x (@tmp != 1)) ~ \":\\n\";\n            for @tmp {\n                warn \"\\t$_ used at \", %post_types{$_}.<line>, \"\\n\";\n            }\n        }\n        if %unk_types {\n            my @tmp = sort keys(%unk_types);\n            warn \"Undeclared name\" ~ ('s' x (@tmp != 1)) ~ \":\\n\";\n            for @tmp {\n                warn \"\\t$_ used at \", %unk_types{$_}.<line>, \"\\n\";\n            }\n        }\n        if %unk_routines {\n            my @tmp = sort keys(%unk_routines);\n            warn \"Undeclared routine\" ~ ('s' x (@tmp != 1)) ~ \":\\n\";\n            for @tmp {\n                warn \"\\t$_ used at \", %unk_routines{$_}.<line>, \"\\n\";\n            }\n        }\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
constant_declarator: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: constant_declarator
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: constant_declarator
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: constant_declarator
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: constant_declarator
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*SCOPE eq 'constant' "
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: constant_declarator
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $.is_name($<identifier>.Str) "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: constant_declarator
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*IN_DECL = 0; self.add_name($<identifier>.Str) "
      - !!perl/hash:RE_method 
        a: 0
        dba: constant_declarator
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: constant_declarator
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
dec_number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: decimal number
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &121 !!perl/hash:RE_any 
          a: 0
          altname: dec_number_01
          dba: decimal number
          i: 0
          min: 2
          name: dec_number_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: dec_number_01 0
              dba: decimal number
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 2
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: decimal number
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  var: coeff
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 12345
                    name: escale
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: dec_number_01 1
              dba: decimal number
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 3
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 3
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: decimal number
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  var: coeff
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 12345
                    name: escale
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: dec_number_01 2
              dba: decimal number
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: decimal number
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: coeff
                - !!perl/hash:RE_method 
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 12345
                  name: escale
                  r: 1
                  rest: ''
                  s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method_re 
            a: 0
            dba: decimal number
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE 
              decl: []

              min: 0
              re: !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: decimal number
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_meta 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Number contains two decimal points (missing 'v' for version number?)")
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
            s: 0
dec_number_01: *121
declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &15 !!perl/hash:RE_any 
      a: 0
      altname: declarator_01
      dba: declarator
      i: 0
      min: 12345
      name: declarator_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 0
          dba: declarator
          i: 0
          min: 12345
          name: constant_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 1
          dba: declarator
          i: 0
          min: 12345
          name: variable_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: declarator_01 2
          dba: declarator
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: declarator
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_meta 
              a: 0
              dba: declarator
              extra: "local $::GOAL = ')' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: declarator
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: declarator
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: declarator
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (')' , 'declarator')
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: declarator
                i: 0
                min: 12345
                name: trait
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 3
          dba: declarator
          i: 0
          min: 12345
          name: routine_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 4
          dba: declarator
          i: 0
          min: 12345
          name: regex_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 5
          dba: declarator
          i: 0
          min: 12345
          name: type_declarator
          r: 1
          rest: ''
          s: 0
declarator_01: *15
def_module_name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: def_module_name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: def_module_name
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: generic role
            i: 0
            min: 12347
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: generic role
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " ($*PKGDECL//'') eq 'role' "
              - !!perl/hash:RE_string 
                a: 0
                dba: generic role
                i: 0
                min: 1
                r: 1
                s: 0
                text: "["
              - !!perl/hash:RE_meta 
                a: 0
                dba: generic role
                extra: "local $::GOAL = ']' "
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: generic role
                i: 0
                min: 12345
                name: signature
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: generic role
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: generic role
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "]"
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (']' , 'generic role')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
default_value: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: default_value
    i: 0
    min: 1
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_string 
        a: 0
        dba: default_value
        i: 0
        min: 1
        r: 1
        s: 1
        text: =
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: EXPR
        rest: (item %item_assignment)
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
deflongname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: name to be defined
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: name to be defined
        i: 0
        min: 12345
        name: name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: name to be defined
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: name to be defined
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 0
                min: 12345
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: name to be defined
                i: 0
                min: 0
                r: 1
                s: 0
                text: " $.add_macro($<name>) if $*IN_DECL; "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: name to be defined
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.add_routine($<name>.Str) if $*IN_DECL; "
desigilname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &101 !!perl/hash:RE_any 
      a: 0
      altname: desigilname_01
      dba: desigilname
      i: 0
      min: 12345
      name: desigilname_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: desigilname_01 0
          dba: desigilname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: desigilname
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: desigilname
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: $
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: desigilname
              i: 0
              min: 12345
              name: variable
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: desigilname
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $*VAR = $<variable> "
        - !!perl/hash:RE_method 
          a: 0
          alt: desigilname_01 1
          dba: desigilname
          i: 0
          min: 12345
          name: longname
          r: 1
          rest: ''
          s: 0
desigilname_01: *101
dotty__S_098DotStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: dotty__S_098DotStar
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: dotty__S_098DotStar
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: dotty__S_098DotStar
                i: 0
                min: 1
                r: 1
                s: 0
                text: .
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: &22 !!perl/hash:RE_any 
                  a: 0
                  altname: dotty__S_098DotStar_02
                  dba: dotty__S_098DotStar
                  i: 0
                  min: 1
                  name: dotty__S_098DotStar_02
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_cclass 
                      a: 0
                      alt: dotty__S_098DotStar_02 0
                      dba: dotty__S_098DotStar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "[+*?=]"
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: dotty__S_098DotStar_02 1
                      dba: dotty__S_098DotStar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: dotty__S_098DotStar
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "^"
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: dotty__S_098DotStar
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "!"
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
        min: 2
        var: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: dotty__S_098DotStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_098DotStar
        i: 0
        min: 12345
        name: unspacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_098DotStar
        i: 0
        min: 12345
        name: dottyop
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: dotty__S_098DotStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $0.Str; "
dotty__S_098DotStar_02: *22
dotty__S_099Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: dotty__S_099Dot
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_099Dot
        endsym: unspacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: .
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_099Dot
        i: 0
        min: 12345
        name: unspacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_099Dot
        i: 0
        min: 12345
        name: dottyop
        r: 1
        rest: ''
        s: 0
dottyop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &106 !!perl/hash:RE_any 
      a: 0
      altname: dottyop_01
      dba: dotty method or postfix
      i: 0
      min: 12345
      name: dottyop_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: dottyop_01 0
          dba: dotty method or postfix
          i: 0
          min: 12345
          name: methodop
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: dottyop_01 1
          dba: dotty method or postfix
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: dottyop_01 2
          dba: dotty method or postfix
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: dotty method or postfix
                i: 0
                min: 12345
                name: alpha
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: dotty method or postfix
              i: 0
              min: 12345
              name: postop
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: dotty method or postfix
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $<O> = $<postop><O>; $<sym> = $<postop><sym>; "
dottyop_01: *106
dottyopish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: dottyopish
      i: 0
      min: 12345
      name: dottyop
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: dottyopish
    i: 0
    min: 12345
    r: 1
    s: 0
    var: noun
eat_terminator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: !!perl/hash:RE_first 
      a: 0
      dba: eat_terminator
      i: 0
      min: 0
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_string 
          a: 0
          dba: eat_terminator
          i: 0
          min: 1
          r: 1
          s: 0
          text: ;
        - !!perl/hash:RE_sequence 
          a: 0
          dba: eat_terminator
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: eat_terminator
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " @*MEMOS[$.pos]<endstmt> "
            - !!perl/hash:RE_method 
              a: 0
              dba: eat_terminator
              i: 0
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
        - !!perl/hash:RE_assertion 
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method 
            a: 0
            dba: eat_terminator
            i: 0
            min: 12345
            name: terminator
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_meta 
          a: 0
          dba: eat_terminator
          i: 0
          min: 0
          r: 1
          s: 0
          text: $
        - !!perl/hash:RE_sequence 
          a: 0
          dba: eat_terminator
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: eat_terminator
              i: 0
              min: 0
              r: 1
              s: 0
              text: " if @*MEMOS[$.pos]<ws> { $.pos = @*MEMOS[$.pos]<ws>; } "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Syntax error")
escale: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escale
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_cclass 
        a: 0
        dba: escale
        i: 0
        min: 1
        r: 1
        s: 0
        text: "[Ee]"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: escale
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[+\\-]"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: escale
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: escale
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: escale
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: escale
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
escape__S_206none: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_206none
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
fatarrow: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: fatarrow
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: fatarrow
          i: 0
          min: 12345
          name: identifier
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: fatarrow
        i: 0
        min: 12345
        r: 1
        s: 0
        var: key
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: fatarrow
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: fatarrow
        i: 0
        min: 2
        r: 1
        s: 0
        text: =>
      - !!perl/hash:RE_method 
        a: 0
        dba: fatarrow
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: EXPR
          nobind: 1
          rest: (item %item_assignment)
        dba: fatarrow
        i: 0
        min: 0
        r: 1
        s: 0
        var: val
foo: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: foo
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: foo
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_bracket 
              decl: []

              min: 12345
              re: &11 !!perl/hash:RE_any 
                a: 0
                altname: foo_02
                dba: foo
                i: 0
                min: 12345
                name: foo_02
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: foo_02 0
                    dba: foo
                    i: 0
                    min: 12345
                    name: ident
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: foo_02 1
                    dba: foo
                    i: 0
                    min: 12345
                    name: number
                    r: 1
                    rest: ''
                    s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &132 !!perl/hash:RE_any 
          a: 0
          altname: foo_03
          dba: foo
          i: 0
          min: 12345
          name: foo_03
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: foo_03 0
              dba: foo
              i: 0
              min: 12345
              name: ident
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: foo_03 1
              dba: foo
              i: 0
              min: 12345
              name: number
              r: 1
              rest: ''
              s: 0
foo_02: *11
foo_03: *132
fulltypename: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: fulltypename
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: fulltypename
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12346
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: fulltypename
            i: 0
            min: 12346
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: fulltypename
                i: 0
                min: 1
                r: 1
                s: 1
                text: "|"
              - !!perl/hash:RE_method 
                a: 0
                dba: fulltypename
                i: 0
                min: 12345
                name: typename
                r: 1
                rest: ''
                s: 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24692
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: fulltypename
            i: 0
            min: 24692
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_string 
                a: 0
                dba: fulltypename
                i: 0
                min: 2
                r: 1
                s: 1
                text: of
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                a: 0
                dba: fulltypename
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                a: 0
                dba: fulltypename
                i: 0
                min: 12345
                name: fulltypename
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
hexint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: hexint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: hexint
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ 0..9 a..f A..F ]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: hexint
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: hexint
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_cclass 
                  a: 0
                  dba: hexint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[ 0..9 a..f A..F ]"
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
ident: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: ident
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: ident
        i: 0
        min: 12345
        name: alpha
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: ident
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
identifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: identifier
        i: 0
        min: 12345
        name: ident
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: identifier
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: identifier
                i: 0
                min: 12345
                name: apostrophe
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: identifier
                i: 0
                min: 12345
                name: ident
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
infix__S_299lambda: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_299lambda
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_299lambda
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &93 !!perl/hash:RE_any 
              a: 0
              altname: infix__S_299lambda_01
              dba: infix__S_299lambda
              i: 0
              min: 1
              name: infix__S_299lambda_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: infix__S_299lambda_01 0
                  dba: infix__S_299lambda
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: infix__S_299lambda_01 1
                  dba: infix__S_299lambda
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: ->
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_299lambda
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        my $line = $.lineof($.pos);\n        for 'if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when' {\n            my $m = %*MYSTERY{$_};\n            next unless $m;\n            if $line - ($m.<line>//-123) < 5 {\n                $.panic(\"$_() interpreted as function call at line \" ~ $m.<line> ~\n                \"; please use whitespace instead of parens\\nUnexpected block in infix position (two terms in a row)\");\n            }\n        }\n        $.panic(\"Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)\");\n    "
infix__S_299lambda_01: *93
infix__S_304Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_304Dot
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix__S_304Dot
        i: 0
        min: 1
        r: 1
        s: 0
        text: .
      - !!perl/hash:RE_cclass 
        a: 0
        dba: infix__S_304Dot
        i: 0
        min: 1
        r: 1
        s: 0
        text: "[\\]\\)\\},:\\s\\$\"']"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('. to concatenate strings', '~')
infix__S_310StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Exponentiation
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_310StarStar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "**"
infix__S_321Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_321Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
infix__S_322Slash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_322Slash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: /
infix__S_323div: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_323div
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: div
infix__S_324Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_324Percent
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_324Percent
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_324Percent
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><iffy> = 1; "
infix__S_325mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_325mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod
infix__S_326PlusAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_326PlusAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +&
infix__S_327PlusLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_327PlusLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_327PlusLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +<
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_327PlusLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_327PlusLt
              i: 0
              min: 1
              r: 1
              s: 0
              text: <
          s: 0
infix__S_328LtLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_328LtLt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_328LtLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <<
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_328LtLt
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('<< to do left shift', '+< or ~<')
infix__S_329GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_329GtGt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_329GtGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ">>"
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_329GtGt
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('>> to do right shift', '+> or ~>')
infix__S_330PlusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_330PlusGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_330PlusGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +>
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_330PlusGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_330PlusGt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
          s: 0
infix__S_331TildeAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_331TildeAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~&
infix__S_332QuestionAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_332QuestionAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?&
infix__S_333TildeLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_333TildeLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_333TildeLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~<
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_333TildeLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_333TildeLt
              i: 0
              min: 1
              r: 1
              s: 0
              text: <
          s: 0
infix__S_334TildeGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_334TildeGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_334TildeGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~>
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_334TildeGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_334TildeGt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
          s: 0
infix__S_335Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_335Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
infix__S_336Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_336Minus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "-"
infix__S_337PlusVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_337PlusVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +|
infix__S_338PlusCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_338PlusCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +^
infix__S_339TildeVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_339TildeVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~|
infix__S_340TildeCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_340TildeCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~^
infix__S_341QuestionVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_341QuestionVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?|
infix__S_342QuestionCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_342QuestionCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?^
infix__S_343x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Replication
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_343x
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: x
infix__S_344xx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Replication
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_344xx
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: xx
infix__S_345Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Concatenation
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_345Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
infix__S_346Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_346Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
infix__S_347also: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_347also
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: also
infix__S_348Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_348Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
infix__S_349Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_349Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
infix__S_354LtEqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_354LtEqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_354LtEqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <=>
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_354LtEqualGt
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_355cmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_355cmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_355cmp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: cmp
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_355cmp
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_356leg: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_356leg
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_356leg
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: leg
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_356leg
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_357but: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_357but
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: but
infix__S_358does: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_358does
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: does
infix__S_359DotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_359DotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_359DotDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ..
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: infix__S_359DotDot
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix__S_359DotDot
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $*IN_META "
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: infix__S_359DotDot
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &2 !!perl/hash:RE_any 
                      a: 0
                      altname: infix__S_359DotDot_02
                      dba: infix__S_359DotDot
                      i: 0
                      min: 1
                      name: infix__S_359DotDot_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: infix__S_359DotDot_02 0
                          dba: infix__S_359DotDot
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: infix__S_359DotDot_02 1
                          dba: infix__S_359DotDot
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Please use ..* for indefinite range")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
infix__S_359DotDot_02: *2
infix__S_360CaretDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_360CaretDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^.."
infix__S_361DotDotCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_361DotDotCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ..^
infix__S_362CaretDotDotCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_362CaretDotDotCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^..^"
infix__S_363EqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_363EqualEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_363EqualEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_363EqualEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_363EqualEqual
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
          s: 0
infix__S_364BangEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_364BangEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_364BangEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!="
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_364BangEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: infix__S_364BangEqual
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
infix__S_365Lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_365Lt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <
infix__S_366LtEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_366LtEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <=
infix__S_367Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_367Gt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ">"
infix__S_368GtEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_368GtEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ">="
infix__S_369TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_369TildeTilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~~
infix__S_370BangTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_370BangTilde
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_370BangTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!~"
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_370BangTilde
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('!~ to do negated pattern matching', '!~~')
infix__S_371EqualTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_371EqualTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_371EqualTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =~
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('=~ to do pattern matching', '~~')
infix__S_372eq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_372eq
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: eq
infix__S_373ne: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_373ne
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ne
infix__S_374lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_374lt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: lt
infix__S_375le: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_375le
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: le
infix__S_376gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_376gt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: gt
infix__S_377ge: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_377ge
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ge
infix__S_378EqualColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_378EqualColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =:=
infix__S_379EqualEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_379EqualEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ===
infix__S_380eqv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_380eqv
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: eqv
infix__S_381before: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_381before
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: before
infix__S_382after: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_382after
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: after
infix__S_383AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_383AmpAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&&"
infix__S_384VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_384VertVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "||"
infix__S_385CaretCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_385CaretCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^^"
infix__S_386SlashSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_386SlashSlash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: //
infix__S_387min: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_387min
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: min
infix__S_388max: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_388max
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: max
infix__S_389QuestionQuestion_BangBang: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: infix__S_389QuestionQuestion_BangBang
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '!!'
  kind: token
  min: 12347
  pkg: STD::Conditional
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_389QuestionQuestion_BangBang
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix__S_389QuestionQuestion_BangBang
        i: 0
        min: 2
        r: 1
        s: 0
        text: ??
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_389QuestionQuestion_BangBang
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: EXPR
        rest: (item %item_assignment)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix__S_389QuestionQuestion_BangBang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: infix__S_389QuestionQuestion_BangBang
              i: 0
              min: 2
              r: 1
              s: 0
              text: "!!"
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: !!perl/hash:RE_first 
                a: 0
                dba: infix__S_389QuestionQuestion_BangBang
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_389QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_389QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_string 
                              a: 0
                              dba: infix__S_389QuestionQuestion_BangBang
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: =
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Assignment not allowed within ??!!")
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_389QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_389QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_string 
                              a: 0
                              dba: infix__S_389QuestionQuestion_BangBang
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              text: "::"
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Please use !! rather than ::")
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_389QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_389QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 12345
                            re: !!perl/hash:RE_method 
                              a: 0
                              dba: infix__S_389QuestionQuestion_BangBang
                              i: 0
                              min: 12345
                              name: infixish
                              r: 1
                              rest: ''
                              s: 0
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Precedence too loose within ??!!; use ??()!! instead ")
                  - !!perl/hash:RE_method 
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Found ?? but no !!; possible precedence problem")
infix__S_390Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_390Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_390Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: "('?: for the conditional operator', '??!!')"
infix__S_391ff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_391ff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ff
infix__S_392Caretff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_392Caretff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^ff"
infix__S_393ffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_393ffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ff^
infix__S_394CaretffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_394CaretffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^ff^"
infix__S_395fff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_395fff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: fff
infix__S_396Caretfff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_396Caretfff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^fff"
infix__S_397fffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_397fffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: fff^
infix__S_398CaretfffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_398CaretfffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^fff^"
infix__S_399Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_399Equal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_399Equal
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_399Equal
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $ = $*SIGIL eq '$' \n        ?? ::Item_assignment.coerce($)\n        !! ::List_assignment.coerce($);\n    "
infix__S_400ColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_400ColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: :=
infix__S_401ColonColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_401ColonColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ::=
infix__S_402DotEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_402DotEqual
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_402DotEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: .=
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_402DotEqual
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix__S_402DotEqual
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix__S_402DotEqual
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 2
                  re: &27 !!perl/hash:RE_any 
                    a: 0
                    altname: infix__S_402DotEqual_02
                    dba: infix__S_402DotEqual
                    i: 0
                    min: 2
                    name: infix__S_402DotEqual_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: infix__S_402DotEqual_02 0
                        dba: infix__S_402DotEqual
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: infix__S_402DotEqual
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \w
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: infix__S_402DotEqual
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: ;
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_402DotEqual_02 1
                        dba: infix__S_402DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: new
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_402DotEqual_02 2
                        dba: infix__S_402DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: sort
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_402DotEqual_02 3
                        dba: infix__S_402DotEqual
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: subst
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_402DotEqual_02 4
                        dba: infix__S_402DotEqual
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: trans
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_402DotEqual_02 5
                        dba: infix__S_402DotEqual
                        i: 0
                        min: 7
                        r: 1
                        s: 0
                        text: reverse
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_402DotEqual_02 6
                        dba: infix__S_402DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: uniq
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_402DotEqual_02 7
                        dba: infix__S_402DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: map
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_402DotEqual_02 8
                        dba: infix__S_402DotEqual
                        i: 0
                        min: 8
                        r: 1
                        s: 0
                        text: samecase
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_402DotEqual_02 9
                        dba: infix__S_402DotEqual
                        i: 0
                        min: 6
                        r: 1
                        s: 0
                        text: substr
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_402DotEqual_02 10
                        dba: infix__S_402DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: flip
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: worryobs
              rest: ('.= as append operator', '~=')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_402DotEqual
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><nextterm> = 'dottyopish' "
infix__S_402DotEqual_02: *27
infix__S_403EqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_403EqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_403EqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =>
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_403EqualGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><fiddly> = 0; "
infix__S_406Comma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_406Comma
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_406Comma
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ","
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_406Comma
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><fiddly> = 0; "
infix__S_407Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_407Colon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_407Colon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_407Colon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &31 !!perl/hash:RE_any 
              a: 0
              altname: infix__S_407Colon_01
              dba: infix__S_407Colon
              i: 0
              min: 1
              name: infix__S_407Colon_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: infix__S_407Colon_01 0
                  dba: infix__S_407Colon
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_method 
                  a: 0
                  alt: infix__S_407Colon_01 1
                  dba: infix__S_407Colon
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_407Colon
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.panic(\"Illegal use of colon as invocant marker\") unless $*INVOCANT_OK--; "
infix__S_407Colon_01: *31
infix__S_408p5EqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_408p5EqualGt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: p5=>
infix__S_409Z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_409Z
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: Z
infix__S_410minmax: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_410minmax
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: minmax
infix__S_411DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_411DotDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ...
infix__S_418and: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_418and
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: and
infix__S_419andthen: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_419andthen
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: andthen
infix__S_420or: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_420or
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: or
infix__S_421orelse: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_421orelse
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: orelse
infix__S_422xor: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_422xor
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: xor
infix__S_423LtEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_423LtEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <==
infix__S_424EqualEqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_424EqualEqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_424EqualEqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==>
      - !!perl/hash:RE_method_internal 
        args: $S, 'infix__S_424EqualEqualGt'
        max: 0
        min: 0
        name: _REDUCE
infix__S_425LtLtEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_425LtLtEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <<==
infix__S_426EqualEqualGtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_426EqualEqualGtGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_426EqualEqualGtGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==>>
      - !!perl/hash:RE_method_internal 
        args: $S, 'infix__S_426EqualEqualGtGt'
        max: 0
        min: 0
        name: _REDUCE
infix_circumfix_meta_operator__S_106Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_circumfix_meta_operator__S_106Fre_Nch
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &40 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_106Fre_Nch_01
          dba: infix_circumfix_meta_operator__S_106Fre_Nch
          i: 0
          min: 1
          name: infix_circumfix_meta_operator__S_106Fre_Nch_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_106Fre_Nch_01 0
              dba: infix_circumfix_meta_operator__S_106Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_106Fre_Nch_01 1
              dba: infix_circumfix_meta_operator__S_106Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_circumfix_meta_operator__S_106Fre_Nch
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &45 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_106Fre_Nch_02
          dba: infix_circumfix_meta_operator__S_106Fre_Nch
          i: 0
          min: 1
          name: infix_circumfix_meta_operator__S_106Fre_Nch_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_106Fre_Nch_02 0
              dba: infix_circumfix_meta_operator__S_106Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_106Fre_Nch_02 1
              dba: infix_circumfix_meta_operator__S_106Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<infixish>, "hyper")
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_circumfix_meta_operator__S_106Fre_Nch
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> := $<infixish><O>; "
infix_circumfix_meta_operator__S_106Fre_Nch_01: *40
infix_circumfix_meta_operator__S_106Fre_Nch_02: *45
infix_circumfix_meta_operator__S_107LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &50 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_107LtLt_GtGt_01
          dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
          i: 0
          min: 2
          name: infix_circumfix_meta_operator__S_107LtLt_GtGt_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_107LtLt_GtGt_01 0
              dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: <<
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_107LtLt_GtGt_01 1
              dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &30 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_107LtLt_GtGt_02
          dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
          i: 0
          min: 2
          name: infix_circumfix_meta_operator__S_107LtLt_GtGt_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_107LtLt_GtGt_02 0
              dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: <<
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_107LtLt_GtGt_02 1
              dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<infixish>, "hyper")
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_circumfix_meta_operator__S_107LtLt_GtGt
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> := $<infixish><O>; "
infix_circumfix_meta_operator__S_107LtLt_GtGt_01: *50
infix_circumfix_meta_operator__S_107LtLt_GtGt_02: *30
infix_postfix_meta_operator__S_108Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_postfix_meta_operator__S_108Equal
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix_postfix_meta_operator__S_108Equal
        i: 0
        min: 1
        r: 1
        s: 0
        text: =
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($op, "make assignment out of")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix_postfix_meta_operator__S_108Equal
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix_postfix_meta_operator__S_108Equal
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " $op<O><diffy> "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't make assignment out of a " ~ $op<O><dba> ~ " operator because it's diffy")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_postfix_meta_operator__S_108Equal
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O> = $op<O>; $<O><prec>:delete; $<O><fiddly> = 1; "
infix_prefix_meta_operator__S_103Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_103Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_103Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix_prefix_meta_operator__S_103Bang
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix_prefix_meta_operator__S_103Bang
              i: 0
              min: 1
              r: 1
              s: 0
              text: "!"
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_prefix_meta_operator__S_103Bang
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix_prefix_meta_operator__S_103Bang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: infix_prefix_meta_operator__S_103Bang
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix_prefix_meta_operator__S_103Bang
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $<infixish>.Str eq '=' "
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix_prefix_meta_operator__S_103Bang
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $ = ::Chaining.coerce($); "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: infix_prefix_meta_operator__S_103Bang
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: can_meta
                  nobind: 1
                  rest: ($<infixish>, "negate")
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix_prefix_meta_operator__S_103Bang
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $<infixish><O><iffy> "
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix_prefix_meta_operator__S_103Bang
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $<O> = $<infixish><O>; "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't negate a " ~ $<infixish><O><dba> ~ " operator because it's not iffy enough")
infix_prefix_meta_operator__S_104R: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_104R
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_104R
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: R
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_prefix_meta_operator__S_104R
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<infixish>, "reverse")
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_prefix_meta_operator__S_104R
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> = $<infixish><O>; "
infix_prefix_meta_operator__S_105X: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_105X
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_105X
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: X
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_prefix_meta_operator__S_105X
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: infix_prefix_meta_operator__S_105X
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: infixish
                rest: (1)
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix_prefix_meta_operator__S_105X
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: infix_prefix_meta_operator__S_105X
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: X
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Old form of XopX found")
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                min: 0
                name: can_meta
                nobind: 1
                rest: ($<infixish>[0], "cross")
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix_prefix_meta_operator__S_105X
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $<O> = $<infixish>[0]<O>; $<O><prec>:delete; $<sym> ~= $<infixish>[0].Str "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
infixish: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: infixish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $infix
    - !!perl/hash:RE_decl 
      a: 0
      dba: infixish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_META is context<rw> = $in_meta
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix or meta-infix
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &125 !!perl/hash:RE_any 
          a: 0
          altname: infixish_01
          dba: infix or meta-infix
          i: 0
          min: 2
          name: infixish_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 0
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            $<fake> = 1;\n            $<sym> = ':';\n            %<O><prec> = %comma<prec>;  # actual test is non-inclusive of comma!\n            %<O><assoc> = 'unary';\n            %<O><uassoc> = 'left';\n        "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 1
              dba: infix or meta-infix
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: infix or meta-infix
                  extra: "local $::GOAL = ']' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  min: 0
                  name: infixish
                  rest: (1)
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: infix or meta-infix
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: infix or meta-infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'infix or meta-infix')
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infixish><O>; $<sym> = $<infixish><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 2
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix_circumfix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_circumfix_meta_operator><O>;\n          $<sym> = $<infix_circumfix_meta_operator><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 3
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix_prefix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_prefix_meta_operator><O>;\n          $<sym> = $<infix_prefix_meta_operator><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 4
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: infix or meta-infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix>.<O>; $<sym> = $<infix>.<sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 5
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: infix or meta-infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                    s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $infix = $<infix>; "
                - !!perl/hash:RE_method 
                  min: 0
                  name: infix_postfix_meta_operator
                  rest: ($infix)
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_postfix_meta_operator>.<O>; $<sym> = $<infix_postfix_meta_operator>.<sym>; "
infixish_01: *125
infixstopper: !!perl/hash:RE 
  decl: []

  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &63 !!perl/hash:RE_any 
      a: 0
      altname: infixstopper_01
      dba: infix stopper
      i: 0
      min: 0
      name: infixstopper_01
      r: 0
      s: 0
      zyg: 
        - !!perl/hash:RE_assertion 
          alt: infixstopper_01 0
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method_re 
            a: 0
            dba: infix stopper
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 0
            re: !!perl/hash:RE 
              decl: []

              min: 12345
              re: !!perl/hash:RE_method 
                a: 0
                dba: infix stopper
                i: 0
                min: 12345
                name: stopper
                r: 0
                rest: ''
                s: 0
            s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: infixstopper_01 1
          dba: infix stopper
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix stopper
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 2
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: infix stopper
                    i: 0
                    min: 2
                    r: 0
                    s: 0
                    text: "!!"
                s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix stopper
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $*GOAL eq '!!' "
        - !!perl/hash:RE_sequence 
          a: 0
          alt: infixstopper_01 2
          dba: infix stopper
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix stopper
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: &94 !!perl/hash:RE_any 
                    a: 0
                    altname: infixstopper_04
                    dba: infix stopper
                    i: 0
                    min: 1
                    name: infixstopper_04
                    r: 0
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infixstopper_04 0
                        dba: infix stopper
                        i: 0
                        min: 1
                        r: 0
                        s: 0
                        text: "{"
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: infixstopper_04 1
                        dba: infix stopper
                        i: 0
                        min: 12345
                        name: lambda
                        r: 0
                        rest: ''
                        s: 0
                s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix stopper
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " ($*GOAL eq '{' or $*GOAL eq 'endargs') and @*MEMOS[$.pos]<ws> "
        - !!perl/hash:RE_assertion 
          alt: infixstopper_01 3
          assert: "?"
          min: 0
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: infix stopper
            i: 0
            min: 0
            nobind: 1
            r: 0
            s: 0
            text: " $*GOAL eq 'endargs' and @*MEMOS[$.pos]<endargs> "
infixstopper_01: *63
infixstopper_04: *94
integer: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: integer
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &123 !!perl/hash:RE_any 
          a: 0
          altname: integer_01
          dba: integer
          i: 0
          min: 1
          name: integer_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: integer_01 0
              dba: integer
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: integer
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: &48 !!perl/hash:RE_any 
                    a: 0
                    altname: integer_02
                    dba: integer
                    i: 0
                    min: 1
                    name: integer_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 0
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: b
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[01]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[01]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 1
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: o
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[0..7]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[0..7]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 2
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: x
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[0..9a..fA..F]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[0..9a..fA..F]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 3
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: d
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_meta 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: \d
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 4
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_meta 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: \d
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_assertion 
                            assert: "!"
                            min: 0
                            re: !!perl/hash:RE_assertion 
                              assert: "!"
                              min: 0
                              nobind: 1
                              re: !!perl/hash:RE_block 
                                a: 0
                                context: bool
                                dba: integer
                                i: 0
                                min: 0
                                nobind: 1
                                r: 1
                                s: 0
                                text: " $.worry(\"Leading 0 does not indicate octal in Perl 6\") "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: integer_01 1
              dba: integer
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: integer
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \d
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: integer
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: _
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method_re 
            a: 0
            dba: integer
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE 
              decl: []

              min: 0
              re: !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: integer
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: integer
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: &124 !!perl/hash:RE_any 
                              a: 0
                              altname: integer_11
                              dba: integer
                              i: 0
                              min: 1
                              name: integer_11
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_meta 
                                  a: 0
                                  alt: integer_11 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \s
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: integer_11 1
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: ","
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: integer_11 2
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: =
                                - !!perl/hash:RE_method 
                                  a: 0
                                  alt: integer_11 3
                                  dba: integer
                                  i: 0
                                  min: 12345
                                  name: terminator
                                  r: 1
                                  rest: ''
                                  s: 0
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Decimal point must be followed by digit")
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
            s: 0
integer_01: *123
integer_02: *48
integer_11: *124
label: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: label
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $label
  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: label
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: label
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: label
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: label
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: label
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: label
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: label
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: label
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $.is_name($label = $<identifier>.Str) "
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Illegal redeclaration of '$label'")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: label
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.add_my_name($label); "
lambda: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &109 !!perl/hash:RE_any 
    a: 0
    altname: lambda_00
    dba: lambda
    i: 0
    min: 2
    name: lambda_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        alt: lambda_00 0
        dba: lambda
        i: 0
        min: 2
        r: 1
        s: 0
        text: ->
      - !!perl/hash:RE_string 
        a: 0
        alt: lambda_00 1
        dba: lambda
        i: 0
        min: 3
        r: 1
        s: 0
        text: <->
lambda_00: *109
longname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: longname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: longname
        i: 0
        min: 12345
        name: name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: longname
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
macro_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: macro_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: macro_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: macro_def
        i: 0
        min: 24690
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 24690
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: macro_def
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    re: &114 !!perl/hash:RE_any 
                      a: 0
                      altname: macro_def_02
                      dba: macro_def
                      i: 0
                      min: 1
                      name: macro_def_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_02 0
                          dba: macro_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "&"
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_method 
                                a: 0
                                dba: macro_def
                                i: 0
                                min: 12345
                                name: deflongname
                                r: 1
                                rest: ''
                                s: 1
                              min: 0
                              quant: 
                                - "?"
                                - ":"
                                - ''
                                - 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_02 1
                          dba: macro_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 12345
                              name: deflongname
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: macro_def
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &13 !!perl/hash:RE_any 
                      a: 0
                      altname: macro_def_03
                      dba: macro_def
                      i: 0
                      min: 12345
                      name: macro_def_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_03 0
                          dba: macro_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 12345
                              name: multisig
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_03 1
                          dba: macro_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: macro_def
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 1
                    text: "\n            $ = $*PARSER.bless($);\n            $*IN_DECL = 0;\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: macro_def
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: macro_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed macro")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
macro_def_02: *114
macro_def_03: *13
method_def: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: method_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: method_def
        i: 0
        min: 24690
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            a: 0
            dba: method_def
            i: 0
            min: 12345
            name: newpad
            nobind: 1
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: method_def
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: &70 !!perl/hash:RE_any 
                    a: 0
                    altname: method_def_02
                    dba: subscript signature
                    i: 0
                    min: 0
                    name: method_def_02
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 0
                        dba: method_def
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: method_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "[ ! ^ ]"
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 12345
                            name: longname
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 12345
                              re: &1 !!perl/hash:RE_any 
                                a: 0
                                altname: method_def_03
                                dba: method_def
                                i: 0
                                min: 12345
                                name: method_def_03
                                r: 1
                                s: 1
                                zyg: 
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: method_def_03 0
                                    dba: method_def
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 1
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: method_def
                                        i: 0
                                        min: 12345
                                        name: multisig
                                        r: 1
                                        rest: ''
                                        s: 1
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: method_def_03 1
                                    dba: method_def
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 1
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: method_def
                                        i: 0
                                        min: 12345
                                        name: trait
                                        r: 1
                                        rest: ''
                                        s: 1
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 1
                        dba: method_def
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 12345
                            name: multisig
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: method_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 2
                        dba: subscript signature
                        i: 0
                        min: 24691
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 12345
                            name: sigil
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: .
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 12345
                            re: &108 !!perl/hash:RE_any 
                              a: 0
                              altname: method_def_04
                              dba: subscript signature
                              i: 0
                              min: 12345
                              name: method_def_04
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 0
                                  dba: subscript signature
                                  i: 0
                                  min: 12347
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: (
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_meta 
                                      a: 0
                                      dba: subscript signature
                                      extra: local $::GOAL = ')'
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 1
                                      text: "::"
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: signature
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_bracket 
                                      decl: []

                                      min: 1
                                      re: !!perl/hash:RE_first 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 1
                                        zyg: 
                                          - !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: )
                                          - !!perl/hash:RE_method 
                                            min: 0
                                            name: FAILGOAL
                                            nobind: 1
                                            rest: (')', 'subscript signature')
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 1
                                  dba: subscript signature
                                  i: 0
                                  min: 12347
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: "["
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_meta 
                                      a: 0
                                      dba: subscript signature
                                      extra: local $::GOAL = ']'
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 1
                                      text: "::"
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: signature
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_bracket 
                                      decl: []

                                      min: 1
                                      re: !!perl/hash:RE_first 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 1
                                        zyg: 
                                          - !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: "]"
                                          - !!perl/hash:RE_method 
                                            min: 0
                                            name: FAILGOAL
                                            nobind: 1
                                            rest: (']', 'subscript signature')
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 2
                                  dba: subscript signature
                                  i: 0
                                  min: 12347
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: "{"
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_meta 
                                      a: 0
                                      dba: subscript signature
                                      extra: local $::GOAL = '}'
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 1
                                      text: "::"
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: signature
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_bracket 
                                      decl: []

                                      min: 1
                                      re: !!perl/hash:RE_first 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 1
                                        zyg: 
                                          - !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: "}"
                                          - !!perl/hash:RE_method 
                                            min: 0
                                            name: FAILGOAL
                                            nobind: 1
                                            rest: ('}', 'subscript signature')
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 3
                                  dba: subscript signature
                                  i: 0
                                  min: 12345
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_assertion 
                                      assert: "?"
                                      min: 0
                                      re: !!perl/hash:RE_method_re 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 0
                                        name: before
                                        nobind: 1
                                        r: 1
                                        re: !!perl/hash:RE 
                                          decl: []

                                          min: 1
                                          re: !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: <
                                        s: 1
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: postcircumfix
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 3
                        dba: subscript signature
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_noop 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: method_def
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: method_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed method")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
method_def_02: *70
method_def_03: *1
method_def_04: *108
methodop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: method arguments
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &80 !!perl/hash:RE_any 
          a: 0
          altname: methodop_01
          dba: methodop
          i: 0
          min: 12345
          name: methodop_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: methodop_01 0
              dba: methodop
              i: 0
              min: 12345
              name: longname
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: methodop_01 1
              dba: methodop
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: &118 !!perl/hash:RE_any 
                        a: 0
                        altname: methodop_02
                        dba: methodop
                        i: 0
                        min: 1
                        name: methodop_02
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 0
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: $
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 1
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "@"
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: methodop
                  i: 0
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: methodop
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $*VAR = $<variable> "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: methodop_01 2
              dba: methodop
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: methodop
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[ ' \" ]"
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: methodop
                  i: 0
                  min: 12345
                  name: quote
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: methodop
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<quote> ~~ /\\W/ or $.panic(\"Useless use of quotes\") "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: methodop
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &68 !!perl/hash:RE_any 
            a: 0
            altname: methodop_04
            dba: method arguments
            i: 0
            min: 12345
            name: methodop_04
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: methodop_04 0
                dba: method arguments
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_method_re 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE 
                        decl: []

                        min: 1
                        re: !!perl/hash:RE_meta 
                          a: 0
                          dba: method arguments
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                      s: 0
                  - !!perl/hash:RE_assertion 
                    assert: "!"
                    min: 0
                    re: !!perl/hash:RE_block 
                      a: 0
                      context: bool
                      dba: method arguments
                      i: 0
                      min: 0
                      nobind: 1
                      r: 1
                      s: 0
                      text: " $*INTERPOLATION "
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 12345
                    name: arglist
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: methodop_04 1
                dba: method arguments
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_cclass 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 1
                      nobind: 1
                      r: 1
                      s: 0
                      text: "[\\\\(]"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 12345
                    name: args
                    r: 1
                    rest: ''
                    s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
methodop_01: *80
methodop_02: *118
methodop_04: *68
modifier_expr: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: modifier_expr
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: modifier_expr
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
module_name__S_079normal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: module_name__S_079normal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: module_name__S_079normal
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: generic role
            i: 0
            min: 12347
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: module_name__S_079normal
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: module_name__S_079normal
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: generic role
                i: 0
                min: 1
                r: 1
                s: 0
                text: "["
              - !!perl/hash:RE_meta 
                a: 0
                dba: generic role
                extra: "local $::GOAL = ']' "
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: generic role
                i: 0
                min: 12345
                name: arglist
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: generic role
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: generic role
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "]"
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (']' , 'generic role')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
module_name__S_080deprecated: !!perl/hash:RE 
  decl: []

  kind: token
  min: 8
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: module_name__S_080deprecated
    i: 0
    min: 8
    r: 1
    s: 0
    text: v6-alpha
morename: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: morename
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: morename
        i: 0
        min: 2
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: morename
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: morename
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &126 !!perl/hash:RE_any 
                      a: 0
                      altname: morename_02
                      dba: morename
                      i: 0
                      min: 1
                      name: morename_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: morename_02 0
                          dba: morename
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: (
                        - !!perl/hash:RE_method 
                          a: 0
                          alt: morename_02 1
                          dba: morename
                          i: 0
                          min: 12345
                          name: alpha
                          r: 1
                          rest: ''
                          s: 0
                  s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: &127 !!perl/hash:RE_any 
                  a: 0
                  altname: morename_03
                  dba: indirect name
                  i: 0
                  min: 12345
                  name: morename_03
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: morename_03 0
                      dba: morename
                      i: 0
                      min: 12345
                      name: identifier
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: morename_03 1
                      dba: indirect name
                      i: 0
                      min: 12347
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: indirect name
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: (
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: indirect name
                          extra: "local $::GOAL = ')' "
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "::"
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: indirect name
                          i: 0
                          min: 12345
                          name: EXPR
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: !!perl/hash:RE_first 
                            a: 0
                            dba: indirect name
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: indirect name
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: )
                              - !!perl/hash:RE_method 
                                min: 0
                                name: FAILGOAL
                                nobind: 1
                                rest: (')' , 'indirect name')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
morename_02: *126
morename_03: *127
multi_declarator__S_132multi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_132multi
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_132multi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: multi
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_132multi
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_132multi
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_132multi
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_132multi
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ('Malformed multi')
multi_declarator__S_133proto: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_133proto
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_133proto
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: proto
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_133proto
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_133proto
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_133proto
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_133proto
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ('Malformed proto')
multi_declarator__S_134only: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_134only
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_134only
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: only
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_134only
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_134only
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_134only
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_134only
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ('Malformed only')
multi_declarator__S_135null: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: multi_declarator__S_135null
    i: 0
    min: 12345
    name: declarator
    r: 1
    rest: ''
    s: 0
multisig: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multisig
    i: 0
    min: 12347
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: multisig
            i: 0
            min: 12347
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_string 
                  a: 0
                  dba: multisig
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ":"
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_string 
                a: 0
                dba: multisig
                i: 0
                min: 1
                r: 1
                s: 1
                text: (
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_meta 
                a: 0
                dba: multisig
                extra: local $::GOAL = ')'
                i: 0
                min: 0
                r: 1
                s: 1
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: multisig
                i: 0
                min: 12345
                name: signature
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: multisig
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: multisig
                      i: 0
                      min: 1
                      r: 1
                      s: 1
                      text: )
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (')', 'multisig')
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 12347
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: multisig
            i: 0
            min: 1
            r: 1
            s: 1
            text: "|"
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &83 !!perl/hash:RE_any 
      a: 0
      altname: name_01
      dba: name
      i: 0
      min: 12345
      name: name_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: name_01 0
          dba: name
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: name
              i: 0
              min: 12345
              name: identifier
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: name
                i: 0
                min: 12345
                name: morename
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_quantified_atom 
          alt: name_01 1
          atom: !!perl/hash:RE_method 
            a: 0
            dba: name
            i: 0
            min: 12345
            name: morename
            r: 1
            rest: ''
            s: 0
          min: 12345
          quant: 
            - +
            - ":"
            - ''
            - 1
name_01: *83
named_param: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: named_param
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = ')'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: named_param
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: named_param
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &28 !!perl/hash:RE_any 
          a: 0
          altname: named_param_01
          dba: named_param
          i: 0
          min: 12345
          name: named_param_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: named_param_01 0
              dba: named_param
              i: 0
              min: 37036
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: named_param
                    i: 0
                    min: 12345
                    name: identifier
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: name
                - !!perl/hash:RE_string 
                  a: 0
                  dba: named_param
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_method 
                  a: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &99 !!perl/hash:RE_any 
                    a: 0
                    altname: named_param_02
                    dba: named_param
                    i: 0
                    min: 12345
                    name: named_param_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: named_param_02 0
                        dba: named_param
                        i: 0
                        min: 12345
                        name: named_param
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: named_param_02 1
                        dba: named_param
                        i: 0
                        min: 24690
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: named_param
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: named_param
                            i: 0
                            min: 12345
                            name: ws
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: named_param
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: named_param
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unable to parse named parameter; couldn't find right parenthesis")
            - !!perl/hash:RE_method 
              a: 0
              alt: named_param_01 1
              dba: named_param
              i: 0
              min: 12345
              name: param_var
              r: 1
              rest: ''
              s: 0
named_param_01: *28
named_param_02: *99
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $text = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $from = self.pos
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $to = $from
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my @nibbles = ()
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $multiline = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $nibble
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: nibbler
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<_from> = self.pos; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: nibbler
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_method 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 12345
                      name: stopper
                      r: 1
                      rest: ''
                      s: 0
                  s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: starter
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: nibbler
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: stopper
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );\n\n                            my $n = $<nibbler>[*-1]<nibbles>;\n                            my @n = @$n;\n\n                            push @nibbles, $<starter>;\n                            push @nibbles, @n;\n                            push @nibbles, $<stopper>;\n\n                            $text = '';\n                            $to = $from = $.pos;\n                        "
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: escape
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to ), $<escape>[*-1];\n                            $text = '';\n                            $to = $from = $.pos;\n                        "
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            my $ch = substr($*ORIG, $.pos-1, 1);\n                            $text ~= $ch;\n                            $to = $.pos;\n                            if $ch ~~ \"\\n\" {\n                                $multiline++;\n                            }\n                        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: nibbler
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        push @nibbles, $.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );\n        $<nibbles> = \\@nibbles;\n        $<_pos> = $.pos;\n        $<nibbler> :delete;\n        $<escape> :delete;\n        $<starter> :delete;\n        $<stopper> :delete;\n        $COMPILING::LAST_NIBBLE = $;\n        $COMPILING::LAST_NIBBLE_MULTILINE = $ if $multiline;\n    "
nofun: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: nofun
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: &54 !!perl/hash:RE_any 
          a: 0
          altname: nofun_01
          dba: nofun
          i: 0
          min: 1
          name: nofun_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 0
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 1
              dba: nofun
              i: 0
              min: 2
              r: 1
              s: 0
              text: .(
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 2
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
      s: 0
nofun_01: *54
noun__S_082fatarrow: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_082fatarrow
    i: 0
    min: 12345
    name: fatarrow
    r: 1
    rest: ''
    s: 0
noun__S_083variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: noun__S_083variable
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: noun__S_083variable
        i: 0
        min: 12345
        name: variable
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: noun__S_083variable
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*VAR = $<variable> "
noun__S_084package_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_084package_declarator
    i: 0
    min: 12345
    name: package_declarator
    r: 1
    rest: ''
    s: 0
noun__S_085scope_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_085scope_declarator
    i: 0
    min: 12345
    name: scope_declarator
    r: 1
    rest: ''
    s: 0
noun__S_086multi_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: noun__S_086multi_declarator
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: noun__S_086multi_declarator
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 4
            re: &77 !!perl/hash:RE_any 
              a: 0
              altname: noun__S_086multi_declarator_01
              dba: noun__S_086multi_declarator
              i: 0
              min: 4
              name: noun__S_086multi_declarator_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: noun__S_086multi_declarator_01 0
                  dba: noun__S_086multi_declarator
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: multi
                - !!perl/hash:RE_string 
                  a: 0
                  alt: noun__S_086multi_declarator_01 1
                  dba: noun__S_086multi_declarator
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: proto
                - !!perl/hash:RE_string 
                  a: 0
                  alt: noun__S_086multi_declarator_01 2
                  dba: noun__S_086multi_declarator
                  i: 0
                  min: 4
                  r: 1
                  s: 0
                  text: only
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: noun__S_086multi_declarator
        i: 0
        min: 12345
        name: multi_declarator
        r: 1
        rest: ''
        s: 0
noun__S_086multi_declarator_01: *77
noun__S_087routine_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_087routine_declarator
    i: 0
    min: 12345
    name: routine_declarator
    r: 1
    rest: ''
    s: 0
noun__S_088regex_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_088regex_declarator
    i: 0
    min: 12345
    name: regex_declarator
    r: 1
    rest: ''
    s: 0
noun__S_089type_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_089type_declarator
    i: 0
    min: 12345
    name: type_declarator
    r: 1
    rest: ''
    s: 0
noun__S_090circumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_090circumfix
    i: 0
    min: 12345
    name: circumfix
    r: 1
    rest: ''
    s: 0
noun__S_091dotty: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_091dotty
    i: 0
    min: 12345
    name: dotty
    r: 1
    rest: ''
    s: 0
noun__S_092value: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_092value
    i: 0
    min: 12345
    name: value
    r: 1
    rest: ''
    s: 0
noun__S_093capterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_093capterm
    i: 0
    min: 12345
    name: capterm
    r: 1
    rest: ''
    s: 0
noun__S_094sigterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_094sigterm
    i: 0
    min: 12345
    name: sigterm
    r: 1
    rest: ''
    s: 0
noun__S_095term: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_095term
    i: 0
    min: 12345
    name: term
    r: 1
    rest: ''
    s: 0
noun__S_096statement_prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_096statement_prefix
    i: 0
    min: 12345
    name: statement_prefix
    r: 1
    rest: ''
    s: 0
noun__S_097colonpair: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 24690
      re: !!perl/hash:RE_sequence 
        a: 0
        dba: noun__S_097colonpair
        i: 0
        min: 24690
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: noun__S_097colonpair
            i: 0
            min: 12345
            name: colonpair
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: noun__S_097colonpair
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
    min: 24690
    quant: 
      - +
      - ":"
      - ''
      - 1
nullterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: nullterm
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
nulltermish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &97 !!perl/hash:RE_any 
      a: 0
      altname: nulltermish_01
      dba: null term
      i: 0
      min: 0
      name: nulltermish_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_assertion 
          alt: nulltermish_01 0
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method 
            a: 0
            dba: null term
            i: 0
            min: 12345
            name: stdstopper
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: nulltermish_01 1
          dba: null term
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_method 
                a: 0
                dba: null term
                i: 0
                min: 12345
                name: termish
                nobind: 1
                r: 1
                rest: ''
                s: 0
              dba: null term
              i: 0
              min: 12345
              r: 1
              s: 0
              var: noun
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: null term
              i: 0
              min: 0
              r: 1
              s: 0
              text: "\n            $<PRE>  = $<noun><PRE>:delete;\n            $<POST> = $<noun><POST>:delete;\n        "
        - !!perl/hash:RE_assertion 
          alt: nulltermish_01 2
          assert: "?"
          min: 0
          re: !!perl/hash:RE_noop 
            a: 0
            dba: null term
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
nulltermish_01: *97
number__S_203rational: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: number__S_203rational
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: number__S_203rational
          i: 0
          min: 12345
          name: integer
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: number__S_203rational
        i: 0
        min: 12345
        r: 1
        s: 0
        var: nu
      - !!perl/hash:RE_string 
        a: 0
        dba: number__S_203rational
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: number__S_203rational
          i: 0
          min: 12345
          name: integer
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: number__S_203rational
        i: 0
        min: 12345
        r: 1
        s: 0
        var: de
number__S_204complex: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: &39 !!perl/hash:RE_any 
    a: 0
    altname: number__S_204complex_00
    dba: number__S_204complex
    i: 0
    min: 12346
    name: number__S_204complex_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        alt: number__S_204complex_00 0
        dba: number__S_204complex
        i: 0
        min: 24692
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_method 
              a: 0
              dba: number__S_204complex
              i: 0
              min: 12345
              name: numish
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: number__S_204complex
            i: 0
            min: 12345
            r: 1
            s: 0
            var: re
          - !!perl/hash:RE_string 
            a: 0
            dba: number__S_204complex
            i: 0
            min: 1
            r: 1
            s: 0
            text: +
          - !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_method 
              a: 0
              dba: number__S_204complex
              i: 0
              min: 12345
              name: numish
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: number__S_204complex
            i: 0
            min: 12345
            r: 1
            s: 0
            var: im
          - !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_string 
              a: 0
              dba: number__S_204complex
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            min: 0
            quant: 
              - "?"
              - ":"
              - ''
              - 0
          - !!perl/hash:RE_string 
            a: 0
            dba: number__S_204complex
            i: 0
            min: 1
            r: 1
            s: 0
            text: i
      - !!perl/hash:RE_sequence 
        a: 0
        alt: number__S_204complex_00 1
        dba: number__S_204complex
        i: 0
        min: 12346
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_method 
              a: 0
              dba: number__S_204complex
              i: 0
              min: 12345
              name: numish
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: number__S_204complex
            i: 0
            min: 12345
            r: 1
            s: 0
            var: im
          - !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_string 
              a: 0
              dba: number__S_204complex
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            min: 0
            quant: 
              - "?"
              - ":"
              - ''
              - 0
          - !!perl/hash:RE_string 
            a: 0
            dba: number__S_204complex
            i: 0
            min: 1
            r: 1
            s: 0
            text: i
number__S_204complex_00: *39
number__S_205numish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: number__S_205numish
    i: 0
    min: 12345
    name: numish
    r: 1
    rest: ''
    s: 0
numish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 3
    re: &134 !!perl/hash:RE_any 
      a: 0
      altname: numish_01
      dba: numish
      i: 0
      min: 3
      name: numish_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: numish_01 0
          dba: numish
          i: 0
          min: 12345
          name: integer
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: numish_01 1
          dba: numish
          i: 0
          min: 12345
          name: dec_number
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: numish_01 2
          dba: numish
          i: 0
          min: 12345
          name: rad_number
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 3
          dba: numish
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 3
              r: 1
              s: 0
              text: NaN
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 4
          dba: numish
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 3
              r: 1
              s: 0
              text: Inf
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 5
          dba: numish
          i: 0
          min: 4
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 4
              r: 1
              s: 0
              text: +Inf
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 6
          dba: numish
          i: 0
          min: 4
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 4
              r: 1
              s: 0
              text: -Inf
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: 
numish_01: *134
octint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: octint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: octint
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ 0..7 ]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: octint
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: octint
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_cclass 
                  a: 0
                  dba: octint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[ 0..7 ]"
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
old_rx_mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: old_rx_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_qw 
              a: 0
              dba: old_rx_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: < i g s m x c e >
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: old_rx_mods
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $0.Str {\n            $_ ~~ /i/ and $.worryobs('/i',':i');\n            $_ ~~ /g/ and $.worryobs('/g',':g');\n            $_ ~~ /s/ and $.worryobs('/s','^^ and $$ anchors');\n            $_ ~~ /m/ and $.worryobs('/m','. or \\N');\n            $_ ~~ /x/ and $.worryobs('/x','normal default whitespace');\n            $_ ~~ /c/ and $.worryobs('/c',':c or :p');\n            $_ ~~ /e/ and $.worryobs('/e','interpolated {...} or s{} = ... form');\n            $.obs('suffix regex modifiers','prefix adverbs');\n        }\n    "
old_tr_mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: old_tr_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_qw 
              a: 0
              dba: old_tr_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: < c d s ] >
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: old_tr_mods
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $0.Str {\n            $_ ~~ /c/ and $.worryobs('/c',':c');\n            $_ ~~ /d/ and $.worryobs('/g',':d');\n            $_ ~~ /s/ and $.worryobs('/s',':s');\n            $.obs('suffix transliteration modifiers','prefix adverbs');\n        }\n    "
opener: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass 
    a: 0
    dba: opener
    i: 0
    min: 1
    r: 1
    s: 0
    text: "[\\x{0028} \\x{003C} \\x{005B}\n    \\x{007B} \\x{00AB} \\x{0F3A}\n    \\x{0F3C} \\x{169B} \\x{2039}\n    \\x{2045} \\x{207D} \\x{208D}\n    \\x{2208} \\x{2209} \\x{220A}\n    \\x{2215} \\x{223C} \\x{2243}\n    \\x{2252} \\x{2254} \\x{2264}\n    \\x{2266} \\x{2268} \\x{226A}\n    \\x{226E} \\x{2270} \\x{2272}\n    \\x{2274} \\x{2276} \\x{2278}\n    \\x{227A} \\x{227C} \\x{227E}\n    \\x{2280} \\x{2282} \\x{2284}\n    \\x{2286} \\x{2288} \\x{228A}\n    \\x{228F} \\x{2291} \\x{2298}\n    \\x{22A2} \\x{22A6} \\x{22A8}\n    \\x{22A9} \\x{22AB} \\x{22B0}\n    \\x{22B2} \\x{22B4} \\x{22B6}\n    \\x{22C9} \\x{22CB} \\x{22D0}\n    \\x{22D6} \\x{22D8} \\x{22DA}\n    \\x{22DC} \\x{22DE} \\x{22E0}\n    \\x{22E2} \\x{22E4} \\x{22E6}\n    \\x{22E8} \\x{22EA} \\x{22EC}\n    \\x{22F0} \\x{22F2} \\x{22F3}\n    \\x{22F4} \\x{22F6} \\x{22F7}\n    \\x{2308} \\x{230A} \\x{2329}\n    \\x{23B4} \\x{2768} \\x{276A}\n    \\x{276C} \\x{276E} \\x{2770}\n    \\x{2772} \\x{2774} \\x{27C3}\n    \\x{27C5} \\x{27D5} \\x{27DD}\n    \\x{27E2} \\x{27E4} \\x{27E6}\n    \\x{27E8} \\x{27EA} \\x{2983}\n    \\x{2985} \\x{2987} \\x{2989}\n    \\x{298B} \\x{298D} \\x{298F}\n    \\x{2991} \\x{2993} \\x{2995}\n    \\x{2997} \\x{29C0} \\x{29C4}\n    \\x{29CF} \\x{29D1} \\x{29D4}\n    \\x{29D8} \\x{29DA} \\x{29F8}\n    \\x{29FC} \\x{2A2B} \\x{2A2D}\n    \\x{2A34} \\x{2A3C} \\x{2A64}\n    \\x{2A79} \\x{2A7D} \\x{2A7F}\n    \\x{2A81} \\x{2A83} \\x{2A8B}\n    \\x{2A91} \\x{2A93} \\x{2A95}\n    \\x{2A97} \\x{2A99} \\x{2A9B}\n    \\x{2AA1} \\x{2AA6} \\x{2AA8}\n    \\x{2AAA} \\x{2AAC} \\x{2AAF}\n    \\x{2AB3} \\x{2ABB} \\x{2ABD}\n    \\x{2ABF} \\x{2AC1} \\x{2AC3}\n    \\x{2AC5} \\x{2ACD} \\x{2ACF}\n    \\x{2AD1} \\x{2AD3} \\x{2AD5}\n    \\x{2AEC} \\x{2AF7} \\x{2AF9}\n    \\x{2E02} \\x{2E04} \\x{2E09}\n    \\x{2E0C} \\x{2E1C} \\x{3008}\n    \\x{300A} \\x{300C} \\x{300E}\n    \\x{3010} \\x{3014} \\x{3016}\n    \\x{3018} \\x{301A} \\x{301D}\n    \\x{FD3E} \\x{FE17} \\x{FE35}\n    \\x{FE37} \\x{FE39} \\x{FE3B}\n    \\x{FE3D} \\x{FE3F} \\x{FE41}\n    \\x{FE43} \\x{FE47} \\x{FE59}\n    \\x{FE5B} \\x{FE5D} \\x{FF08}\n    \\x{FF1C} \\x{FF3B} \\x{FF5B}\n    \\x{FF5F} \\x{FF62}]"
package_declarator__S_123class: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_123class
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'class'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_123class
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_123class
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: class
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_123class
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_124grammar: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_124grammar
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'grammar'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_124grammar
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_124grammar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: grammar
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_124grammar
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_125module: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_125module
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'module'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_125module
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_125module
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: module
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_125module
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_126package: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_126package
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'package'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_126package
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_126package
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: package
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_126package
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_127role: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_127role
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'role'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_127role
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_127role
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: role
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_127role
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_128knowhow: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_128knowhow
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'knowhow'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_128knowhow
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_128knowhow
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: knowhow
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_128knowhow
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_129require: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_129require
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_129require
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: require
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_129require
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: package_declarator__S_129require
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: package_declarator__S_129require
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: package_declarator__S_129require
                  i: 0
                  min: 12345
                  name: module_name
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: package_declarator__S_129require
                    i: 0
                    min: 12345
                    name: EXPR
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_method 
              a: 0
              dba: package_declarator__S_129require
              i: 0
              min: 12345
              name: EXPR
              r: 1
              rest: ''
              s: 0
package_declarator__S_130trusts: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_130trusts
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_130trusts
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: trusts
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_130trusts
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_130trusts
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 0
package_declarator__S_131does: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_131does
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_131does
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: does
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_131does
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_131does
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 0
package_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $longname
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: package_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: package_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 0
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: package_def
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: package_def
                      i: 0
                      min: 12345
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: package_def
                          i: 0
                          min: 12345
                          name: def_module_name
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: package_def
                          i: 0
                          min: 0
                          r: 1
                          s: 1
                          text: "\n                $longname = $<def_module_name>[0]<longname>;\n                $.add_name($longname.Str);\n            "
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: package_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: package_def
                    i: 0
                    min: 0
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: package_def
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: package_def
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: "{"
                              s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: package_def
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "\n            # figure out the actual full package name (nested in outer package)\n                my $pkg = $*PKGNAME || \"GLOBAL\";\n                my $shortname;\n                if $longname {\n                     $shortname = $longname.<name>.Str;\n                }\n                else {\n                    $shortname = '_anon_';\n                }\n                $*PKGNAME = $pkg ~ '::' ~ $shortname;\n                my $newpkg = $*CURPKG.{$shortname ~ '::'} //= {};\n                $newpkg.<PARENT::> = $*CURPKG;\n                $*CURPKG = $newpkg;\n                push @PKGS, $pkg;\n                # say \"adding $newpkg \" ~ $*PKGNAME;\n            "
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: package_def
                            i: 0
                            min: 12345
                            name: block
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: package_def
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "\n                $*PKGNAME = pop(@PKGS);\n                $*CURPKG = $*CURPKG.{'PARENT::'};\n            "
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'package_def_block'
                            max: 0
                            min: 0
                            name: _REDUCE
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_block 
                              a: 0
                              context: bool
                              dba: package_def
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 1
                              text: " $*begin_compunit "
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: package_def
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: ''
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: package_def
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: package_def
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: ;
                              s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: package_def
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "\n                $longname orelse $.panic(\"Compilation unit cannot be anonymous\");\n                my $shortname = $longname.<name>.Str;\n                $*PKGNAME = $shortname;\n                my $newpkg = $*CURPKG.{$shortname ~ '::'} //= {};\n                $newpkg.<PARENT::> = $*CURPKG;\n                $*CURPKG = $newpkg;\n                $*begin_compunit = 0;\n            "
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'package_def_semi'
                            max: 0
                            min: 0
                            name: _REDUCE
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_method 
                            min: 0
                            name: panic
                            nobind: 1
                            rest: ("Unable to parse " ~ $*PKGDECL ~ " definition")
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: package_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed $*PKGDECL")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
param_sep: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: param_sep
    i: 0
    min: 1
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &59 !!perl/hash:RE_any 
          a: 0
          altname: param_sep_01
          dba: param_sep
          i: 0
          min: 1
          name: param_sep_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 0
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ","
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 1
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ":"
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 2
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ;
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 3
              dba: param_sep
              i: 0
              min: 2
              r: 1
              s: 1
              text: ;;
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
param_sep_01: *59
param_var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &117 !!perl/hash:RE_any 
      a: 0
      altname: param_var_01
      dba: param_var
      i: 0
      min: 12345
      name: param_var_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 0
          dba: param_var
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: param_var
              i: 0
              min: 1
              r: 1
              s: 0
              text: "["
            - !!perl/hash:RE_meta 
              a: 0
              dba: param_var
              extra: "local $::GOAL = ']' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: param_var
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: param_var
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (']' , 'param_var')
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 1
          dba: param_var
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: param_var
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_meta 
              a: 0
              dba: param_var
              extra: "local $::GOAL = ')' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: param_var
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: param_var
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (')' , 'param_var')
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 2
          dba: param_var
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: param_var
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_assertion 
                      assert: "?"
                      min: 0
                      re: !!perl/hash:RE_method_re 
                        a: 0
                        dba: param_var
                        i: 0
                        min: 0
                        name: before
                        nobind: 1
                        r: 1
                        re: !!perl/hash:RE 
                          decl: []

                          min: 12346
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12346
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_method 
                                a: 0
                                dba: param_var
                                i: 0
                                min: 12345
                                name: twigil
                                nobind: 1
                                r: 1
                                rest: ''
                                s: 0
                              - !!perl/hash:RE_meta 
                                a: 0
                                dba: param_var
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \w
                        s: 0
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      name: twigil
                      r: 1
                      rest: ''
                      s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: param_var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: param_var
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $<sigil>.Str eq '&' "
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12345
                            name: ident
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: param_var
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: ''
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12345
                            name: sublongname
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: param_var
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: name
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: param_var
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: " $*REALLYADD = 0 "
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: param_var
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $<sigil>.Str eq '@' || $<sigil>.Str eq '%' "
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: param_var
                              i: 0
                              min: 12345
                              name: identifier
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            nobind: 1
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          dba: param_var
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          var: name
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_cclass 
                                a: 0
                                dba: param_var
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "[ \\< \\( \\[ \\{ ]"
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: param_var
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                    - !!perl/hash:RE_bindnamed 
                      a: 0
                      atom: !!perl/hash:RE_method 
                        a: 0
                        dba: param_var
                        i: 0
                        min: 12345
                        name: identifier
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      var: name
                    - !!perl/hash:RE_bindnamed 
                      a: 0
                      atom: !!perl/hash:RE_bracket 
                        decl: []

                        min: 1
                        nobind: 1
                        re: !!perl/hash:RE_cclass 
                          a: 0
                          dba: param_var
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "[/!]"
                      dba: param_var
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      var: name
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: param_var
              i: 0
              min: 0
              r: 1
              s: 0
              text: "\n            my $vname = $<sigil>.Str;\n            my $t = $<twigil>;\n            my $twigil = '';\n            $twigil = $t.[0].Str if @$t;\n            $vname ~= $twigil;\n            my $n = try { $<name>[0].Str } // '';\n            $vname ~= $n;\n            if $*REALLYADD {\n                given $twigil {\n                    when '' {\n                        self.add_variable($vname) if $n ne '';\n                    }\n                    when '.' {\n                    }\n                    when '!' {\n                    }\n                    default {\n                        self.worry(\"Illegal to use $twigil twigil in signature\");\n                    }\n                }\n            }\n        "
param_var_01: *117
parameter: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $kind
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $quant = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $q
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $REALLYADD is context<rw> = 0
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parameter
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*REALLYADD = 1 "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &49 !!perl/hash:RE_any 
          a: 0
          altname: parameter_01
          dba: parameter
          i: 0
          min: 12345
          name: parameter_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 0
              dba: parameter
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: parameter
                    i: 0
                    min: 12345
                    name: type_constraint
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            my $t = $<type_constraint>;\n            @$t > 1 and $.panic(\"Multiple prefix constraints not yet supported\")\n        "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: &62 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_02
                    dba: parameter
                    i: 0
                    min: 0
                    name: parameter_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 0
                        dba: parameter
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "*"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '*'; $kind = '*'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 1
                        dba: parameter
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "|"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '|'; $kind = '*'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 2
                        dba: parameter
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '\\\\'; $kind = '!'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 3
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 12345
                            re: &98 !!perl/hash:RE_any 
                              a: 0
                              altname: parameter_03
                              dba: parameter
                              i: 0
                              min: 12345
                              name: parameter_03
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_03 0
                                  dba: parameter
                                  i: 0
                                  min: 12345
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 12345
                                      name: param_var
                                      r: 1
                                      rest: ''
                                      s: 0
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = ''; $kind = '!'; "
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_03 1
                                  dba: parameter
                                  i: 0
                                  min: 12345
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 12345
                                      name: named_param
                                      r: 1
                                      rest: ''
                                      s: 0
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = ''; $kind = '*'; "
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 0
                            re: &113 !!perl/hash:RE_any 
                              a: 0
                              altname: parameter_04
                              dba: parameter
                              i: 0
                              min: 0
                              name: parameter_04
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_04 0
                                  dba: parameter
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "?"
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = '?'; $kind = '?' "
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_04 1
                                  dba: parameter
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "!"
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = '!'; $kind //= '!' "
                                - !!perl/hash:RE_assertion 
                                  alt: parameter_04 2
                                  assert: "?"
                                  min: 0
                                  re: !!perl/hash:RE_noop 
                                    a: 0
                                    dba: parameter
                                    i: 0
                                    min: 0
                                    nobind: 1
                                    r: 1
                                    s: 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 4
                        dba: parameter
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_noop 
                              a: 0
                              dba: parameter
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '!' "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 1
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "*"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '*'; $kind = '*'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 2
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "|"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '|'; $kind = '*'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 3
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '\\\\'; $kind = '!'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 4
              dba: parameter
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &8 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_05
                    dba: parameter
                    i: 0
                    min: 12345
                    name: parameter_05
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_05 0
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '!'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_05 1
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: named_param
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '*'; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: &9 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_06
                    dba: parameter
                    i: 0
                    min: 0
                    name: parameter_06
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_06 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "?"
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '?'; $kind = '?' "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_06 1
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "!"
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '!'; $kind //= '!' "
                      - !!perl/hash:RE_assertion 
                        alt: parameter_06 2
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_noop 
                          a: 0
                          dba: parameter
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: post_constraint
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: parameter
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: parameter
                i: 0
                min: 12345
                name: default_value
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: parameter
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            given $quant {\n              when '!' { $.panic(\"Can't put a default on a required parameter\") }\n              when '*' { $.panic(\"Can't put a default on a slurpy parameter\") }\n              when '|' { $.panic(\"Can't put a default on an slurpy capture parameter\") }\n              when '\\\\' { $.panic(\"Can't put a default on a capture parameter\") }\n            }\n            $kind = '?';\n        "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        $<quant> = $quant;\n        $<kind> = $kind;\n    "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $kind {\n            when '!' {\n                given $*zone {\n                    when 'posopt' {\n$.panic(\"Can't put required parameter after optional parameters\");\n                    }\n                    when 'var' {\n$.panic(\"Can't put required parameter after variadic parameters\");\n                    }\n                }\n            }\n            when '?' {\n                given $*zone {\n                    when 'posreq' { $*zone = 'posopt' }\n                    when 'var' {\n$.panic(\"Can't put optional positional parameter after variadic parameters\");\n                    }\n                }\n            }\n            when '*' {\n                $*zone = 'var';\n            }\n        }\n    "
parameter_01: *49
parameter_02: *62
parameter_03: *98
parameter_04: *113
parameter_05: *8
parameter_06: *9
pblock: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: parameterized block
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: parameterized block
        i: 0
        min: 24690
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_assertion 
            assert: "?"
            min: 0
            re: !!perl/hash:RE_method_re 
              a: 0
              dba: parameterized block
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE 
                decl: []

                min: 1
                re: &74 !!perl/hash:RE_any 
                  a: 0
                  altname: pblock_01
                  dba: parameterized block
                  i: 0
                  min: 1
                  name: pblock_01
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: pblock_01 0
                      dba: parameterized block
                      i: 0
                      min: 12345
                      name: lambda
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_string 
                      a: 0
                      alt: pblock_01 1
                      dba: parameterized block
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "{"
              s: 0
          - !!perl/hash:RE_bracket 
            decl: []

            min: 24690
            re: &75 !!perl/hash:RE_any 
              a: 0
              altname: pblock_02
              dba: parameterized block
              i: 0
              min: 24690
              name: pblock_02
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: pblock_02 0
                  dba: parameterized block
                  i: 0
                  min: 49380
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: parameterized block
                      i: 0
                      min: 12345
                      name: lambda
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: parameterized block
                      i: 0
                      min: 12345
                      name: newpad
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: parameterized block
                      i: 0
                      min: 12345
                      name: signature
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: parameterized block
                      i: 0
                      min: 12345
                      name: blockoid
                      r: 1
                      rest: ''
                      s: 0
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: pblock_02 1
                  dba: parameterized block
                  i: 0
                  min: 24690
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_assertion 
                      assert: "?"
                      min: 0
                      re: !!perl/hash:RE_method_re 
                        a: 0
                        dba: parameterized block
                        i: 0
                        min: 0
                        name: before
                        nobind: 1
                        r: 1
                        re: !!perl/hash:RE 
                          decl: []

                          min: 1
                          re: !!perl/hash:RE_string 
                            a: 0
                            dba: parameterized block
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "{"
                        s: 0
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: parameterized block
                      i: 0
                      min: 12345
                      name: newpad
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: parameterized block
                      i: 0
                      min: 12345
                      name: blockoid
                      r: 1
                      rest: ''
                      s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Malformed block")
pblock_01: *74
pblock_02: *75
pod_comment: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: pod_comment
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: pod_comment
        i: 0
        min: 0
        r: 1
        s: 0
        text: "^^"
      - !!perl/hash:RE_string 
        a: 0
        dba: pod_comment
        i: 0
        min: 1
        r: 1
        s: 0
        text: =
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: pod_comment
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &24 !!perl/hash:RE_any 
          a: 0
          altname: pod_comment_01
          dba: pod_comment
          i: 0
          min: 0
          name: pod_comment_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 0
              dba: pod_comment
              i: 0
              min: 12352
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: begin
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_method 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 7
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_double 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: \n=
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 3
                            r: 1
                            s: 0
                            text: end
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_var 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            var: $<identifier>
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \N
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'pod_comment_tagged'
                            max: 0
                            min: 0
                            name: _REDUCE
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'pod_comment_end'
                            max: 0
                            min: 0
                            name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 1
              dba: pod_comment
              i: 0
              min: 5
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: begin
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $$
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "#"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unrecognized token after =begin")
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 6
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_double 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: \n=
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 3
                            r: 1
                            s: 0
                            text: end
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \N
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("=begin without =end")
                - !!perl/hash:RE_method_internal 
                  args: $S, 'pod_comment_anon'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 2
              dba: pod_comment
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 0
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: pod_comment
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 5
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: pod_comment
                                i: 0
                                min: 5
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: .*?
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 0
                                    r: 1
                                    s: 0
                                    text: "^^"
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 4
                                    r: 1
                                    s: 0
                                    text: =cut
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 0
                                    r: 1
                                    s: 0
                                    text: 
                            s: 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Obsolete pod format, please use =begin/=end instead")
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \N
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'pod_comment_misc'
                  max: 0
                  min: 0
                  name: _REDUCE
pod_comment_01: *24
post_constraint: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: post_constraint
    i: 0
    min: 5
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 5
        re: &90 !!perl/hash:RE_any 
          a: 0
          altname: post_constraint_01
          dba: post_constraint
          i: 0
          min: 5
          name: post_constraint_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 0
              dba: post_constraint
              i: 0
              min: 12347
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: "["
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: post_constraint
                  extra: local $::GOAL = ']'
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: post_constraint
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: post_constraint
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']', 'post_constraint')
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 1
              dba: post_constraint
              i: 0
              min: 12347
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: (
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: post_constraint
                  extra: local $::GOAL = ')'
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: post_constraint
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: post_constraint
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')', 'post_constraint')
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 2
              dba: post_constraint
              i: 0
              min: 5
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: where
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %chaining)
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
post_constraint_01: *90
postcircumfix__S_109Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: argument list
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: argument list
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: argument list
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: argument list
        i: 0
        min: 12345
        name: semiarglist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: argument list
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: argument list
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'argument list')
postcircumfix__S_110Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: subscript
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_meta 
        a: 0
        dba: subscript
        extra: "local $::GOAL = ']' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: subscript
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: subscript
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'subscript')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: subscript
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<semilist>.Str eq '-1' and $.obs(\"[-1] subscript to access final element\",\"[*-1]\") "
postcircumfix__S_111Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: subscript
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: subscript
        extra: "local $::GOAL = '}' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: subscript
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: subscript
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: ('}' , 'subscript')
postcircumfix__S_112Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_112Lt_Gt
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_112Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_112Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_112Lt_Gt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right angle quote")
postcircumfix__S_113LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_113LtLt_GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_113LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_113LtLt_GtGt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_113LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right double-angle quote")
postcircumfix__S_114Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_114Fre_Nch
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_114Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_114Fre_Nch
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_114Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right double-angle quote")
postfix__S_303i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix__S_303i
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: postfix__S_303i
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: i
      - !!perl/hash:RE_meta 
        a: 0
        dba: postfix__S_303i
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
postfix__S_305MinusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix__S_305MinusGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postfix__S_305MinusGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: ->
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('-> to call a method', '.')
postfix__S_306PlusPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: postfix__S_306PlusPlus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ++
postfix__S_307MinusMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: postfix__S_307MinusMinus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: --
postfix_prefix_meta_operator__S_102Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &4 !!perl/hash:RE_any 
    a: 0
    altname: postfix_prefix_meta_operator__S_102Nch_00
    dba: postfix_prefix_meta_operator__S_102Nch
    i: 0
    min: 2
    name: postfix_prefix_meta_operator__S_102Nch_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        alt: postfix_prefix_meta_operator__S_102Nch_00 0
        dba: postfix_prefix_meta_operator__S_102Nch
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 
      - !!perl/hash:RE_string 
        a: 0
        alt: postfix_prefix_meta_operator__S_102Nch_00 1
        dba: postfix_prefix_meta_operator__S_102Nch
        i: 0
        min: 2
        r: 1
        s: 0
        text: ">>"
postfix_prefix_meta_operator__S_102Nch_00: *4
postop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: &10 !!perl/hash:RE_any 
    a: 0
    altname: postop_00
    dba: postop
    i: 0
    min: 12345
    name: postop_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        alt: postop_00 0
        dba: postop
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: postop
            i: 0
            min: 12345
            name: postfix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: postop
            i: 0
            min: 0
            r: 1
            s: 0
            text: " $<O> := $<postfix><O>; $<sym> := $<postfix><sym>; "
      - !!perl/hash:RE_sequence 
        a: 0
        alt: postop_00 1
        dba: postop
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: postop
            i: 0
            min: 12345
            name: postcircumfix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: postop
            i: 0
            min: 0
            r: 1
            s: 0
            text: " $<O> := $<postcircumfix><O>; $<sym> := $<postcircumfix><sym>; "
postop_00: *10
prefix__S_308PlusPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_308PlusPlus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ++
prefix__S_309MinusMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_309MinusMinus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: --
prefix__S_311Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_311Bang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!"
prefix__S_312Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_312Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
prefix__S_313Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_313Minus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "-"
prefix__S_314Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_314Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
prefix__S_315Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_315Question
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "?"
prefix__S_316TildeCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_316TildeCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~^
prefix__S_317PlusCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_317PlusCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +^
prefix__S_318QuestionCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_318QuestionCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?^
prefix__S_319Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_319Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
prefix__S_320Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_320Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
prefix__S_350sleep: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_350sleep
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_350sleep
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: sleep
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_350sleep
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_350sleep
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_350sleep
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_351abs: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_351abs
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_351abs
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: abs
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_351abs
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_351abs
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_351abs
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_352let: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_352let
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_352let
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: let
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_352let
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_352let
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_352let
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_353temp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_353temp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_353temp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: temp
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_353temp
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_353temp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_353temp
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_404true: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_404true
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_404true
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 'true'
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_404true
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
prefix__S_405not: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_405not
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_405not
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: not
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_405not
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
prefix_circumfix_meta_operator__S_100reduce: !!perl/hash:RE 
  decl: []

  kind: regex
  min: 1
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix_circumfix_meta_operator__S_100reduce
    i: 0
    min: 1
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix_circumfix_meta_operator__S_100reduce
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 0
          re: !!perl/hash:RE 
            decl: []

            min: 3
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: prefix_circumfix_meta_operator__S_100reduce
              i: 0
              min: 3
              r: 0
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_100reduce
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: prefix_circumfix_meta_operator__S_100reduce
                    i: 0
                    min: 1
                    r: 0
                    s: 0
                    text: \S
                  min: 1
                  quant: 
                    - +
                    - "!"
                    - ''
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_100reduce
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: "]"
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: prefix_circumfix_meta_operator__S_100reduce
            i: 0
            min: 1
            r: 0
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: prefix_circumfix_meta_operator__S_100reduce
                i: 0
                min: 1
                r: 0
                s: 0
                text: "["
              - !!perl/hash:RE_bracket 
                decl: []

                min: 0
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_100reduce
                  i: 0
                  min: 0
                  r: 0
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: prefix_circumfix_meta_operator__S_100reduce
                      i: 0
                      min: 1
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            min: 0
                            name: infixish
                            nobind: 1
                            rest: (1)
                          dba: prefix_circumfix_meta_operator__S_100reduce
                          i: 0
                          min: 0
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_100reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &78 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_100reduce_04
                            dba: prefix_circumfix_meta_operator__S_100reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_100reduce_04
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_100reduce_04 0
                                dba: prefix_circumfix_meta_operator__S_100reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_100reduce_04 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_100reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: prefix_circumfix_meta_operator__S_100reduce
                      i: 0
                      min: 2
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_100reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: \
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            min: 0
                            name: infixish
                            nobind: 1
                            rest: (1)
                          dba: prefix_circumfix_meta_operator__S_100reduce
                          i: 0
                          min: 0
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_100reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &79 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_100reduce_06
                            dba: prefix_circumfix_meta_operator__S_100reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_100reduce_06
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_100reduce_06 0
                                dba: prefix_circumfix_meta_operator__S_100reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_100reduce_06 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_100reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
                    - !!perl/hash:RE_assertion 
                      assert: "!"
                      min: 0
                      re: !!perl/hash:RE_noop 
                        a: 0
                        dba: prefix_circumfix_meta_operator__S_100reduce
                        i: 0
                        min: 0
                        nobind: 1
                        r: 0
                        s: 0
        dba: prefix_circumfix_meta_operator__S_100reduce
        i: 0
        min: 1
        r: 0
        s: 0
        var: s
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix_circumfix_meta_operator__S_100reduce
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 0
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: prefix_circumfix_meta_operator__S_100reduce
              i: 0
              min: 1
              r: 0
              s: 0
              text: "[ \\s ( ]"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<s><op>, "reduce")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: prefix_circumfix_meta_operator__S_100reduce
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: prefix_circumfix_meta_operator__S_100reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $<s><op><O><diffy> "
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: prefix_circumfix_meta_operator__S_100reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $<s><op><O><assoc> eq 'chain' "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't reduce a " ~ $<s><op><O><dba> ~ " operator because it's diffy and not chaining")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: prefix_circumfix_meta_operator__S_100reduce
        i: 0
        min: 0
        r: 0
        s: 0
        text: " $<O> = $<s><op><O>; $<O><prec>:delete; $<O><assoc> = 'unary'; $<O><uassoc> = 'left'; "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: prefix_circumfix_meta_operator__S_100reduce
        i: 0
        min: 0
        r: 0
        s: 0
        text: " $<sym> = $<s>.Str; "
prefix_circumfix_meta_operator__S_100reduce_04: *78
prefix_circumfix_meta_operator__S_100reduce_06: *79
prefix_postfix_meta_operator__S_101Fre: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &5 !!perl/hash:RE_any 
    a: 0
    altname: prefix_postfix_meta_operator__S_101Fre_00
    dba: prefix_postfix_meta_operator__S_101Fre
    i: 0
    min: 2
    name: prefix_postfix_meta_operator__S_101Fre_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        alt: prefix_postfix_meta_operator__S_101Fre_00 0
        dba: prefix_postfix_meta_operator__S_101Fre
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 
      - !!perl/hash:RE_string 
        a: 0
        alt: prefix_postfix_meta_operator__S_101Fre_00 1
        dba: prefix_postfix_meta_operator__S_101Fre
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
prefix_postfix_meta_operator__S_101Fre_00: *5
privop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: privop
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: privop
        i: 0
        min: 1
        r: 1
        s: 0
        text: "!"
      - !!perl/hash:RE_method 
        a: 0
        dba: privop
        i: 0
        min: 12345
        name: methodop
        r: 1
        rest: ''
        s: 0
quasiquibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quasiquibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
    - !!perl/hash:RE_decl 
      a: 0
      dba: quasiquibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QUASI_QUASH is context = 0
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quasiquibble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quasiquibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: quasiquibble
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: quasiquibble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: quasiquibble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start eq '{' "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: quasiquibble
                    i: 0
                    lang: ($lang)
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_decl 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        max: 0
                        min: 0
                        noquant: 1
                        r: 1
                        s: 0
                        text: "my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); "
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        min: 12345
                        name: block
                        r: 1
                        rest: ''
                        s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: quasiquibble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_var 
                  a: 0
                  dba: quasiquibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $start
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: quasiquibble
                    i: 0
                    lang: ($lang)
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_decl 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        max: 0
                        min: 0
                        noquant: 1
                        r: 1
                        s: 0
                        text: "my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); "
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        min: 12345
                        name: statementlist
                        r: 1
                        rest: ''
                        s: 0
                - !!perl/hash:RE_var 
                  a: 0
                  dba: quasiquibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
quibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($lang)
      - !!perl/hash:RE_var 
        a: 0
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        if $lang<_herelang> {\n            push @herestub_queue,\n                ::Herestub.new(\n                    delim => $<nibble><nibbles>[0]<TEXT>,\n                    orignode => $,\n                    lang => $lang<_herelang>,\n                );\n        }\n    "
quote__S_207Single_Single: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_207Single_Single
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_double 
        a: 0
        dba: quote__S_207Single_Single
        i: 0
        min: 1
        r: 1
        s: 0
        text: "'"
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).unbalanced("'"))
      - !!perl/hash:RE_double 
        a: 0
        dba: quote__S_207Single_Single
        i: 0
        min: 1
        r: 1
        s: 0
        text: "'"
quote__S_208Double_Double: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_208Double_Double
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_208Double_Double
        i: 0
        min: 1
        r: 1
        s: 0
        text: "\""
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).unbalanced('"'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_208Double_Double
        i: 0
        min: 1
        r: 1
        s: 0
        text: "\""
quote__S_209Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_209Fre_Nch
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_209Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_209Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
quote__S_210LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_210LtLt_GtGt
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_210LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_210LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: ">>"
quote__S_211Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_211Lt_Gt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_211Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quote__S_211Lt_Gt
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: quote__S_211Lt_Gt
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 6
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: quote__S_211Lt_Gt
                      i: 0
                      min: 6
                      r: 1
                      s: 0
                      text: STDIN>
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('<STDIN>', '$' ~ '*IN.lines')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quote__S_211Lt_Gt
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: quote__S_211Lt_Gt
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: quote__S_211Lt_Gt
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ">"
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('<>', 'lines() or ()')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_211Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: ">"
quote__S_212Slash_Slash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_212Slash_Slash
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_212Slash_Slash
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ( $.cursor_fresh( ::Regex ).unbalanced("/") )
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: quote__S_212Slash_Slash
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: quote__S_212Slash_Slash
              i: 0
              min: 1
              r: 1
              s: 0
              text: /
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find final '/'")
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_212Slash_Slash
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quote__S_213qq: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_213qq
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_213qq
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_213qq
        i: 0
        min: 2
        r: 1
        s: 0
        text: qq
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &84 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_213qq_01
          dba: quote__S_213qq
          i: 0
          min: 12345
          name: quote__S_213qq_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_213qq_01 0
              dba: quote__S_213qq
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_213qq
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_213qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_213qq
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_213qq
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_213qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.Str "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_213qq
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_213qq_01 1
              dba: quote__S_213qq
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_213qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_213qq
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_213qq
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_213qq
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq))
quote__S_213qq_01: *84
quote__S_214q: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_214q
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_214q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_214q
        i: 0
        min: 1
        r: 1
        s: 0
        text: q
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &65 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_214q_01
          dba: quote__S_214q
          i: 0
          min: 12345
          name: quote__S_214q_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_214q_01 0
              dba: quote__S_214q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_214q
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_214q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_214q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_214q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_214q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.Str "
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_214q_01 1
              dba: quote__S_214q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_214q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_214q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_214q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_214q
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:q))
quote__S_214q_01: *65
quote__S_215Q: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_215Q
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_215Q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_215Q
        i: 0
        min: 1
        r: 1
        s: 0
        text: Q
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &64 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_215Q_01
          dba: quote__S_215Q
          i: 0
          min: 12345
          name: quote__S_215Q_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_215Q_01 0
              dba: quote__S_215Q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_215Q
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_215Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_215Q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_215Q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_215Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.Str "
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_215Q_01 1
              dba: quote__S_215Q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_215Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_215Q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_215Q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_215Q
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ))
quote__S_215Q_01: *64
quote__S_226rx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_226rx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_226rx
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rx
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_226rx
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_226rx
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_226rx
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( ::Regex ) )
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_226rx
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_227m: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_227m
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_227m
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: m
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_227m
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_227m
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_227m
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( ::Regex ) )
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_227m
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_228mm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_228mm
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_228mm
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: mm
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_228mm
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_228mm
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_228mm
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( ::Regex ).tweak(:s))
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_228mm
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_229s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_229s
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_229s
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: s
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_229s
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_229s
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_229s
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: sibble
          nobind: 1
          rest: ( $.cursor_fresh( ::Regex ), $.cursor_fresh( ::STD::Q ).tweak(:qq))
        dba: quote__S_229s
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_229s
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_230ss: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_230ss
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_230ss
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ss
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_230ss
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_230ss
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_230ss
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: sibble
          nobind: 1
          rest: ( $.cursor_fresh( ::Regex ).tweak(:s), $.cursor_fresh( ::STD::Q ).tweak(:qq))
        dba: quote__S_230ss
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_230ss
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_231tr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_231tr
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_231tr
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: tr
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_231tr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_231tr
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_231tr
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: tribble
          nobind: 1
          rest: ( $.cursor_fresh( ::STD::Q ).tweak(:q))
        dba: quote__S_231tr
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_231tr
          i: 0
          min: 12345
          name: old_tr_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_232quasi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_232quasi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_232quasi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: quasi
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_232quasi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_232quasi
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_232quasi
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quasiquibble
        rest: ($.cursor_fresh( ::STD::Quasi ))
quote_mod__S_216w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_216w
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
quote_mod__S_217ww: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_217ww
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ww
quote_mod__S_218x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_218x
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: x
quote_mod__S_219to: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_219to
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: to
quote_mod__S_220s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_220s
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
quote_mod__S_221a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_221a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
quote_mod__S_222h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_222h
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
quote_mod__S_223f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_223f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
quote_mod__S_224c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_224c
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: c
quote_mod__S_225b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_225b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
quotepair: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quotepair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $key
    - !!perl/hash:RE_decl 
      a: 0
      dba: quotepair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $value
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: colon pair (restricted)
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quotepair
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &36 !!perl/hash:RE_any 
          a: 0
          altname: quotepair_01
          dba: colon pair (restricted)
          i: 0
          min: 2
          name: quotepair_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 0
              dba: colon pair (restricted)
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; $value = 0; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair_false'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 1
              dba: colon pair (restricted)
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: colon pair (restricted)
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: colon pair (restricted)
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                              s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: colon pair (restricted)
                            i: 0
                            min: 12345
                            name: postcircumfix
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: colon pair (restricted)
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $value = $<postcircumfix>; "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: colon pair (restricted)
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $value = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair_value'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 2
              dba: colon pair (restricted)
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: 'n'
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_cclass 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[a..z]"
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: id
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<id>.Str; $value = $<n>.Str; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair_nth'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: colon pair (restricted)
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<k> = $key; $<v> = $value; "
quotepair_01: *36
rad_number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: number in radix notation
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: rad_number
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: rad_number
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        dba: rad_number
        i: 0
        min: 1
        r: 1
        s: 0
        var: radix
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: rad_number
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: rad_number
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 3
        re: !!perl/hash:RE_first 
          a: 0
          dba: number in radix notation
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: <
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_cclass 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "[ 0..9 a..z A..Z ]"
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: number in radix notation
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: number in radix notation
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_cclass 
                                    a: 0
                                    dba: number in radix notation
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "[ 0..9 a..z A..Z ]"
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: intpart
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_bracket 
                      decl: []

                      min: 2
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: number in radix notation
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[ 0..9 a..z A..Z ]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: number in radix notation
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: number in radix notation
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: number in radix notation
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[ 0..9 a..z A..Z ]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: number in radix notation
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: fracpart
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24693
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 24693
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: number in radix notation
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "*"
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 12345
                            name: radint
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: number in radix notation
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: base
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: number in radix notation
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: "**"
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 12345
                            name: radint
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: number in radix notation
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: exp
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "["
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
radint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &103 !!perl/hash:RE_any 
      a: 0
      altname: radint_01
      dba: radint
      i: 0
      min: 12345
      name: radint_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: radint_01 0
          dba: radint
          i: 0
          min: 12345
          name: integer
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: radint_01 1
          dba: radint
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: radint
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: radint
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: radint
              i: 0
              min: 12345
              name: rad_number
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: radint
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: "\n                        defined $<rad_number><intpart>\n                        and\n                        not defined $<rad_number><fracpart>\n                    "
radint_01: *103
regex_block: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $lang = ::Regex
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_block
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: regex_block
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: regex_block
                i: 0
                min: 12345
                name: quotepair
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: regex_block
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: regex_block
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            my $kv = $<quotepair>[*-1];\n            $lang = $lang.tweak($kv.<k>, $kv.<v>)\n                or self.panic(\"Unrecognized adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: regex_block
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ( $.cursor_fresh($lang).unbalanced('}') )
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: regex_block
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: regex_block
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right brace")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &20 !!perl/hash:RE_any 
          a: 0
          altname: regex_block_04
          dba: regex_block
          i: 0
          min: 0
          name: regex_block_04
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 0
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 0
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: regex_block
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: regex_block
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: regex_block
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_endstmt_simple_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 1
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: regex_block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[,:]"
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_normal_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 2
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_endstmt_complex'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 3
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<endargs> = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_endargs'
                  max: 0
                  min: 0
                  name: _REDUCE
regex_block_04: *20
regex_declarator__S_140regex: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_140regex
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_140regex
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: regex
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_140regex
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_declarator__S_141token: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_141token
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_141token
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: token
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_141token
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_declarator__S_142rule: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_142rule
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_142rule
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rule
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_142rule
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: regex_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: regex_def
        i: 0
        min: 37035
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 37035
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: regex_def
              i: 0
              min: 37035
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    re: &91 !!perl/hash:RE_any 
                      a: 0
                      altname: regex_def_02
                      dba: regex_def
                      i: 0
                      min: 1
                      name: regex_def_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_02 0
                          dba: regex_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: regex_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "&"
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_method 
                                a: 0
                                dba: regex_def
                                i: 0
                                min: 12345
                                name: deflongname
                                r: 1
                                rest: ''
                                s: 1
                              min: 0
                              quant: 
                                - "?"
                                - ":"
                                - ''
                                - 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_02 1
                          dba: regex_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: regex_def
                              i: 0
                              min: 12345
                              name: deflongname
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: regex_def
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &16 !!perl/hash:RE_any 
                      a: 0
                      altname: regex_def_03
                      dba: regex_def
                      i: 0
                      min: 12345
                      name: regex_def_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_03 0
                          dba: regex_def
                          i: 0
                          min: 12347
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 12347
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: regex_def
                                i: 0
                                min: 12347
                                r: 1
                                s: 1
                                zyg: 
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_string 
                                      a: 0
                                      dba: regex_def
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: ":"
                                    min: 0
                                    quant: 
                                      - "?"
                                      - ":"
                                      - ''
                                      - 0
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: regex_def
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 1
                                    text: (
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: ws
                                    nobind: 1
                                    noquant: 1
                                    rest: ''
                                  - !!perl/hash:RE_method 
                                    a: 0
                                    dba: regex_def
                                    i: 0
                                    min: 12345
                                    name: signature
                                    r: 1
                                    rest: ''
                                    s: 1
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: ws
                                    nobind: 1
                                    noquant: 1
                                    rest: ''
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: regex_def
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 1
                                    text: )
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_03 1
                          dba: regex_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: regex_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: " $*IN_DECL = 0; "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: regex_def
                  i: 0
                  min: 12345
                  name: finishpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: regex_def
                  i: 0
                  min: 12345
                  name: regex_block
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: regex_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed regex")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
regex_def_02: *91
regex_def_03: *16
routine_declarator__S_136sub: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_136sub
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_136sub
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: sub
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_136sub
        i: 0
        min: 12345
        name: routine_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_137method: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_137method
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_137method
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: method
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_137method
        i: 0
        min: 12345
        name: method_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_138submethod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_138submethod
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_138submethod
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: submethod
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_138submethod
        i: 0
        min: 12345
        name: method_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_139macro: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_139macro
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_139macro
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: macro
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_139macro
        i: 0
        min: 12345
        name: macro_def
        r: 1
        rest: ''
        s: 0
routine_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: routine_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: routine_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: routine_def
        i: 0
        min: 24690
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 24690
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: routine_def
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    re: &115 !!perl/hash:RE_any 
                      a: 0
                      altname: routine_def_02
                      dba: routine_def
                      i: 0
                      min: 1
                      name: routine_def_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_02 0
                          dba: routine_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "&"
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_method 
                                a: 0
                                dba: routine_def
                                i: 0
                                min: 12345
                                name: deflongname
                                r: 1
                                rest: ''
                                s: 1
                              min: 0
                              quant: 
                                - "?"
                                - ":"
                                - ''
                                - 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_02 1
                          dba: routine_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 12345
                              name: deflongname
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: routine_def
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &95 !!perl/hash:RE_any 
                      a: 0
                      altname: routine_def_03
                      dba: routine_def
                      i: 0
                      min: 12345
                      name: routine_def_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_03 0
                          dba: routine_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 12345
                              name: multisig
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_03 1
                          dba: routine_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: routine_def
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 1
                    text: "\n            $ = $*PARSER.bless($);\n            $*IN_DECL = 0;\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: routine_def
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: routine_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed routine")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
routine_def_02: *115
routine_def_03: *95
scope_declarator__S_116my: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_116my
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_116my
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: my
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_116my
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_116my
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_116my
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_117our: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_117our
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_117our
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: our
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_117our
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_117our
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_117our
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_118state: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_118state
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_118state
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: state
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_118state
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_118state
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_118state
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_119constant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_119constant
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_119constant
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: constant
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_119constant
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_119constant
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_119constant
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_120has: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_120has
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_120has
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: has
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_120has
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_120has
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_120has
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_121augment: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_121augment
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_121augment
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: augment
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_121augment
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_121augment
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_121augment
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_122supersede: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_122supersede
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_122supersede
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: supersede
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_122supersede
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_122supersede
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_122supersede
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scoped: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: scoped declarator
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: scoped declarator
        i: 0
        min: 12345
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 12345
            re: &60 !!perl/hash:RE_any 
              a: 0
              altname: scoped_01
              dba: scoped declarator
              i: 0
              min: 12345
              name: scoped_01
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 1
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: regex_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 2
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: package_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 3
                  dba: scoped declarator
                  i: 0
                  min: 24690
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_method 
                        a: 0
                        dba: scoped declarator
                        i: 0
                        min: 12345
                        name: fulltypename
                        r: 1
                        rest: ''
                        s: 1
                      min: 12345
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                    - !!perl/hash:RE_block 
                      a: 0
                      context: void
                      dba: scoped declarator
                      i: 0
                      min: 0
                      r: 1
                      s: 1
                      text: "\n            my $t = $<fulltypename>;\n            @$t > 1 and $.panic(\"Multiple prefix constraints not yet supported\")\n        "
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: multi_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 4
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: multi_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: scoped declarator
        i: 0
        min: 12345
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion 
            assert: "?"
            min: 0
            re: !!perl/hash:RE_method_re 
              a: 0
              dba: scoped declarator
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE 
                decl: []

                min: 1
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_cclass 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 1
                      r: 1
                      s: 1
                      text: "[A..Z]"
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
              s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            a: 0
            dba: scoped declarator
            i: 0
            min: 12345
            name: longname
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: scoped declarator
            i: 0
            min: 0
            r: 1
            s: 1
            text: "\n            my $t = $<longname>.Str;\n            if not $.is_known($t) {\n                $.panic(\"In \\\"$*SCOPE\\\" declaration, typename $t must be predeclared (or marked as declarative with :: prefix)\");\n            }\n        "
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion 
            assert: "!"
            min: 0
            re: !!perl/hash:RE_noop 
              a: 0
              dba: scoped declarator
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: scoped declarator
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed $*SCOPE")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
scoped_01: *60
semiarglist: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: semiarglist
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: semiarglist
          i: 0
          min: 12345
          name: arglist
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: semiarglist
            i: 0
            min: 1
            r: 1
            s: 0
            text: ;
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: semiarglist
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
semilist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: semilist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 0
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: semicolon list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &51 !!perl/hash:RE_any 
          a: 0
          altname: semilist_01
          dba: semicolon list
          i: 0
          min: 0
          name: semilist_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: semilist_01 0
              dba: semicolon list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: semicolon list
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: semicolon list
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: semicolon list
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "[\\)\\]\\}]"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: semilist_01 1
              dba: semicolon list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: semicolon list
                      i: 0
                      min: 24690
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: semicolon list
                          i: 0
                          min: 12345
                          name: statement
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: semicolon list
                          i: 0
                          min: 12345
                          name: eat_terminator
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
semilist_01: *51
sibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: sibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: nibble
          nobind: 1
          rest: ($lang)
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: left
      - !!perl/hash:RE_var 
        a: 0
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: sibble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: sibble
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: sibble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start ne $stop "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: sibble
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: sibble
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Missing '='")
                - !!perl/hash:RE_method 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: EXPR
                    nobind: 1
                    rest: (item %item_assignment)
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
            - !!perl/hash:RE_sequence 
              a: 0
              dba: sibble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $lang = $lang2.unbalanced($stop); "
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: nibble
                    nobind: 1
                    rest: ($lang)
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
                - !!perl/hash:RE_var 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
sigil__S_187Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_187Dollar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $
sigil__S_188AtAt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_188AtAt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "@@"
sigil__S_189At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_189At
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "@"
sigil__S_190Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_190Percent
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "%"
sigil__S_191Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_191Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
signature: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $zone is context<rw> = 'posreq'
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $startpos = self.pos
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: signature
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &71 !!perl/hash:RE_any 
            a: 0
            altname: signature_01
            dba: signature
            i: 0
            min: 0
            name: signature_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                alt: signature_01 0
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: signature
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &7 !!perl/hash:RE_any 
                      a: 0
                      altname: signature_02
                      dba: signature
                      i: 0
                      min: 1
                      name: signature_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 0
                          dba: signature
                          i: 0
                          min: 3
                          r: 1
                          s: 0
                          text: -->
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 1
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 2
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 3
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "{"
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: signature_02 4
                          dba: signature
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: signature
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: ":"
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: signature
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \s
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                alt: signature_01 1
                dba: signature
                i: 0
                min: 12345
                name: parameter
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_method 
            a: 0
            dba: signature
            i: 0
            min: 12345
            name: param_sep
            r: 1
            rest: ''
            s: 0
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24693
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: signature
            i: 0
            min: 24693
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: signature
                i: 0
                min: 3
                r: 1
                s: 0
                text: -->
              - !!perl/hash:RE_method 
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: fulltypename
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: signature
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*IN_DECL = 0; $*SIGIL = '@'; $*CURPAD.{'$?GOTSIG'} ~= '(' ~ substr($*ORIG, $startpos, $.pos - $startpos) ~ ')'; "
signature_01: *71
signature_02: *7
sigterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sigterm
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: sigterm
        i: 0
        min: 2
        r: 1
        s: 0
        text: :(
      - !!perl/hash:RE_meta 
        a: 0
        dba: sigterm
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: sigterm
        i: 0
        min: 12345
        name: signature
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: sigterm
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: sigterm
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'sigterm')
spacey: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: spacey
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: &76 !!perl/hash:RE_any 
          a: 0
          altname: spacey_01
          dba: spacey
          i: 0
          min: 1
          name: spacey_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_meta 
              a: 0
              alt: spacey_01 0
              dba: spacey
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string 
              a: 0
              alt: spacey_01 1
              dba: spacey
              i: 0
              min: 1
              r: 1
              s: 0
              text: "#"
      s: 0
spacey_01: *76
special_variable__S_143Dollar_a2_: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: special_variable__S_143Dollar_a2_
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $
special_variable__S_144DollarBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_144DollarBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_144DollarBang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $!
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_144DollarBang
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: special_variable__S_144DollarBang
              i: 0
              min: 1
              r: 1
              s: 0
              text: \w
          s: 0
special_variable__S_145DollarBangCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_145DollarBangCur_Ly
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 5
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_145DollarBangCur_Ly
            i: 0
            min: 5
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_145DollarBangCur_Ly
                i: 0
                min: 3
                r: 1
                s: 0
                text: $!{
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_145DollarBangCur_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_145DollarBangCur_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_145DollarBangCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 5
        var: 1
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ($0.Str ~ " variable", 'smart match against $!')
special_variable__S_146DollarSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_146DollarSlash
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_146DollarSlash
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $/
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_146DollarSlash
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: special_variable__S_146DollarSlash
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: special_variable__S_146DollarSlash
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: special_variable__S_146DollarSlash
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: special_variable__S_146DollarSlash
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: =
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_cclass 
                            a: 0
                            dba: special_variable__S_146DollarSlash
                            i: 0
                            min: 1
                            nobind: 1
                            r: 1
                            s: 0
                            text: "[=]"
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: "('$/ variable as input record separator',\n             \"filehandle's :irs attribute\")"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
special_variable__S_147DollarTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_147DollarTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_147DollarTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $~
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_147DollarTilde
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_147DollarTilde
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &96 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_147DollarTilde_01
              dba: special_variable__S_147DollarTilde
              i: 0
              min: 1
              name: special_variable__S_147DollarTilde_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_147DollarTilde_01 0
                  dba: special_variable__S_147DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_147DollarTilde_01 1
                  dba: special_variable__S_147DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_147DollarTilde_01 2
                  dba: special_variable__S_147DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_147DollarTilde_01 3
                  dba: special_variable__S_147DollarTilde
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$~ variable', 'Form module')
special_variable__S_147DollarTilde_01: *96
special_variable__S_148DollarGrave: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_148DollarGrave
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_148DollarGrave
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $`
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_148DollarGrave
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_148DollarGrave
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &42 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_148DollarGrave_01
              dba: special_variable__S_148DollarGrave
              i: 0
              min: 1
              name: special_variable__S_148DollarGrave_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_148DollarGrave_01 0
                  dba: special_variable__S_148DollarGrave
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_148DollarGrave_01 1
                  dba: special_variable__S_148DollarGrave
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_148DollarGrave_01 2
                  dba: special_variable__S_148DollarGrave
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$` variable', 'explicit pattern before <(')
special_variable__S_148DollarGrave_01: *42
special_variable__S_149DollarAt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_149DollarAt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_149DollarAt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $@
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_149DollarAt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$@ variable as eval error', '$!')
special_variable__S_150DollarSharp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_150DollarSharp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_150DollarSharp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $#
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_150DollarSharp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: special_variable__S_150DollarSharp
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: special_variable__S_150DollarSharp
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: special_variable__S_150DollarSharp
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  min: 1
                  var: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: obs
                  nobind: 1
                  rest: ("\$#" ~ $0.Str ~ " variable", "\@\{" ~ $0.Str ~ "}.end")
            - !!perl/hash:RE_method 
              min: 0
              name: obs
              nobind: 1
              rest: ('$# variable', '.fmt')
special_variable__S_151DollarDollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_151DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_151DollarDollar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $$
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: special_variable__S_151DollarDollar
          i: 0
          min: 12345
          name: alpha
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_151DollarDollar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_151DollarDollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &107 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_151DollarDollar_01
              dba: special_variable__S_151DollarDollar
              i: 0
              min: 1
              name: special_variable__S_151DollarDollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_151DollarDollar_01 0
                  dba: special_variable__S_151DollarDollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_151DollarDollar_01 1
                  dba: special_variable__S_151DollarDollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_151DollarDollar_01 2
                  dba: special_variable__S_151DollarDollar
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$$ variable', '$*PID')
special_variable__S_151DollarDollar_01: *107
special_variable__S_152DollarPercent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_152DollarPercent
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_152DollarPercent
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $%
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_152DollarPercent
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$% variable', 'Form module')
special_variable__S_153DollarCaretX: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_153DollarCaretX
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_153DollarCaretX
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_153DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        text: "^"
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_cclass 
            a: 0
            dba: special_variable__S_153DollarCaretX
            i: 0
            min: 1
            r: 1
            s: 0
            text: "[A..Z]"
        dba: special_variable__S_153DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        var: letter
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_153DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
      - !!perl/hash:RE_method 
        min: 0
        name: obscaret
        nobind: 1
        rest: ($<sigil>.Str ~ '^' ~ $<letter>.Str, $<sigil>, $<letter>.Str)
special_variable__S_154DollarCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_154DollarCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_154DollarCaret
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $^
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_154DollarCaret
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_154DollarCaret
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &47 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_154DollarCaret_01
              dba: special_variable__S_154DollarCaret
              i: 0
              min: 1
              name: special_variable__S_154DollarCaret_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_154DollarCaret_01 0
                  dba: special_variable__S_154DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_154DollarCaret_01 1
                  dba: special_variable__S_154DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_154DollarCaret_01 2
                  dba: special_variable__S_154DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_154DollarCaret_01 3
                  dba: special_variable__S_154DollarCaret
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$^ variable', 'Form module')
special_variable__S_154DollarCaret_01: *47
special_variable__S_155DollarAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_155DollarAmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_155DollarAmp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $&
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_155DollarAmp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_155DollarAmp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &21 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_155DollarAmp_01
              dba: special_variable__S_155DollarAmp
              i: 0
              min: 1
              name: special_variable__S_155DollarAmp_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_155DollarAmp_01 0
                  dba: special_variable__S_155DollarAmp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_155DollarAmp_01 1
                  dba: special_variable__S_155DollarAmp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_155DollarAmp_01 2
                  dba: special_variable__S_155DollarAmp
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$& variable', '$/ or $()')
special_variable__S_155DollarAmp_01: *21
special_variable__S_156DollarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_156DollarStar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_156DollarStar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $*
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_156DollarStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_156DollarStar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &25 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_156DollarStar_01
              dba: special_variable__S_156DollarStar
              i: 0
              min: 1
              name: special_variable__S_156DollarStar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_156DollarStar_01 0
                  dba: special_variable__S_156DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_156DollarStar_01 1
                  dba: special_variable__S_156DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_156DollarStar_01 2
                  dba: special_variable__S_156DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_156DollarStar_01 3
                  dba: special_variable__S_156DollarStar
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$* variable', '^^ and $$')
special_variable__S_156DollarStar_01: *25
special_variable__S_157DollarThesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_157DollarThesis
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_157DollarThesis
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $)
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_157DollarThesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_157DollarThesis
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &88 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_157DollarThesis_01
              dba: special_variable__S_157DollarThesis
              i: 0
              min: 1
              name: special_variable__S_157DollarThesis_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_157DollarThesis_01 0
                  dba: special_variable__S_157DollarThesis
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_157DollarThesis_01 1
                  dba: special_variable__S_157DollarThesis
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_157DollarThesis_01 2
                  dba: special_variable__S_157DollarThesis
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$) variable', '$*EGID')
special_variable__S_157DollarThesis_01: *88
special_variable__S_158DollarMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_158DollarMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_158DollarMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $-
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_158DollarMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_158DollarMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &46 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_158DollarMinus_01
              dba: special_variable__S_158DollarMinus
              i: 0
              min: 1
              name: special_variable__S_158DollarMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_158DollarMinus_01 0
                  dba: special_variable__S_158DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_158DollarMinus_01 1
                  dba: special_variable__S_158DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_158DollarMinus_01 2
                  dba: special_variable__S_158DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_158DollarMinus_01 3
                  dba: special_variable__S_158DollarMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$- variable', 'Form module')
special_variable__S_158DollarMinus_01: *46
special_variable__S_159DollarEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_159DollarEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_159DollarEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $=
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_159DollarEqual
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_159DollarEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &53 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_159DollarEqual_01
              dba: special_variable__S_159DollarEqual
              i: 0
              min: 1
              name: special_variable__S_159DollarEqual_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_159DollarEqual_01 0
                  dba: special_variable__S_159DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_159DollarEqual_01 1
                  dba: special_variable__S_159DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_159DollarEqual_01 2
                  dba: special_variable__S_159DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_159DollarEqual_01 3
                  dba: special_variable__S_159DollarEqual
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$= variable', 'Form module')
special_variable__S_159DollarEqual_01: *53
special_variable__S_160AtPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_160AtPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_160AtPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "@+"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_160AtPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_160AtPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &120 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_160AtPlus_01
              dba: special_variable__S_160AtPlus
              i: 0
              min: 1
              name: special_variable__S_160AtPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_160AtPlus_01 0
                  dba: special_variable__S_160AtPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_160AtPlus_01 1
                  dba: special_variable__S_160AtPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_160AtPlus_01 2
                  dba: special_variable__S_160AtPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_160AtPlus_01: *120
special_variable__S_161PercentPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_161PercentPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_161PercentPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%+"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_161PercentPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_161PercentPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &82 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_161PercentPlus_01
              dba: special_variable__S_161PercentPlus
              i: 0
              min: 1
              name: special_variable__S_161PercentPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_161PercentPlus_01 0
                  dba: special_variable__S_161PercentPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_161PercentPlus_01 1
                  dba: special_variable__S_161PercentPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_161PercentPlus_01 2
                  dba: special_variable__S_161PercentPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%+ variable', '.to method')
special_variable__S_161PercentPlus_01: *82
special_variable__S_162DollarPlusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_162DollarPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_162DollarPlusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: $+[
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_163AtPlusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_163AtPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_163AtPlusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@+["
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_164AtPlusCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_164AtPlusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_164AtPlusCur_Ly
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@+{"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%+ variable', '.to method')
special_variable__S_165AtMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_165AtMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_165AtMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "@-"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_165AtMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_165AtMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &67 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_165AtMinus_01
              dba: special_variable__S_165AtMinus
              i: 0
              min: 1
              name: special_variable__S_165AtMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_165AtMinus_01 0
                  dba: special_variable__S_165AtMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_165AtMinus_01 1
                  dba: special_variable__S_165AtMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_165AtMinus_01 2
                  dba: special_variable__S_165AtMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_165AtMinus_01: *67
special_variable__S_166PercentMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_166PercentMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_166PercentMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%-"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_166PercentMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_166PercentMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &32 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_166PercentMinus_01
              dba: special_variable__S_166PercentMinus
              i: 0
              min: 1
              name: special_variable__S_166PercentMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_166PercentMinus_01 0
                  dba: special_variable__S_166PercentMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_166PercentMinus_01 1
                  dba: special_variable__S_166PercentMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_166PercentMinus_01 2
                  dba: special_variable__S_166PercentMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%- variable', '.from method')
special_variable__S_166PercentMinus_01: *32
special_variable__S_167DollarMinusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_167DollarMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_167DollarMinusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: $-[
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_168AtMinusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_168AtMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_168AtMinusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@-["
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_169PercentMinusCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_169PercentMinusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_169PercentMinusCur_Ly
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@-{"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%- variable', '.from method')
special_variable__S_170DollarPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_170DollarPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_170DollarPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $+
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_170DollarPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_170DollarPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &56 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_170DollarPlus_01
              dba: special_variable__S_170DollarPlus
              i: 0
              min: 1
              name: special_variable__S_170DollarPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_170DollarPlus_01 0
                  dba: special_variable__S_170DollarPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_170DollarPlus_01 1
                  dba: special_variable__S_170DollarPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_170DollarPlus_01 2
                  dba: special_variable__S_170DollarPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$+ variable', 'Form module')
special_variable__S_170DollarPlus_01: *56
special_variable__S_171DollarCurCaret_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_171DollarCurCaret_Ly
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 12349
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_171DollarCurCaret_Ly
            i: 0
            min: 12349
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: special_variable__S_171DollarCurCaret_Ly
                i: 0
                min: 12345
                name: sigil
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_171DollarCurCaret_Ly
                i: 0
                min: 2
                r: 1
                s: 0
                text: "{^"
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_171DollarCurCaret_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_171DollarCurCaret_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_171DollarCurCaret_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 12349
        var: 1
      - !!perl/hash:RE_method 
        min: 0
        name: obscaret
        nobind: 1
        rest: ($0.Str, $<sigil>, $0.{0}.Str)
special_variable__S_172ColonColonCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_172ColonColonCur_Ly
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_172ColonColonCur_Ly
        i: 0
        min: 2
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_172ColonColonCur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: special_variable__S_172ColonColonCur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
special_variable__S_173DollarCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_173DollarCur_Ly
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 4
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_173DollarCur_Ly
            i: 0
            min: 4
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_cclass 
                a: 0
                dba: special_variable__S_173DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "[$@%]"
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_173DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "{"
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_173DollarCur_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_173DollarCur_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_173DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 4
        var: 1
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ("" ~ $0.Str ~ " variable", "\{" ~ $<sigil>.Str ~ "}(" ~ $0.{0}.Str ~ ")")
special_variable__S_174DollarBra: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_174DollarBra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_174DollarBra
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $[
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_174DollarBra
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_174DollarBra
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &105 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_174DollarBra_01
              dba: special_variable__S_174DollarBra
              i: 0
              min: 1
              name: special_variable__S_174DollarBra_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_174DollarBra_01 0
                  dba: special_variable__S_174DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_174DollarBra_01 1
                  dba: special_variable__S_174DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_174DollarBra_01 2
                  dba: special_variable__S_174DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_174DollarBra_01 3
                  dba: special_variable__S_174DollarBra
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$[ variable', 'user-defined array indices')
special_variable__S_174DollarBra_01: *105
special_variable__S_175DollarKet: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_175DollarKet
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_175DollarKet
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $]
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_175DollarKet
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_175DollarKet
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &104 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_175DollarKet_01
              dba: special_variable__S_175DollarKet
              i: 0
              min: 1
              name: special_variable__S_175DollarKet_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_175DollarKet_01 0
                  dba: special_variable__S_175DollarKet
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_175DollarKet_01 1
                  dba: special_variable__S_175DollarKet
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_175DollarKet_01 2
                  dba: special_variable__S_175DollarKet
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$] variable', '$*PERL_VERSION')
special_variable__S_175DollarKet_01: *104
special_variable__S_176DollarBack: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_176DollarBack
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_176DollarBack
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $\
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_176DollarBack
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_176DollarBack
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &43 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_176DollarBack_01
              dba: special_variable__S_176DollarBack
              i: 0
              min: 1
              name: special_variable__S_176DollarBack_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_176DollarBack_01 0
                  dba: special_variable__S_176DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_176DollarBack_01 1
                  dba: special_variable__S_176DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_176DollarBack_01 2
                  dba: special_variable__S_176DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_176DollarBack_01 3
                  dba: special_variable__S_176DollarBack
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$\\ variable', "the filehandle's :ors attribute")
special_variable__S_176DollarBack_01: *43
special_variable__S_177DollarVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_177DollarVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_177DollarVert
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $|
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_177DollarVert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_177DollarVert
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &41 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_177DollarVert_01
              dba: special_variable__S_177DollarVert
              i: 0
              min: 1
              name: special_variable__S_177DollarVert_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_177DollarVert_01 0
                  dba: special_variable__S_177DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_177DollarVert_01 1
                  dba: special_variable__S_177DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_177DollarVert_01 2
                  dba: special_variable__S_177DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_177DollarVert_01 3
                  dba: special_variable__S_177DollarVert
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$| variable', 'Form module')
special_variable__S_177DollarVert_01: *41
special_variable__S_178DollarColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_178DollarColon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_178DollarColon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "$:"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_178DollarColon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: special_variable__S_178DollarColon
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[\\x20\\t\\n\\],=)}]"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: "('$: variable', 'Form module')"
special_variable__S_179DollarSemi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_179DollarSemi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_179DollarSemi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $;
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_179DollarSemi
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_179DollarSemi
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &102 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_179DollarSemi_01
              dba: special_variable__S_179DollarSemi
              i: 0
              min: 1
              name: special_variable__S_179DollarSemi_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_179DollarSemi_01 0
                  dba: special_variable__S_179DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_179DollarSemi_01 1
                  dba: special_variable__S_179DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_179DollarSemi_01 2
                  dba: special_variable__S_179DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_179DollarSemi_01 3
                  dba: special_variable__S_179DollarSemi
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$; variable', 'real multidimensional hashes')
special_variable__S_179DollarSemi_01: *102
special_variable__S_180DollarSingle: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_180DollarSingle
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_180DollarSingle
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $'
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_180DollarSingle
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_180DollarSingle
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &100 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_180DollarSingle_01
              dba: special_variable__S_180DollarSingle
              i: 0
              min: 1
              name: special_variable__S_180DollarSingle_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_180DollarSingle_01 0
                  dba: special_variable__S_180DollarSingle
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_180DollarSingle_01 1
                  dba: special_variable__S_180DollarSingle
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_180DollarSingle_01 2
                  dba: special_variable__S_180DollarSingle
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")
special_variable__S_180DollarSingle_01: *100
special_variable__S_181DollarDouble: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_181DollarDouble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_181DollarDouble
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_181DollarDouble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_181DollarDouble
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &19 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_181DollarDouble_01
              dba: special_variable__S_181DollarDouble
              i: 0
              min: 1
              name: special_variable__S_181DollarDouble_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_181DollarDouble_01 0
                  dba: special_variable__S_181DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_181DollarDouble_01 1
                  dba: special_variable__S_181DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_181DollarDouble_01 2
                  dba: special_variable__S_181DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_181DollarDouble_01 3
                  dba: special_variable__S_181DollarDouble
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$" variable', '.join() method')
special_variable__S_181DollarDouble_01: *19
special_variable__S_182DollarComma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_182DollarComma
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_182DollarComma
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $,
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_182DollarComma
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_182DollarComma
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &136 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_182DollarComma_01
              dba: special_variable__S_182DollarComma
              i: 0
              min: 1
              name: special_variable__S_182DollarComma_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_182DollarComma_01 0
                  dba: special_variable__S_182DollarComma
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_182DollarComma_01 1
                  dba: special_variable__S_182DollarComma
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_182DollarComma_01 2
                  dba: special_variable__S_182DollarComma
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$, variable', ".join() method")
special_variable__S_182DollarComma_01: *136
special_variable__S_183DollarLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_183DollarLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_183DollarLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "['$<']"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_183DollarLt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_183DollarLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: special_variable__S_183DollarLt
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_183DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_183DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \w
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_183DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: special_variable__S_183DollarLt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$< variable', '$*UID')
special_variable__S_184DollarGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_184DollarGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_184DollarGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $>
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_184DollarGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_184DollarGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &81 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_184DollarGt_01
              dba: special_variable__S_184DollarGt
              i: 0
              min: 1
              name: special_variable__S_184DollarGt_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_184DollarGt_01 0
                  dba: special_variable__S_184DollarGt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_184DollarGt_01 1
                  dba: special_variable__S_184DollarGt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_184DollarGt_01 2
                  dba: special_variable__S_184DollarGt
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ("$() variable", '$*EUID')
special_variable__S_184DollarGt_01: *81
special_variable__S_185DollarDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_185DollarDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_185DollarDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $.
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_185DollarDot
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_185DollarDot
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &12 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_185DollarDot_01
              dba: special_variable__S_185DollarDot
              i: 0
              min: 1
              name: special_variable__S_185DollarDot_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_185DollarDot_01 0
                  dba: special_variable__S_185DollarDot
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_185DollarDot_01 1
                  dba: special_variable__S_185DollarDot
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_185DollarDot_01 2
                  dba: special_variable__S_185DollarDot
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$. variable', "filehandle's .line method")
special_variable__S_185DollarDot_01: *12
special_variable__S_186DollarQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_186DollarQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_186DollarQuestion
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $?
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_186DollarQuestion
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_186DollarQuestion
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &26 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_186DollarQuestion_01
              dba: special_variable__S_186DollarQuestion
              i: 0
              min: 1
              name: special_variable__S_186DollarQuestion_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_186DollarQuestion_01 0
                  dba: special_variable__S_186DollarQuestion
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_186DollarQuestion_01 1
                  dba: special_variable__S_186DollarQuestion
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_186DollarQuestion_01 2
                  dba: special_variable__S_186DollarQuestion
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$? variable as child error', '$!')
special_variable__S_186DollarQuestion_01: *26
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
statement: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $endargs is context = -1
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: statement
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[\\)\\]\\}]"
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: statement
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: " $ = $*PARSER.bless($); "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &44 !!perl/hash:RE_any 
          a: 0
          altname: statement_02
          dba: statement end
          i: 0
          min: 0
          name: statement_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 0
              dba: statement
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: label
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: statement
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_label'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 1
              dba: statement
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: statement_control
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 2
              dba: statement end
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: EXPR
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_expr'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: statement modifier
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: statement end
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " (@*MEMOS[$.pos]<endstmt> // 0) == 2 "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement modifier
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: statement modifier
                            i: 0
                            min: 12345
                            name: ws
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 12345
                              re: &131 !!perl/hash:RE_any 
                                a: 0
                                altname: statement_05
                                dba: statement modifier loop
                                i: 0
                                min: 12345
                                name: statement_05
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: statement_05 0
                                    dba: statement modifier
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: statement modifier
                                        i: 0
                                        min: 12345
                                        name: statement_mod_loop
                                        r: 1
                                        rest: ''
                                        s: 0
                                      - !!perl/hash:RE_method_internal 
                                        args: $S, 'statement_mod_loop'
                                        max: 0
                                        min: 0
                                        name: _REDUCE
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: statement_05 1
                                    dba: statement modifier loop
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: statement modifier
                                        i: 0
                                        min: 12345
                                        name: statement_mod_cond
                                        r: 1
                                        rest: ''
                                        s: 0
                                      - !!perl/hash:RE_method_internal 
                                        args: $S, 'statement_mod_cond'
                                        max: 0
                                        min: 0
                                        name: _REDUCE
                                      - !!perl/hash:RE_bracket 
                                        decl: []

                                        min: 0
                                        re: !!perl/hash:RE_first 
                                          a: 0
                                          dba: statement modifier loop
                                          i: 0
                                          min: 0
                                          r: 1
                                          s: 0
                                          zyg: 
                                            - !!perl/hash:RE_assertion 
                                              assert: "?"
                                              min: 0
                                              re: !!perl/hash:RE_block 
                                                a: 0
                                                context: bool
                                                dba: statement modifier loop
                                                i: 0
                                                min: 0
                                                nobind: 1
                                                r: 1
                                                s: 0
                                                text: " (@*MEMOS[$.pos]<endstmt> // 0) == 2 "
                                            - !!perl/hash:RE_sequence 
                                              a: 0
                                              dba: statement modifier loop
                                              i: 0
                                              min: 12345
                                              r: 1
                                              s: 0
                                              zyg: 
                                                - !!perl/hash:RE_method 
                                                  a: 0
                                                  dba: statement modifier loop
                                                  i: 0
                                                  min: 12345
                                                  name: ws
                                                  nobind: 1
                                                  r: 1
                                                  rest: ''
                                                  s: 0
                                                - !!perl/hash:RE_quantified_atom 
                                                  atom: !!perl/hash:RE_method 
                                                    a: 0
                                                    dba: statement modifier loop
                                                    i: 0
                                                    min: 12345
                                                    name: statement_mod_loop
                                                    r: 1
                                                    rest: ''
                                                    s: 0
                                                  min: 0
                                                  quant: 
                                                    - "?"
                                                    - ":"
                                                    - ''
                                                    - 0
                                                - !!perl/hash:RE_method_internal 
                                                  args: $S, 'statement_mod_condloop'
                                                  max: 0
                                                  min: 0
                                                  name: _REDUCE
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_modexpr'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 3
              dba: statement end
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement end
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: statement end
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: ;
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_null'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: statement
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " (@*MEMOS[@*MEMOS[$.pos]<ws>//$.pos]<endargs>//0) == 1 "
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: statement
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \h
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &89 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_10
                      dba: statement
                      i: 0
                      min: 1
                      name: statement_10
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 0
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: ;
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 1
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 2
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 3
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "}"
                  s: 0
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: infixstopper
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Statements must be separated with semicolon")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
statement_02: *44
statement_05: *131
statement_10: *89
statement_control__S_037use: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_037use
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037use
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: use
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037use
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &92 !!perl/hash:RE_any 
          a: 0
          altname: statement_control__S_037use_01
          dba: statement_control__S_037use
          i: 0
          min: 12345
          name: statement_control__S_037use_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_037use_01 0
              dba: statement_control__S_037use
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_037use
                  i: 0
                  min: 12345
                  name: version
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_037use_01 1
              dba: statement_control__S_037use
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_037use
                  i: 0
                  min: 12345
                  name: module_name
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: statement_control__S_037use
                    i: 0
                    min: 12345
                    name: arglist
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: statement_control__S_037use
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "\n            my $longname = $<module_name><longname>.Str;\n            $.add_our_name($longname);\n            # XXX cheat on import list for now\n            $.do_imports($longname, $<arglist>[0]);\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_037use_01: *92
statement_control__S_038no: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_038no
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 'no'
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: statement_control__S_038no
          i: 0
          min: 12345
          name: arglist
          r: 1
          rest: ''
          s: 1
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_039if: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_039if
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039if
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: if
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039if
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039if
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12350
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_039if
            i: 0
            min: 12350
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_string 
                a: 0
                dba: statement_control__S_039if
                i: 0
                min: 5
                r: 1
                s: 1
                text: elsif
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: spacey
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: xblock
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                dba: statement_control__S_039if
                i: 0
                min: 12345
                r: 1
                s: 1
                var: elsif
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method_internal 
                args: $S, 'statement_control__S_039if_elsif'
                max: 0
                min: 0
                name: _REDUCE
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12349
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_039if
            i: 0
            min: 12349
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_string 
                a: 0
                dba: statement_control__S_039if
                i: 0
                min: 4
                r: 1
                s: 1
                text: else
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: spacey
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: pblock
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                dba: statement_control__S_039if
                i: 0
                min: 12345
                r: 1
                s: 1
                var: else
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method_internal 
                args: $S, 'statement_control__S_039if_else'
                max: 0
                min: 0
                name: _REDUCE
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_040unless: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_040unless
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040unless
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: unless
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040unless
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040unless
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: statement_control__S_040unless
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_040unless
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement_control__S_040unless
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 4
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: statement_control__S_040unless
                        i: 0
                        min: 4
                        r: 1
                        s: 1
                        text: else
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_040unless
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("unless does not take \"else\" in Perl 6; please rewrite using \"if\"")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_041while: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_041while
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041while
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: while
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041while
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_041while
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_041while
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 5
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_041while
                      i: 0
                      min: 5
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 3
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: statement_control__S_041while
                              i: 0
                              min: 3
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_string 
                                    a: 0
                                    dba: statement_control__S_041while
                                    i: 0
                                    min: 2
                                    r: 1
                                    s: 1
                                    text: my
                                  min: 0
                                  quant: 
                                    - "?"
                                    - ":"
                                    - ''
                                    - 0
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: ws
                                  nobind: 1
                                  noquant: 1
                                  rest: ''
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: statement_control__S_041while
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: $
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: statement_control__S_041while
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 1
                                    text: \w
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: ws
                                  nobind: 1
                                  noquant: 1
                                  rest: ''
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: statement_control__S_041while
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: =
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: <
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: statement_control__S_041while
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: $
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: statement_control__S_041while
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \w
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ">"
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: )
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("This appears to be Perl 5 code")
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041while
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_042until: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_042until
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042until
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: until
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042until
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042until
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_043repeat: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37040
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_043repeat
    i: 0
    min: 37040
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043repeat
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: repeat
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043repeat
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12350
        re: &119 !!perl/hash:RE_any 
          a: 0
          altname: statement_control__S_043repeat_01
          dba: statement_control__S_043repeat
          i: 0
          min: 12350
          name: statement_control__S_043repeat_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_043repeat_01 0
              dba: statement_control__S_043repeat
              i: 0
              min: 12350
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 5
                    re: &6 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_control__S_043repeat_02
                      dba: statement_control__S_043repeat
                      i: 0
                      min: 5
                      name: statement_control__S_043repeat_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_02 0
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: while
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_02 1
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: until
                  min: 5
                  var: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_043repeat
                  i: 0
                  min: 12345
                  name: xblock
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_043repeat_01 1
              dba: statement_control__S_043repeat
              i: 0
              min: 24695
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_043repeat
                  i: 0
                  min: 12345
                  name: block
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_043repeat_block_wu'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 5
                    re: &130 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_control__S_043repeat_03
                      dba: statement_control__S_043repeat
                      i: 0
                      min: 5
                      name: statement_control__S_043repeat_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_03 0
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: while
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_03 1
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: until
                  min: 5
                  var: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_043repeat
                  i: 0
                  min: 12345
                  name: EXPR
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_043repeat_expr_wu'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_043repeat_01: *119
statement_control__S_043repeat_02: *6
statement_control__S_043repeat_03: *130
statement_control__S_044loop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_044loop
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044loop
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: loop
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044loop
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_paren 
            decl: []

            min: 4
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_044loop
              i: 0
              min: 4
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: (
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_044loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ;
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop_e1'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_044loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e2
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ;
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop_e2'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_044loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e3
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop_e3'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: )
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop_eee'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          min: 0
          nobind: 1
          quant: 
            - "?"
            - ":"
            - ''
            - 0
        dba: statement_control__S_044loop
        i: 0
        min: 0
        r: 1
        s: 1
        var: eee
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044loop
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_control__S_044loop_block'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_045for: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_045for
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045for
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: for
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045for
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_045for
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_045for
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 3
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_045for
                      i: 0
                      min: 3
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 2
                            r: 1
                            s: 1
                            text: my
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: $
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \w
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("This appears to be Perl 5 code")
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_045for
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_045for
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 4
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_045for
                      i: 0
                      min: 4
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 12345
                            name: EXPR
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ;
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 12345
                            name: EXPR
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ;
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 12345
                            name: EXPR
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: )
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('C-style "for (;;)" loop', '"loop (;;)"')
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045for
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_046given: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_046given
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046given
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: given
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046given
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046given
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_047when: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_047when
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047when
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: when
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047when
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047when
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_048default: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_048default
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048default
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: default
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048default
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048default
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_049BEGIN: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_049BEGIN
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049BEGIN
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: BEGIN
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049BEGIN
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049BEGIN
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_050CHECK: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_050CHECK
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050CHECK
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CHECK
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050CHECK
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050CHECK
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_051INIT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_051INIT
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051INIT
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: INIT
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051INIT
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051INIT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_052END: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_052END
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052END
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: END
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052END
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052END
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_053START: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_053START
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053START
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: START
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053START
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053START
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_054ENTER: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_054ENTER
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054ENTER
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: ENTER
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054ENTER
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054ENTER
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_055LEAVE: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_055LEAVE
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055LEAVE
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: LEAVE
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055LEAVE
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055LEAVE
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_056KEEP: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_056KEEP
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056KEEP
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: KEEP
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056KEEP
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056KEEP
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_057UNDO: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_057UNDO
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057UNDO
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: UNDO
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057UNDO
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057UNDO
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_058FIRST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_058FIRST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058FIRST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: FIRST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058FIRST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058FIRST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_059NEXT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_059NEXT
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059NEXT
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: NEXT
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059NEXT
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059NEXT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_060LAST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_060LAST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060LAST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: LAST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060LAST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060LAST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_061PRE: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_061PRE
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061PRE
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: PRE
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061PRE
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061PRE
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_062POST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_062POST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062POST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: POST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062POST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062POST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_063CATCH: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_063CATCH
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_063CATCH
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CATCH
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_063CATCH
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_063CATCH
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_064CONTROL: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_064CONTROL
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_064CONTROL
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CONTROL
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_064CONTROL
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_064CONTROL
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_065TEMP: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_065TEMP
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_065TEMP
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: TEMP
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_065TEMP
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_065TEMP
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_072if: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_072if
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_072if
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: if
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_072if
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_072if
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_cond__S_072if_if'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_073unless: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_073unless
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_073unless
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: unless
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_073unless
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_073unless
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_cond__S_073unless_unless'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_074when: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_074when
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_074when
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: when
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_074when
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_074when
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_cond__S_074when_when'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_075while: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_075while
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_075while
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: while
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_075while
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_075while
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_075while_while'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_076until: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_076until
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_076until
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: until
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_076until
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_076until
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_076until_until'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_077for: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_077for
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_077for
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: for
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_077for
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_077for
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_077for_for'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_078given: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_078given
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_078given
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: given
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_078given
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_078given
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_078given_given'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_prefix__S_277try: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_277try
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_277try
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: try
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_277try
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_277try
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_277try
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_277try
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_278gather: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_278gather
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_278gather
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: gather
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_278gather
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_278gather
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_278gather
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_278gather
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_279contend: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_279contend
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_279contend
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: contend
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_279contend
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_279contend
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_279contend
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_279contend
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_280async: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_280async
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_280async
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: async
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_280async
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_280async
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_280async
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_280async
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_281maybe: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_281maybe
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_281maybe
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: maybe
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_281maybe
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_281maybe
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_281maybe
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_281maybe
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_282lazy: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_282lazy
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_282lazy
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: lazy
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_282lazy
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_282lazy
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_282lazy
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_282lazy
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_283do: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_283do
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_283do
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: do
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_283do
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_283do
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_283do
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_283do
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: statement_prefix__S_283do
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        my $loop = $<statement><statement_mod_loop>;\n        if $loop and @$loop and (my $s = $loop.[0].<sym>) ~~ /while|until/ {\n            $.obs(\"do...$s\" ,\"repeat...$s\");\n        }\n    "
statement_prefix__S_284lift: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement_prefix__S_284lift
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QUASI_QUASH is context = 1
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_284lift
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_284lift
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: lift
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_284lift
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_284lift
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_284lift
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_284lift
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statementlist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statementlist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PARSER is context<rw> = self
    - !!perl/hash:RE_decl 
      a: 0
      dba: statementlist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 0
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &37 !!perl/hash:RE_any 
          a: 0
          altname: statementlist_01
          dba: statement list
          i: 0
          min: 0
          name: statementlist_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 0
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: statement list
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: $
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 1
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement list
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement list
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: statement list
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "[\\)\\]\\}]"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 2
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement list
                      i: 0
                      min: 24690
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: statement list
                          i: 0
                          min: 12345
                          name: statement
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: statement list
                          i: 0
                          min: 12345
                          name: eat_terminator
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statementlist_01: *37
stdstopper: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: stdstopper
      i: 0
      max: 0
      min: 0
      r: 0
      s: 0
      text: my @stub = return self if @*MEMOS[self.pos]<endstmt> :exists
  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: standard stopper
    i: 0
    min: 0
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &57 !!perl/hash:RE_any 
          a: 0
          altname: stdstopper_01
          dba: standard stopper
          i: 0
          min: 0
          name: stdstopper_01
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: stdstopper_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: standard stopper
                i: 0
                min: 12345
                name: terminator
                nobind: 1
                r: 0
                rest: ''
                s: 0
            - !!perl/hash:RE_assertion 
              alt: stdstopper_01 1
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: standard stopper
                i: 0
                min: 12345
                name: unitstopper
                nobind: 1
                r: 0
                rest: ''
                s: 0
            - !!perl/hash:RE_meta 
              a: 0
              alt: stdstopper_01 2
              dba: standard stopper
              i: 0
              min: 0
              r: 0
              s: 0
              text: $
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: standard stopper
        i: 0
        min: 0
        r: 0
        s: 0
        text: " @*MEMOS[$.pos]<endstmt> ||= 1; "
stdstopper_01: *57
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: stopper
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
sublongname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sublongname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: sublongname
        i: 0
        min: 12345
        name: subshortname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: sublongname
          i: 0
          min: 12345
          name: sigterm
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
subshortname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &33 !!perl/hash:RE_any 
      a: 0
      altname: subshortname_01
      dba: subshortname
      i: 0
      min: 12345
      name: subshortname_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: subshortname_01 0
          dba: subshortname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: subshortname
              i: 0
              min: 12345
              name: category
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: subshortname
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_method 
                        a: 0
                        dba: subshortname
                        i: 0
                        min: 12345
                        name: colonpair
                        r: 1
                        rest: ''
                        s: 0
                      min: 12345
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_block 
                      a: 0
                      context: void
                      dba: subshortname
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: " $.add_macro($<category>) if $*IN_DECL; "
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: subshortname_01 1
          dba: subshortname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: subshortname
              i: 0
              min: 12345
              name: desigilname
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: subshortname
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $.add_routine($<desigilname>.Str) if $*IN_DECL; "
subshortname_01: *33
term__S_066BEGIN: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_066BEGIN
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_066BEGIN
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: BEGIN
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_066BEGIN
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_067CHECK: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_067CHECK
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_067CHECK
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CHECK
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_067CHECK
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_068INIT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_068INIT
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_068INIT
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: INIT
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_068INIT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_069START: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_069START
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_069START
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: START
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_069START
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_070ENTER: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_070ENTER
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_070ENTER
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: ENTER
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_070ENTER
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_071FIRST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_071FIRST
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_071FIRST
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: FIRST
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_071FIRST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_285new: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_285new
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: term__S_285new
        i: 0
        min: 3
        r: 1
        s: 0
        text: new
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: term__S_285new
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_285new
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: term__S_285new
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: term__S_285new
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: term__S_285new
              i: 0
              min: 1
              r: 1
              s: 0
              text: ":"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ("C++ constructor syntax", "method call syntax")
term__S_286ColonColonQuestionIDENT: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_286ColonColonQuestionIDENT
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12348
          nobind: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_286ColonColonQuestionIDENT
            i: 0
            min: 12348
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: term__S_286ColonColonQuestionIDENT
                i: 0
                min: 3
                r: 1
                s: 0
                text: ::?
              - !!perl/hash:RE_method 
                a: 0
                dba: term__S_286ColonColonQuestionIDENT
                i: 0
                min: 12345
                name: identifier
                r: 1
                rest: ''
                s: 0
        dba: term__S_286ColonColonQuestionIDENT
        i: 0
        min: 12348
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_286ColonColonQuestionIDENT
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_287undef: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_287undef
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_287undef
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: undef
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_287undef
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_287undef
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_287undef
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_287undef
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_287undef
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: term__S_287undef
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: $/
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: "('$/ variable as input record separator',\n             \"the filehandle's .slurp method\")"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_287undef
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_287undef
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 12346
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_287undef
                      i: 0
                      min: 12346
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_287undef
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: term__S_287undef
                          i: 0
                          min: 12345
                          name: sigil
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: term__S_287undef
                            i: 0
                            min: 12345
                            name: twigil
                            r: 1
                            rest: ''
                            s: 0
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: term__S_287undef
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \w
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('undef as a verb', 'undefine function')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_288continue: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_288continue
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_288continue
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: continue
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_288continue
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_289self: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_289self
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_289self
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: self
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_289self
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_290defer: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_290defer
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_290defer
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: defer
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_290defer
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_291rand: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_291rand
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_291rand
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rand
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_291rand
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_291rand
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_291rand
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_291rand
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_291rand
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: &23 !!perl/hash:RE_any 
                            a: 0
                            altname: term__S_291rand_03
                            dba: term__S_291rand
                            i: 0
                            min: 1
                            name: term__S_291rand_03
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_meta 
                                a: 0
                                alt: term__S_291rand_03 0
                                dba: term__S_291rand
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: term__S_291rand_03 1
                                dba: term__S_291rand
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: $
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('rand(N)', 'N.rand or (1..N).pick')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_291rand_03: *23
term__S_292e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_292e
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_292e
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: e
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_292e
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_293i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_293i
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_293i
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: i
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_293i
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_294pi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_294pi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_294pi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: pi
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_294pi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_295Inf: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_295Inf
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_295Inf
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Inf
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_295Inf
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_296NaN: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_296NaN
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_296NaN
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: NaN
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_296NaN
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_297Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_method 
    a: 0
    dba: term__S_297Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
term__S_298StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_method 
    a: 0
    dba: term__S_298StarStar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "**"
term__S_412DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_412DotDotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_412DotDotDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ...
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_412DotDotDot
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_413QuestionQuestionQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_413QuestionQuestionQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_413QuestionQuestionQuestion
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ???
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_413QuestionQuestionQuestion
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_414BangBangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_414BangBangBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_414BangBangBang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!!!"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_414BangBangBang
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_415identifier: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_415identifier
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $name
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_415identifier
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $pos
  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_415identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_415identifier
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: term__S_415identifier
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: &135 !!perl/hash:RE_any 
                  a: 0
                  altname: term__S_415identifier_02
                  dba: term__S_415identifier
                  i: 0
                  min: 1
                  name: term__S_415identifier_02
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: term__S_415identifier_02 0
                      dba: term__S_415identifier
                      i: 0
                      min: 12345
                      name: unsp
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_string 
                      a: 0
                      alt: term__S_415identifier_02 1
                      dba: term__S_415identifier
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_415identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $name = $<identifier>.Str; $pos = $.pos; "
      - !!perl/hash:RE_method 
        min: 0
        name: args
        rest: ( $.is_name($name) )
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_415identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: " self.add_mystery($name,$pos) unless $<args><invocant>; "
term__S_415identifier_02: *135
term__S_416opfunc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_416opfunc
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_416opfunc
        i: 0
        min: 12345
        name: category
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_416opfunc
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_416opfunc
        i: 0
        min: 12345
        name: args
        r: 1
        rest: ''
        s: 0
term__S_417name: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_417name
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $name
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_417name
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $pos
  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_417name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_417name
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_417name
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        $name = $<longname>.Str;\n        $pos = $.pos;\n    "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: type parameter
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: type parameter
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: term__S_417name
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: "\n            $.is_name($<longname>.Str) or substr($<longname>.Str,0,2) eq '::'\n        "
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: term__S_417name
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_417name
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: term__S_417name
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_string 
                                a: 0
                                dba: term__S_417name
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "["
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: term__S_417name
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12347
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: type parameter
                      i: 0
                      min: 12347
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: type parameter
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: "::"
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: type parameter
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_bracket 
                                decl: []

                                min: 1
                                re: &61 !!perl/hash:RE_any 
                                  a: 0
                                  altname: term__S_417name_06
                                  dba: type parameter
                                  i: 0
                                  min: 1
                                  name: term__S_417name_06
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_417name_06 0
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_417name_06 1
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: <
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_417name_06 2
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "{"
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_417name_06 3
                                      dba: type parameter
                                      i: 0
                                      min: 2
                                      r: 1
                                      s: 0
                                      text: <<
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: type parameter
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method_internal 
                          args: $S, 'term__S_417name_packagevar_'
                          max: 0
                          min: 0
                          name: _REDUCE
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'term__S_417name_typename'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              dba: type parameter
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type parameter
                  i: 0
                  min: 12345
                  name: args
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: type parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " self.add_mystery($name,$pos) unless $<args><invocant>; "
term__S_417name_06: *61
terminator__S_427Semi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_427Semi
    i: 0
    min: 1
    r: 1
    s: 0
    text: ;
terminator__S_428if: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_428if
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_428if
        i: 0
        min: 2
        r: 1
        s: 0
        text: if
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_428if
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_428if
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_429unless: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12351
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_429unless
    i: 0
    min: 12351
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_429unless
        i: 0
        min: 6
        r: 1
        s: 0
        text: unless
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_429unless
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_429unless
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_430while: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_430while
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_430while
        i: 0
        min: 5
        r: 1
        s: 0
        text: while
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_430while
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_430while
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_431until: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_431until
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_431until
        i: 0
        min: 5
        r: 1
        s: 0
        text: until
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_431until
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_431until
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_432for: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_432for
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_432for
        i: 0
        min: 3
        r: 1
        s: 0
        text: for
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_432for
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_432for
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_433given: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_433given
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_433given
        i: 0
        min: 5
        r: 1
        s: 0
        text: given
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_433given
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_433given
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_434when: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_434when
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_434when
        i: 0
        min: 4
        r: 1
        s: 0
        text: when
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_434when
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_434when
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_435MinusMinusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_435MinusMinusGt
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_435MinusMinusGt
        i: 0
        min: 3
        r: 1
        s: 0
        text: -->
      - !!perl/hash:RE_method_internal 
        args: $S, 'terminator__S_435MinusMinusGt'
        max: 0
        min: 0
        name: _REDUCE
terminator__S_436Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Terminator
  re: !!perl/hash:RE_method 
    a: 0
    dba: terminator__S_436Thesis
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: )
terminator__S_437Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_437Ket
    i: 0
    min: 1
    r: 1
    s: 0
    text: "]"
terminator__S_438Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_438Ly
    i: 0
    min: 1
    r: 1
    s: 0
    text: "}"
terminator__S_439BangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_439BangBang
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_439BangBang
        i: 0
        min: 2
        r: 1
        s: 0
        text: "!!"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: terminator__S_439BangBang
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*GOAL eq '!!' "
termish: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: termish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $SCOPE is context<rw> = "our"
    - !!perl/hash:RE_decl 
      a: 0
      dba: termish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $VAR is context<rw>
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &52 !!perl/hash:RE_any 
          a: 0
          altname: termish_01
          dba: prefix or noun
          i: 0
          min: 12345
          name: termish_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: termish_01 0
              dba: prefix or noun
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: prefix or noun
                    i: 0
                    min: 12345
                    name: PRE
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or noun
                  i: 0
                  min: 12345
                  name: noun
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: termish_01 1
              dba: prefix or noun
              i: 0
              min: 12345
              name: noun
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postfix
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: postfix
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: postfix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $*INTERPOLATION "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: postfix
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: postfix
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_block 
                              a: 0
                              context: bool
                              dba: postfix
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 0
                              text: " $*INTERPOLATION eq '$' "
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 12345
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: postfix
                                i: 0
                                min: 12345
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_method 
                                      a: 0
                                      dba: postfix
                                      i: 0
                                      min: 12345
                                      name: POST
                                      r: 1
                                      rest: ''
                                      s: 0
                                    min: 12345
                                    quant: 
                                      - +
                                      - "!"
                                      - ''
                                      - 1
                                  - !!perl/hash:RE_assertion 
                                    assert: "?"
                                    min: 0
                                    re: !!perl/hash:RE_method_re 
                                      a: 0
                                      dba: postfix
                                      i: 0
                                      min: 0
                                      name: after
                                      nobind: 1
                                      r: 1
                                      re: !!perl/hash:RE 
                                        decl: []

                                        min: 1
                                        re: !!perl/hash:RE_cclass 
                                          a: 0
                                          dba: postfix
                                          i: 0
                                          min: 1
                                          r: 1
                                          s: 0
                                          text: "[ \\] } > ) ]"
                                      s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: postfix
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: postfix
                              i: 0
                              min: 12345
                              name: POST
                              r: 1
                              rest: ''
                              s: 0
                            min: 12345
                            quant: 
                              - +
                              - "!"
                              - ''
                              - 1
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: postfix
                              i: 0
                              min: 0
                              name: after
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_cclass 
                                  a: 0
                                  dba: postfix
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "[ \\] } > ) ]"
                              s: 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: postfix
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $VAR = 0; "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: postfix
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: postfix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $*INTERPOLATION "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: postfix
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method 
                          a: 0
                          dba: postfix
                          i: 0
                          min: 12345
                          name: stdstopper
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_method 
                          a: 0
                          dba: postfix
                          i: 0
                          min: 12345
                          name: POST
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: postfix
        i: 0
        min: 0
        r: 1
        s: 0
        text: " self.check_variable($VAR) if $VAR; "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: postfix
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.<~CAPS> = $<noun><~CAPS> "
termish_01: *52
trait: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: trait
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &73 !!perl/hash:RE_any 
          a: 0
          altname: trait_01
          dba: trait
          i: 0
          min: 12345
          name: trait_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 0
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: trait_verb
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 1
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: trait_auxiliary
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 2
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_01: *73
trait_auxiliary__S_268is: !!perl/hash:RE 
  decl: []

  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_auxiliary__S_268is
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_268is
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: is
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_268is
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_268is
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_268is
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: trait_auxiliary__S_268is
          i: 0
          min: 12345
          name: postcircumfix
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
trait_auxiliary__S_269does: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: trait_auxiliary__S_269does
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'role'
  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_auxiliary__S_269does
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_269does
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: does
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_269does
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_269does
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_269does
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 0
trait_auxiliary__S_270will: !!perl/hash:RE 
  decl: []

  kind: token
  min: 74070
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_auxiliary__S_270will
    i: 0
    min: 74070
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_270will
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: will
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_270will
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_270will
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_270will
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_270will
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_270will
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 0
trait_verb__S_271of: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_271of
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_271of
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: of
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_271of
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_271of
        i: 0
        min: 12345
        name: fulltypename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_verb__S_272as: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_272as
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_272as
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: as
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_272as
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_272as
        i: 0
        min: 12345
        name: fulltypename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_verb__S_273returns: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_273returns
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_273returns
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: returns
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_273returns
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_273returns
        i: 0
        min: 12345
        name: fulltypename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_verb__S_274handles: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_274handles
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_274handles
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: handles
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_274handles
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_274handles
        i: 0
        min: 12345
        name: noun
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
tribble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: tribble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: tribble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: nibble
          nobind: 1
          rest: ($lang)
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: left
      - !!perl/hash:RE_var 
        a: 0
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: tribble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: tribble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: tribble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start ne $stop "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: tribble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($lang2)
            - !!perl/hash:RE_sequence 
              a: 0
              dba: tribble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $lang = $lang2.unbalanced($stop); "
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: nibble
                    nobind: 1
                    rest: ($lang)
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
                - !!perl/hash:RE_var 
                  a: 0
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
twigil__S_192Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_192Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
twigil__S_193Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_193Bang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!"
twigil__S_194Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_194Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
twigil__S_195Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: twigil__S_195Colon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: twigil__S_195Colon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ":"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: twigil__S_195Colon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: twigil__S_195Colon
              i: 0
              min: 1
              r: 1
              s: 0
              text: ":"
          s: 0
twigil__S_196Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_196Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
twigil__S_197Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: twigil__S_197Plus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: twigil__S_197Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method 
            min: 0
            name: worry
            nobind: 1
            rest: ("The + twigil is deprecated, use the * twigil instead")
twigil__S_198Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_198Question
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "?"
twigil__S_199Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_199Equal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =
type_constraint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_constraint
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &14 !!perl/hash:RE_any 
          a: 0
          altname: type_constraint_01
          dba: type_constraint
          i: 0
          min: 12345
          name: type_constraint_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: type_constraint_01 0
              dba: type_constraint
              i: 0
              min: 12345
              name: value
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: type_constraint_01 1
              dba: type_constraint
              i: 0
              min: 12345
              name: fulltypename
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: type_constraint_01 2
              dba: type_constraint
              i: 0
              min: 12350
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: where
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %chaining)
      - !!perl/hash:RE_method 
        a: 0
        dba: type_constraint
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
type_constraint_01: *14
type_declarator__S_275subset: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: type_declarator__S_275subset
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: type_declarator__S_275subset
        i: 0
        min: 24690
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: type_declarator__S_275subset
            i: 0
            min: 12345
            name: sym
            r: 1
            rest: ''
            s: 0
            sym: subset
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: type_declarator__S_275subset
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_declarator__S_275subset
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: type_declarator__S_275subset
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: " $.add_name($<longname>.Str); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24692
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: type_declarator__S_275subset
                      i: 0
                      min: 24692
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: type_declarator__S_275subset
                          i: 0
                          min: 2
                          r: 1
                          s: 1
                          text: of
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: type_declarator__S_275subset
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: type_declarator__S_275subset
                          i: 0
                          min: 12345
                          name: fulltypename
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 5
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: type_declarator__S_275subset
                      i: 0
                      min: 5
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: type_declarator__S_275subset
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: where
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          min: 0
                          name: EXPR
                          rest: (item %chaining)
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: type_declarator__S_275subset
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed subset")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
type_declarator__S_276enum: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: type_declarator__S_276enum
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $l
  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_declarator__S_276enum
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_276enum
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: enum
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_276enum
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_first 
          a: 0
          dba: type_declarator__S_276enum
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: type_declarator__S_276enum
              i: 0
              min: 49380
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindvar 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: type_declarator__S_276enum
                    i: 0
                    min: 12345
                    name: longname
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: type_declarator__S_276enum
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: $l
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_declarator__S_276enum
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_declarator__S_276enum
                  i: 0
                  min: 12345
                  name: arglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_declarator__S_276enum
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: type_declarator__S_276enum
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $.add_name($l.Str); $.add_enum($l.Str, $<arglist>.Str); "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: type_declarator__S_276enum
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_declarator__S_276enum
                  i: 0
                  min: 12345
                  name: arglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_declarator__S_276enum
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
typename: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: typename
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &122 !!perl/hash:RE_any 
          a: 0
          altname: typename_01
          dba: typename
          i: 0
          min: 12345
          name: typename_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: typename_01 0
              dba: typename
              i: 0
              min: 12348
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: typename
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: ::?
                - !!perl/hash:RE_method 
                  a: 0
                  dba: typename
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: typename_01 1
              dba: typename
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: typename
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: typename
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: "\n        my $longname = $<longname>.Str;\n        if substr($longname, 0, 2) eq '::' {\n            $.add_my_name(substr($longname, 2));\n        }\n        else {\n            $.is_name($longname)\n        }\n      "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: typename
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: typename
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: typename
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: typename
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: typename
                i: 0
                min: 12345
                name: postcircumfix
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
typename_01: *122
unitstopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_meta 
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    text: $
unsp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: unspace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: unsp
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: unsp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: &38 !!perl/hash:RE_any 
                a: 0
                altname: unsp_02
                dba: unsp
                i: 0
                min: 1
                name: unsp_02
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_meta 
                    a: 0
                    alt: unsp_02 0
                    dba: unsp
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  - !!perl/hash:RE_string 
                    a: 0
                    alt: unsp_02 1
                    dba: unsp
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "#"
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &18 !!perl/hash:RE_any 
            a: 0
            altname: unsp_03
            dba: unspace
            i: 0
            min: 0
            name: unsp_03
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 0
                dba: unspace
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 12345
                    name: vws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'unsp_vwhite'
                    max: 0
                    min: 0
                    name: _REDUCE
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 1
                dba: unspace
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'unsp_unv'
                    max: 0
                    min: 0
                    name: _REDUCE
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 2
                dba: unspace
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_meta 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: $
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: unspace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: " $.moreinput "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
unsp_02: *38
unsp_03: *18
unspacey: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_method 
      a: 0
      dba: unspacey
      i: 0
      min: 12345
      name: unsp
      nobind: 1
      r: 1
      rest: ''
      s: 0
    min: 0
    quant: 
      - "?"
      - ":"
      - ''
      - 0
unv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &3 !!perl/hash:RE_any 
      a: 0
      altname: unv_01
      dba: horizontal whitespace
      i: 0
      min: 1
      name: unv_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 0
          dba: horizontal whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 1
                r: 1
                s: 0
                text: \h
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_method_internal 
              args: $S, 'unv_hwhite'
              max: 0
              min: 0
              name: _REDUCE
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 1
          dba: horizontal whitespace
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: horizontal whitespace
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                s: 0
            - !!perl/hash:RE_meta 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 0
              r: 1
              s: 0
              text: "^^"
            - !!perl/hash:RE_method 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 12345
              name: pod_comment
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method_internal 
              args: $S, 'unv_pod'
              max: 0
              min: 0
              name: _REDUCE
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 2
          dba: horizontal whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 1
                r: 1
                s: 0
                text: \h
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_string 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 1
              r: 1
              s: 0
              text: "#"
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &58 !!perl/hash:RE_any 
                a: 0
                altname: unv_03
                dba: horizontal whitespace
                i: 0
                min: 0
                name: unv_03
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: unv_03 0
                    dba: horizontal whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 12345
                          name: opener
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                      - !!perl/hash:RE_bracket 
                        decl: []

                        min: 0
                        re: !!perl/hash:RE_first 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_assertion 
                              assert: "!"
                              min: 0
                              re: !!perl/hash:RE_method_re 
                                a: 0
                                dba: horizontal whitespace
                                i: 0
                                min: 0
                                name: after
                                nobind: 1
                                r: 1
                                re: !!perl/hash:RE 
                                  decl: []

                                  min: 1
                                  re: !!perl/hash:RE_sequence 
                                    a: 0
                                    dba: horizontal whitespace
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_meta 
                                        a: 0
                                        dba: horizontal whitespace
                                        i: 0
                                        min: 0
                                        r: 1
                                        s: 0
                                        text: "^^"
                                      - !!perl/hash:RE_meta 
                                        a: 0
                                        dba: horizontal whitespace
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 0
                                        text: .
                                s: 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: panic
                              nobind: 1
                              rest: ("Can't use embedded comments in column 1")
                      - !!perl/hash:RE_method 
                        min: 0
                        name: quibble
                        nobind: 1
                        rest: ($.cursor_fresh( ::STD::Q ))
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'unv_embedded'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: unv_03 1
                    dba: horizontal whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: horizontal whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: ''
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_meta 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \N
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'unv_end'
                        max: 0
                        min: 0
                        name: _REDUCE
unv_01: *3
unv_03: *58
value__S_200quote: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: value__S_200quote
    i: 0
    min: 12345
    name: quote
    r: 1
    rest: ''
    s: 0
value__S_201number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: value__S_201number
    i: 0
    min: 12345
    name: number
    r: 1
    rest: ''
    s: 0
value__S_202version: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: value__S_202version
    i: 0
    min: 12345
    name: version
    r: 1
    rest: ''
    s: 0
variable: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_META is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $sigil = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $twigil = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $name
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: variable
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: variable
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: variable
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n        $sigil = $<sigil>.Str;\n        $*SIGIL ||= $sigil;\n    "
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: variable
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "&"
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 2
                  re: &85 !!perl/hash:RE_any 
                    a: 0
                    altname: variable_03
                    dba: variable
                    i: 0
                    min: 2
                    name: variable_03
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: variable_03 0
                        dba: variable
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: variable
                              i: 0
                              min: 12345
                              name: twigil
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: variable
                            i: 0
                            min: 12345
                            name: sublongname
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: variable
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $name = $<sublongname>.Str "
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'variable_subnoun'
                            max: 0
                            min: 0
                            name: _REDUCE
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: variable_03 1
                        dba: variable
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: variable
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "["
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: variable
                            extra: "local $::GOAL = ']' "
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: "::"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: infixish
                            rest: (1)
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: variable
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "]"
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: FAILGOAL
                                  nobind: 1
                                  rest: (']' , 'variable')
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: variable
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 4
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: variable
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: $::(
                    s: 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: $
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: name
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: "$::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: name
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: "$:"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: name
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &86 !!perl/hash:RE_any 
                a: 0
                altname: variable_09
                dba: variable
                i: 0
                min: 0
                name: variable_09
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_09 0
                    dba: variable
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_method 
                          a: 0
                          dba: variable
                          i: 0
                          min: 12345
                          name: twigil
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: desigilname
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: variable
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $name = $<desigilname>.Str "
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_desigilname'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_09 1
                    dba: variable
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: special_variable
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_special'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_09 2
                    dba: variable
                    i: 0
                    min: 12346
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_bindnamed 
                        a: 0
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          nobind: 1
                          re: !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: variable
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                        dba: variable
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        var: index
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_$0'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_09 3
                    dba: variable
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: variable
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: &111 !!perl/hash:RE_any 
                              a: 0
                              altname: variable_11
                              dba: variable
                              i: 0
                              min: 1
                              name: variable_11
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_11 0
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: <
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_11 1
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                          s: 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: postcircumfix
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_$()'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_09 4
                    dba: variable
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: variable
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " $*IN_DECL "
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_anondecl'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_method 
                    alt: variable_09 5
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Anonymous variable requires declarator")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $t = $<twigil>; $twigil = $t.[0].Str if @$t; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: variable
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: variable
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $twigil eq '.' "
              - !!perl/hash:RE_bracket 
                decl: []

                min: 0
                re: &87 !!perl/hash:RE_any 
                  a: 0
                  altname: variable_13
                  dba: variable
                  i: 0
                  min: 0
                  name: variable_13
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: variable_13 0
                      dba: variable
                      i: 0
                      min: 12345
                      name: unsp
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_string 
                      a: 0
                      alt: variable_13 1
                      dba: variable
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \
                    - !!perl/hash:RE_assertion 
                      alt: variable_13 2
                      assert: "?"
                      min: 0
                      re: !!perl/hash:RE_noop 
                        a: 0
                        dba: variable
                        i: 0
                        min: 0
                        nobind: 1
                        r: 1
                        s: 0
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: variable
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: variable
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: variable
                i: 0
                min: 12345
                name: postcircumfix
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method_internal 
                args: $S, 'variable_methcall'
                max: 0
                min: 0
                name: _REDUCE
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
variable_03: *85
variable_09: *86
variable_11: *111
variable_13: *87
variable_declarator: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable_declarator
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: variable_declarator
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: variable_declarator
        i: 0
        min: 12345
        name: variable
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable_declarator
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*IN_DECL = 0; self.add_variable($<variable>.Str) "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: variable_declarator
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: variable_declarator
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &69 !!perl/hash:RE_any 
                      a: 0
                      altname: variable_declarator_02
                      dba: shape definition
                      i: 0
                      min: 12345
                      name: variable_declarator_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 0
                          dba: variable_declarator
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: variable_declarator
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: (
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: variable_declarator
                              extra: "local $::GOAL = ')' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: variable_declarator
                              i: 0
                              min: 12345
                              name: signature
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: variable_declarator
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: variable_declarator
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: )
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: (')' , 'variable_declarator')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 1
                          dba: shape definition
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "["
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: shape definition
                              extra: "local $::GOAL = ']' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: semilist
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "]"
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: (']' , 'shape definition')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 2
                          dba: shape definition
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "{"
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: shape definition
                              extra: "local $::GOAL = '}' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: semilist
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "}"
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: ('}' , 'shape definition')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 3
                          dba: shape definition
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_assertion 
                              assert: "?"
                              min: 0
                              re: !!perl/hash:RE_method_re 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 0
                                name: before
                                nobind: 1
                                r: 1
                                re: !!perl/hash:RE 
                                  decl: []

                                  min: 1
                                  re: !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: <
                                s: 0
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: postcircumfix
                              r: 1
                              rest: ''
                              s: 0
                  min: 0
                  nobind: 1
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                dba: variable_declarator
                i: 0
                min: 0
                r: 1
                s: 0
                var: shape
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: variable_declarator
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: variable_declarator
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
variable_declarator_02: *69
version__S_081v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: version__S_081v
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: version__S_081v
        i: 0
        min: 1
        r: 1
        s: 0
        text: v
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: version__S_081v
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: version__S_081v
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: version__S_081v
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \d
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: version__S_081v
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: .
          s: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: version__S_081v
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: version__S_081v
          i: 0
          min: 12345
          name: vnum
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: version__S_081v
            i: 0
            min: 1
            r: 1
            s: 0
            text: .
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: version__S_081v
          i: 0
          min: 1
          r: 1
          s: 0
          text: +
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
vnum: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: &110 !!perl/hash:RE_any 
    a: 0
    altname: vnum_00
    dba: vnum
    i: 0
    min: 1
    name: vnum_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        alt: vnum_00 0
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: vnum
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_string 
        a: 0
        alt: vnum_00 1
        dba: vnum
        i: 0
        min: 1
        r: 1
        s: 0
        text: "*"
vnum_00: *110
vws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: vertical whitespace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: vertical whitespace
        i: 0
        min: 1
        r: 1
        s: 0
        text: \v
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 9
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: vertical whitespace
            i: 0
            min: 9
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: vertical whitespace
                i: 0
                min: 9
                r: 1
                s: 0
                text: "#DEBUG -1"
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: vertical whitespace
                i: 0
                min: 0
                r: 1
                s: 0
                text: " say \"DEBUG\"; $STD::DEBUG = $*DEBUG = -1; "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: ws
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my @stub = return self if @*MEMOS[self.pos]<ws> :exists
    - !!perl/hash:RE_decl 
      a: 0
      dba: ws
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $startpos = self.pos
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: whitespace
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &35 !!perl/hash:RE_any 
          a: 0
          altname: ws_01
          dba: whitespace
          i: 0
          min: 0
          name: ws_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: ws_01 0
              dba: whitespace
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_cclass 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 1
                    nobind: 1
                    r: 1
                    s: 0
                    text: "[#\\s\\\\]"
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$.pos]<ws> = $startpos; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: ws_01 1
              dba: whitespace
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                    s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    name: after
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                    s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ":::"
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$startpos]<ws> = undef; "
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_noop 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
      - !!perl/hash:RE_sequence 
        a: 0
        dba: whitespace
        i: 0
        min: 0
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &129 !!perl/hash:RE_any 
                a: 0
                altname: ws_05
                dba: whitespace
                i: 0
                min: 0
                name: ws_05
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: ws_05 0
                    dba: whitespace
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: ws_05 1
                    dba: whitespace
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 12345
                        name: vws
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 12345
                        name: heredoc
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: ws_05 2
                    dba: whitespace
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: ws_05 3
                    dba: whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $.moreinput "
            min: 0
            quant: 
              - "*"
              - ":"
              - ''
              - 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: whitespace
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n        if ($.pos == $startpos) {\n            @*MEMOS[$.pos]<ws> = undef;\n        }\n        else {\n            @*MEMOS[$.pos]<ws> = $startpos;\n            @*MEMOS[$.pos]<endstmt> = @*MEMOS[$startpos]<endstmt>\n                if @*MEMOS[$startpos]<endstmt> :exists;\n        }\n    "
ws_01: *35
ws_05: *129
xblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: xblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '{'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: xblock
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: pblock
        r: 1
        rest: ''
        s: 0
RETREE_END
}

1;
# vim: sw=4 ft=perl
