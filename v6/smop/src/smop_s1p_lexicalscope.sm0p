#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <smop.h>
#include <smop_s1p.h>
#include <smop_oo.h>
#include <smop_lowlevel.h>

SMOP__Object* SMOP__S1P__LexicalScope;
typedef struct smop_s1p_lexicalscope_struct {
  SMOP__Object__BASE
  SMOP__Object* entries;
  SMOP__Object* outer;
} smop_s1p_lexicalscope_struct;

static SMOP__Object* SMOP__ID__entries;
static SMOP__Object* SMOP__ID__lookup;

static SMOP__Object* mold_code_lookup;

static SMOP__Object* lexicalscope_message(SMOP__Object* interpreter,
                                          SMOP__ResponderInterface* self,
                                          SMOP__Object* identifier,
                                          SMOP__Object* capture) {

  SMOP__Object* ret = SMOP__NATIVE__bool_false;
  ___NATIVE_CAPTURE_ONLY___;
  ___CONST_IDENTIFIER_ONLY___;
  ___INVOCANT_RI_SHOULD_MATCH___;


  if (identifier == SMOP__ID__new) {
    ret = smop_lowlevel_alloc(sizeof(smop_s1p_lexicalscope_struct));
    ret->RI = (SMOP__ResponderInterface*)SMOP__S1P__LexicalScope;
    ((smop_s1p_lexicalscope_struct*)ret)->entries = SMOP__S1P__Hash_create();
    ((smop_s1p_lexicalscope_struct*)ret)->outer = SMOP__S1P__Scalar_create(SMOP__NATIVE__bool_false);

  } else if (identifier == SMOP__ID__outer) {
    smop_lowlevel_rdlock(invocant);
    ret = ((smop_s1p_lexicalscope_struct*)invocant)->outer;
    smop_lowlevel_unlock(invocant);
    SMOP_REFERENCE(interpreter, ret);

  } else if (identifier == SMOP__ID__bool) {
    ret = SMOP__NATIVE__bool_true;

  } else if (identifier == SMOP__ID__entries) {
    smop_lowlevel_rdlock(invocant);
    ret = ((smop_s1p_lexicalscope_struct*)invocant)->entries;
    smop_lowlevel_unlock(invocant);
    SMOP_REFERENCE(interpreter, ret);

  } else if (identifier == SMOP__ID__postcircumfix_curly) {
    smop_lowlevel_rdlock(invocant);
    SMOP__Object* entries = ((smop_s1p_lexicalscope_struct*)invocant)->entries;
    smop_lowlevel_unlock(invocant);
    ret = SMOP_DISPATCH(interpreter, SMOP_RI(entries),
                        SMOP__ID__postcircumfix_curly,
                        SMOP__NATIVE__capture_delegate(interpreter,
                                                       SMOP_REFERENCE(interpreter,entries),
                                                       SMOP_REFERENCE(interpreter,capture)));

  } else if (identifier == SMOP__ID__exists) {
    smop_lowlevel_rdlock(invocant);
    SMOP__Object* entries = ((smop_s1p_lexicalscope_struct*)invocant)->entries;
    smop_lowlevel_unlock(invocant);
    ret = SMOP_DISPATCH(interpreter, SMOP_RI(entries),
                        SMOP__ID__exists,
                        SMOP__NATIVE__capture_delegate(interpreter,
                                                       SMOP_REFERENCE(interpreter,entries),
                                                       SMOP_REFERENCE(interpreter,capture)));
  } else if (identifier == SMOP__ID__lookup) {

    SMOP__Object* continuation = SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                                               SMOP__ID__continuation,
                                               SMOP__NATIVE__capture_create(interpreter,interpreter,NULL,NULL));

    SMOP__Object* frame = SMOP__Mold__Frame_create(interpreter,SMOP_REFERENCE(interpreter,mold_code_lookup));



    SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                SMOP__ID__goto,
                frame);
  } else {
    ___UNKNOWN_METHOD___;

  }

  SMOP_RELEASE(interpreter, invocant);
  SMOP_RELEASE(interpreter, capture);
  return ret;
}

void smop_s1p_lexicalscope_init() {

  SMOP__S1P__LexicalScope = calloc(1,sizeof(SMOP__ResponderInterface));
  ((SMOP__ResponderInterface*)SMOP__S1P__LexicalScope)->MESSAGE = lexicalscope_message;
  ((SMOP__ResponderInterface*)SMOP__S1P__LexicalScope)->REFERENCE = smop_lowlevel_generic_reference;
  ((SMOP__ResponderInterface*)SMOP__S1P__LexicalScope)->RELEASE = smop_lowlevel_generic_release;
  ((SMOP__ResponderInterface*)SMOP__S1P__LexicalScope)->id = "S1P LexicalScope";

  SMOP__ID__entries = SMOP__NATIVE__idconst_create("entries");
  SMOP__ID__lookup = SMOP__NATIVE__idconst_create("lookup");

};

void smop_s1p_lexicalscope_mold_init() {

  SMOP__Object* interpreter = SMOP__GlobalInterpreter;

  SMOP__Object* mold;
  {
    use m0ld;
    my $capture;
    my $continuation;
    my $interpreter;

    my $name = $capture."positional"(0);
    my $back = $continuation;
    my $invocant = $capture."invocant"();
    my $exists = $invocant."exists"($name);
    
    my $void;
    my $ret;
    
    if $exists {goto than} else {goto else};
    than:
      $ret = $invocant."postcircumfix:{ }"($name);
      $void = $back."setr"($ret);
      $void = $interpreter."goto"($back);
    else:
      my $outer = $invocant."outer"();
      my $outer_true = $outer."bool"();
      my $outer_cell = $outer."FETCH"();
      if $outer_true {goto than2} else {goto else2};
      than2:
        $ret = $outer_cell."lookup"($name);
        $void = $back."setr"($ret);
        $void = $interpreter."goto"($back);
      else2:
        my $OUT_SCALAR = Â¢SMOP__S1P__RootNamespace."postcircumfix:{ }"("$*OUT");
        my $OUT = $OUT_SCALAR."FETCH"();
        $void = $OUT."print"("no variable in the current scope");
  };

  mold_code_lookup = mold;

}

void smop_s1p_lexicalscope_mold_destr() {
  SMOP_RELEASE(SMOP__GlobalInterpreter, mold_code_lookup);
  mold_code_lookup = NULL;
}

void smop_s1p_lexicalscope_destr() {
  free(SMOP__S1P__LexicalScope);
}
