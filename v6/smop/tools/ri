#!/usr/bin/perl
package SMOP::RI;
use warnings;
use strict;
use IO::Select;
use IO::Handle;
use IPC::Open2;
use Symbol;
require 'mangle.pl';


my ($base,$m0ld) = (shift @ARGV,shift @ARGV);
sub preprocess_m0ld {
    my $code = shift;
    return preprocess($code,"$m0ld");
}
sub preprocess {
    my $code = shift;
    my ($writer, $reader);
    my $pid = open2($reader,$writer,@_) || die "$@";
    print $writer $code;
    close($writer);
    my $out = <$reader>;
    return $out;
}
sub mangle {
    my $id = shift;
    return 'ID__'.::mangle($id);
}

my @properties = qw(RI RI.id prefix include prototype singleton);
my %properties;

my %methods;
my $method;

my %mold;
my $mold;

my @attrs;
my @getters;

my %raw;

sub debug {
}
while (my $line = <>) {
    if ($line =~ /^\%\s*(\w*)\s*\{\s*$/) {
         debug "raw.$1 start\n";
         $raw{$1} = '';
         until((my $raw_line = <>) =~ /^\%}\s*$/) {
             debug "raw $raw_line";
             $raw{$1} .= $raw_line;
         }
         debug "raw.R1 stop\n";
    } elsif ($method) {
        if ($line =~ /^%/) {
            undef $method;
            redo;
        } else {
            debug "in method $line";
            $methods{$method} .= $line;
            next;
        }
    } elsif ($mold) {
        if ($line =~ /^%/) {
            undef $mold;
            redo;
        } else {
            debug "in mold $line";
            $mold{$mold} .= $line;
            next;
        }
    } elsif ($line =~ /^%method\s*(.*)$/) {
        $method = $1;
        $methods{$method} = '';
        debug "method start:$method\n";
    } elsif ($line =~ /^%mold\s*(.*)$/) {
        $mold = $1;
        debug "mold start:$mold\n";
    } elsif ($line =~ /^%attr\s*(.*)\n$/) {
        push(@attrs,$1);
    } elsif ($line =~ /^%getter\s*(\S+)$/) {
        push(@getters,$1);
    } elsif ($line =~ / ^\s*$ | ^\# | ^\/\/ /x) {
        debug "ws/comment:$line";
    } else {
        for my $property (@properties) {
            if ($line =~ /^% \s* \Q$property\E \s+ (.*)$/x) {
                $properties{$property} = $1;
                debug "prop $property = $1\n";
                goto FOUND;
            }
        }
        die "unrecognised line: $line";
        FOUND: ;
    } 
}

die "a %prefix is required\n" unless $properties{prefix};

print qq[/* generated by tools/ri - do not edit*/
#include <smop.h>
#include <smop_lowlevel.h>
#include <smop_s1p.h>
#include <stdlib.h>
#include <stdio.h>
#include <smop_mold.h>
];
for (split (/,/,$properties{include} || '')) {
    print "#include $_\n";
}

my $id = defined $properties{"RI.id"} ? $properties{"RI.id"} : "unknown RI";

if ($properties{prototype}) {
    print "SMOP__Object* $properties{prototype};\n";
}
if ($properties{singleton}) {
    print "SMOP__Object* $properties{singleton};\n";
}
if ($properties{RI}) {
    print "SMOP__Object* $properties{RI};\n";
} else {
    print "static SMOP__Object* RI;\n";
}
my $RI = $properties{RI} || 'RI';
my %declared_ids;
for (keys %methods) {
    next if $declared_ids{mangle($_)}++;
    print 'static SMOP__Object* ',mangle($_),";\n";
}
for (@getters) {
    next if $declared_ids{mangle($_)}++;
    print 'static SMOP__Object* ',mangle($_),";\n";
}
for (keys %mold) {
    print 'static SMOP__Object* ',$_,";\n";
}
print qq[
typedef struct $properties{prefix}_struct {
  SMOP__Object__BASE
];
for my $attr (@attrs) {
    print "$attr;\n";
}
print "} $properties{prefix}_struct;\n";

print $raw{''} || '';


for my $getter (@getters) {
    $methods{$getter} = qq[    smop_lowlevel_rdlock(invocant);
    ret = (($properties{prefix}_struct*)invocant)->$getter;
    smop_lowlevel_unlock(invocant);
    SMOP_REFERENCE(interpreter, ret);
];
}
print q[
static SMOP__Object* message(SMOP__Object* interpreter,
                                     SMOP__ResponderInterface* self,
                                     SMOP__Object* identifier,
                                     SMOP__Object* capture) {
];
my $message = $raw{message} || q[
  ___NATIVE_CAPTURE_ONLY___;
  ___CONST_IDENTIFIER_ONLY___;
  SMOP__Object* invocant = (SMOP__Object*) SMOP__NATIVE__capture_invocant(interpreter, capture);
  SMOP__Object* ret = SMOP__NATIVE__bool_false;
  %%METHODS%%
  {
    ___UNKNOWN_METHOD___;
  }
  if (invocant) SMOP_RELEASE(interpreter,invocant);
  SMOP_RELEASE(interpreter,capture);
  return ret;
];
my $methods = '';
while (my ($method,$body) = each %methods) {
    $methods .= "if (" . mangle($method) . " == identifier) {\n$body  } else ";
}
$message =~ s/%%METHODS%%/$methods/g;
print $message;
print q[
}
];

if ($properties{singleton}) {
  print qq[
   static SMOP__Object* noop_refcount(SMOP__Object* interpreter,
           SMOP__ResponderInterface* responder, SMOP__Object* obj) {
     return obj;
   }
   void $properties{prefix}_init() {
    $RI = SMOP__RI__create(
      message,
      noop_refcount,
      noop_refcount,
      "$id");
  ];
} else {
  print qq[
   void $properties{prefix}_init() {
    $RI = SMOP__RI__create(
      message,
      smop_lowlevel_generic_reference,
      smop_lowlevel_generic_release,
      "$id");
  ];
}
print "  SMOP__Object* interpreter = SMOP__GlobalInterpreter;\n";
for (keys %methods) {
    print "  ",mangle($_)," = ","SMOP__NATIVE__idconst_create(\"$_\");\n";
}

if ($properties{prototype}) {
    print qq[
  $properties{prototype} = SMOP__Proto__create($RI);
];
}
if ($properties{singleton}) {
    print qq[
  $properties{singleton} = malloc(sizeof(SMOP__Object));
  $properties{singleton}->RI = $RI ;
];
}
print qq[ 
}
void $properties{prefix}_mold_init() {
  SMOP__Object* interpreter = SMOP__GlobalInterpreter;
];
while (my ($name,$mold) = each %mold) {
    print "  $name = ",preprocess_m0ld($mold),";\n";
}
print qq[ 
}
void $properties{prefix}_mold_destr() {
];
while (my ($name,$mold) = each %mold) {
    print "SMOP_RELEASE(SMOP__GlobalInterpreter,$name);\n";
}
print qq[
}
void $properties{prefix}_destr() {
];
#printf("$properties{prefix}_destr()\\n");
if ($properties{prototype}) {
    print qq[
     free($properties{prototype});
    ];
}
if ($properties{singleton}) {
    print qq[
     free($properties{singleton});
    ];
}
print qq[
  free($RI);
}
];
print $raw{'bottom'} || '';
