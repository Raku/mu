# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;
package KindaPerl6::Grammar::Regex;
sub new { shift; bless { @_ }, "KindaPerl6::Grammar::Regex" }
my  $Hash_rule_terms;
sub ws { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { do { my  $m2 = KindaPerl6::Grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } } }); return($MATCH) };
sub ident { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = KindaPerl6::Grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } } || do { $MATCH->to($pos1); do { my  $m2 = $grammar->digit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'digit'} = $m2;1 } else { 0 } } } }) }); return($MATCH) };
sub any { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } }); return($MATCH) };
sub literal { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->literal($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'literal'} = $m2;1 } else { 0 } } })) } || (do { $MATCH->to($pos1); (do { my  $tmp = $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } }); $tmp->bool(($MATCH ? 0 : 1)); $MATCH = $tmp; ($MATCH ? 1 : 0) } && ((('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->literal($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'literal'} = $m2;1 } else { 0 } } })) } || do { $MATCH->to($pos1); 1 })) }); return($MATCH) };
sub metasyntax { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $pos1 = $MATCH->to(); (do { ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) } || (do { $MATCH->to($pos1); ((('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->literal($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))) } || (do { $MATCH->to($pos1); ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->parsed_code($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || (do { $MATCH->to($pos1); ((('<' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))) } || do { $MATCH->to($pos1); (do { my  $tmp = $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } }); $tmp->bool(($MATCH ? 0 : 1)); $MATCH = $tmp; ($MATCH ? 1 : 0) } && (('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) })))) } && do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'metasyntax'} = $m2;1 } else { 0 } } } } || do { $MATCH->to($pos1); 1 }) }) } }); return($MATCH) };
sub char_range { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $pos1 = $MATCH->to(); (do { ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) } || do { $MATCH->to($pos1); (do { my  $tmp = $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((']' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } }); $tmp->bool(($MATCH ? 0 : 1)); $MATCH = $tmp; ($MATCH ? 1 : 0) } && (('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) }) } && do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->char_range($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'char_range'} = $m2;1 } else { 0 } } } } || do { $MATCH->to($pos1); 1 }) }) } }); return($MATCH) };
sub char_class { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } } || do { $MATCH->to($pos1); ((('[' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->char_range($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((']' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))) }) }); return($MATCH) };
sub parsed_code { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = KindaPerl6::Grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { COMPILER::add_pad($KindaPerl6::Grammar::Class_name) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 } && (do { my  $m2 = KindaPerl6::Grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'KindaPerl6::Grammar.exp_stmts'} = $m2;1 } else { 0 } } } && (do { my  $m2 = KindaPerl6::Grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { my  $env = $List_COMPILER::PAD->[0]; COMPILER::drop_pad(); return(Lit::Code->new( 'pad' => $env,'state' => {  },'sig' => Sig->new( 'invocant' => (undef),'positional' => [],'named' => {  }, ),'body' => ${$MATCH->{'KindaPerl6::Grammar.exp_stmts'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))))) } }); return($MATCH) };
sub named_capture_body { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'} = $m2;1 } else { 0 } } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Capture->new( 'rule' => ${$MATCH->{'rule'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || (do { $MATCH->to($pos1); ((('[' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'} = $m2;1 } else { 0 } } } && (((']' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'rule'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || (do { $MATCH->to($pos1); ((('<' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'metasyntax'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Subrule->new( 'metasyntax' => ${$MATCH->{'metasyntax'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { die('invalid alias syntax') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 } }))) }); return($MATCH) };
sub variables { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((('$<' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(('$/{' . ('\'' . ($MATCH->{'ident'} . ('\'' . '}'))))) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || (do { $MATCH->to($pos1); (do { my  $m2 = KindaPerl6::Grammar->sigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'KindaPerl6::Grammar.sigil'} = $m2;1 } else { 0 } } } && (do { my  $m2 = KindaPerl6::Grammar->digits($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'KindaPerl6::Grammar.digits'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(($MATCH->{'KindaPerl6::Grammar.sigil'} . ('/[' . ($MATCH->{'KindaPerl6::Grammar.digits'} . ']')))) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 })) } || do { $MATCH->to($pos1); (do { my  $m2 = KindaPerl6::Grammar->sigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'KindaPerl6::Grammar.sigil'} = $m2;1 } else { 0 } } } && (do { my  $m2 = KindaPerl6::Grammar->twigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'KindaPerl6::Grammar.twigil'} = $m2;1 } else { 0 } } } && (do { my  $m2 = KindaPerl6::Grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'KindaPerl6::Grammar.full_ident'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Var->new( 'sigil' => ("" . $MATCH->{'KindaPerl6::Grammar.sigil'}),'twigil' => ("" . $MATCH->{'KindaPerl6::Grammar.twigil'}),'name' => ("" . $MATCH->{'KindaPerl6::Grammar.full_ident'}), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) })) }); return($MATCH) };
sub assertion_modifier { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (('!' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('?' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); 1 })) }); return($MATCH) };
sub rule_terms { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'} = $m2;1 } else { 0 } } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Capture->new( 'rule' => ${$MATCH->{'rule'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || (do { $MATCH->to($pos1); ((('<(' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'} = $m2;1 } else { 0 } } } && (((')>' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::CaptureResult->new( 'rule' => ${$MATCH->{'rule'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || (do { $MATCH->to($pos1); ((('<' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->assertion_modifier($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'assertion_modifier'} = $m2;1 } else { 0 } } } && ((('after' eq substr($str, $MATCH->to(), 5)) ? (1 + $MATCH->to((5 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::After->new( 'rule' => ${$MATCH->{'rule'}},'assertion_modifier' => ${$MATCH->{'assertion_modifier'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 })))))) } || (do { $MATCH->to($pos1); ((('<' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->assertion_modifier($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'assertion_modifier'} = $m2;1 } else { 0 } } } && ((('before' eq substr($str, $MATCH->to(), 6)) ? (1 + $MATCH->to((6 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Before->new( 'rule' => ${$MATCH->{'rule'}},'assertion_modifier' => ${$MATCH->{'assertion_modifier'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 })))))) } || (do { $MATCH->to($pos1); ((('<!' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'metasyntax'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return({ 'negate' => { 'metasyntax' => ${$MATCH->{'metasyntax'}}, }, }) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || (do { $MATCH->to($pos1); ((('<+' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->char_class($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'char_class'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::CharClass->new( 'chars' => ("" . $MATCH->{'char_class'}), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || (do { $MATCH->to($pos1); ((('<-' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->char_class($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'char_class'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::NegateCharClass->new( 'chars' => ("" . $MATCH->{'char_class'}), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || (do { $MATCH->to($pos1); ((('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->literal($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'literal'} = $m2;1 } else { 0 } } } && ((('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Constant->new( 'constant' => ${$MATCH->{'literal'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || (do { $MATCH->to($pos1); ((('<' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->variables($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'variables'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::InterpolateVar->new( 'var' => ${$MATCH->{'variables'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 })) } || (do { $MATCH->to($pos1); ((('?' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'metasyntax'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::SubruleNoCapture->new( 'metasyntax' => ${$MATCH->{'metasyntax'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || do { $MATCH->to($pos1); (do { my  $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'metasyntax'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Subrule->new( 'metasyntax' => ${$MATCH->{'metasyntax'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 })) })) }) } || (do { $MATCH->to($pos1); ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->parsed_code($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'parsed_code'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Block->new( 'closure' => ${$MATCH->{'parsed_code'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 })) } || (do { $MATCH->to($pos1); (do { my  $m2 = KindaPerl6::Grammar->backslash($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'KindaPerl6::Grammar.backslash'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->any($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'any'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::SpecialChar->new( 'char' => ${$MATCH->{'any'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }) } }) } || (do { $MATCH->to($pos1); ((('.' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Dot->new( 'dot' => 1, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }) } || do { $MATCH->to($pos1); ((('[' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'} = $m2;1 } else { 0 } } } && (((']' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'rule'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) })))))))))))) }); return($MATCH) };
sub term { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((('$<' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((':=' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'} = $m2;1 } else { 0 } } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::NamedCapture->new( 'rule' => ${$MATCH->{'rule'}},'ident' => ${$MATCH->{'ident'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))))))))) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->variables($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'variables'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((':=' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->named_capture_body($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'named_capture_body'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::NamedCapture->new( 'rule' => ${$MATCH->{'named_capture_body'}},'ident' => ${$MATCH->{'variables'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 })))) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'variables'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 } }) }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->rule_terms($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule_terms'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'rule_terms'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }) } || do { $MATCH->to($pos1); (do { my  $tmp = $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((']' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); ((')' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); ((':' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('?' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('+' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('*' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('|' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('&' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); (('/' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) })))))))))) }); $tmp->bool(($MATCH ? 0 : 1)); $MATCH = $tmp; ($MATCH ? 1 : 0) } && (do { my  $m2 = $grammar->any($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'any'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Constant->new( 'constant' => ${$MATCH->{'any'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 })) }))) }); return($MATCH) };
sub quant { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((('**' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = KindaPerl6::Grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->parsed_code($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'parsed_code'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return({ 'closure' => ${$MATCH->{'parsed_code'}}, }) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 })))) } || do { $MATCH->to($pos1); do { my  $pos1 = $MATCH->to(); (do { (('?' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('*' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); (('+' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) })) } }) }); return($MATCH) };
sub greedy { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (('?' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('+' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); 1 })) }); return($MATCH) };
sub quantifier { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = KindaPerl6::Grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->term($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'term'} = $m2;1 } else { 0 } } } && (do { my  $m2 = KindaPerl6::Grammar->opt_ws2($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->quant($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'quant'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->greedy($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'greedy'} = $m2;1 } else { 0 } } } && (do { my  $m2 = KindaPerl6::Grammar->opt_ws3($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Quantifier->new( 'term' => ${$MATCH->{'term'}},'quant' => ${$MATCH->{'quant'}},'greedy' => ${$MATCH->{'greedy'}},'ws1' => ${$MATCH->{'KindaPerl6::Grammar.opt_ws'}},'ws2' => ${$MATCH->{'KindaPerl6::Grammar.opt_ws2'}},'ws3' => ${$MATCH->{'KindaPerl6::Grammar.opt_ws3'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }))) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'term'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 } }) }))) } }); return($MATCH) };
sub concat_list { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->quantifier($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'quantifier'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->concat_list($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'concat_list'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'quantifier'}}, @{${$MATCH->{'concat_list'}}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'quantifier'}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 } }) }) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 } }) }); return($MATCH) };
sub concat { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->concat_list($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'concat_list'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Concat->new( 'concat' => ${$MATCH->{'concat_list'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 }) } }); return($MATCH) };
sub or_list { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->concat($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'concat'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { ((('|' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->or_list($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'or_list'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'concat'}}, @{${$MATCH->{'or_list'}}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 })) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'concat'}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 } }) }) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 } }) }); return($MATCH) };
sub rule { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (('|' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) } || do { $MATCH->to($pos1); 1 }) } && (do { my  $m2 = $grammar->or_list($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'or_list'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Rule::Or->new( 'or' => ${$MATCH->{'or_list'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);$MATCH->bool(1);return($MATCH) } else {  } }; 1 })) } }); return($MATCH) }


;
1;
