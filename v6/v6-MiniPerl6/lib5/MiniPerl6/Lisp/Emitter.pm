# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;
package MiniPerl6::Lisp::LexicalBlock;
sub new { shift; bless { @_ }, "MiniPerl6::Lisp::LexicalBlock" }
sub block { @_ == 1 ? ( $_[0]->{block} ) : ( $_[0]->{block} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; my  $str = ''; my  $has_my_decl = 0; my  $my_decl = ''; do { for my $decl ( @{$self->{block}} ) { do { if ((Main::isa($decl, 'Decl') && ($decl->decl() eq 'my'))) { $has_my_decl = 1;$my_decl = ($my_decl . ('(' . ($decl->var()->emit() . ' nil)'))) } else {  } };do { if ((Main::isa($decl, 'Bind') && (Main::isa($decl->parameters(), 'Decl') && ($decl->parameters()->decl() eq 'my')))) { $has_my_decl = 1;$my_decl = ($my_decl . ('(' . ($decl->parameters()->var()->emit() . ' nil)'))) } else {  } } } }; do { if ($has_my_decl) { $str = ($str . ('(let (' . ($my_decl . ') '))) } else { $str = ($str . '(progn ') } }; do { for my $decl ( @{$self->{block}} ) { do { if (((Main::isa($decl, 'Decl') && ($decl->decl() eq 'my')) ? 0 : 1)) { $str = ($str . $decl->emit()) } else {  } } } }; return(($str . ')')) }


;
package CompUnit;
sub new { shift; bless { @_ }, "CompUnit" }
sub name { @_ == 1 ? ( $_[0]->{name} ) : ( $_[0]->{name} = $_[1] ) };
sub attributes { @_ == 1 ? ( $_[0]->{attributes} ) : ( $_[0]->{attributes} = $_[1] ) };
sub methods { @_ == 1 ? ( $_[0]->{methods} ) : ( $_[0]->{methods} = $_[1] ) };
sub body { @_ == 1 ? ( $_[0]->{body} ) : ( $_[0]->{body} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; my  $class_name = Main::to_lisp_namespace($self->{name}); my  $str = (';; class ' . ($self->{name} . Main->newline())); $str = ($str . ('(defpackage ' . ($class_name . (')' . Main->newline())))); my  $has_my_decl = 0; my  $my_decl = ''; do { for my $decl ( @{$self->{body}} ) { do { if ((Main::isa($decl, 'Decl') && ($decl->decl() eq 'my'))) { $has_my_decl = 1;$my_decl = ($my_decl . ('(' . ($decl->var()->emit() . ' nil)'))) } else {  } };do { if ((Main::isa($decl, 'Bind') && (Main::isa($decl->parameters(), 'Decl') && ($decl->parameters()->decl() eq 'my')))) { $has_my_decl = 1;$my_decl = ($my_decl . ('(' . ($decl->parameters()->var()->emit() . ' nil)'))) } else {  } } } }; do { if ($has_my_decl) { $str = ($str . ('(let (' . ($my_decl . (')' . Main->newline())))) } else {  } }; $str = ($str . ('(if (not (ignore-errors (find-class \'' . ($class_name . (')))
  (defclass ' . ($class_name . ' () ()))

'))))); do { for my $decl ( @{$self->{body}} ) { do { if ((Main::isa($decl, 'Decl') && ($decl->decl() eq 'has'))) { my  $accessor_name = $decl->var()->name();$str = ($str . (';; has $.' . ($accessor_name . ('
(let ((new-slots (list (list :name \'' . ($accessor_name . ('
  :readers \'(' . ($accessor_name . (')
  :writers \'((setf ' . ($accessor_name . ('))
  :initform \'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class \'' . ($class_name . (')))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class \'' . ($class_name . ' :direct-slots new-slots))

'))))))))))))) } else {  } };do { if (Main::isa($decl, 'Method')) { my  $sig = $decl->sig();my  $invocant = $sig->invocant();my  $pos = $sig->positional();my  $str2 = ('(self ' . ($class_name . ')'));do { for my $field ( @{$pos} ) { $str2 = ($str2 . (' ' . $field->emit())) } };my  $block = MiniPerl6::Lisp::LexicalBlock->new( 'block' => $decl->block(), );$str = ($str . (';; method ' . ($decl->name() . ('
(if (not (ignore-errors (find-method \'' . ($decl->name() . (' () ())))
  (defgeneric ' . ($decl->name() . (' (self)
      (:documentation ' . ('"' . ('a method' . ('"' . (')))
(defmethod ' . ($decl->name() . (' (' . ($str2 . (')
  (block mp6-function
    ' . ($block->emit() . '))

'))))))))))))))))) } else {  } } } }; do { for my $decl ( @{$self->{body}} ) { do { if ((((Main::isa($decl, 'Decl') && (($decl->decl() eq 'has') || ($decl->decl() eq 'my'))) ? 0 : 1) && (Main::isa($decl, 'Method') ? 0 : 1))) { $str = ($str . ($decl->emit() . Main->newline())) } else {  } } } }; do { if ($has_my_decl) { $str = ($str . ')') } else {  } }; $str = ($str . (Main->newline() . Main->newline())) }


;
package Val::Int;
sub new { shift; bless { @_ }, "Val::Int" }
sub int { @_ == 1 ? ( $_[0]->{int} ) : ( $_[0]->{int} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; $self->{int} }


;
package Val::Bit;
sub new { shift; bless { @_ }, "Val::Bit" }
sub bit { @_ == 1 ? ( $_[0]->{bit} ) : ( $_[0]->{bit} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; $self->{bit} }


;
package Val::Num;
sub new { shift; bless { @_ }, "Val::Num" }
sub num { @_ == 1 ? ( $_[0]->{num} ) : ( $_[0]->{num} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; $self->{num} }


;
package Val::Buf;
sub new { shift; bless { @_ }, "Val::Buf" }
sub buf { @_ == 1 ? ( $_[0]->{buf} ) : ( $_[0]->{buf} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; ('"' . (Main::lisp_escape_string($self->{buf}) . '"')) }


;
package Val::Undef;
sub new { shift; bless { @_ }, "Val::Undef" }
sub emit { my $self = shift; my $List__ = \@_; do { [] }; 'nil' }


;
package Val::Object;
sub new { shift; bless { @_ }, "Val::Object" }
sub class { @_ == 1 ? ( $_[0]->{class} ) : ( $_[0]->{class} = $_[1] ) };
sub fields { @_ == 1 ? ( $_[0]->{fields} ) : ( $_[0]->{fields} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; ('bless(' . (Main::perl($self->{fields}, ) . (', ' . (Main::perl($self->{class}, ) . ')')))) }


;
package Lit::Seq;
sub new { shift; bless { @_ }, "Lit::Seq" }
sub seq { @_ == 1 ? ( $_[0]->{seq} ) : ( $_[0]->{seq} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; ('(' . (Main::join([ map { $_->emit() } @{ $self->{seq} } ], ' ') . ')')) }


;
package Lit::Array;
sub new { shift; bless { @_ }, "Lit::Array" }
sub array { @_ == 1 ? ( $_[0]->{array} ) : ( $_[0]->{array} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; ('(list ' . (Main::join([ map { $_->emit() } @{ $self->{array} } ], ' ') . ')')) }


;
package Lit::Hash;
sub new { shift; bless { @_ }, "Lit::Hash" }
sub hash { @_ == 1 ? ( $_[0]->{hash} ) : ( $_[0]->{hash} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; my  $fields = $self->{hash}; my  $str = ''; do { for my $field ( @{$fields} ) { $str = ($str . ('(setf (gethash ' . ($field->[0]->emit() . (' h) ' . ($field->[1]->emit() . ')'))))) } }; ('(let ((h (cl:make-hash-table))) ' . ($str . ' h)')) }


;
package Lit::Code;
sub new { shift; bless { @_ }, "Lit::Code" }
1


;
package Lit::Object;
sub new { shift; bless { @_ }, "Lit::Object" }
sub class { @_ == 1 ? ( $_[0]->{class} ) : ( $_[0]->{class} = $_[1] ) };
sub fields { @_ == 1 ? ( $_[0]->{fields} ) : ( $_[0]->{fields} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; my  $fields = $self->{fields}; my  $str = ''; do { for my $field ( @{$fields} ) { $str = ($str . ('(setf (' . (Main::to_lisp_identifier($field->[0]->buf()) . (' m) ' . ($field->[1]->emit() . ')'))))) } }; ('(let ((m (make-instance \'' . (Main::to_lisp_namespace($self->{class}) . ('))) ' . ($str . ' m)')))) }


;
package Index;
sub new { shift; bless { @_ }, "Index" }
sub obj { @_ == 1 ? ( $_[0]->{obj} ) : ( $_[0]->{obj} = $_[1] ) };
sub index { @_ == 1 ? ( $_[0]->{index} ) : ( $_[0]->{index} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; do { if (Main::isa($self->{obj}, 'Var')) { return(('(aref ' . ($self->{obj}->name() . (' ' . ($self->{index}->emit() . ')'))))) } else {  } }; return(('(aref ' . ($self->{obj}->emit() . (' ' . ($self->{index}->emit() . ')'))))) }


;
package Lookup;
sub new { shift; bless { @_ }, "Lookup" }
sub obj { @_ == 1 ? ( $_[0]->{obj} ) : ( $_[0]->{obj} = $_[1] ) };
sub index { @_ == 1 ? ( $_[0]->{index} ) : ( $_[0]->{index} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; do { if (Main::isa($self->{obj}, 'Var')) { return(('(gethash ' . ($self->{index}->emit() . (' ' . ($self->{obj}->name() . ')'))))) } else {  } }; return(('(gethash ' . ($self->{index}->emit() . (' ' . ($self->{obj}->emit() . ')'))))) }


;
package Var;
sub new { shift; bless { @_ }, "Var" }
sub sigil { @_ == 1 ? ( $_[0]->{sigil} ) : ( $_[0]->{sigil} = $_[1] ) };
sub twigil { @_ == 1 ? ( $_[0]->{twigil} ) : ( $_[0]->{twigil} = $_[1] ) };
sub name { @_ == 1 ? ( $_[0]->{name} ) : ( $_[0]->{name} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; (($self->{twigil} eq '.') ? ('(' . (Main::to_lisp_identifier($self->{name}) . ' self)')) : (($self->{name} eq '/') ? 'MATCH' : Main::to_lisp_identifier($self->{name}))) };
sub name { my $self = shift; my $List__ = \@_; do { [] }; Main::to_lisp_identifier($self->{name}) }


;
package Bind;
sub new { shift; bless { @_ }, "Bind" }
sub parameters { @_ == 1 ? ( $_[0]->{parameters} ) : ( $_[0]->{parameters} = $_[1] ) };
sub arguments { @_ == 1 ? ( $_[0]->{arguments} ) : ( $_[0]->{arguments} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; do { if (Main::isa($self->{parameters}, 'Lit::Object')) { my  $class = $self->{parameters}->class();my  $a = $self->{parameters}->fields();my  $b = $self->{arguments};my  $str = 'do { ';my  $i = 0;my  $arg;do { for my $var ( @{$a} ) { my  $bind = Bind->new( 'parameters' => $var->[1],'arguments' => Call->new( 'invocant' => $b,'method' => $var->[0]->buf(),'arguments' => [],'hyper' => 0, ), );$str = ($str . (' ' . ($bind->emit() . ' ')));$i = ($i + 1) } };return(($str . ($self->{parameters}->emit() . ' }'))) } else {  } }; do { if ((Main::isa($self->{parameters}, 'Decl') && ($self->{parameters}->decl() eq 'my'))) { return(('(setf ' . ($self->{parameters}->var()->emit() . (' ' . ($self->{arguments}->emit() . ')'))))) } else {  } }; ('(setf ' . ($self->{parameters}->emit() . (' ' . ($self->{arguments}->emit() . ')')))) }


;
package Proto;
sub new { shift; bless { @_ }, "Proto" }
sub name { @_ == 1 ? ( $_[0]->{name} ) : ( $_[0]->{name} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; ("" . $self->{name}) }


;
package Call;
sub new { shift; bless { @_ }, "Call" }
sub invocant { @_ == 1 ? ( $_[0]->{invocant} ) : ( $_[0]->{invocant} = $_[1] ) };
sub hyper { @_ == 1 ? ( $_[0]->{hyper} ) : ( $_[0]->{hyper} = $_[1] ) };
sub method { @_ == 1 ? ( $_[0]->{method} ) : ( $_[0]->{method} = $_[1] ) };
sub arguments { @_ == 1 ? ( $_[0]->{arguments} ) : ( $_[0]->{arguments} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; my  $invocant = $self->{invocant}->emit(); do { if (($invocant eq 'self')) { $invocant = 'self' } else {  } }; do { if (($self->{method} eq 'values')) { do { if ($self->{hyper}) { die('not implemented') } else { return(('@{' . ($invocant . '}'))) } } } else {  } }; do { if (($self->{method} eq 'perl')) { return(('(prin1-to-string ' . ($invocant . ')'))) } else {  } }; do { if ((($self->{method} eq 'yaml') || (($self->{method} eq 'say') || (($self->{method} eq 'join') || (($self->{method} eq 'chars') || ($self->{method} eq 'isa')))))) { do { if ($self->{hyper}) { return(('[ map { Main::' . ($self->{method} . ('( $_, ' . (', ' . (Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . (')' . (' } @{ ' . ($invocant . ' } ]'))))))))) } else { return(('(Main::' . ($self->{method} . (' ' . ($invocant . (' ' . (Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . ')'))))))) } } } else {  } }; my  $meth = $self->{method}; do { if (($meth eq 'postcircumfix:<( )>')) { $meth = '' } else {  } }; my  $call = ('(' . ($meth . (' ' . (Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . ')')))); do { if ($self->{hyper}) { ('[ map { $_' . ($call . (' } @{ ' . ($invocant . ' } ]')))) } else { my  $args = Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ');do { if (($args ne '')) { return(('(setf (' . ($meth . (' ' . ($invocant . (') ' . (Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . ')'))))))) } else { return(('(' . ($meth . (' ' . ($invocant . ')'))))) } } } } }


;
package Apply;
sub new { shift; bless { @_ }, "Apply" }
sub code { @_ == 1 ? ( $_[0]->{code} ) : ( $_[0]->{code} = $_[1] ) };
sub arguments { @_ == 1 ? ( $_[0]->{arguments} ) : ( $_[0]->{arguments} = $_[1] ) };
sub emit { my $self = shift; my $List__ = \@_; do { [] }; my  $code = $self->{code}; do { if (Main::isa($code, 'Str')) {  } else { return(('(' . ($self->{code}->emit() . (')->(' . (Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ', ') . ')'))))) } }; do { if (($code eq 'self')) { return('self') } else {  } }; do { if (($code eq 'make')) { return(('return(' . (Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . ')'))) } else {  } }; do { if (($code eq 'substr')) { return(('(Main::substr ' . (Main::join([ map { $_->emit() } @{ $self->{arguments} } ], ' ') . ')'))) } else {  } }; do { if (($code eq 'say')) { return(('(format t ' . ('"' . ('狺ェěě扉篝ㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗ┃┅┅┅屐箦滹殒èゃ镤羼ю蜷铘З蝈趱蝾èЖ骘蝽狒ěě狺ěě扉篝ㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗ┃┅┅┅屐箦滹殒èゃ镤羼ч铈轼杭晶┅蝈趱蝾èЖ骘蝽狒铋ěě狺ěě扉篝ㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗ┃┅┅┅屐箦滹殒èゃ镤羼麽蝾З蝈趱蝾è麽蝾ěㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼п蝌狴З蝈趱蝾èЮㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗ┅屐箦滹殒èゃ镤羼ю蝈骈杭晶┅蝈趱蝾èЖㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼ю蝈骈杭【З蝈趱蝾èЖ铒ㄍ衢詈衡镲ㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠З┅З┅屐箦滹殒èゃ镤羼ю蝈骈杭烤З蝈趱蝾èЖ歪轭汉怙镬ㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠З┃┅屐箦滹殒èゃ镤羼ю蝈骈杭ぞЗ蝈趱蝾èГㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗ┅屐箦滹殒èゃ镤羼ю蝈骈杭谰З蝈趱蝾èЁㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЁ┅屐箦滹殒èゃ镤羼ю蝈骈杭ゾЗ蝈趱蝾èДㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗ┅屐箦滹殒èゃ镤羼ч铈轼杭晶┅蝈趱蝾èЖㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼ч铈轼杭晶┅蝈趱蝾èЖㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼ч铈轼杭揪З蝈趱蝾èЖㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼ч铈轼杭晶┅蝈趱蝾èЖㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼ч铈轼杭Ζ晶┅蝈趱蝾èЖ犷ㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼ч铈轼杭晶┅蝈趱蝾èЖ矧ㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼ч铈轼杭羼晶┅蝈趱蝾èЖ羼ㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼ч铈轼杭铄晶┅蝈趱蝾èЖ铄ㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼ч铈轼杭浇晶┅蝈趱蝾èЖ浇ㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼ч铈轼杭〗晶┅蝈趱蝾èЖ〗ㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅屐箦滹殒èゃ镤羼翦蝾狎杭靠　晶┅蝈趱蝾èЖ殒ㄍ衢詈衡镲à箦戽钧狎珲礤铘簖聚拜惧黹舁ěà箦戽钧狎珲礤铘簖聚陛惧黹舁ěà箦戽钧狎珲礤铘簖聚草惧黹舁ЗЗ┅┅┅屐箦ěěà箦戽钧泔溴ěㄍ衢詈宏镩瞑磲み惧黹舁利ん屐姝钧狎珲礤铘簖莠ЗЗЗ┅疳汶徵义趱蝾篚铄箬殒艋忪弩肋⒁弭躜睥篚蝈篚祠肋浇み郯莪钧蝈篚祠み郯莪钧蝈篚祠み郾篚屙轸睐ん屐箬殒艋睐ぬ轶暨芾呋滹圯蝈趱蝾èЖ蝈趱蝾骝镯眇董骢钽糸镱à箦戽钧蝈篚祠惧黹舁ЗЗ┅疳汶徵涉篚铄箬殒艋忪弩肋⑸姊篚泔钿肋浇み郯莪钧泔钿み郯莪钧泔钿み郾篚怙澌肋浇み郯莪钧怙澌み郯莪钧怙澌み郾篚雉桢蝼轶肋浇み郯莪钧雉桢蝼轶妪み郯莪钧雉桢蝼轶妪み郾篚屙轸睐ん屐箬殒艋睐ぬ轶暨芾呋滹圯睐も祜汶烷铋绣蜢逗禾轶鸷禾屮殂犰蚂镢氕绢鬻р祜汶骄ん屐姝钧怙澌┗睐も祜汶烷铋绣蜢逗禾轶鸷禾屮殂犰蚂镢氕绢鬻р祜汶骄ん屐姝钧雉桢蝼轶妪┗ěㄩㄍ衢詈衡镲à箦戽钧泔钿惧黹舁ěà忪镢氡惧黹舁ěà忪镢氩惧黹舁ЗЗ┅┅疳汶徵骑蚧篚铄箬殒艋忪弩肋⑵矧篚泔钿肋浇み郯莪钧泔钿み郯莪钧泔钿み郾篚怙澌肋浇み郯莪钧怙澌み郯莪钧怙澌み郾篚麸痖肋浇み郯莪钧麸痖泯み郯莪钧麸痖泯み郾篚屙轸睐ん屐箬殒艋睐ぬ轶暨芾呋滹圯睐ゃ镱ん屐姝钧泔钿睐も祜汶烷铋绣蜢逗禾轶鸷禾屮殂犰蚂镢氕绢鬻р祜汶骄ん屐姝钧怙澌┗滹殒è歪轭汉轶屺ゃ镱洮е狎ЗΖà泔钿倔殓殪ī羼ЮЗ┅ゃ镱琉痨绢鬻с镤濮骄ю蝈骈杭谰Кп蜱蹴孱趔骄郅泔钿莠屐箦ěㄤ镬轶ěà箦戽钧麸痖泯惧黹舁ěà泔钿惧黹舁ěà忪镢氕惧黹舁ЗЗ┅┅疳汶徵腻沆篚铄箬殒艋忪弩肋⒛邈膦篚溴沆肋浇み郯莪钧溴沆み郯莪钧溴沆み郾篚豉疱肋浇み郯莪钧豉疱み郯莪钧豉疱み郾篚鲠肋浇み郯莪钧鲠螨み郯莪钧鲠螨み郾篚屙轸睐ん屐箬殒艋睐ぬ轶暨芾呋滹圯睐や邈ん屐姝钧溴沆睐ゎ犴ん屐姝钧鲠螨绢犴濞┗èや邈羼ц狍Зě篚à钺礤ěě肋浇ěみ郯莪钧à钺礤ěěみ郯莪钧à钺礤ěみ郾З┅┅┅┅à箦戽钧溴沆ěà箦戽钧豉疱ěん屐姝钧鲠螨惧黹舁┅┅┅疳汶徵娱缁篚铄箬殒艋忪弩肋⒂殓篚轭鲲汜铘肋浇み郯莪钧轭鲲汜铘み郯莪钧轭鲲汜铘み郾篚痫箝糸镱犰肋浇み郯莪钧痫箝糸镱犰み郯莪钧痫箝糸镱犰み郾篚钺礤肋浇み郯莪钧钺礤潺み郯莪钧钺礤潺み郾篚屙轸睐ん屐箬殒艋睐ぬ轶暨芾呋滹圯痱轭堙娱珙狒躜韵南堙溟堙娱珙狒躜韵南堙篚轭鲲汜铘睐ん屐箬殒艋睐ぬ轶暨芾呋滹圯ん屐姝钧轭鲲汜铘篚痫箝糸镱犰睐ん屐箬殒艋睐ぬ轶暨芾呋滹圯ん屐姝钧痫箝糸镱犰疳汶徵湾翳镤篚铄箬殒艋忪弩肋⑼弭栾洧篚钺礤肋浇み郯莪钧钺礤み郯莪钧钺礤み郾篚箝肋浇み郯莪钧箝琮み郯莪钧箝琮み郾篚忪镢肋浇み郯莪钧忪镢臊み郯莪钧忪镢臊み郾篚屙轸睐ん屐箬殒艋睐ぬ轶暨芾呋滹圯疳汶徵吁饣篚铄箬殒艋忪弩肋⒂踱篚钺礤肋浇み郯莪钧钺礤み郯莪钧钺礤み郾篚箝肋浇み郯莪钧箝琮み郯莪钧箝琮み郾篚忪镢肋浇み郯莪钧忪镢臊み郯莪钧忪镢臊み郾篚屙轸睐ん屐箬殒艋睐ぬ轶暨芾呋滹圯睐ん殓ん屐姝钧箝琮睐ゐ矬ん殓攫矬轸轱钺歙┗睐も祜汶烷铋绣蜢逗禾轶鸷禾屮殂犰蚂镢氕绢鬻р祜汶骄ん屐姝钧忪镢臊┗睐ん趄滹骘睐ゆ殄熹利ゐ矬ん趄à篝à骈屐洵惧黹舁Зěㄤ彐躅à箦戽钧钺礤ěà篝ě┃ㄍ衢瞽绢鬻扉铄īěㄢ祜汶眇董骢钽糸镱à忪镢氕惧黹舁ě┅歪轭绢鬻扉铄ī┅┅┅┅疳汶徵娘篚铄箬殒艋忪弩肋⒛铫篚忪镢肋浇み郯莪钧忪镢臊み郯莪钧忪镢臊み郾篚屙轸睐ん屐箬殒艋睐ぬ轶暨芾呋滹圯睐も祜汶烷铋绣蜢逗禾轶鸷禾屮殂犰蚂镢氕绢鬻р祜汶骄ん屐姝钧忪镢臊┗蝈趱蝾à忪镢氕惧黹舁┅疳汶徵阵寤篚铄箬殒艋忪弩肋⒄箦篚盹肋浇み郯莪钧盹潺み郯莪钧盹潺み郾篚屙轸睐ん屐箬殒艋睐ぬ轶暨芾呋滹圯ě躞歪轭汉麸哽轶疬钺礤箴徙濞ん屐姝钧盹潺┅被