#!/usr/local/bin/perl
use lib '../../src/perl6';
use lib 'src';
use STD;
package Mildew;
do 'viv';
use AST;
use AST::Helpers;
use DumpMatch;
use utf8;
use YAML::XS;
use Encode;
use strict;
use warnings;
use Getopt::Long;
use Carp 'confess';
use Scalar::Util 'blessed';
use File::Temp qw(tempfile tmpnam);

#  -e program      one line of program (multiple -e are allowed, omit programfile)
#  -c              parse the file or -e, but do not run it
sub help {
print <<'HELP';
Usage: mildew [switches] [--] [programfile] [arguments]
  -Bbackend       execute using the compiler backend
  -Cbackend       compile using the compiler backend
                  (valid backends are: m0ld, desugar, yaml, via-C)
  -o              output to file
  -h or --help    give this message
HELP
exit;
}
my ($debug,$B,$C,$output,$help);
Getopt::Long::Parser->new( config => [qw( bundling no_ignore_case pass_through require_order)], )->getoptions("C=s"=>\$C,"output|o=s"=>\$output,"B=s"=>\$B,'debug'=>\$debug,'h|help'=>\$help) || help;
help if $help;

sub move_CONTROL {
    my $statementlist = shift;
    my @control;
    my @statementlist = 
      grep { !( exists $_->{statement_control} &&
		exists $_->{statement_control}{sym} &&
		($_->{statement_control}{sym} =~ /^(CONTROL|CATCH)$/) &&
	        (push @control, $_) ) }
	  @{$statementlist};
    if (@control) {
      unshift @statementlist, @control;
    }
    return @statementlist;
}
sub XXX {
    confess join ' ', 'unimplemented: ', @_;
}
{ package VAST::Base;
    sub as_constant_string {
        my $m = shift;
        use YAML::XS;
        die Dump($m)." can't be represented as a constant string\n";
    }
}

sub routine {
  my ($mold, $sig) = @_;
  my $realcode = $mold->emit_m0ld;
  unshift @{$realcode->stmts},
    call(STORE => call('postcircumfix:{ }' => reg '$scope', [ string '&?ROUTINE' ]), [ call(continuation => reg '$interpreter') ]),
    call(STORE => call('postcircumfix:{ }' => reg '$scope', [ string '&?BLOCK' ]), [ call(continuation => reg '$interpreter') ]),
    call(set_control => call(continuation => reg '$interpreter'),
	 [
	  call new => FETCH(lookup('Code')),[],
	  [ string 'outer' => reg '$scope',
	    string 'mold' =>
	    AST::Block->new
	    ( regs => ['interpreter','scope'],
	      stmts =>
	      [ call( "setr" =>
		      ( call "back" => (call "continuation" => reg '$interpreter' )),
		      [ call( handle_return =>
			      call('new' => FETCH(lookup('ControlExceptionReturn'))),
			      [ FETCH(lookup('$_')),FETCH(lookup('&?ROUTINE')) ] )]),
		call( "goto" => reg '$interpreter',
		      [ call("back" => call("continuation" => reg '$interpreter'))])])]]);

  call new => FETCH(lookup('Code')),[],
    [ string 'mold' => $realcode,
      string 'outer' => reg '$scope',
      ( $sig ? ( string 'signature' => $sig->emit_m0ld_ahsig ) : () )];
}

sub code {
  my ($mold,$sig) = @_;
  my $realcode = $mold->emit_m0ld;
  unshift @{$realcode->stmts},
    call(STORE=> call('postcircumfix:{ }' => reg '$scope', [ string '&?BLOCK' ]), [ call(continuation => reg '$interpreter') ]);

  call new => FETCH(lookup('Code')),[],
    [ string 'mold' => $realcode,
      string 'outer' => reg '$scope',
      ( $sig ? ( string 'signature' => $sig->emit_m0ld_ahsig ) : () )];
}

sub VAST::ws::emit_m0ld {}

sub VAST::longname::canonical {
    my $m = shift;
    my $name = $m->{name}{identifier}{TEXT};
    my $v = $m->{colonpair}[0]{v}{nibble}{nibbles}[0];
    if ($v) {
        $name . ':' . $v;
    } else {
        $name;
    }
}
sub VAST::integer::emit_m0ld {
    my $m = shift;
    #XXX non-base 10
    integer($m->{TEXT});
}

sub VAST::scope_declarator::emit_m0ld {
    my $m = shift;
    if ($m->{'sym'} eq 'my' || $m->{'sym'} eq 'our') {
        if (my $decl = $m->{scoped}{declarator}) {
            if (my $var_decl = $decl->{variable_declarator}) {
		let call(new => FETCH(lookup 'Scalar')), sub {
		    my $value = shift;
		    AST::Seq->new(stmts => [
				      ( $m->{'sym'} eq 'our' ? 
				      call(BIND => (call 'postcircumfix:{ }' => FETCH(lookup '$?PACKAGE'),
						    [ string varname($var_decl->{variable}) ]),[$value])
				      :()),
				      call(BIND => (call 'postcircumfix:{ }' => reg('$scope'),
						    [ string varname($var_decl->{variable}) ]),[$value])
				  ]);

		}
            } elsif (my $routine_decl = $decl->{routine_declarator}) {
		my $name = '&'.$routine_decl->{routine_def}{deflongname}[0]{name}{identifier}{TEXT};
		let $routine_decl->{routine_def}->emit_m0ld(), sub {
		    my $value = shift;
		    AST::Seq->new(stmts => [
				      ( $m->{'sym'} eq 'our' ? 
				      call(BIND => (call 'postcircumfix:{ }' => FETCH(lookup '$?PACKAGE'),
						     [ string $name ]),[$value])
				      : ()),
				      call(BIND => (call 'postcircumfix:{ }' => reg('$scope'),
						    [ string $name ]),[$value]),
				  ]);
		};
            } else {
                XXX('unknown scope declarator');
            }
        } else {
            XXX('scoped declarator without a declarator');
        }
    } else {
        XXX('unknown sym in scope declarator');
    }
}

sub oo_package_declarator {
    my $m = shift;
    my $name  = $m->{package_def}{module_name}[0]{longname}{name}{identifier}{TEXT};
    my $id_type_sub = AST::unique_id;

    my $how_type = '';
    if ($m->{sym} eq 'knowhow') {
        $how_type = 'PurePrototypeHow';
    } elsif ($m->{sym} eq 'class') {
        $how_type = 'ClassHOW';
    } else {
        XXX;
    }

    
    my $init = $m->{package_def}{block}->emit_m0ld;

    my $mold = AST::Block->new(regs => $init->regs,stmts => [
        let(call(new=>FETCH(lookup("Package"))),sub {
            my $package = shift;
            let call("^!CREATE" => FETCH(lookup("p6opaque"))),sub {
                my $proto = shift;
                AST::Seq->new(stmts => [
                    call(STORE => call(name => $package),[string $name]),
                    call(STORE => call("postcircumfix:{ }" => FETCH(call(outer => reg '$scope')),
                                  [string $name]),[$proto]),
                    call(STORE => call("postcircumfix:{ }" => FETCH(call outer => reg '$scope'),
                                  [string $name.'::']),[$package]),
                    call(STORE => call("postcircumfix:{ }" => FETCH(call(outer => reg '$scope')),
                                  [string '&'.$name]),[
			     call(new => FETCH(lookup('Code')),[],[string 'outer'=>reg '$scope',string 'mold' => AST::Block->new(regs=>['interpreter','scope'],stmts=>trailing_return([lookup('$?CLASS')]))])
                                  ]),
                    call(STORE => call("postcircumfix:{ }" => reg '$scope',[string '$?PACKAGE']),[$package]),
                    call(STORE => call("postcircumfix:{ }" => FETCH(call lookup => FETCH(call outer => reg '$scope'),[string '$?PACKAGE']),[string $name.'::']),[$package]),
                    call(STORE => call("postcircumfix:{ }" => reg '$scope',[string '$?CLASS']),[$proto]),
                    call(STORE => call("^!how" => $proto),[FETCH lookup($how_type)]),
                    call(STORE => call("^!who" => $proto),[$package])
                ]);
            };
        }),
        @{$init->stmts}
    ]);
    call("postcircumfix:( )" =>
	 call(new => FETCH(lookup('Code')),[],[string 'outer'=>reg '$scope',string 'mold' => $mold]),
	 [capturize()]
        );
}

sub plain_package_declarator {
    my $m = shift;
    my $name  = $m->{package_def}{module_name}[0]{longname}{name}{identifier}{TEXT};
    my $id_type_sub = AST::unique_id;

    my $init = $m->{package_def}{block}->emit_m0ld;

    my $mold = AST::Block->new(regs => $init->regs,stmts => [
        let(call(new=>FETCH(lookup("Package"))),sub {
            my $package = shift;
	    AST::Seq->new(stmts => [
		    call(STORE => call(name => $package),[string $name]),
                    call(STORE => call("postcircumfix:{ }" => reg '$scope',[string '$?PACKAGE']),[$package]),
                    call(STORE => call("postcircumfix:{ }" => FETCH(call outer => reg '$scope'),[string $name.'::']),[$package]),
                    call(STORE => call("postcircumfix:{ }" => FETCH(call lookup => FETCH(call outer => reg '$scope'),[string '$?PACKAGE']),[string $name.'::']),[$package])
                 ]);
        }),
        @{$init->stmts}
    ]);
    call("postcircumfix:( )" =>
	 call(new => FETCH(lookup('Code')),[],[string 'outer'=>reg '$scope',string 'mold' => $mold]),
	 [capturize()]
        );
}

sub VAST::package_declarator::emit_m0ld {
    my $m = shift;
    if ($m->{sym} eq 'knowhow') {
        oo_package_declarator($m);
    } elsif ($m->{sym} eq 'class') {
        oo_package_declarator($m);
    } elsif ($m->{sym} eq 'module') {
	plain_package_declarator($m);
    } else {
        XXX;
    }
}

sub VAST::noun::emit_m0ld {
    my $m = shift;
    if ($m->{variable}) {
        $m->{variable}->emit_m0ld;
    } elsif ($m->{value}) {
        $m->{value}->emit_m0ld;
    } elsif ($m->{routine_declarator}) {
        if ($m->{routine_declarator}{routine_def}) {
            $m->{routine_declarator}{routine_def}->emit_m0ld;
        } elsif ($m->{routine_declarator}{method_def}) {
            $m->{routine_declarator}{method_def}->emit_m0ld;
        } else {
            XXX;
        }
    } elsif ($m->{term}) {
        $m->{term}->emit_m0ld;
    } elsif ($m->{scope_declarator}) {
        $m->{scope_declarator}->emit_m0ld;
    } elsif ($m->{package_declarator}) {
        $m->{package_declarator}->emit_m0ld;
        #my $p = $m->{package_declarator};
    } elsif ($m->{circumfix}) {
        $m->{circumfix}->emit_m0ld;
    } else {
        XXX;
    }
}

sub VAST::term::emit_m0ld {
    my $m = shift;
    if ($m->{sym} eq 'self') {
        lookup('$¿self');
    } elsif ($m->{identifier} && $m->{args}) {
        my $func = lookup('&'.$m->{identifier}{TEXT});
        call 'postcircumfix:( )' => FETCH($func),[capturize($m->{args}->emit_m0ld)];
    } elsif ($m->{longname} && $m->{args}) {
	my $outer = FETCH(lookup($m->{longname}{name}{identifier}{TEXT}.'::'));
	my @morenames = @{$m->{longname}{name}{morename}};
	while (my $new_outer = shift @morenames) {
	    my $inner = $outer;
	    my $name = $new_outer->{identifier}[0]{TEXT};
	    last unless $name;
	    if (@morenames) {
		$name .= '::';
	    } else {
		$name = '&'.$name;
	    }
	    $outer = FETCH(call( 'postcircumfix:{ }' => $inner, [ string $name ]));
	}
        call 'postcircumfix:( )' => $outer,[capturize($m->{args}[0]->emit_m0ld)];
    } elsif (my $name = $m->{longname}->{name}) {
        if ($name->{morename} and !$name->{identifier}) {
            lookup join '',map {$_->{identifier}[0]{TEXT}} @{$name->{morename}};
        } elsif ($name->{identifier}{TEXT} eq 'CALLER') {
	    call new => reg '¢SMOP__S1P__FlattenedScope',
	      [ call lexical => (call back => (call continuation => reg '$interpreter')) ];
        } elsif ($name->{identifier}{TEXT} eq 'MY') {
	    call new => reg '¢SMOP__S1P__FlattenedScope',
	      [ reg '$scope' ];
	} else {
	    XXX;
	}
    } else {
	XXX;
    }
}
sub VAST::identifier::emit_m0ld {
    my $m = shift;
}
sub VAST::Terminator::emit_m0ld {
    my $m = shift;
    if ($m->{noun}) {
        $m->{noun}->emit_m0ld;
    } else {
        XXX;
    }
}

sub VAST::args::emit_m0ld {
    my $m = shift;
    if ($m->{listopargs}) {
        my $positional = $m->{semilist}{statement}[0];
        [(map {$_->{EXPR}->emit_m0ld} @{$m->{listopargs}}),($positional ? $positional->emit_m0ld : ())];
    } else {
        XXX;
    }
}

sub VAST::routine_def::emit_m0ld {
    my $m = shift;
    routine($m->{block},$m->{multisig}[0]{signature}[0]);
}


sub VAST::method_def::emit_m0ld {
    my $m = shift;
    AST::Let->new(value => FETCH(lookup('$?CLASS')), block => sub {
        my $CLASS = shift;
        call add_method => FETCH(call '^!how' => $CLASS),[$CLASS,string $m->{longname}{name}{identifier}{TEXT}, routine($m->{block},$m->{multisig}[0]{signature}[0])];
    });
}

sub VAST::signature::emit_m0ld_ahsig {
    my $m = shift;

    my $pc = 0;
    my $other = 0;
    my @stmts;
    push @stmts, call BIND => (call 'postcircumfix:{ }' => reg '$scope',[string '$¿self']),[call invocant => reg '$capture'];
    for my $param (@{$m->{parameter}}) {
        if ($m->{param_sep}[$pc]{TEXT} && $m->{param_sep}[$pc]{TEXT} =~ /\s*:\s*/) {
            push @stmts, $param->emit_m0ld_ahsig_BIND_invocant();
        } else {
            push @stmts, $param->emit_m0ld_ahsig_BIND($other);
            $other++;
        }
        $pc++;
    }

    AST::Call->new
        ( identifier => string 'new',
          capture => AST::Capture->new
          ( invocant => FETCH(lookup('AdhocSignature')),
            positional => [],
            named =>
            [ string 'BIND' => AST::Block->new
              ( regs => [qw(interpreter scope capture)],
                stmts => trailing_return(\@stmts))]));
}

sub VAST::parameter::emit_m0ld_ahsig_BIND_invocant {
    my ($m) = @_;
    if ($m->{param_var}) {
#        call STORE => (call 'postcircumfix:{ }' => reg '$scope',[string $m->{param_var}{sigil}{sym}.$m->{param_var}{identifier}[0]{TEXT} ]),[call FETCH => (call invocant => reg '$capture')];
        call BIND => (call 'postcircumfix:{ }' => reg '$scope',[string $m->{param_var}{sigil}{sym}.$m->{param_var}{identifier}[0]{TEXT} ]),[call invocant => reg '$capture'];
    } else {
        XXX;
    }
}

sub VAST::parameter::emit_m0ld_ahsig_BIND {
    my ($m, $count) = @_;
    if ($m->{param_var}) {
      if ($m->{quant} eq '|') {
        call 'STORE' => (call 'postcircumfix:{ }' => reg '$scope',
			[ string $m->{param_var}{sigil}{sym}.$m->{param_var}{identifier}[0]{TEXT}]),
			  [ reg '$capture' ];
      } else {
        call 'BIND' => (call 'postcircumfix:{ }' => reg '$scope',
			[ string $m->{param_var}{sigil}{sym}.$m->{param_var}{identifier}[0]{TEXT}]),
			  [call 'positional' => reg '$capture',[integer($count) ]];
      }
    } else {
        XXX;
    }
}

sub trailing_return {
    my ($stmts,) = @_;
    $stmts->[-1] = call(setr => call(back=>call(continuation => reg '$interpreter')),[$stmts->[-1]]) if $stmts->[-1];
    [@{$stmts},call(goto => reg '$interpreter',[call back=>call(continuation => reg '$interpreter')])];
}
sub VAST::block::emit_m0ld {
    my $m = shift;
    AST::Block->new(regs=>['interpreter','scope'],stmts=>trailing_return($m->{statementlist}->emit_m0ld));
}
sub VAST::circumfix::emit_m0ld {
    my $m = shift;
    if ($m->{sym}[0] eq '{' && $m->{sym}[1] eq '}' && scalar @{$m->{sym}} == 2) {
        code($m->{pblock}{block});
    } else {
        XXX;
    }
}
sub VAST::value::emit_m0ld {
    my $m = shift;
    if ($m->{number}) {
        $m->{number}->emit_m0ld;
    } elsif ($m->{quote}) {
        $m->{quote}->emit_m0ld;
    } else {
        warn Dump($m);
        XXX;
    }
}
sub VAST::quote::emit_m0ld {
    my $m = shift;
    # XXX escapes
    string join '',map {ref $_ ? $_->as_constant_string : $_} @{$m->{nibble}{nibbles}};
}
sub VAST::escape::as_constant_string {
    my $m = shift;
    $m->{item}->as_constant_string;
}
sub VAST::backslash::as_constant_string {
    my $m = shift;
    my $text = $m->{TEXT} // $m->{text}{TEXT};
    if ($text =~ /^\w$/ and $m->{text}) {
        '\\' . $text;
    } elsif ($text =~ /^[n]$/) {
        "\n";
    } elsif ($text =~ /^\W$/) {
        $text;
    } else {
        XXX;
    }
}
sub VAST::number::emit_m0ld {
    my $m = shift;
    if ($m->{integer}) {
        $m->{integer}->emit_m0ld;
    } else {
        XXX;
    }
}
sub VAST::sublongname::canonical {
    my $m = shift;
}
sub varname {
    my $m = shift;
    if ($m->{desigilname}) {
        $m->{sigil}{TEXT}.($m->{twigil}[0]{TEXT} || '').$m->{desigilname}{longname}->canonical;
    } elsif ($m->{sublongname}) {
        $m->{sigil}{TEXT}.($m->{twigil}[0]{TEXT} || '').$m->{sublongname}{subshortname}{desigilname}{longname}->canonical;
    } else {
        XXX;
    }
}
sub VAST::variable::emit_m0ld {
    my $m = shift;
    AST::Call->new(
        identifier=>string 'lookup',
        capture=>AST::Capture->new(invocant=>reg '$scope',positional=>[string varname($m)]),
    );
}

#returns a list of nodes
sub VAST::Comma::emit_m0ld {
    my $m = shift;
    map {$_->emit_m0ld} @{$m->{list}};
}
sub VAST::nulltermish::emit_m0ld {
    my $m = shift;
    $m->{termish}[0] ? $m->{termish}[0]->emit_m0ld : ();
}

sub VAST::dotty::emit_m0ld {
    my ($m,$noun) = @_;
    if (my $methodop = $m->{dottyop}{methodop}) {
        if ($methodop->{longname}) {
            my $positional = $methodop->{semilist}[0]{statement}[0];
            my @positional = $positional ? $positional->emit_m0ld : ();
            my $ident = $methodop->{longname}->canonical;
            if ($m->{sym} eq '.^!') {
                $ident = '^!' . $ident;
            }
            AST::Call->new(
                identifier=>string $ident,
                capture=>AST::Capture->new(invocant=>FETCH($noun),positional=>[@positional]),
            );
        } else {
            XXX('unknown methodop');
        }
    } elsif (my $postop = $m->{dottyop}{postop}) {
        if (my $postcircumfix = $postop->{postcircumfix}) {
            my $positional = $postcircumfix->{semilist}{statement}[0];
            my @positional = $positional ? $positional->emit_m0ld : ();
            if ($postcircumfix->{sym}[0] eq '(' && $postcircumfix->{sym}[1] eq ')') {
                call 'postcircumfix:( )' => FETCH($noun),[capturize([@positional])];
            } else {
                call ('postcircumfix:'.$postcircumfix->{sym}[0].' '.$postcircumfix->{sym}[1] => FETCH($noun),[@positional]);
            }
        } else {
            XXX('unknown postop');
        }
    } else {
        XXX('unknown dotty');
    }
}
sub EXPR {
    my $m = shift;
    if ($m->{noun}) {
        my $noun = $m->{noun}->emit_m0ld;
        if ($m->{POST}) {
            for (@{$m->{POST}}) {
                if ($_->{dotty}) {
                    $noun = $_->{dotty}->emit_m0ld($noun);
		} elsif ($_->{postop}) {
		    if (my $pc = $_->{postop}{postcircumfix}) {
			if (ref $pc->{sym} eq 'ARRAY' &&
			    $pc->{sym}[0] eq '<' &&
			    $pc->{sym}[1] eq '>') {
			    my $nib = join '', @{$pc->{nibble}{nibbles}};
			    $noun = call 'postcircumfix:{ }' => $noun, [ string $nib ];
			} else {
			    XXX;
			}
		    } else {
			XXX;
		    }
                } else {
                    XXX;
                }
            }
            $noun;
        } else {
            $noun;
        }
    } else {
        XXX;
    }
} 
sub VAST::EXPR::emit_m0ld {
    EXPR(shift);
}
sub VAST::termish::emit_m0ld {
    EXPR(shift);
}
sub VAST::Methodcall::emit_m0ld {
    my $m = shift;
    $m->{arg}->emit_m0ld;
}
sub VAST::List_assignment::emit_m0ld {
    my $m = shift;
    if ($m->{infix}{TEXT} eq '=') {
        AST::Call->new(
            identifier=>string 'STORE',
            capture=>AST::Capture->new(invocant=>$m->{left}->emit_m0ld,positional=>[FETCH($m->{right}->emit_m0ld)]),
        );
    } else {
        XXX;
    }
}
sub VAST::Item_assignment::emit_m0ld {
    my $m = shift;
    if ($m->{infix}{TEXT} eq ':=') {
        AST::Call->new(
            identifier=>string 'BIND',
            capture=>AST::Capture->new(invocant=>$m->{left}->emit_m0ld,positional=>[$m->{right}->emit_m0ld]),
        );
    } else {
        XXX;
    }
}
sub VAST::statement::emit_m0ld {
    my $m = shift;
    if ($m->{label}) {
        AST::Label->new(label=>label($m->{label}),stmt=>statement($m->{statement}));
    } elsif ($m->{statement_control}) {
        my $stm = $m->{statement_control};

        if ($stm->{sym} eq 'if') {
            my $then = call 'postcircumfix:( )' => code($stm->{xblock}{pblock}{block}),[capturize];
            my $else;
            if (ref $stm->{else} eq 'ARRAY' &&
                blessed $stm->{else}[0] &&
                ref $stm->{else}[0]{pblock} &&
                ref $stm->{else}[0]{pblock}{block}) {

                $else = call 'postcircumfix:( )' => code($stm->{else}[0]{pblock}{block}),[capturize];
            }

            my @elsif;
            if (ref $stm->{elsif} eq 'ARRAY') {
                foreach my $elsif_part (@{$stm->{elsif}}) {

                    my $elsif = call 'postcircumfix:( )' => code($elsif_part->{xblock}{pblock}{block}),[capturize];

                    push @elsif, AST::If->new
                      ( cond => $elsif_part->{xblock}{EXPR}->emit_m0ld,
                        then => $elsif );
                }
            }

            AST::If->new
                ( cond => $stm->{xblock}{EXPR}->emit_m0ld,
                  then => $then,
                  else => $else,
                  elsif => \@elsif );

	} elsif ($stm->{sym} eq 'CONTROL') {
	    # CONTROL blocks are moved to the top of the
	    # statementlist, so we know that no code was executed
	    # before this, so we can peacefully delay the setup of the
	    # control block up to this point.
	    call 'set_control' => (call 'continuation' => reg '$interpreter'), [ code($stm->{block}) ];
	} elsif ($stm->{sym} eq 'CATCH') {
	    # the same for CATCH blocks.
	    call 'set_catch' => (call 'continuation' => reg '$interpreter'), [ code($stm->{block}) ];
        } else {
            XXX('unkown sym in statement_control')
        }
    } elsif ($m->{EXPR}) {
        $m->{EXPR}->emit_m0ld;
    } else {
        XXX('unknown statement')
    }
}
sub VAST::comp_unit::emit_m0ld {
    my $m = shift;
    AST::Block->new(regs=>['interpreter','scope'],stmts=>$m->{statementlist}->emit_m0ld);
}
sub VAST::statementlist::emit_m0ld {
    my $m = shift;
    [map {$_->emit_m0ld} move_CONTROL($m->{statement})]
}

sub m0ld_to_c {
    my ($m0ld,) = @_;
    use IPC::Open2;
    local $ENV{LD_LIBRARY_PATH} = '../smop/build';
    open2(my $m0ld_exe_out,my $m0ld_exe_in,"../smop/m0ld_exe");
    binmode $m0ld_exe_in, ':utf8';
    print $m0ld_exe_in $m0ld;
    close($m0ld_exe_in);
    local $/;
    binmode $m0ld_exe_out, ':utf8';
    return <$m0ld_exe_out>;
}
sub compile_via_c {
    my ($m0ld,$output) = @_;
    my ($c_fh,$c_file) = tempfile();
    binmode($c_fh,":utf8");
    open(my $boilerplate_front,"../smop/m0ld/m0ld_boilerplate_front") || die "can't open internal file\n";
    open(my $boilerplate_back,"../smop/m0ld/m0ld_boilerplate_back") || die "can't open internal file\n";
    local $/;
    print {$c_fh} <$boilerplate_front>;
    print {$c_fh} m0ld_to_c($m0ld);
    print {$c_fh} <$boilerplate_back>;
    close($c_fh);
    system("gcc","-xc","-L../smop/build","-I../smop/include","-lperl","-lsmop","-lpcl",$c_file,"-o",$output);
}
sub compile_to_so {
    my ($m0ld,$output) = @_;
    my ($c_fh,$c_file) = tempfile();
    print {$c_fh} <<'BOILERPLATE_FRONT';
#include <stdio.h>
#include <smop.h>
#include <smop_s1p.h>
#include <smop_mold.h>
#include <smop_lowlevel.h>
void init(SMOP__Object* interpreter,SMOP__Object* scope) {
    SMOP__Object* mold =
BOILERPLATE_FRONT
    print {$c_fh} m0ld_to_c($m0ld);
    print {$c_fh} <<'BOILERPLATE_BACK';
;
  SMOP__Object* frame = SMOP__Mold__Frame_create(interpreter,mold);
  mold_reg_set(interpreter,frame,0,scope);
  SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                SMOP__ID__goto,
                frame);
}
BOILERPLATE_BACK
    close($c_fh);
    system("gcc","-xc","-L../smop/build","-I../smop/include","-shared",$c_file,"-o",$output);
}
sub output {
    my ($what,$where) = @_;
    if ($where) {
        open(my $out,">",$where);
        binmode $out, ':utf8';
        print $out $what;
    } else {
        binmode STDOUT, ':utf8';
        print $what;
    }
}
my $m;
die "output=$output too many arguments @ARGV" if scalar @ARGV > 1;
if (@ARGV) {
    $m = STD->parsefile($ARGV[0],'comp_unit');
} else {
    $m = STD->parse(join('', <STDIN>), 'comp_unit');
}

#print dump_match('comp_unit'=>$m,{vertical=>1,mark_arrays=>1,visit_twice=>1}),"\n" if $debug;
print "#################\n" if $debug;
print Dump($m->item) if $debug;
print Dump($m->item->emit_m0ld) if $debug;
print "#################\n" if $debug;
my $mold = $m->item->emit_m0ld;
my $m0ld;
$C = '' unless $C;
if ($C eq 'desugar') {
    output($mold->pretty,$output);
    exit;
} elsif ($C eq 'ast-yaml') {
    use YAML::XS;
    output(Dump($mold),$output);
    exit;
} else {
    my $scope;
    if ($C eq 'so') {
        $scope = "my \$scope;\n"
    } else {
        $scope = "my \$scope = ?SMOP__S1P__LexicalPrelude;\n";
    }
    $m0ld = $scope.<<'BOILERPLATE_FRONT'.$mold->emit_('$main').<<'BOILERPLATE_BACK';
    my $void;
BOILERPLATE_FRONT
    my $Code_scalar = $scope."lookup"("Code");
    my $Code = $Code_scalar."FETCH"();
    my $main_code = $Code."new"(:"outer"($scope),:"mold"($main));
    my $capture = ¢SMOP__S1P__Capturize."capturize"();
    my $void = $main_code."postcircumfix:( )"($capture);
BOILERPLATE_BACK
}
if ($output and not $C) {
    $C = 'via-C';
}
if ($C eq 'via-C') {
    die "-o is required when compiling to an executable\n" unless $output;
    compile_via_c($m0ld,$output);
} elsif ($C eq 'so') {
    die "-o is required when compiling to a shared library \n" unless $output;
    compile_to_so($m0ld,$output);
} elsif ($C eq 'm0ld') {
    output($m0ld,$output);
} elsif ($C) {
    die "unknown backend passed to -C: $C\n";
}

if ($B && $C) {
    die "can't specify both -C and -B\n";
} elsif (!$B && !$C) {
    $B = 'via-C';
} else {
    exit;
}

if ($B eq 'via-C') {
    local $ENV{LD_LIBRARY_PATH} = '../smop/build';
    my $tmp = tmpnam;
    compile_via_c($m0ld,$tmp);
    exec($tmp);
} elsif ($B) {
    die "unknown backend passed to -B: $C\n";
}

