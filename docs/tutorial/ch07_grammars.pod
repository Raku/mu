# Copyright (C) 2003-2007, The Perl Foundation.

=pod

=head0 Grammars and Rules

Z<CHP-7>

X<rules;grammars and>
X<grammars and rules>
X<regular expressions>
Perl 6 "regular expressions" are so far beyond the formal definition
of regular expressions that we decided it was time for a more
meaningful name.N<Regular expressions describe regular languages, and
consist of three primitives and a limited set of operations (three or
so, depending on the formulation). So, even Perl 5 "regular
expressions" weren't formal regular expressions.> We now call them
"rules." Perl 6 rules bring the full power of recursive descent
parsing to the core of Perl, but are comfortably useful even if you
don't know anything about recursive descent parsing. In the usual
case, all you'll ever need to know is that rules are X<patterns>
patterns for matching text.

=head1 Using Rules

Z<CHP-7-SECT-1>

X<rules;syntax>
Rules are a language within a language, with their own syntax and
conventions. At the highest level, though, they're just another set of
Perl constructs. So the first thing to learn about rules is the Perl
"glue" code for creating and using them.

=head2 Immediate Matches

Z<CHP-7-SECT-1.1>

The simplest way to create and use a rule is an immediate match. A rule
defined with the C<m//>X<m// (match) operator> operator always
immediately matches.  Substitutions, defined with the C<s///>
X<s/// (substitution) operator> operator also immediately match.  A
rule defined with the C<//>X</ (slash);//;;(see m// operator)>
operator immediately matches when it's in void, boolean, string, or
numeric context, or the argument of the smart-match operator (C<~~>).
X<~ (tilde);~~ (smart match) operator>

  if $string ~~ m/\w+/      {...}
  if $string ~~ s/\w+/word/ {...}
  if $string ~~ /\w+/       {...}

You can substitute other delimiters, like C<#...#>, C<[...]>, and
C<{...}> for the standard C</.../>, though C<?...?> and C<(...)> are
not valid delimiters:

  $string ~~ s/\w+/word/
  $string ~~ s[\w+][word]     # The same
  $string ~~ s{\w+}{word}     # The same
  $string ~~ s#\w+#word#      # The same
  $string ~~ s(\w+)(word)     # Wrong!
  $string ~~ s?\w?word}       # Wrong!

Modifiers now come in front using I<adverb> syntax, so to do multiple
substitutions on the same string is:

  $string ~~ s:g/\w+/word/

Also, if you use brackets on the first part of a substitution, the second
part can be specified as a pseudoassignment:

  $string ~~ s[\w+] = 'word';

This form also allows assignment operators, so if you want to add one to
all the number within a string, you can say:

  $string ~~ s:g[\d+] += 1;

If you want to do some processing on the match, you can call a function
to prepare the replacement text too:

  $string ~~ s:g[\d+] = build_replacement()

=head2 Deferred Matches

Z<CHP-7-SECT-1.2>

Sometimes you want a little more flexibility than an immediate match.
The C<rx//>X<rx// (anonymous rule) operator> operator defines an
anonymous rule that can be executed later.

  $digits = rx/\d+/;

The simple C<//> operator also defines an anonymous rule in all
contexts other than void, boolean, string, or numeric, or as an
argument of C<~~>.

  $digits = /\d+/; # store rule

You can use the unary context forcing operators, C<+>, C<?>, and C<~>,
to force the C<//> operator to match immediately in a context where it
ordinarily wouldn't. For a boolean value of success or failure, force
boolean context with C<?//>. For a count of matches, force numeric
context with C<+//>. For the matched string value, force string
context with C<~//>.

  $truth  = ?/\d+/;       # match $_ and return success
  $count  = +/(\d+\s+)*/; # match $_ and return count
  $string = ~/^\w+/;      # match $_ and return string

Another option for deferred matches is a C<rule> block. The C<rule>
keyword defines a named or anonymous rule, in much the same way that
C<sub> declares a subroutine or C<method> declares a method. But the
code within the block of a C<rule> is rule syntax, not Perl syntax.

  $digits = rule {\d+};

  rule digits {\d+}

To match a named or anonymous rule, call it as a subrule within
another rule. Subrules, whether they're named rules or a variable
containing an anonymous rule, are enclosed in assertion delimiters 
C<< <...> >>. You can read more about assertions in A<CHP-7-SECT-2.4>
"Assertions" later in this chapter.

  $string ~~ /\d+/;
  # same as
  $string ~~ /<$digits>/;
  $string ~~ /E<lt>digitsE<gt>/;

A<CHP-7-TABLE-1>Table 7-1 summarizes the basic Perl syntax for
defining rules.

=begin table picture Rules

Z<CHP-7-TABLE-1>

=headrow 

=row 

=cell Syntax

=cell Meaning

=bodyrows 

=row 

=cell C<m/.../>

=cell Match a pattern (immediate execution).

=row 

=cell C<s/.../.../>

=cell Perform a substitution (immediate execution).

=row 

=cell C<rx/.../>

=cell Define an anonymous rule (deferred execution).

=row 

=cell C</.../>

=cell Immediately match or define an anonymous rule, depending on the
context.

=row 

=cell C<rule {...}>

=cell Define an anonymous rule.

=row 

=cell C<rule name {...}>

=cell Define a named rule.

=end table

=head2 Grammars

Z<CHP-7-SECT-1.3>

X<grammars>

A grammar is a collection of rules, in much the same way that a class is
a collection of methods. In fact, grammars are classes, they're just
classes that inherit from the universal base class C<Rule>X<Rule class>.
This means that grammars can inherit from other grammars, and that they
define a namespace for their rules.

  grammar Hitchhikers {
      rule name {Zaphod|Ford|Arthur}
  
      rule id   {\d+}

      ...
  }

Any rule in the current grammar or in one of its parents can be called
directly, but a rule from an external grammar needs to have its package
specified:

  if $newsrelease ~~ /E<lt>Hitchhikers.nameE<gt>/ {
      send_alert($1);
  }

If you want to match against the entire grammar, you can define a rule
C<TOP> in that grammar.

  grammar Hitchhikers {
      rule TOP { <name> <id> }
      ...
  }

  $roster ~~ Hitchhikers;           # Calls Hitchhikers.TOP by default

X<parsing text>
X<text parsing>
Grammars are especially useful for complex text or data parsing. In fact,
overloading grammar rules for the Perl 6 grammar itself is a method to
change the way the program is parsed. Instead of having to create custom
complex source filters like was necessary in Perl 5, we can overload the
rules in the C<Perl6::Grammar> Grammar class to change the very syntax of
Perl 6 on the fly.

=head1 Building Blocks

Z<CHP-7-SECT-2>

Every language has a set of basic components (words or parts of words)
and a set of syntax rules for combining them. The "words" in rules are
literal characters (or symbols), some X<metacharacters> metacharacters
(or metasymbols),  and X<rules;escape sequences>X<escape sequences,
rules> escape sequences, while the combining syntax includes other
metacharacters, X<quantifiers, rules> X<rules;quantifiers> quantifiers,
bracketing characters, and assertions.


=head2 Metacharacters

Z<CHP-7-SECT-2.1>

The "word"-like metacharacters are C<.>, C<^>, C<^^>, C<$>, C<$$>. The
C<.> matches any single character, even a newline character. Actually,
what it matches by default is a Unicode grapheme, but you can change
that behavior with a pragma in your code, or a modifier on the rule.
We'll talk more about modifiers in A<CHP-7-SECT-2.5>"Modifiers" later
in this chapter. The C<^> and C<$> metacharacters are zero-width
matches on the beginning and end of a string. They each have doubled
alternates C<^^> and C<$$> that match at the beginning and end of
every line within a string.

The C<|>, C<&>, C<\>, C<#>, and C<:=> metacharacters are all syntax
structure elements. The C<|> is an alternation between two options. The
C<&> matches two patterns simultaneously (the patterns must be the same
length). The C<\> turns literal characters into metacharacters (the
escape sequences) or turns metacharacters into literal characters. The
C<#> marks a comment to the end of the line. Whitespace insensitivity
(the old C</x> modifier) is on by default, so you can start a comment at
any point on any line in a rule. Just make sure you don't comment out
the symbol that terminates the rule. The C<:=>
X<: (colon);:= (binding);in rules> binds a hypothetical variable to
the result of a subrule or grouped pattern. Hypotheticals are covered
in A<CHP-7-SECT-5>"Hypothetical Variables" later in this chapter.

The metacharacters C<()>, C<[]>, C<{}> and C<E<lt>E<gt>> are bracketing
pairs. The pairs always have to be balanced within the rule, unless they
are literal characters (escaped with a C<\>). The brackets C<()> and
C<[]> group patterns to match as a single atom. They're often used to
capture a result, mark the boundaries of an alternation, or mark a group
of patterns with a quantifier, among other things. Parentheses C<()> are
capturing and square brackets C<[]> are non-capturing. The C<{}>
brackets define a section of Perl code (a closure) within a rule. These
closures are always a successful zero-width match, unless the code
explicitly calls the C<fail> function. The C<E<lt>...E<gt>> brackets
mark assertions, which handle a variety of constructs including
character classes and user-defined quantifiers. Assertions are covered
in A<CHP-7-SECT-2.4>"Assertions" later in this chapter.

A<CHP-7-TABLE-2>Table 7-2 summarizes the basic set of metacharacters.

=begin table picture Metacharacters

Z<CHP-7-TABLE-2>

=headrow 

=row 

=cell Symbol

=cell Meaning

=bodyrows 

=row 

=cell C<.>

=cell Match any single character, including a newline.
X<. (dot);. match single character (rules)>

=row 

=cell C<^>

=cell Match the beginning of a string.
X<^ (caret);^ beginning of string (rules)>

=row 

=cell C<$>

=cell Match the end of a string.
X<$ (dollar sign);$ end of string (rules)>

=row 

=cell C<^^>

=cell Match the beginning of a line.
X<^ (caret);^^ beginning of line (rules)>

=row 

=cell C<$$>

=cell Match the end of a line.
X<$ (dollar sign);$$ end of line (rules)>

=row 

=cell C<|>

=cell Match alternate patterns (OR).

=row 

=cell C<&>

=cell Match multiple patterns (AND).

=row 

=cell C<\>

=cell Escape a metacharacter to get a literal character, or escape a
literal character to get a metacharacter.
X<\ (backslash);\ escape sequences (rules)>
X<\ (backslash);\ to escape metacharacters (rules)>

=row 

=cell C<#>

=cell Mark a comment (to the end of the line).

=row 

=cell C<:=>

=cell Bind the result of a match to a hypothetical variable.
X<: (colon);:= (binding);in rules>

=row 

=cell C<(...)>

=cell Group patterns and capture the result.

=row 

=cell C<[...]>

=cell Group patterns without capturing.

=row 

=cell C<{...}>

=cell Execute a closure (Perl 6 code) within a rule.

=row 

=cell C<E<lt>...E<gt>>

=cell Match an assertion.

=end table


=head2 Escape Sequences

Z<CHP-7-SECT-2.2>

X<escape sequences, rules>
X<rules;escape sequences>
X<\ (backslash);\ escape sequences (rules)>
The escape sequences are literal characters acting as metacharacters,
marked with the C<\> escape. Some escape sequences represent single
characters that are difficult to represent literally, like C<\t> for
tab, or C<\x[...]> for a character specified by a hexadecimal number.
Some represent limited character classes, like C<\d> for digits or C<\w>
for word characters. Some represent zero-width positions in a match,
like C<\b> for a word boundary. With all the escape sequences that use
brackets, C<()>, C<{}>, and C<E<lt>E<gt>> work in place of C<[]>. 

X<variable interpolation in rules>
X<rules;variable interpolation>
Note that since an ordinary variable now interpolates as a literal
string by default, the C<\Q> escape sequence is rarely needed.

A<CHP-7-TABLE-3>Table 7-3 shows the escape sequences for rules. 

=begin table picture Escape sequences

Z<CHP-7-TABLE-3>

=headrow 

=row 

=cell Escape

=cell Meaning

=bodyrows 

=row 

=cell C<\0[...]>

=cell Match a character given in octal (brackets optional).

=row 

=cell C<\b>

=cell Match a word boundary.

=row 

=cell C<\B>

=cell Match when not on a word boundary.

=row 

=cell C<\c[...]>

=cell Match a named character or control character.

=row 

=cell C<\C[...]>

=cell Match any character except the bracketed named or control character.

=row 

=cell C<\d>

=cell Match a digit.

=row 

=cell C<\D>

=cell Match a non-digit.

=row 

=cell C<\e>

=cell Match an escape character.

=row 

=cell C<\E>

=cell Match anything but an escape character.

=row 

=cell C<\f>

=cell Match the form feed character.

=row 

=cell C<\F>

=cell Match anything but a form feed.

=row 

=cell C<\n>

=cell Match a (logical) newline.

=row 

=cell C<\N>

=cell Match anything but a (logical) newline.

=row 

=cell C<\h>

=cell Match horizontal whitespace.

=row 

=cell C<\H>

=cell Match anything but horizontal whitespace.

=row 

=cell C<\L[...]>

=cell Everything within the brackets is lowercase.

=row 

=cell C<\Q[...]>

=cell All metacharacters within the brackets match as literal characters.

=row 

=cell C<\r>

=cell Match a return.

=row 

=cell C<\R>

=cell Match anything but a return.

=row 

=cell C<\s>

=cell Match any whitespace character.

=row 

=cell C<\S>

=cell Match anything but whitespace.

=row 

=cell C<\t>

=cell Match a tab.

=row 

=cell C<\T>

=cell Match anything but a tab.

=row 

=cell C<\U[...]>

=cell Everything within the brackets is uppercase.

=row 

=cell C<\v>

=cell Match vertical whitespace.

=row 

=cell C<\V>

=cell Match anything but vertical whitespace.

=row 

=cell C<\w>

=cell Match a word character (Unicode alphanumeric plus "_").

=row 

=cell C<\W>

=cell Match anything but a word character.

=row 

=cell C<\x[...]>

=cell Match a character given in hexadecimal (brackets optional).

=row 

=cell C<\X[...]>

=cell Match anything but the character given in hexadecimal (brackets
optional).

=end table


=head2 Quantifiers

Z<CHP-7-SECT-2.3>

Quantifiers specify the number of times an atom (a single character,
metacharacter, escape sequence, grouped pattern, assertion, etc) will
match.

X<. (dot);.. (range);quantifier (rules)>
X<. (dot);... (infinite range);quantifier (rules)>
The numeric quantifiers use assertion syntax. A single number
(C<E<lt>3E<gt>>) requires exactly that many matches. A numeric range
quantifier (C<E<lt>3C<..>5E<gt>>) succeeds if the number of matches is
between the minimum and maximum numbers. A range with three trailing
dots (C<E<lt>2...E<gt>>) is shorthand for C<E<lt>R<n>..InfE<gt>> and
matches as many times as possible.

Each quantifier has a minimal alternate form, marked with a trailing
C<?>, that matches the shortest possible sequence first.


A<CHP-7-TABLE-4>Table 7-4 shows the built-in 
X<quantifiers, rules> X<rules;quantifiers> quantifiers.

=begin table picture Quantifiers

Z<CHP-7-TABLE-4>

=headrow 

=row 

=cell Maximal

=cell Minimal

=cell Meaning

=bodyrows 

=row 

=cell C<*>

=cell C<*?>

=cell Match 0 or more times.

=row 

=cell C<+>

=cell C<+?>

=cell Match 1 or more times.

=row 

=cell C<?>

=cell C<??>

=cell Match 0 or 1 times.

=row 

=cell C<E<lt>>R<n>C<E<gt>>

=cell C<E<lt>>R<n>C<E<gt>?>

=cell Match exactly R<n> times.

=row 

=cell C<E<lt>>R<n>C<..>R<m>C<E<gt>>

=cell C<E<lt>>R<n>C<..>R<m>C<E<gt>?>

=cell Match at least R<n> and no more than R<m> times.

=row 

=cell C<E<lt>>R<n>C<...E<gt>>

=cell C<E<lt>>R<n>C<...E<gt>?>

=cell Match at least R<n> times.

=end table


=head2 Assertions

Z<CHP-7-SECT-2.4>

X<assertions, rules>
X<rules;assertions>
In general, an assertion simply states that some condition or state is
true and the match fails when that assertion is false. Many different
constructs with many different purposes use assertion syntax. 

X<variable interpolation in rules>
X<rules;variable interpolation>
Assertions match named and anonymous rules, arrays or hashes containing
anonymous rules, and subroutines or closures that return anonymous
rules. You have to enclose a variable in assertion delimiters to get it
to interpolate as an anonymous rule or rules. A bare scalar in a pattern
interpolates as a literal string, while a scalar variable in assertion
brackets interpolates as an anonymous rule. A bare array in a pattern
matches as a series of alternate literal strings, while an array in
assertion brackets interpolates as a series of alternate anonymous
rules. In the simplest case, a bare hash in a pattern matches a word
(C<\w+>) and tries to find that word as one of its keys.N<The effect is
much as if it matched the keys as a series of alternates, but you're
guaranteed to match the longest possible key, instead of just the first
one it hits in random order.>, while a hash in assertion brackets does
the same, but then also matches the associated value as an anonymous
rule.

X<fail keyword>
A bare closure in a pattern always matches (unless it calls C<fail>),
but a closure in assertion brackets C<E<lt>{...}E<gt>> must return an
anonymous rule, which is immediately matched.

An assertion with parentheses C<E<lt>(...)E<gt>> is similar to a bare
closure in a pattern in that it allows you to include straight Perl code
within a rule. The difference is that C<E<lt>(...)E<gt>> evaluates the
return value of the closure in boolean context. The match succeeds if
the return value is true and fails if the return value is false.

Assertions match character classes, both named and enumerated. A named
rule character class is often more accurate than an enumerated character
class. For example, C<E<lt>[a-zA-Z]E<gt>> is commonly used to match
alphabetic characters, but generally what's really needed is the
built-in rule C<E<lt>alphaE<gt>> which matches the full set of Unicode
alphabetic characters.

A<CHP-7-TABLE-5>Table 7-5 shows the syntax for assertions.

=begin table picture Assertions

Z<CHP-7-TABLE-5>

=headrow 

=row 

=cell Syntax

=cell Meaning

=bodyrows 

=row 

=cell C<E<lt>...E<gt>>

=cell Generic assertion delimiter.

=row 

=cell C<E<lt>!...E<gt>>

=cell Negate any assertion.

=row 

=cell C<E<lt>>R<name>C<E<gt>>

=cell Match a named rule or character class.

=row 

=cell C<E<lt>[...]E<gt>>

=cell Match an enumerated character class.

=row 

=cell C<E<lt>-...E<gt>>

=cell Complement a character class (named or enumerated).

=row 

=cell C<E<lt>"..."E<gt>>

=cell Match a literal string (interpolated at match time).

=row 

=cell C<E<lt>'...'E<gt>>

=cell Match a literal string (not interpolated).

=row 

=cell C<E<lt>(...)E<gt>>

=cell Boolean assertion. Execute a closure and match if it returns a true
result.

=row 

=cell C<E<lt>$scalarE<gt>>

=cell Match an anonymous rule.

=row 

=cell C<E<lt>@arrayE<gt>>

=cell Match a series of anonymous rules as alternates.

=row 

=cell C<E<lt>%hashE<gt>>

=cell Match a key from the hash, then its value (which is an anonymous
rule).

=row 

=cell C<E<lt>E<amp>sub()E<gt>>

=cell Match an anonymous rule returned by a sub.

=row 

=cell C<E<lt>{>R<code>C<}E<gt>>

=cell Match an anonymous rule returned by a closure.

=row 

=cell C<E<lt>.E<gt>>

=cell Match any logical grapheme, including combining character sequences.

=end table


=head1 Modifiers

Z<CHP-7-SECT-2.5>

X<modifiers>
X<: (colon);: modifier delimiter in rules>
Modifiers alter the meaning of the pattern syntax. The standard
position for modifiers is at the beginning of the rule, right after
the C<m>, C<s>, or C<rx>, or after the name in a named rule. Modifiers
cannot attach to the outside of a bare C</.../>. For example:

  m:i/marvin/ # case insensitive
  rule names :i { marvin | ford | arthur }

The single-character modifiers can be grouped, but the others must be
separated by a colon:

  m:wig/ zaphod /                        # OK
  m:words:ignorecase:globally / zaphod / # OK
  m:wordsignorecaseglobally / zaphod /   # Not OK

Most of the modifiers can also go inside the rule, attached to the
rule delimiters or to grouping delimiters. Internal modifiers are
lexically scoped to their enclosing delimiters, so you get a temporary
alteration of the pattern:

  m/:w I saw [:i zaphod] / # only 'zaphod' is case insensitive

The repetition modifiers (C<:R<N>x>, C<:R<N>th>, C<:once>,
C<:globally>, and C<:exhaustive>) and the continue modifier (C<:cont>)
can't be lexically scoped, because they alter the return value of the
entire rule.

The C<:R<N>x> modifier matches the rule a counted number of times. If
the modifier expects more matches than the string has, the match fails.
It has an alternate form C<:x(R<N>)> that can take a variable in place
of the number. 

The C<:once> modifier on a rule only allows it to match once. The rule
will not match again until the you call the C<.reset> method on the rule
object.

The C<:globally> modifier matches as many times as possible. The
C<:exhaustive> modifier also matches as many times as possible, but in
as many different ways as possible.

The C<:R<N>th> modifier preserves one result from a particular counted
match. If the rule matches fewer times than the modifier expects, the
match fails. It has several alternate forms. One form--C<:th(R<N>)>--can
take a variable in place of the number. The other forms--C<:R<N>st>,
C<:R<N>nd>, and C<:R<N>rd>--are for cases where it's more natural to
write C<:1st>, C<:2nd>, C<:3rd> than it is to write C<:1th>, C<:2th>,
C<:3th>. Either way is valid, so pick the one that's most comfortable
for you.

By default, rules ignore literal whitespace within the pattern.  The
C<:w> modifier makes rules sensitive to literal whitespace, but in an
intelligent way. Any cluster of literal whitespace acts like an explicit
C<\s+> when it separates two identifiers and C<\s*> everywhere else.

There are no modifiers to alter whether the matched string is treated as
a single line or multiple lines. That's why the "beginning of string"
and "end of string" metasymbols have "beginning of line" and "end of
line" counterparts.

A<CHP-7-TABLE-6>Table 7-6 shows the current list of modifiers.

=begin table picture Modifiers

Z<CHP-7-TABLE-6>

=headrow 

=row 

=cell Short

=cell Long

=cell Meaning

=bodyrows 

=row 

=cell C<:i>

=cell C<:ignorecase>

=cell Case-insensitive match.

=row 

=cell C<:I>

=cell 

=cell Case-sensitive match (on by default).

=row 

=cell C<:c>

=cell C<:cont>

=cell Continue where the previous match on the string left off.

=row 

=cell C<:w>

=cell C<:words>

=cell Literal whitespace in the pattern matches as C<\s+>
or C<\s*>.

=row 

=cell C<:W>

=cell 

=cell Turn off intelligent whitespace matching (return to default).

=row 

=cell 

=cell :R<N>C<x>/C<:x(>R<N>C<)>

=cell Match the pattern R<N> times.

=row 

=cell 

=cell C<:>R<N>C<th>/C<:nth(>R<N>C<)>

=cell Match the R<N>th occurrence of a pattern.

=row 

=cell 

=cell C<:once>

=cell Only match the pattern once.

=row 

=cell C<:g>

=cell C<:globally>

=cell Match the pattern as many times as possible, but only possibilities
that don't overlap.

=row 

=cell C<:e>

=cell C<:exhaustive>

=cell Match every possible occurrence of a pattern, even overlapping
possibilities.

=row 

=cell 

=cell C<:u0>

=cell . is a byte.

=row 

=cell 

=cell C<:u1>

=cell . is a Unicode codepoint.

=row 

=cell 

=cell C<:u2>

=cell . is a Unicode grapheme.

=row 

=cell 

=cell C<:u3>

=cell . is language dependent.

=row 

=cell 

=cell C<:p5>

=cell The pattern uses Perl 5 regex syntax.

=end table


=head1 Built-in Rules

Z<CHP-7-SECT-3>

X<rules;built-in>
A number of named rules are provided by default, including a complete
set of X<POSIX-style classes> POSIX-style classes, and X<Unicode
property classes> Unicode property classes. The list isn't fully
defined yet, but A<CHP-7-TABLE-7>Table 7-7 shows a few you're
likely to see.

The C<E<lt>nullE<gt>> rule matches a zero-width string (so it's always
true) and C<E<lt>priorE<gt>> matches whatever the most recent successful
rule matched. These replace the two behaviors of 
X</ (slash);// invalid null pattern>
X<invalid null pattern //> the Perl 5 null pattern C<//>,
which is no longer valid syntax for rules. 

=begin table picture Built-in rules

Z<CHP-7-TABLE-7>

=headrow 

=row 

=cell Rule

=cell Meaning

=bodyrows 

=row 

=cell C<E<lt>alphaE<gt>>

=cell Match a Unicode alphabetic character.

=row 

=cell C<E<lt>digitE<gt>>

=cell Match a Unicode digit.

=row 

=cell C<E<lt>spE<gt>>

=cell Match a single space character (the same as C<\s>).

=row 

=cell C<E<lt>wsE<gt>>

=cell Match any whitespace (the same as C<\s+>).

=row 

=cell C<E<lt>nullE<gt>>

=cell Match the null string.

=row 

=cell C<E<lt>priorE<gt>>

=cell Match the same thing as the previous match.

=row 

=cell C<E<lt>before ...E<gt>>

=cell Zero-width lookahead. Assert that you're I<before> a pattern.

=row 

=cell C<E<lt>after ...E<gt>>

=cell Zero-width lookbehind. Assert that you're I<after> a pattern.

=row 

=cell C<E<lt>prop ...E<gt>>

=cell Match any character with the named property.

=row 

=cell C<E<lt>replace(...)E<gt>>

=cell Replace everything matched so far in the rule or subrule with the
given string (under consideration).

=end table


=head1 Backtracking Control

Z<CHP-7-SECT-4>

X<backtracking controls>
X<fail keyword> 
Backtracking is triggered whenever part of the pattern fails to match.
You can also explicitly trigger backtracking by calling the C<fail>
function within a closure. A<CHP-7-TABLE-8>Table 7-8 shows some
metacharacters and built-in rules relevant to backtracking.

=begin table picture Backtracking controls

Z<CHP-7-TABLE-8>

=headrow 

=row 

=cell Operator

=cell Meaning

=bodyrows 

=row 

=cell C<:>

=cell Don't retry the previous atom, fail to the next
earlier atom.
X<: (colon);: fail to atom before last (rules)>
X<backtracking controls;: fail to atom before last>

=row 

=cell C<::>

=cell Don't backtrack over this point, fail out of the closest
enclosing group (C<(...)>, C<[...]>, or the rule delimiters).
X<: (colon);:: fail out of group (rules)>
X<backtracking controls;: fail out of group>

=row 

=cell C<:::>

=cell Don't backtrack over this point, fail out of the
current rule or subrule.
X<: (colon);::: fail out of rule (rules)>
X<backtracking controls;: fail out of rule>

=row 

=cell C<E<lt>commitE<gt>>

=cell Don't backtrack over this point, fail out of the
entire match (even from within a subrule).

=row 

=cell C<E<lt>cutE<gt>>

=cell Like C<E<lt>commitE<gt>>, but also cuts the string matched. The
current matching position at this point becomes the new beginning of
the string.

=end table

=head1 Hypothetical Variables

Z<CHP-7-SECT-5>

X<variables;hypothetical>
X<hypothetical variables>
X<rules;captures>
Hypothetical variables are a powerful way of building up data structures
from within a match. Ordinary captures with C<()> store the result of
the captures in C<$1>, C<$2>, etc. The values stored in these variables
will be kept if the match is successful, but thrown away if the match
fails (hence the term "hypothetical"). The numbered capture variables
are accessible outside the match, but only within the immediate
surrounding lexical scope:

  "Zaphod Beeblebrox" ~~ m:w/ (\w+) (\w+) /;
  
  print $1; # prints Zaphod

You can also capture into any user-defined variable with the binding
operator C<:=>. These variables must already be defined in the lexical
scope surrounding the rule:

  my $person;
  "Zaphod's just this guy." ~~ / ^ $person := (\w+) /;
  print $person; # prints Zaphod

Repeated matches can be captured into an array:

  my @words;
  "feefifofum" ~~ / @words := (f<-[f]>+)* /;
  # @words contains ("fee", "fi", "fo", "fum")

Pairs of repeated matches can be captured into a hash:

  my %customers;
  $records ~~ m:w/ %customers := [ E<lt>idE<gt> = E<lt>nameE<gt> \n]* /;

If you don't need the captured value outside the rule, use a C<$?>
variable instead. These are only directly accessible within the rule:

  "Zaphod saw Zaphod" ~~ m:w/ $?name := (\w+) \w+ $?name/;

A match of a named rule stores the result in a C<$?> variable with the
same name as the rule. These variables are also accessible only within
the rule:

  "Zaphod saw Zaphod" ~~ m:w/ E<lt>nameE<gt> \w+ $?name /;



=cut
